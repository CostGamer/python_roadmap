# Правила
- Все что не отмечено звездочкой надо точно и уверено знать  
- `*` - must have for interview  
- `**` - for flex in the interview

----

# `1` Python
## `1.1` Что такое компилируемых и интерпретируемых языки? В чем их отличие?
**Компилируемые языки** (C, C++, Rust, Go) — код сначала полностью переводится (компилируется) в машинный код (понятный процессору), затем выполняется. Компиляция происходит один раз, потом программа запускается напрямую.

**Интерпретируемые языки** (Python, JavaScript, Ruby) — код выполняется построчно специальной программой (интерпретатором), которая переводит и выполняет команды "на лету", без предварительной компиляции.

**Основные отличия:**

| Характеристика | Компилируемые | Интерпретируемые |
|----------------|---------------|------------------|
| **Скорость выполнения** | Быстрее (машинный код) | Медленнее (перевод на лету) |
| **Запуск** | Нужна компиляция перед запуском | Сразу запускается |
| **Ошибки** | Находятся при компиляции | Находятся при выполнении |
| **Переносимость** | Нужна перекомпиляция для разных ОС | Один код работает везде (где есть интерпретатор) |
| **Отладка** | Сложнее | Проще |

**Важно:** Python — гибридный язык. Код сначала компилируется в байт-код (`.pyc` файлы), который затем выполняется виртуальной машиной Python (PVM). Это промежуточный вариант между чистой интерпретацией и компиляцией.

**Пример:**
```python
# Python — интерпретируемый
print("Hello")  # Выполняется сразу при запуске

# C — компилируемый
// Сначала компиляция: gcc program.c -o program
// Затем запуск: ./program
```

## `1.2` Плюсы и минусы `Python`
**Плюсы:**

✅ **Простой синтаксис** — легко читать и писать, быстрое обучение  
✅ **Кроссплатформенность** — работает на Windows, Linux, macOS  
✅ **Огромная экосистема** — библиотеки для любых задач (numpy, pandas, django, tensorflow)  
✅ **Высокая продуктивность** — быстрая разработка, меньше кода  
✅ **Динамическая типизация** — не нужно объявлять типы переменных  
✅ **Большое сообщество** — много обучающих материалов, готовых решений  
✅ **Универсальность** — веб, анализ данных, ML, автоматизация, скрипты  
✅ **Встроенные структуры данных** — списки, словари, множества из коробки  

**Минусы:**

❌ **Низкая скорость** — медленнее C/C++/Java в 10-100 раз  
❌ **Высокое потребление памяти** — объекты занимают больше места  
❌ **GIL (Global Interpreter Lock)** — проблемы с многопоточностью для CPU-задач  
❌ **Мобильная разработка** — слабая поддержка iOS/Android  
❌ **Динамическая типизация** — ошибки типов находятся только во время выполнения  
❌ **Зависимости** — сложное управление версиями библиотек  
❌ **Плохо для низкоуровневого программирования** — системное ПО, драйверы  

**Пример:**
```python
# Плюс: простота
numbers = [1, 2, 3, 4, 5]
squares = [x**2 for x in numbers]  # Лаконично!

# Минус: скорость
# Сумма 100 млн чисел в Python — несколько секунд
# В C — доли секунды
```

## `1.3` Какие задачи решает `Python`?
**Основные области применения:**

1. **Веб-разработка** (Django, Flask, FastAPI)
   - Бэкенд для сайтов и API
   - Пример: Instagram, Spotify, YouTube используют Python

2. **Анализ данных и Data Science** (pandas, numpy, matplotlib)
   - Обработка больших данных
   - Визуализация
   - Статистический анализ

3. **Machine Learning и AI** (scikit-learn, TensorFlow, PyTorch)
   - Обучение моделей
   - Компьютерное зрение
   - Обработка естественного языка (NLP)

4. **Автоматизация и скрипты**
   - Парсинг сайтов (BeautifulSoup, Selenium)
   - Автоматизация рутинных задач
   - Работа с файлами и системой

5. **Научные вычисления** (scipy, sympy)
   - Математические расчёты
   - Моделирование
   - Исследования

6. **Тестирование** (pytest, unittest)
   - Автоматическое тестирование ПО
   - CI/CD пайплайны

7. **DevOps и администрирование**
   - Настройка серверов (Ansible)
   - Мониторинг систем
   - Деплой приложений

8. **Разработка игр** (Pygame)
   - Инди-игры
   - Прототипирование

**Где Python НЕ используется:**
- Мобильные приложения (лучше Swift/Kotlin)
- Системное программирование (лучше C/Rust)
- Высоконагруженные real-time системы (лучше C++/Go)
- Встроенные системы с малой памятью

----

# `2` Ввод - вывод
## `2.1` print()
### `2.1.1` Как работает `print()`?
`print()` — встроенная функция для вывода данных на экран (в консоль). Она принимает любые значения, преобразует их в строку и отображает.

**Примеры:**
```python
print("Привет, мир!")  # Привет, мир!
print(42)              # 42
print(3.14)            # 3.14
print(True)            # True

# Можно выводить несколько значений через запятую
print("Мне", 25, "лет")  # Мне 25 лет
```

### `2.1.2` Что такон аргумент?
**Аргумент** — это значение, которое мы передаём в функцию в круглых скобках. Функция использует эти значения для своей работы.

**Примеры:**
```python
print("Текст")  # "Текст" — это аргумент функции print()
print(10, 20)   # 10 и 20 — два аргумента

# У функций может быть разное количество аргументов
print()                      # 0 аргументов — выведет пустую строку
print("один")                # 1 аргумент
print("один", "два", "три")  # 3 аргумента
```

## `2.2` input()
### `2.2.1` Как работает `input()`? Что принимает `input()`?
`input()` — функция для получения данных от пользователя. Она:
1. Останавливает программу и ждёт ввода
2. Выводит приглашение (если передан аргумент)
3. Возвращает введённый текст как **строку**

**Важно:** `input()` всегда возвращает строку, даже если вы вводите число!

**Примеры:**
```python
# Без приглашения
name = input()  # Ждёт ввода, курсор мигает

# С приглашением (текстом-подсказкой)
name = input("Введите ваше имя: ")  # Введите ваше имя: _
print("Привет,", name)

age = input("Сколько вам лет? ")  # Сколько вам лет? 25
print(age)        # "25" — это строка!
print(type(age))  # <class 'str'>
```

### `2.2.2` Что такое переменная? Как можно и принято называть переменную?
**Переменная** — это "контейнер" для хранения данных. Она имеет имя, по которому можно обращаться к сохранённому значению.

**Правила именования:**
- Только латинские буквы, цифры и подчёркивание `_`
- Не может начинаться с цифры
- Регистр важен: `name` и `Name` — разные переменные
- Нельзя использовать зарезервированные слова (`if`, `for`, `print` и т.д.)

**Стиль именования (PEP8):**
- `snake_case` — слова через подчёркивание (рекомендуется)
- Имя должно быть понятным и описывать содержимое

**Примеры:**
```python
# Правильные имена
name = "Иван"
user_age = 25
total_price = 1500
is_active = True
_private = 10  # Начинается с _, но допустимо

# Неправильные имена
# 2name = "Ошибка"      # Начинается с цифры
# user-age = 25         # Дефис запрещён
# class = "A"           # Зарезервированное слово

# Плохой стиль (работает, но не рекомендуется)
x = 25          # Неинформативное имя
userName = 25   # camelCase не принят в Python для переменных
USERAGE = 25    # Заглавные буквы для констант

# Хороший стиль
user_name = "Пётр"
user_age = 30
total_sum = 5000
```

### `2.2.3` Что такое комментарий и как его делать?
**Комментарий** — текст, который игнорируется Python и нужен для пояснений в коде. Помогает понять, что делает программа.

**Виды комментариев:**
- `#` — однострочный комментарий
- `'''...'''` или `"""..."""` — многострочный комментарий (технически это строки, но используются как комментарии)

**Примеры:**
```python
# Это однострочный комментарий

print("Привет")  # Комментарий в конце строки

# Вычисляем сумму
a = 10
b = 20
total = a + b  # Сохраняем результат

"""
Это многострочный комментарий.
Он может занимать несколько строк.
Используется для документации.
"""

'''
Тоже многострочный комментарий,
только с одинарными кавычками.
'''
```

### `2.2.4` Несколько переменных в `print()`
`print()` может выводить несколько значений через запятую. Они автоматически разделяются пробелом.

**Примеры:**
```python
name = "Анна"
age = 28

print("Имя:", name)  # Имя: Анна
print("Возраст:", age)  # Возраст: 28

# Несколько переменных сразу
print("Меня зовут", name, "и мне", age, "лет")
# Меня зовут Анна и мне 28 лет

# Можно смешивать переменные и текст
city = "Москва"
print(name, "живёт в городе", city)  # Анна живёт в городе Москва
```

### `2.2.5` Переменные в `input()`
Можно использовать переменные в тексте приглашения `input()`, чтобы делать запросы более персонализированными.

**Примеры:**
```python
name = input("Как вас зовут? ")  # Как вас зовут? Иван
print("Привет,", name)

# Использование переменной в следующем input()
age = input(name + ", сколько вам лет? ")  # Иван, сколько вам лет? 25

# Или через запятую (более читабельно)
city = input("Где вы живёте,", name, "?")  # Где вы живёте, Иван ? 

# Лучше использовать f-строки (об этом позже)
hobby = input(f"{name}, какое у вас хобби? ")  # Иван, какое у вас хобби?
```

### `2.2.6` Параметры `sep` & `end` в `print()`
У `print()` есть дополнительные параметры:
- `sep` (separator) — разделитель между значениями (по умолчанию пробел `" "`)
- `end` — что добавить в конец (по умолчанию перевод строки `"\n"`)

**Примеры:**
```python
# Параметр sep
print(1, 2, 3)           # 1 2 3 (пробелы по умолчанию)
print(1, 2, 3, sep="-")  # 1-2-3
print(1, 2, 3, sep=" | ")  # 1 | 2 | 3
print(1, 2, 3, sep="")   # 123 (без разделителя)

# Параметр end
print("Первая строка")
print("Вторая строка")
# Первая строка
# Вторая строка

print("Первая строка", end=" ")
print("Вторая строка")
# Первая строка Вторая строка (в одной строке!)

print("Загрузка", end="...")
print("Готово!")
# Загрузка...Готово!

# Оба параметра вместе
print("Яблоко", "Груша", "Банан", sep=", ", end=".\n")
# Яблоко, Груша, Банан.

# Практический пример — прогресс бар
print("Загрузка: ", end="")
print("█", "█", "█", sep="", end=" ")
print("30%")
# Загрузка: ███ 30%
```

## `2.3` PEP8
### `2.3.1` Что такое `PEP8`?
**PEP8** (Python Enhancement Proposal 8) — официальный стандарт оформления кода на Python. Это набор правил, которые делают код читабельным и единообразным. Все Python-программисты следуют PEP8.

**Зачем нужен:**
- Код легче читать
- Проще работать в команде
- Меньше ошибок

### `2.3.2` Обшие рекомендации  
**Основные правила PEP8:**

**1. Отступы:**
- 4 пробела (не табуляция!)

**2. Длина строки:**
- Максимум 79 символов

**3. Пустые строки:**
- 2 пустые строки между функциями/классами
- 1 пустая строка между методами

**4. Пробелы:**
- После запятых: `print(1, 2, 3)` ✅, не `print(1,2,3)` ❌
- Вокруг операторов: `x = 5 + 3` ✅, не `x=5+3` ❌
- Не перед скобками: `print("text")` ✅, не `print ("text")` ❌

**5. Имена:**
- Переменные и функции: `snake_case`
- Константы: `UPPER_CASE`
- Классы: `PascalCase`

**Примеры:**
```python
# ✅ Правильно
user_name = "Иван"
user_age = 25
total_sum = user_age * 100

print("Привет,", user_name)
print("Сумма:", total_sum)

# ❌ Неправильно
userName="Иван"  # camelCase и нет пробелов
user_age=25
totalSum=user_age*100  # Нет пробелов вокруг операторов

print("Привет,",user_name)  # Пробел после запятой
print( "Сумма:",totalSum )  # Лишние пробелы внутри скобок
```

## `2.4` Целочисленные операции
### `2.4.1` `int()`, `int(input())`
`int()` — функция для преобразования в целое число.  
`input()` всегда возвращает строку, поэтому для работы с числами нужно преобразование.

**Примеры:**
```python
# Преобразование строки в число
age = "25"
age_number = int(age)
print(age_number + 5)  # 30

# input() возвращает строку
age = input("Возраст: ")  # Возраст: 25
print(age + 5)  # Ошибка! Нельзя складывать строку и число

# Правильно — сначала преобразуем
age = int(input("Возраст: "))  # Возраст: 25
print(age + 5)  # 30

# Несколько чисел
a = int(input("Первое число: "))
b = int(input("Второе число: "))
print("Сумма:", a + b)
```

### `2.4.2` Математические операции

Python поддерживает стандартные математические операции с числами.

**Примеры:**
```python
a = 10
b = 3

print(a + b)  # 13 — сложение
print(a - b)  # 7  — вычитание
print(a * b)  # 30 — умножение
print(a / b)  # 3.333... — деление (всегда float)

# Пример с input()
x = int(input("Введите число: "))  # 5
y = int(input("Введите число: "))  # 2

print("Сумма:", x + y)        # 7
print("Разность:", x - y)     # 3
print("Произведение:", x * y) # 10
print("Частное:", x / y)      # 2.5
```

### `2.4.3` Операторы: (), **, //, %  
Дополнительные математические операторы:
- `()` — скобки (приоритет операций)
- `**` — возведение в степень
- `//` — целочисленное деление (отбрасывает дробную часть)
- `%` — остаток от деления (модуль)

**Примеры:**
```python
# Скобки — приоритет операций
print(2 + 3 * 4)      # 14 (сначала умножение)
print((2 + 3) * 4)    # 20 (сначала скобки)

# Возведение в степень
print(2 ** 3)   # 8 (2 в степени 3)
print(5 ** 2)   # 25 (5 в квадрате)
print(10 ** 0)  # 1 (любое число в степени 0 = 1)

# Целочисленное деление
print(10 / 3)   # 3.333... — обычное деление
print(10 // 3)  # 3 — отбрасываем дробную часть
print(17 // 5)  # 3
print(20 // 6)  # 3

# Остаток от деления (модуль)
print(10 % 3)   # 1 (10 = 3*3 + 1)
print(17 % 5)   # 2 (17 = 5*3 + 2)
print(20 % 6)   # 2 (20 = 6*3 + 2)
print(15 % 5)   # 0 (делится нацело)

# Практические примеры
# Проверка чётности
number = int(input("Число: "))  # 7
print(number % 2)  # 1 (нечётное), если бы 8 — было бы 0 (чётное)

# Вычисление последней цифры числа
number = 12345
last_digit = number % 10
print(last_digit)  # 5

# Конвертация минут в часы и минуты
total_minutes = 125
hours = total_minutes // 60  # 2 часа
minutes = total_minutes % 60 # 5 минут
print(f"{hours} ч {minutes} мин")  # 2 ч 5 мин
```

----

# `3` Условный оператор
## `3.1` `if-else`
`if-else` — конструкция для выполнения кода в зависимости от условия. Если условие истинно (`True`) — выполняется один блок кода, если ложно (`False`) — другой.

**Структура:**
```python
if условие:
    # код, если условие True
else:
    # код, если условие False
```

**Варианты:**
- `if` — только проверка условия
- `if-else` — два варианта (да/нет)
- `if-elif-else` — несколько условий

**Примеры:**

```python
# Пример 1: Простой if
age = 18
if age >= 18:
    print("Вы совершеннолетний")
# Вы совершеннолетний

# Пример 2: if-else
age = 15
if age >= 18:
    print("Вы совершеннолетний")
else:
    print("Вы несовершеннолетний")
# Вы несовершеннолетний

# Пример 3: if-elif-else (несколько условий)
score = 85

if score >= 90:
    print("Отлично!")
elif score >= 70:
    print("Хорошо")
elif score >= 50:
    print("Удовлетворительно")
else:
    print("Неудовлетворительно")
# Хорошо

# Пример 4: Вложенные условия
age = 20
has_license = True

if age >= 18:
    if has_license:
        print("Можете водить автомобиль")
    else:
        print("Нужны права")
else:
    print("Слишком молоды для вождения")
# Можете водить автомобиль

# Пример 5: С input()
password = input("Введите пароль: ")

if password == "secret123":
    print("Доступ разрешён")
else:
    print("Неверный пароль")

# Пример 6: Несколько elif
temperature = int(input("Температура: "))

if temperature > 30:
    print("Жарко")
elif temperature > 20:
    print("Тепло")
elif temperature > 10:
    print("Прохладно")
elif temperature > 0:
    print("Холодно")
else:
    print("Мороз")
```

## `3.2` Что такое табуляция?
**Табуляция (отступ)** — пробелы в начале строки, которые показывают, что код принадлежит определённому блоку. В Python отступы **обязательны** и определяют структуру программы.

**Важно:**
- В Python используются **4 пробела** (стандарт PEP8)
- Нельзя смешивать табуляцию (клавиша Tab) и пробелы
- Отступы показывают вложенность кода

**Примеры:**

```python
# ✅ Правильно — 4 пробела
if True:
    print("Это внутри if")
    print("И это тоже")
print("А это снаружи")

# ❌ Ошибка — нет отступа
if True:
print("Ошибка!")  # IndentationError

# ✅ Вложенные блоки — по 4 пробела на уровень
age = 20
has_ticket = True

if age >= 18:              # 0 пробелов
    if has_ticket:         # 4 пробела
        print("Проходите") # 8 пробелов
    else:                  # 4 пробела
        print("Нужен билет") # 8 пробелов
else:                      # 0 пробелов
    print("Слишком молоды") # 4 пробела

# ❌ Ошибка — разные отступы
if True:
    print("4 пробела")
  print("2 пробела")  # IndentationError!

# Пример с несколькими уровнями
number = 15

if number > 0:                           # Уровень 0
    print("Число положительное")         # Уровень 1
    if number % 2 == 0:                  # Уровень 1
        print("И чётное")                # Уровень 2
    else:                                # Уровень 1
        print("И нечётное")              # Уровень 2
        if number > 10:                  # Уровень 2
            print("И больше 10")         # Уровень 3
```

**Почему это важно:**
```python
# Код без правильных отступов работать не будет
x = 5
if x > 0:
print("Положительное")  # Ошибка!

# С отступами — всё работает
x = 5
if x > 0:
    print("Положительное")  # ✅
```

## `3.3` Какие есть операторы сравнения? Цепочки сравнения и транзитивность
**Операторы сравнения** — специальные символы для сравнения значений. Результат сравнения — всегда `True` или `False`.

**Основные операторы:**
- `==` — равно
- `!=` — не равно
- `>` — больше
- `<` — меньше
- `>=` — больше или равно
- `<=` — меньше или равно

**Важно:** `=` это присваивание, а `==` это сравнение!

**Примеры базовых сравнений:**

```python
# Сравнение чисел
print(5 == 5)   # True
print(5 == 3)   # False
print(5 != 3)   # True
print(5 > 3)    # True
print(5 < 3)    # False
print(5 >= 5)   # True
print(5 <= 4)   # False

# В условиях
age = 18
if age >= 18:
    print("Совершеннолетний")

# Сравнение строк
name = "Иван"
if name == "Иван":
    print("Привет, Иван!")

password = input("Пароль: ")
if password != "12345":
    print("Неверный пароль")
```

**Цепочки сравнений:**
Python позволяет записывать несколько сравнений подряд — это короче и понятнее, чем использовать логические операторы `and`.

**Примеры:**

```python
# Обычный способ (с and)
x = 15
if x > 10 and x < 20:
    print("x между 10 и 20")

# Цепочка сравнений (pythonic way!)
x = 15
if 10 < x < 20:
    print("x между 10 и 20")
# Читается как в математике: "10 меньше x и x меньше 20"

# Проверка диапазона
age = 25
if 18 <= age <= 65:
    print("Трудоспособный возраст")

# Сложные цепочки
a = 5
b = 10
c = 15
if a < b < c:
    print("Возрастающая последовательность")  # ✅

# Можно использовать разные операторы
score = 75
if 0 <= score <= 100:
    print("Корректный балл")

# Эквивалентно:
if score >= 0 and score <= 100:
    print("Корректный балл")

# Практический пример
temperature = int(input("Температура: "))
if 20 <= temperature <= 25:
    print("Комфортная температура")
elif temperature < 20:
    print("Холодно")
else:
    print("Жарко")
```

**Транзитивность:**
**Транзитивность** — математическое свойство: если `a < b` и `b < c`, то автоматически `a < c`. Python использует это в цепочках сравнений.

**Как работает:**
Цепочка `a < b < c` означает `(a < b) and (b < c)`, но:
- **Важно:** `b` вычисляется только один раз
- Python проверяет все части цепочки последовательно
- Если любая часть `False` — вся цепочка `False`

**Примеры:**

```python
# Пример 1: Транзитивность в действии
a = 5
b = 10
c = 15

# Цепочка
if a < b < c:
    print("a меньше b, и b меньше c")  # ✅
    print("Значит, a точно меньше c (транзитивность)")

# Эквивалентно
if (a < b) and (b < c):
    print("То же самое")

# Пример 2: Оптимизация — b вычисляется один раз
def get_value():
    print("Функция вызвана")
    return 10

# С цепочкой — функция вызывается ОДИН раз
if 5 < get_value() < 15:
    print("Условие истинно")
# Функция вызвана
# Условие истинно

# Без цепочки — функция вызывается ДВА раза
if 5 < get_value() and get_value() < 15:
    print("Условие истинно")
# Функция вызвана
# Функция вызвана
# Условие истинно

# Пример 3: Когда транзитивность не работает
x = 10
y = 5
z = 15

if x < y < z:
    print("Не выполнится")
# x < y это False, поэтому вся цепочка False
# Python даже не проверяет y < z

# Пример 4: Смешанные операторы
a = 5
b = 5
c = 10

if a <= b < c:
    print("a меньше или равно b, и b меньше c")  # ✅

# Пример 5: Проверка вхождения в диапазон
min_value = 0
max_value = 100
user_input = int(input("Введите число от 0 до 100: "))

if min_value <= user_input <= max_value:
    print("Число в допустимом диапазоне")
else:
    print("Число вне диапазона")

# Пример 6: Несколько переменных
a = 1
b = 2
c = 3
d = 4

# Длинная цепочка
if a < b < c < d:
    print("Все числа в порядке возрастания")  # ✅

# Эквивалентно (но длиннее):
if (a < b) and (b < c) and (c < d):
    print("То же самое")
```

**Преимущества цепочек:**
- ✅ Короче и понятнее
- ✅ Читается как математическая запись
- ✅ Промежуточное значение вычисляется один раз
- ✅ Меньше скобок

**Когда использовать:**
```python
# ✅ Используй цепочки для диапазонов
if 0 <= age <= 100:
    pass

# ❌ Не используй для несвязанных условий
# Плохо:
if x < 10 < y:  # Непонятно, связаны ли x и y

# Хорошо:
if x < 10 and something_else < y:
    pass
```

## `3.4` Логические операции: `and`, `or`, `not`
Логические операции используются для комбинирования условий и работы с булевыми значениями (`True` и `False`).

### **Оператор `and` (логическое И)**
Возвращает `True`, только если **оба** операнда истинны.

```python
print(True and True)    # True
print(True and False)   # False
print(False and True)   # False
print(False and False)  # False

# Практический пример
age = 25
has_license = True

if age >= 18 and has_license:
    print("Можешь водить машину")  # Выведет: Можешь водить машину

# С числами (непустые значения считаются True)
x = 5
if x > 0 and x < 10:
    print("x находится между 0 и 10")  # Выведет: x находится между 0 и 10
```

### **Оператор `or` (логическое ИЛИ)**
Возвращает `True`, если **хотя бы один** операнд истинен.

```python
print(True or True)     # True
print(True or False)    # True
print(False or True)    # True
print(False or False)   # False

# Практический пример
is_weekend = False
is_holiday = True

if is_weekend or is_holiday:
    print("Можно отдыхать!")  # Выведет: Можно отдыхать!

# Проверка нескольких условий
role = "admin"
if role == "admin" or role == "moderator":
    print("Доступ разрешён")  # Выведет: Доступ разрешён
```

### **Оператор `not` (логическое НЕ)**
Инвертирует булево значение: `True` становится `False` и наоборот.

```python
print(not True)   # False
print(not False)  # True

# Практический пример
is_logged_in = False

if not is_logged_in:
    print("Пожалуйста, войдите в систему")  # Выведет: Пожалуйста, войдите в систему

# Проверка на пустоту
items = []
if not items:
    print("Список пуст")  # Выведет: Список пуст
```

### **Возвращаемые значения (не только True/False)**

В Python логические операторы возвращают **сам операнд**, а не обязательно `True` или `False`.

```python
# and возвращает первый False или последний операнд
print(5 and 10)      # 10 (оба истинны, вернули последний)
print(0 and 10)      # 0 (первый ложный)
print(5 and 0)       # 0 (второй ложный)
print("" and "hi")   # "" (пустая строка ложная)

# or возвращает первый True или последний операнд
print(5 or 10)       # 5 (первый истинный)
print(0 or 10)       # 10 (второй истинный)
print(0 or "")       # "" (оба ложные, вернули последний)
print(None or "default")  # "default" (часто для значений по умолчанию)

# Практическое применение
username = input("Имя: ") or "Гость"  # Если пустой ввод, то "Гость"
print(f"Привет, {username}!")
```


## `3.5` (`*`) Комбинирование и приоритизация логических операций  
При комбинировании нескольких логических операторов важно понимать порядок их выполнения.

### **Приоритет логических операторов:**
1. **`not`** — выполняется первым (наивысший приоритет)
2. **`and`** — выполняется вторым
3. **`or`** — выполняется последним (наименьший приоритет)

```python
# Пример без скобок
result = True or False and False
# Сначала: False and False = False
# Затем: True or False = True
print(result)  # True

# То же самое с явными скобками
result = True or (False and False)
print(result)  # True

# С оператором not
result = not True or False
# Сначала: not True = False
# Затем: False or False = False
print(result)  # False

# Более сложный пример
result = not False and True or False
# 1. not False = True
# 2. True and True = True
# 3. True or False = True
print(result)  # True
```

### **Использование скобок для ясности**

Даже зная приоритет, **всегда используйте скобки** для сложных выражений — это улучшает читаемость.

```python
age = 25
has_license = True
has_car = False

# Без скобок (может быть неочевидно)
can_drive = age >= 18 and has_license or has_car
print(can_drive)  # True

# Со скобками (понятнее)
can_drive = (age >= 18 and has_license) or has_car
print(can_drive)  # True

# Другая группировка даёт другой результат
can_drive = age >= 18 and (has_license or has_car)
print(can_drive)  # True
```

### **Практические примеры комбинирования**

```python
# Проверка диапазона
x = 15
if x > 10 and x < 20:
    print("x между 10 и 20")  # Выведет: x между 10 и 20

# Альтернативная запись (более питоническая)
if 10 < x < 20:
    print("x между 10 и 20")  # Выведет: x между 10 и 20

# Сложное условие с несколькими операторами
role = "user"
is_verified = True
age = 20

if (role == "admin" or role == "moderator") and is_verified and age >= 18:
    print("Полный доступ")
else:
    print("Ограниченный доступ")  # Выведет: Ограниченный доступ

# Проверка с not
password = "12345"
if not (len(password) >= 8 and password.isalnum()):
    print("Слабый пароль")  # Выведет: Слабый пароль

# Множественные условия
score = 85
attendance = 90

# Сначала and, потом or
if score >= 90 or score >= 80 and attendance >= 85:
    print("Отлично!")  # Выведет: Отлично!
    # Выполнится: score >= 80 and attendance >= 85 = True
    # Затем: False or True = True

# С явными скобками для другой логики
if (score >= 90 or score >= 80) and attendance >= 85:
    print("Хорошо!")  # Выведет: Хорошо!
```

### **Таблица истинности для комбинаций**

```python
# Все возможные комбинации для двух переменных
A = True
B = False

print(f"A and B = {A and B}")        # False
print(f"A or B = {A or B}")          # True
print(f"not A = {not A}")            # False
print(f"not A and B = {not A and B}")  # False
print(f"not A or B = {not A or B}")    # False
print(f"A and not B = {A and not B}")  # True
print(f"not (A and B) = {not (A and B)}")  # True (закон Де Моргана)
print(f"not A or not B = {not A or not B}")  # True (эквивалентно предыдущему)
```

**Важные правила:**
- Всегда используйте скобки для сложных выражений
- `not` имеет наивысший приоритет
- `and` выполняется раньше `or`
- Python использует короткое замыкание — вычисления останавливаются, как только результат становится очевидным

## `3.6` Вложенные условия
**Вложенные условия** — это `if` внутри другого `if`. Используются, когда нужно проверить дополнительное условие только после выполнения первого. Каждый уровень вложенности добавляет 4 пробела отступа.

**Когда использовать:**
- Условие зависит от предыдущего
- Нужна последовательная проверка
- Логика требует "если А, то проверить Б"

**Примеры:**

```python
# Пример 1: Простая вложенность
age = 20
has_license = True

if age >= 18:
    print("Возраст подходит")
    if has_license:
        print("Можете водить автомобиль")
    else:
        print("Нужно получить права")
else:
    print("Слишком молоды для вождения")

# Пример 2: Проверка логина и пароля
login = input("Логин: ")
password = input("Пароль: ")

if login == "admin":
    if password == "12345":
        print("Добро пожаловать, администратор!")
    else:
        print("Неверный пароль")
else:
    print("Пользователь не найден")

# Пример 3: Множественная вложенность
number = int(input("Введите число: "))

if number > 0:
    print("Число положительное")
    if number % 2 == 0:
        print("И чётное")
        if number > 100:
            print("И больше 100")
        else:
            print("И меньше или равно 100")
    else:
        print("И нечётное")
else:
    if number == 0:
        print("Это ноль")
    else:
        print("Число отрицательное")

# Пример 4: Проверка скидки
price = 1000
is_member = True
has_coupon = True

if is_member:
    print("Скидка 10% для участников")
    if has_coupon:
        print("Дополнительная скидка 5% по купону")
        final_price = price * 0.85  # 15% общая скидка
    else:
        final_price = price * 0.9   # 10% скидка
else:
    if has_coupon:
        print("Скидка 5% по купону")
        final_price = price * 0.95
    else:
        final_price = price

print(f"Итоговая цена: {final_price}")

# Пример 5: Проверка доступа к контенту
age = int(input("Ваш возраст: "))
has_subscription = input("Есть подписка? (да/нет): ") == "да"

if age >= 18:
    if has_subscription:
        print("Полный доступ ко всему контенту")
    else:
        print("Доступ к бесплатному контенту для взрослых")
        print("Оформите подписку для полного доступа")
else:
    if has_subscription:
        print("Доступ к детскому контенту")
        print("Взрослый контент недоступен")
    else:
        print("Доступ только к демо-версии")
```

**Важно:**
- Не делайте слишком много уровней вложенности (более 3-4 тяжело читать)
- Часто вложенные условия можно упростить логическими операторами

**Упрощение вложенных условий:**

```python
# Вложенные условия (сложнее читать)
age = 20
has_license = True

if age >= 18:
    if has_license:
        print("Можете водить")

# То же самое через логический оператор (проще)
if age >= 18 and has_license:
    print("Можете водить")

# Но иногда вложенность нужна для разных действий
if age >= 18:
    print("Совершеннолетний")  # Выполнится в любом случае
    if has_license:
        print("Можете водить")
else:
    print("Несовершеннолетний")
```

## `3.7` Каскадные условия. Что такое `elif`
**Каскадные условия (elif)** — способ проверить несколько взаимоисключающих условий по порядку. `elif` это сокращение от "else if" (иначе если).

**Как работает:**
1. Python проверяет `if` — если `True`, выполняет его блок и **пропускает остальные**
2. Если `if` был `False`, проверяет первый `elif`
3. Если и он `False`, проверяет следующий `elif`
4. Если все `False`, выполняется `else` (если он есть)

**Важно:** Выполняется **только один** блок — первый, где условие `True`!

**Структура:**
```python
if условие1:
    # код, если условие1 True
elif условие2:
    # код, если условие1 False, а условие2 True
elif условие3:
    # код, если условие1 и условие2 False, а условие3 True
else:
    # код, если все условия False
```

**Примеры:**

```python
# Пример 1: Базовый elif
score = 85

if score >= 90:
    print("Оценка: 5")
elif score >= 70:
    print("Оценка: 4")
elif score >= 50:
    print("Оценка: 3")
else:
    print("Оценка: 2")
# Оценка: 4

# Пример 2: Дни недели
day = int(input("Номер дня (1-7): "))

if day == 1:
    print("Понедельник")
elif day == 2:
    print("Вторник")
elif day == 3:
    print("Среда")
elif day == 4:
    print("Четверг")
elif day == 5:
    print("Пятница")
elif day == 6:
    print("Суббота")
elif day == 7:
    print("Воскресенье")
else:
    print("Некорректный номер дня")

# Пример 3: Определение возрастной категории
age = int(input("Ваш возраст: "))

if age < 0:
    print("Некорректный возраст")
elif age < 7:
    print("Дошкольник")
elif age < 18:
    print("Школьник")
elif age < 25:
    print("Студент")
elif age < 65:
    print("Работающий")
else:
    print("Пенсионер")

# Пример 4: Температурные диапазоны
temperature = int(input("Температура воздуха: "))

if temperature > 35:
    print("Экстремальная жара")
elif temperature > 25:
    print("Жарко")
elif temperature > 15:
    print("Тепло")
elif temperature > 5:
    print("Прохладно")
elif temperature > -5:
    print("Холодно")
elif temperature > -15:
    print("Очень холодно")
else:
    print("Экстремальный мороз")

# Пример 5: Только первое условие выполняется!
number = 100

if number > 50:
    print("Больше 50")  # ✅ Выполнится
elif number > 75:
    print("Больше 75")  # Пропустится, хотя условие True!
elif number > 90:
    print("Больше 90")  # Пропустится
# Вывод: Больше 50

# Чтобы проверить все, нужны отдельные if:
if number > 50:
    print("Больше 50")
if number > 75:
    print("Больше 75")
if number > 90:
    print("Больше 90")
# Вывод:
# Больше 50
# Больше 75
# Больше 90
```

**Сравнение: elif vs несколько if**

```python
# С elif — только одно условие выполнится
score = 85

if score >= 70:
    print("Хорошо")      # ✅ Выполнится
elif score >= 50:
    print("Нормально")   # Пропустится
elif score >= 0:
    print("Плохо")       # Пропустится
# Вывод: Хорошо

# С несколькими if — все True условия выполнятся
score = 85

if score >= 70:
    print("Хорошо")      # ✅ Выполнится
if score >= 50:
    print("Нормально")   # ✅ Выполнится
if score >= 0:
    print("Плохо")       # ✅ Выполнится
# Вывод:
# Хорошо
# Нормально
# Плохо
```

**Когда использовать elif:**
- ✅ Взаимоисключающие варианты (оценка, день недели, категория)
- ✅ Нужно выполнить только один блок кода
- ✅ Проверка диапазонов значений

**Когда использовать отдельные if:**
- ✅ Независимые условия
- ✅ Нужно проверить все условия
- ✅ Несколько действий могут быть одновременно

**Практический пример — калькулятор:**

```python
a = int(input("Первое число: "))
b = int(input("Второе число: "))
operation = input("Операция (+, -, *, /): ")

if operation == "+":
    print(f"Результат: {a + b}")
elif operation == "-":
    print(f"Результат: {a - b}")
elif operation == "*":
    print(f"Результат: {a * b}")
elif operation == "/":
    if b != 0:
        print(f"Результат: {a / b}")
    else:
        print("Ошибка: деление на ноль")
else:
    print("Неизвестная операция")
```

**Типичные ошибки:**

```python
# ❌ Ошибка: неправильный порядок условий
age = 15

if age > 0:
    print("Возраст положительный")  # Всегда выполнится первым
elif age < 18:
    print("Несовершеннолетний")     # Никогда не выполнится!

# ✅ Правильно: от более конкретного к общему
if age < 18:
    print("Несовершеннолетний")
elif age > 0:
    print("Возраст положительный")

# ❌ Ошибка: забыли elif
number = 5

if number > 0:
    print("Положительное")
else number < 0:  # SyntaxError! Нужен elif
    print("Отрицательное")

# ✅ Правильно:
if number > 0:
    print("Положительное")
elif number < 0:
    print("Отрицательное")
else:
    print("Ноль")
```

## `3.8` (`*`) `match-case`
`match-case` — современная конструкция для сопоставления значений с образцами (pattern matching). Появилась в Python 3.10. Это более мощная и читаемая альтернатива длинным цепочкам `if-elif-else`, особенно когда нужно проверить одну переменную на множество значений.

**Структура:**
```python
match переменная:
    case значение1:
        # код для значения1
    case значение2:
        # код для значения2
    case _:
        # код по умолчанию (если ничего не совпало)
```

**Важно:**
- `_` (подчёркивание) — это "wildcard", означает "всё остальное" (аналог `else`)
- В отличие от `if-elif`, здесь нет слова `break` — выполняется только один случай
- Работает только в Python 3.10+

**Примеры:**

```python
# Пример 1: Базовое использование — дни недели
day = int(input("Номер дня (1-7): "))

match day:
    case 1:
        print("Понедельник")
    case 2:
        print("Вторник")
    case 3:
        print("Среда")
    case 4:
        print("Четверг")
    case 5:
        print("Пятница")
    case 6:
        print("Суббота")
    case 7:
        print("Воскресенье")
    case _:
        print("Некорректный номер дня")

# То же самое через if-elif (длиннее и менее читабельно)
if day == 1:
    print("Понедельник")
elif day == 2:
    print("Вторник")
# ... и так далее
```

```python
# Пример 2: Калькулятор
a = int(input("Первое число: "))
b = int(input("Второе число: "))
operation = input("Операция (+, -, *, /): ")

match operation:
    case "+":
        print(f"Результат: {a + b}")
    case "-":
        print(f"Результат: {a - b}")
    case "*":
        print(f"Результат: {a * b}")
    case "/":
        if b != 0:
            print(f"Результат: {a / b}")
        else:
            print("Ошибка: деление на ноль")
    case _:
        print("Неизвестная операция")
```

```python
# Пример 3: Несколько значений в одном case (через |)
status_code = int(input("HTTP код: "))

match status_code:
    case 200 | 201 | 204:
        print("Успех!")
    case 400 | 401 | 403:
        print("Ошибка клиента")
    case 500 | 502 | 503:
        print("Ошибка сервера")
    case _:
        print("Неизвестный код")

# Эквивалент с if-elif (гораздо длиннее)
if status_code in [200, 201, 204]:
    print("Успех!")
elif status_code in [400, 401, 403]:
    print("Ошибка клиента")
# ...
```

```python
# Пример 4: Условия внутри case (guard)
age = int(input("Возраст: "))

match age:
    case n if n < 0:
        print("Некорректный возраст")
    case n if n < 7:
        print("Дошкольник")
    case n if n < 18:
        print("Школьник")
    case n if n < 65:
        print("Работающий")
    case _:
        print("Пенсионер")
```

```python
# Пример 5: Сопоставление строк
command = input("Команда: ").lower()

match command:
    case "start" | "запустить":
        print("Программа запущена")
    case "stop" | "остановить":
        print("Программа остановлена")
    case "help" | "помощь":
        print("Доступные команды: start, stop, help")
    case "exit" | "выход":
        print("До свидания!")
    case _:
        print("Неизвестная команда. Введите 'help' для справки")
```

```python
# Пример 6: Сопоставление с кортежами (более продвинуто)
point = (0, 0)

match point:
    case (0, 0):
        print("Точка в начале координат")
    case (0, y):
        print(f"Точка на оси Y: {y}")
    case (x, 0):
        print(f"Точка на оси X: {x}")
    case (x, y):
        print(f"Точка в координатах ({x}, {y})")
```

```python
# Пример 7: Меню ресторана
choice = input("Выберите блюдо (1-5): ")

match choice:
    case "1":
        print("Вы выбрали: Борщ - 300 руб")
    case "2":
        print("Вы выбрали: Пельмени - 250 руб")
    case "3":
        print("Вы выбрали: Салат - 150 руб")
    case "4":
        print("Вы выбрали: Десерт - 200 руб")
    case "5":
        print("Вы выбрали: Напиток - 100 руб")
    case _:
        print("Блюдо не найдено в меню")
```

**Преимущества match-case:**
- ✅ Короче и понятнее для множества вариантов
- ✅ Удобная группировка значений через `|`
- ✅ Более мощные возможности сопоставления (структур данных)
- ✅ Проще добавлять новые варианты

**Недостатки:**
- ❌ Работает только в Python 3.10+
- ❌ Для простых условий `if-elif` может быть понятнее
- ❌ Нельзя использовать сложные логические выражения напрямую

**Когда использовать match-case:**
- ✅ Проверка одной переменной на много значений
- ✅ Выбор действия на основе кода/команды
- ✅ Меню, калькуляторы, парсеры команд
- ✅ Обработка типов данных или статусов

**Когда использовать if-elif:**
- ✅ Сложные логические условия
- ✅ Сравнение разных переменных
- ✅ Диапазоны значений (хотя можно использовать guard в match)
- ✅ Нужна совместимость со старыми версиями Python

**Сравнение подходов:**

```python
# Задача: определить категорию товара по коду

# С if-elif (старый способ)
code = "A1"

if code == "A1" or code == "A2":
    print("Электроника")
elif code == "B1" or code == "B2":
    print("Одежда")
elif code == "C1" or code == "C2":
    print("Продукты")
else:
    print("Неизвестная категория")

# С match-case (современный способ)
match code:
    case "A1" | "A2":
        print("Электроника")
    case "B1" | "B2":
        print("Одежда")
    case "C1" | "C2":
        print("Продукты")
    case _:
        print("Неизвестная категория")
```

**Практический пример — игра "Камень, ножницы, бумага":**

```python
player = input("Ваш выбор (камень/ножницы/бумага): ").lower()
computer = "ножницы"  # Допустим, компьютер выбрал ножницы

match (player, computer):
    case ("камень", "ножницы") | ("ножницы", "бумага") | ("бумага", "камень"):
        print("Вы победили!")
    case ("камень", "камень") | ("ножницы", "ножницы") | ("бумага", "бумага"):
        print("Ничья!")
    case ("ножницы", "камень") | ("бумага", "ножницы") | ("камень", "бумага"):
        print("Компьютер победил!")
    case _:
        print("Некорректный выбор")
```

**Итог:**
`match-case` — мощный инструмент для чистого и выразительного кода, когда нужно сопоставить значение с множеством вариантов. Однако для простых условий классический `if-elif-else` остаётся вполне подходящим решением.









----

# `4` Типы данных 1
## `4.1` Что такое тип данных и зачем он нужен?
**Тип данных** — это категория данных, которая определяет:
- Какие значения может хранить переменная
- Какие операции можно с ней выполнять
- Сколько памяти она занимает

`Python` — язык с **динамической типизацией**, то есть тип переменной определяется автоматически при присваивании значения. Не нужно явно указывать тип, как в C++ или Java.

**Основные типы данных в Python:**
- `int` — целые числа (1, 42, -100)
- `float` — числа с плавающей точкой (3.14, -0.5)
- `str` — строки ("привет", 'текст')
- `bool` — логические значения (True, False)
- `list` — списки ([1, 2, 3])
- `dict` — словари ({'key': 'value'})
- `tuple` — кортежи ((1, 2, 3))
- `set` — множества ({1, 2, 3})

**Зачем нужны типы данных:**
1. **Безопасность** — предотвращают ошибки (нельзя разделить строку на число)
2. **Оптимизация** — компьютер понимает, как хранить и обрабатывать данные
3. **Ясность** — код становится понятнее (что именно хранится в переменной)
4. **Операции** — каждый тип поддерживает свои операции (сложение чисел ≠ конкатенация строк)

**Примеры:**

```python
# Узнать тип переменной — функция type()
age = 25
print(type(age))  # <class 'int'>

price = 19.99
print(type(price))  # <class 'float'>

name = "Иван"
print(type(name))  # <class 'str'>

is_active = True
print(type(is_active))  # <class 'bool'>

# Python автоматически определяет тип
x = 10        # int
x = 10.5      # Теперь float (тип изменился!)
x = "текст"   # Теперь str

# Разные типы — разные операции
print(5 + 3)        # 8 (сложение чисел)
print("5" + "3")    # "53" (конкатенация строк)
print(5 * 3)        # 15 (умножение чисел)
print("5" * 3)      # "555" (повторение строки)
```

## `4.2` Числовые типы данных. Целые числа и числа с плавающей точкой
### `int` (integer) — целые числа
- Целые числа без дробной части
- Могут быть положительными, отрицательными или нулём
- В Python 3 нет ограничения на размер (ограничены только памятью)
- Используются для подсчёта, индексации, целочисленной арифметики

### `float` (floating point) — числа с плавающей точкой
- Числа с дробной частью
- Записываются с точкой: `3.14`, `0.5`, `-2.718`
- Могут быть в экспоненциальной форме: `1e6` (1 × 10⁶ = 1000000)
- Занимают 8 байт (64 бита)
- Имеют ограниченную точность (~15-17 значащих цифр)

**Важно:** Деление `/` всегда возвращает `float`, даже если результат целое число!

**Примеры:**

```python
# int — целые числа
a = 10
b = -5
c = 0
print(type(a))  # <class 'int'>

# float — дробные числа
x = 3.14
y = -0.5
z = 2.0  # Это float, даже если нет дробной части!
print(type(x))  # <class 'float'>

# Экспоненциальная запись
big_number = 1e6  # 1000000.0
small_number = 1e-3  # 0.001
print(type(big_number))  # <class 'float'>

# Операции с int
print(10 + 5)   # 15 (int)
print(10 - 3)   # 7 (int)
print(10 * 2)   # 20 (int)
print(10 // 3)  # 3 (int — целочисленное деление)
print(10 % 3)   # 1 (int — остаток)
print(2 ** 3)   # 8 (int — степень)

# Операции с float
print(10.5 + 2.3)  # 12.8 (float)
print(10.0 - 3.0)  # 7.0 (float)
print(3.14 * 2)    # 6.28 (float)

# Деление всегда возвращает float!
print(10 / 2)   # 5.0 (не 5!)
print(9 / 3)    # 3.0 (не 3!)
print(type(10 / 2))  # <class 'float'>

# Смешанные операции — результат float
print(10 + 2.5)    # 12.5 (float)
print(5 * 1.5)     # 7.5 (float)
print(type(10 + 2.5))  # <class 'float'>

# Преобразование типов
num_str = "42"
num_int = int(num_str)     # Строка → int
num_float = float(num_str)  # Строка → float

print(int(3.14))    # 3 (отбрасывает дробную часть)
print(float(5))     # 5.0
print(int(9.99))    # 9 (не округляет, а отбрасывает!)

# Проблема точности float
print(0.1 + 0.2)  # 0.30000000000000004 (не 0.3!)
# Это особенность хранения чисел в памяти
```

## `4.3` Функции `min()`, `max()`, `abs()`
### `min()` — минимальное значение
Возвращает наименьшее из переданных значений или элементов последовательности.

### `max()` — максимальное значение
Возвращает наибольшее из переданных значений или элементов последовательности.

### `abs()` — модуль числа (абсолютное значение)
Возвращает число без знака (всегда положительное или ноль).

**Примеры:**

```python
# min() — минимум из нескольких чисел
print(min(5, 2, 8, 1))  # 1
print(min(10, 20))      # 10
print(min(-5, -10, 0))  # -10

# max() — максимум из нескольких чисел
print(max(5, 2, 8, 1))  # 8
print(max(10, 20))      # 20
print(max(-5, -10, 0))  # 0

# abs() — модуль числа
print(abs(5))      # 5
print(abs(-5))     # 5
print(abs(0))      # 0
print(abs(-3.14))  # 3.14

# Практические примеры
a = int(input("Первое число: "))
b = int(input("Второе число: "))
c = int(input("Третье число: "))

print("Минимум:", min(a, b, c))
print("Максимум:", max(a, b, c))

# Разница между двумя числами (всегда положительная)
x = 10
y = 25
difference = abs(x - y)
print(f"Разница: {difference}")  # 15

# Расстояние от нуля
temperature = -15
distance_from_zero = abs(temperature)
print(f"Температура отличается от нуля на {distance_from_zero}°")
```

## `4.4` Функция `round`
`round()` — округляет число с плавающей точкой до указанного количества знаков после запятой.

**Синтаксис:**
```python
round(число, количество_знаков)
```
- Если не указать количество знаков — округлит до целого
- Использует "математическое округление" (до ближайшего чётного при .5)

**Важно:** `round()` возвращает `float`, если указано количество знаков, и `int`, если нет.

**Примеры:**

```python
# Округление до целого
print(round(3.14))    # 3
print(round(3.7))     # 4
print(round(3.5))     # 4 (округление до ближайшего чётного)
print(round(4.5))     # 4 (тоже до чётного!)
print(round(-2.7))    # -3

# Округление до N знаков после запятой
print(round(3.14159, 2))   # 3.14
print(round(3.14159, 3))   # 3.142
print(round(3.14159, 0))   # 3.0 (вернёт float!)

# Округление до десятков, сотен
print(round(1234, -1))  # 1230 (до десятков)
print(round(1234, -2))  # 1200 (до сотен)
print(round(1567, -2))  # 1600

# Практические примеры
price = 19.99876
print(f"Цена: {round(price, 2)} руб")  # Цена: 20.0 руб

pi = 3.141592653589793
print(round(pi, 4))  # 3.1416

# Среднее значение
total = 100
count = 3
average = total / count
print(f"Среднее: {round(average, 2)}")  # Среднее: 33.33
```

## `4.5` Строковый тип данных
**Строка (str)** — последовательность символов, заключённая в кавычки. Строки **неизменяемы** — нельзя изменить отдельный символ, можно только создать новую строку.

**Способы создания строк:**
- Одинарные кавычки: `'текст'`
- Двойные кавычки: `"текст"`
- Тройные кавычки: `'''текст'''` или `"""текст"""` (для многострочных)

**Особенности:**
- Можно использовать любые кавычки, но стиль должен быть единообразным
- Тройные кавычки сохраняют переносы строк
- Экранирование специальных символов: `\n` (новая строка), `\t` (табуляция), `\\` (обратный слэш), `\'` и `\"`

**Операции со строками:**
- `+` — конкатенация (склеивание)
- `*` — повторение
- Индексация: `s[0]` — первый символ, `s[-1]` — последний
- Срезы: `s[1:4]` — символы с 1 по 3 (4 не включается)

**Примеры:**

```python
# Создание строк
name1 = "Иван"
name2 = 'Пётр'
quote = "Он сказал: 'Привет!'"  # Можно смешивать кавычки
multiline = """Это
многострочный
текст"""

# Конкатенация (склеивание)
first_name = "Иван"
last_name = "Иванов"
full_name = first_name + " " + last_name
print(full_name)  # Иван Иванов

greeting = "Привет, " + "мир!"
print(greeting)  # Привет, мир!

# Повторение
print("=" * 20)  # ====================
print("Ха" * 3)  # ХаХаХа

# Индексация (нумерация с 0)
text = "Python"
print(text[0])   # P (первый символ)
print(text[1])   # y
print(text[-1])  # n (последний символ)
print(text[-2])  # o (предпоследний)

# Срезы [начало:конец]
text = "Hello, World!"
print(text[0:5])   # Hello
print(text[7:12])  # World
print(text[:5])    # Hello (с начала до 5)
print(text[7:])    # World! (с 7 до конца)
print(text[-6:])   # World! (последние 6 символов)

# Специальные символы
print("Строка 1\nСтрока 2")  # Перенос строки
# Строка 1
# Строка 2

print("Имя:\tИван")  # Табуляция
# Имя:    Иван

print("Путь: C:\\Users\\file.txt")  # Экранирование \
# Путь: C:\Users\file.txt

# Строки неизменяемы!
text = "Python"
# text[0] = "J"  # Ошибка! TypeError

# Но можно создать новую строку
text = "J" + text[1:]
print(text)  # Jython

# f-строки (форматирование)
name = "Иван"
age = 25
print(f"Меня зовут {name}, мне {age} лет")
# Меня зовут Иван, мне 25 лет

# Методы строк
text = "python"
print(text.upper())      # PYTHON
print(text.capitalize()) # Python
print(text.replace("p", "j"))  # jython
```

## `4.6` Функции `len()`, `in` для строк
### `len()` — длина строки
Возвращает количество символов в строке (включая пробелы и знаки препинания).

### `in` — проверка вхождения
Оператор `in` проверяет, содержится ли подстрока в строке. Возвращает `True` или `False`.  
`not in` — проверяет отсутствие подстроки.

**Примеры:**

```python
# len() — длина строки
text = "Python"
print(len(text))  # 6

message = "Привет, мир!"
print(len(message))  # 12 (пробелы и знаки считаются)

empty = ""
print(len(empty))  # 0

# Практическое применение len()
password = input("Введите пароль: ")
if len(password) < 8:
    print("Пароль слишком короткий")
else:
    print("Пароль принят")

# in — проверка вхождения подстроки
text = "Python — отличный язык программирования"

print("Python" in text)  # True
print("Java" in text)    # False
print("отличный" in text)  # True
print("плохой" in text)  # False

# not in — проверка отсутствия
print("Java" not in text)  # True
print("Python" not in text)  # False

# Использование в условиях
email = input("Email: ")

if "@" in email and "." in email:
    print("Email корректен")
else:
    print("Некорректный email")

# Проверка на запрещённые слова
comment = input("Комментарий: ")
banned_words = ["плохо", "ужасно", "спам"]

contains_banned = False
for word in banned_words:
    if word in comment:
        contains_banned = True
        break

if contains_banned:
    print("Комментарий содержит запрещённые слова")
else:
    print("Комментарий принят")

# Проверка символа в строке
char = input("Введите символ: ")
vowels = "аеёиоуыэюяАЕЁИОУЫЭЮЯ"

if char in vowels:
    print("Это гласная буква")
else:
    print("Это не гласная")

# Регистр важен!
text = "Python"
print("python" in text)  # False (разный регистр)
print("Python" in text)  # True

# Чтобы игнорировать регистр
text_lower = text.lower()
print("python" in text_lower)  # True
```

**Итог:**
- `len()` — универсальная функция для получения длины строки (и других последовательностей)
- `in` — удобный способ проверить наличие подстроки без сложных условий
- Оба часто используются вместе для валидации пользовательского ввода

## `4.7` (`*`) `bool` & `None`
### **Тип `bool` (булев тип)**

`bool` — это логический тип данных с двумя значениями: `True` и `False`.

```python
is_active = True
is_deleted = False

print(type(is_active))  # <class 'bool'>

# bool() преобразует значения
print(bool(1))       # True
print(bool(0))       # False
print(bool("text"))  # True
print(bool(""))      # False
print(bool([1, 2]))  # True
print(bool([]))      # False
```

**Ложные значения (Falsy):** `False`, `None`, `0`, `""`, `[]`, `()`, `{}`. Всё остальное — истина.

```python
items = []
if not items:
    print("Список пуст")  # Выведет: Список пуст
```

### **Тип `None` (отсутствие значения)**

`None` — специальный объект, обозначающий отсутствие значения.

```python
result = None
print(type(result))  # <class 'NoneType'>

# Функции без return возвращают None
def greet():
    print("Привет")

print(greet())  # None

# Проверка на None — используй is/is not
value = None
if value is None:  # Правильно
    print("Значение не задано")  # Выведет: Значение не задано
```

**Отличия `None` от `False`:**

```python
print(None == False)   # False — разные объекты
print(bool(None))      # False — но приводится к False
print(None is False)   # False — разные типы

# Оба ложные в условиях, но проверяются по-разному
if not None:
    print("None — ложь")  # Выведет

value = None
if value is None:  # Для None используй is
    print("Это None")  # Выведет: Это None
```

----

# `5` Строки
## `5.1` (`*`) Индексы

`Индекс` — это числовое значение, обозначающее позицию символа в строке. В Python индексы начинаются с `0` для первого символа.

### **Положительные индексы**

Отсчитываются с начала строки, начиная с `0`.

```python
s = "Python"
print(s[0])  # 'P' (первый символ)
print(s[1])  # 'y' (второй символ)
print(s[5])  # 'n' (шестой символ)

# Обращение к несуществующему индексу вызовет ошибку
# print(s[10])  # IndexError: string index out of range

# Длина строки
print(len(s))  # 6
print(s[len(s) - 1])  # 'n' (последний символ через длину)
```

### **Отрицательные индексы**

Отсчитываются с конца строки: `-1` — последний символ, `-2` — предпоследний и так далее.

```python
s = "Python"
print(s[-1])  # 'n' (последний символ)
print(s[-2])  # 'o' (предпоследний)
print(s[-6])  # 'P' (первый символ через отрицательный индекс)

# Соответствие положительных и отрицательных индексов
# s = "Python"
#     P  y  t  h  o  n
#     0  1  2  3  4  5   (положительные)
#    -6 -5 -4 -3 -2 -1   (отрицательные)
```

### **Практические примеры**

```python
text = "Hello, World!"

# Получение первого и последнего символа
first = text[0]
last = text[-1]
print(f"Первый: {first}, Последний: {last}")  # Первый: H, Последний: !

# Проверка символа на позиции
email = "user@example.com"
if email[0] == '@':
    print("Email не может начинаться с @")
else:
    print("Email корректен")  # Выведет: Email корректен

# Получение расширения файла
filename = "document.pdf"
extension = filename[-3:]  # Последние 3 символа (используя срез)
print(extension)  # 'pdf'
```

## `5.2` (`*`) Срезы. Срезы с одним/двумя/тремя параметрами `[x:y:z]` 
`Срез` (slice) позволяет извлечь подстроку, указав диапазон индексов. Синтаксис: `[start:stop:step]`.

- `start` — начальный индекс (включительно), по умолчанию `0`
- `stop` — конечный индекс (не включается!), по умолчанию конец строки
- `step` — шаг, по умолчанию `1`

### **Срезы с двумя параметрами `[start:stop]`**

```python
s = "Python Programming"

# От индекса 0 до 6 (не включая 6)
print(s[0:6])   # 'Python'
print(s[:6])    # 'Python' (start=0 по умолчанию)

# От индекса 7 до конца
print(s[7:])    # 'Programming'

# От 7 до 18
print(s[7:18])  # 'Programming'

# Средняя часть
print(s[3:9])   # 'hon Pr'

# Пустая строка (start >= stop)
print(s[5:5])   # ''
print(s[5:3])   # ''
```

### **Срезы с одним параметром `[:stop]` или `[start:]`**

```python
s = "Python"

# От начала до индекса 3
print(s[:3])    # 'Pyt'

# От индекса 2 до конца
print(s[2:])    # 'thon'

# Вся строка
print(s[:])     # 'Python'
```

### **Срезы с тремя параметрами `[start:stop:step]`**

Параметр `step` определяет шаг выбора символов.

```python
s = "Python Programming"

# Каждый второй символ
print(s[::2])   # 'Pto rgamn'

# Каждый третий символ
print(s[::3])   # 'Ph ormn'

# От 0 до 12 с шагом 2
print(s[0:12:2])  # 'Pto rg'

# От 7 до конца с шагом 2
print(s[7::2])    # 'Pormig'

# Пропуск первых и последних символов, шаг 2
print(s[1:-1:2])  # 'yhno rgmin'
```

### **Практические примеры**

```python
# Извлечение доменного имени из email
email = "user@example.com"
at_index = email.index('@')
domain = email[at_index + 1:]
print(domain)  # 'example.com'

# Получение первых N символов
text = "Hello, World!"
preview = text[:5]
print(preview)  # 'Hello'

# Удаление первого и последнего символа
s = '"quoted text"'
unquoted = s[1:-1]
print(unquoted)  # 'quoted text'

# Каждое второе слово (через split и срез)
sentence = "one two three four five six"
words = sentence.split()
every_second = words[::2]
print(every_second)  # ['one', 'three', 'five']

# Копирование строки
original = "Python"
copy = original[:]
print(copy)  # 'Python'
```

## `5.3` Методы строк:  
**Методы** — это функции, которые принадлежат определённому типу данных и вызываются через точку: `строка.метод()`. Строковые методы возвращают новую строку, не изменяя оригинал (строки неизменяемы!).

**Синтаксис:**
```python
результат = строка.метод()
```

### `capitalize()` — первая буква заглавная

**Теория:**
Преобразует первый символ строки в заглавную букву, остальные — в строчные.

**Примеры:**
```python
text = "python"
print(text.capitalize())  # Python

text = "PYTHON"
print(text.capitalize())  # Python

text = "привет мир"
print(text.capitalize())  # Привет мир (только первая буква)

# Практическое применение
name = input("Ваше имя: ").capitalize()
print(f"Привет, {name}!")
# Ввод: иВаН → Привет, Иван!
```

### `title()` — каждое слово с заглавной буквы

**Теория:**
Преобразует первую букву каждого слова в заглавную, остальные — в строчные. Слова разделяются пробелами и знаками препинания.

**Примеры:**
```python
text = "python programming"
print(text.title())  # Python Programming

text = "война и мир"
print(text.title())  # Война И Мир

text = "hello, world!"
print(text.title())  # Hello, World!

# Практическое применение
book = "унесённые ветром"
print(book.title())  # Унесённые Ветром

full_name = input("ФИО: ").title()
print(f"Добро пожаловать, {full_name}")
# Ввод: иван иванов → Добро пожаловать, Иван Иванов
```


### `lower()` — все буквы строчные

**Теория:**
Преобразует все буквы в строчные (нижний регистр).

**Примеры:**
```python
text = "PYTHON"
print(text.lower())  # python

text = "Hello, World!"
print(text.lower())  # hello, world!

# Практическое применение — сравнение без учёта регистра
password = input("Пароль: ")
if password.lower() == "secret":
    print("Доступ разрешён")

# Проверка команды
command = input("Команда: ").lower()
if command == "start":
    print("Запуск программы")
elif command == "stop":
    print("Остановка программы")
```


### `upper()` — все буквы заглавные

**Теория:**
Преобразует все буквы в заглавные (верхний регистр).

**Примеры:**
```python
text = "python"
print(text.upper())  # PYTHON

text = "Hello, World!"
print(text.upper())  # HELLO, WORLD!

# Практическое применение
code = input("Промокод: ").upper()
if code == "SALE2024":
    print("Скидка 20%!")

# Выделение важного текста
print("=" * 30)
print("ВНИМАНИЕ!".upper())
print("=" * 30)
```


### `startswith()` — проверка начала строки

**Теория:**
Проверяет, начинается ли строка с указанной подстроки. Возвращает `True` или `False`.

**Синтаксис:**
```python
строка.startswith(подстрока)
```

**Примеры:**
```python
text = "Python — отличный язык"
print(text.startswith("Python"))  # True
print(text.startswith("Java"))    # False

# Регистр важен!
print(text.startswith("python"))  # False

# Практическое применение — проверка префикса
phone = input("Телефон: ")
if phone.startswith("+7") or phone.startswith("8"):
    print("Российский номер")
else:
    print("Иностранный номер")

# Проверка начала email
email = input("Email: ")
if email.startswith("admin"):
    print("Административный аккаунт")

# Проверка протокола
url = "https://example.com"
if url.startswith("https://"):
    print("Безопасное соединение")
elif url.startswith("http://"):
    print("Небезопасное соединение")

# Проверка нескольких вариантов (кортеж)
text = "Hello, world!"
print(text.startswith(("Hi", "Hello")))  # True
```


### `strip()` — удаление пробелов

**Теория:**
Удаляет пробелы (и другие пробельные символы: `\n`, `\t`) с начала и конца строки. Не затрагивает пробелы внутри строки.

**Варианты:**
- `strip()` — с обоих концов
- `lstrip()` — только слева (left)
- `rstrip()` — только справа (right)

**Примеры:**
```python
text = "  Python  "
print(text.strip())  # "Python" (без кавычек в выводе)
print(len(text))          # 10
print(len(text.strip()))  # 6

# Пробелы внутри не удаляются
text = "  Hello World  "
print(text.strip())  # "Hello World"

# Удаление других символов
text = "...Python..."
print(text.strip("."))  # "Python"

text = "###Hello###"
print(text.strip("#"))  # "Hello"

# lstrip() — только слева
text = "  Python  "
print(text.lstrip())  # "Python  "

# rstrip() — только справа
text = "  Python  "
print(text.rstrip())  # "  Python"

# Практическое применение — очистка ввода
name = input("Ваше имя: ").strip()
# Если пользователь ввёл "  Иван  " → сохранится "Иван"

# Удаление переносов строк
text = "Hello\n"
print(text.strip())  # "Hello"

# Цепочка методов
name = "  иВаН  "
clean_name = name.strip().capitalize()
print(clean_name)  # "Иван"
```


### `isalpha()` — только буквы?

**Теория:**
Проверяет, состоит ли строка **только из букв** (без цифр, пробелов, знаков препинания). Возвращает `True` или `False`.

**Важно:** Пустая строка возвращает `False`.

**Примеры:**
```python
print("Python".isalpha())     # True
print("Python3".isalpha())    # False (есть цифра)
print("Hello World".isalpha()) # False (есть пробел)
print("Привет".isalpha())     # True (работает с кириллицей)
print("".isalpha())           # False (пустая строка)
print("!@#".isalpha())        # False (знаки препинания)

# Практическое применение — валидация имени
name = input("Ваше имя: ")
if name.isalpha():
    print("Имя принято")
else:
    print("Имя должно содержать только буквы")

# Проверка логина (только буквы, без цифр)
login = input("Логин (только буквы): ")
if login.isalpha():
    print("Логин корректен")
else:
    print("Используйте только буквы")
```


### `isdigit()` — только цифры?

**Теория:**
Проверяет, состоит ли строка **только из цифр**. Возвращает `True` или `False`.

**Важно:** Пустая строка возвращает `False`. Знак минус `-` не считается частью цифры.

**Примеры:**
```python
print("12345".isdigit())   # True
print("123.45".isdigit())  # False (есть точка)
print("123 456".isdigit()) # False (есть пробел)
print("-123".isdigit())    # False (есть минус)
print("Python".isdigit())  # False (буквы)
print("".isdigit())        # False (пустая строка)

# Практическое применение — проверка перед int()
age_input = input("Ваш возраст: ")
if age_input.isdigit():
    age = int(age_input)
    print(f"Вам {age} лет")
else:
    print("Введите число!")

# Проверка индекса
index = input("Введите индекс: ")
if index.isdigit() and len(index) == 6:
    print("Корректный почтовый индекс")
else:
    print("Индекс должен состоять из 6 цифр")

# Проверка пин-кода
pin = input("Пин-код (4 цифры): ")
if pin.isdigit() and len(pin) == 4:
    print("Пин-код принят")
else:
    print("Пин-код должен быть из 4 цифр")
```


### `islower()` — все буквы строчные?

**Теория:**
Проверяет, все ли буквы в строке находятся в нижнем регистре. Цифры и символы игнорируются.

**Важно:** Возвращает `False`, если в строке нет ни одной буквы.

**Примеры:**
```python
print("python".islower())      # True
print("Python".islower())      # False (есть заглавная P)
print("python3".islower())     # True (цифры игнорируются)
print("hello world".islower()) # True (пробелы игнорируются)
print("123".islower())         # False (нет букв)
print("".islower())            # False (пустая строка)

# Практическое применение
password = input("Пароль (только строчные буквы): ")
if password.islower() and password.isalpha():
    print("Пароль принят")
else:
    print("Используйте только строчные буквы")

# Проверка формата
code = "abc123"
if code[:3].islower() and code[3:].isdigit():
    print("Формат кода корректен: 3 строчные буквы + 3 цифры")
```


### `isupper()` — все буквы заглавные?

**Теория:**
Проверяет, все ли буквы в строке находятся в верхнем регистре. Цифры и символы игнорируются.

**Важно:** Возвращает `False`, если в строке нет ни одной буквы.

**Примеры:**
```python
print("PYTHON".isupper())      # True
print("Python".isupper())      # False (есть строчные)
print("PYTHON3".isupper())     # True (цифры игнорируются)
print("HELLO WORLD".isupper()) # True (пробелы игнорируются)
print("123".isupper())         # False (нет букв)
print("".isupper())            # False (пустая строка)

# Практическое применение — проверка кода
code = input("Введите код: ")
if code.isupper() and len(code) == 4:
    print("Код принят")
else:
    print("Код должен состоять из 4 заглавных букв")

# Проверка аббревиатуры
abbr = input("Аббревиатура: ")
if abbr.isupper() and abbr.isalpha():
    print("Корректная аббревиатура")
else:
    print("Аббревиатура должна быть из заглавных букв")

# Проверка формата
text = "ABC-123"
parts = text.split("-")
if parts[0].isupper() and parts[1].isdigit():
    print("Формат корректен: ABC-123")
```


**Комбинирование методов:**

```python
# Цепочка методов
text = "  PYTHON programming  "
result = text.strip().lower().capitalize()
print(result)  # "Python programming"

# Проверка и преобразование
username = input("Username: ").strip().lower()
if username.isalpha() and 3 <= len(username) <= 15:
    print("Username принят")
else:
    print("Username: 3-15 букв")

# Валидация email (базовая)
email = input("Email: ").strip().lower()
if "@" in email and "." in email and not email.startswith("@"):
    print("Email корректен")
else:
    print("Некорректный email")

# Проверка пароля
password = input("Пароль: ")
has_upper = any(c.isupper() for c in password)
has_lower = any(c.islower() for c in password)
has_digit = any(c.isdigit() for c in password)

if has_upper and has_lower and has_digit and len(password) >= 8:
    print("Пароль надёжный")
else:
    print("Пароль должен содержать: заглавные, строчные буквы, цифры, минимум 8 символов")
```

**Итог:**
- Строковые методы не изменяют оригинальную строку, а возвращают новую
- Можно объединять методы в цепочки: `text.strip().lower()`
- `is*()` методы возвращают `True`/`False` и удобны для валидации
- Методы регистра (`upper()`, `lower()`) полезны для сравнения без учёта регистра

## `5.4` (`*`) Отрицательные срезы  
Отрицательные индексы в срезах позволяют работать с концом строки без вычисления длины. Особенно полезны для реверса строки и извлечения данных с конца.

### **Отрицательные границы среза**

```python
s = "Hello, Python!"

# Последние 6 символов
print(s[-6:])      # 'Python!'

# С 4-го символа с конца до предпоследнего
print(s[-4:-1])    # 'tho'

# Все символы кроме последних 3
print(s[:-3])      # 'Hello, Pyth'

# Все символы кроме первых 7
print(s[7:])       # 'Python!'

# С -10 по -3
print(s[-10:-3])   # ', Pytho'

# Комбинирование положительных и отрицательных
print(s[2:-2])     # 'llo, Python'
```

### **Отрицательный шаг (реверс)**

При отрицательном `step` строка читается справа налево.

```python
s = "Python"

# Реверс строки
print(s[::-1])     # 'nohtyP'

# Каждый второй символ с конца
print(s[::-2])     # 'nhy'

# От конца до начала с шагом 3
print(s[::-3])     # 'nt'

# Реверс подстроки
text = "Hello, World!"
print(text[7:12][::-1])  # 'dlroW'
# Или в одном срезе (сложнее читается):
print(text[11:6:-1])     # 'dlroW'
```

### **Сложные срезы с отрицательными значениями**

При отрицательном шаге `start` должен быть **больше** `stop` (справа от него).

```python
s = "Python Programming"

# От индекса 10 до 5 (справа налево)
print(s[10:5:-1])   # 'mmargor' (неправильное направление)

# От -5 до -10 (справа налево)
print(s[-5:-10:-1]) # 'mim'

# От конца до индекса 7 (справа налево)
print(s[:7:-1])     # 'gnimmargorP'

# От индекса 10 до начала (справа налево)
print(s[10::-1])    # 'rP nohtyP'

# Весь текст в обратном порядке
print(s[::-1])      # 'gnimmargorP nohtyP'
```

### **Практические примеры с отрицательными срезами**

```python
# Проверка палиндрома
word = "radar"
if word == word[::-1]:
    print(f"{word} — палиндром")  # Выведет: radar — палиндром

# Удаление расширения файла
filename = "document.pdf"
name_without_ext = filename[:-4]  # Убираем последние 4 символа
print(name_without_ext)  # 'document'

# Получение последних N символов
text = "1234567890"
last_three = text[-3:]
print(last_three)  # '890'

# Извлечение кода страны из телефона
phone = "+1-555-1234"
country_code = phone[1:phone.index('-')]  # С индекса 1 до первого '-'
print(country_code)  # '1'

# Реверс каждого слова в предложении
sentence = "Hello World Python"
words = sentence.split()
reversed_words = [word[::-1] for word in words]
result = ' '.join(reversed_words)
print(result)  # 'olleH dlroW nohtyP'

# Получение домена верхнего уровня
url = "https://www.example.com"
tld = url[url.rfind('.') + 1:]  # После последней точки
print(tld)  # 'com'

# Удаление первого и последнего символа
quoted = "'Hello'"
unquoted = quoted[1:-1]
print(unquoted)  # 'Hello'

# Проверка, заканчивается ли строка на определённую подстроку
text = "example.txt"
if text[-4:] == ".txt":
    print("Это текстовый файл")  # Выведет: Это текстовый файл
```

### **Визуализация индексов для сложных срезов**

```python
s = "Python"
# Индексы:
#     P   y   t   h   o   n
#     0   1   2   3   4   5   (положительные)
#    -6  -5  -4  -3  -2  -1   (отрицательные)

# Примеры:
print(s[1:4])     # 'yth' (от 1 до 4, не включая 4)
print(s[-5:-2])   # 'yth' (то же самое через отрицательные)
print(s[::2])     # 'Pto' (каждый второй, шаг 2)
print(s[::-1])    # 'nohtyP' (реверс, шаг -1)
print(s[-1::-1])  # 'nohtyP' (от конца к началу)
print(s[:-4:-1])  # 'noh' (от конца до -4, не включая -4, справа налево)
```

**Ключевые моменты:**

- Отрицательные индексы удобны для работы с концом строки
- `[::-1]` — стандартный способ реверса строки
- При отрицательном шаге `start` должен быть правее `stop`
- Срезы никогда не вызывают `IndexError` — выходящие за границы индексы игнорируются
- Срезы создают **новую строку**, не изменяя оригинал (строки неизменяемы)

## `5.5` Конкатенация и другие математические операции
Со строками можно выполнять некоторые операции, похожие на математические, но с особым смыслом:

- **Конкатенация (`+`)** — склеивание строк
- **Повторение (`*`)** — многократное дублирование строки
- **Сравнение (`==`, `!=`, `<`, `>`)** — лексикографическое сравнение

**Важно:** Нельзя напрямую складывать строки и числа — нужно преобразование типов!

### Конкатенация (`+`) — склеивание строк

**Теория:**
Оператор `+` соединяет (склеивает) строки в одну. Работает только со строками!

**Примеры:**

```python
# Базовая конкатенация
first = "Hello"
second = "World"
result = first + second
print(result)  # HelloWorld

# Добавление пробела
result = first + " " + second
print(result)  # Hello World

# Конкатенация нескольких строк
greeting = "Привет" + ", " + "Иван" + "!"
print(greeting)  # Привет, Иван!

# Составление предложения
name = "Анна"
age = "25"
message = "Меня зовут " + name + ", мне " + age + " лет"
print(message)  # Меня зовут Анна, мне 25 лет

# ❌ Ошибка — нельзя складывать строку и число!
age_number = 25
# result = "Мне " + age_number + " лет"  # TypeError!

# ✅ Правильно — преобразуем число в строку
age_number = 25
result = "Мне " + str(age_number) + " лет"
print(result)  # Мне 25 лет

# Практические примеры
first_name = input("Имя: ")
last_name = input("Фамилия: ")
full_name = first_name + " " + last_name
print("Полное имя:", full_name)

# Создание пути к файлу
folder = "documents"
filename = "report.txt"
path = folder + "/" + filename
print(path)  # documents/report.txt

# Составление URL
domain = "example.com"
protocol = "https://"
url = protocol + domain
print(url)  # https://example.com

# Конкатенация с переносом строки
line1 = "Первая строка"
line2 = "Вторая строка"
text = line1 + "\n" + line2
print(text)
# Первая строка
# Вторая строка
```

### Повторение (`*`) — дублирование строки

**Теория:**
Оператор `*` повторяет строку указанное количество раз. Можно писать `строка * число` или `число * строка`.

**Примеры:**

```python
# Базовое повторение
print("Ha" * 3)  # HaHaHa
print("=" * 20)  # ====================
print("*" * 10)  # **********

# Можно менять местами
print(5 * "Hi")  # HiHiHiHiHi

# Создание разделителей
separator = "-" * 40
print(separator)
print("Заголовок")
print(separator)
# ----------------------------------------
# Заголовок
# ----------------------------------------

# Создание паттернов
pattern = "AB" * 5
print(pattern)  # ABABABABAB

# Отступы и форматирование
indent = " " * 4
print(indent + "Текст с отступом")
#     Текст с отступом

# Пустая строка при умножении на 0
print("Hello" * 0)  # (пустая строка)

# Отрицательные числа дают пустую строку
print("Hello" * -5)  # (пустая строка)

# Практические примеры
# Прогресс-бар
progress = 30  # 30%
bar = "█" * (progress // 5) + "░" * (20 - progress // 5)
print(f"Загрузка: [{bar}] {progress}%")
# Загрузка: [██████░░░░░░░░░░░░░░] 30%

# Создание таблицы
width = 50
print("+" + "-" * (width - 2) + "+")
print("|" + " " * (width - 2) + "|")
print("|" + "Заголовок".center(width - 2) + "|")
print("|" + " " * (width - 2) + "|")
print("+" + "-" * (width - 2) + "+")

# Визуализация рейтинга
rating = 4  # из 5
stars = "★" * rating + "☆" * (5 - rating)
print(f"Рейтинг: {stars}")  # Рейтинг: ★★★★☆

# Генерация строк с переменной длиной
n = int(input("Количество символов: "))
line = "#" * n
print(line)
```

### Сравнение строк

**Теория:**
Строки можно сравнивать операторами `==`, `!=`, `<`, `>`, `<=`, `>=`. Сравнение происходит **лексикографически** (по алфавиту), основываясь на Unicode-кодах символов.

**Правила:**
- Цифры < заглавные латинские буквы < строчные латинские буквы < кириллица
- Сравнение идёт посимвольно слева направо
- Регистр важен: `"A" < "a"` (заглавная меньше строчной)

**Примеры:**

```python
# Равенство
print("Python" == "Python")  # True
print("Python" == "python")  # False (регистр важен!)
print("Hello" != "World")    # True

# Сравнение по алфавиту
print("apple" < "banana")   # True
print("cat" > "dog")        # False
print("abc" < "abd")        # True (сравнение идёт посимвольно)

# Первый символ определяет результат
print("a" < "b")     # True
print("apple" < "b") # True (a < b)

# Длина не важна, важен порядок символов
print("z" > "aaaa")  # True (z идёт после a)

# Регистр
print("A" < "a")     # True (заглавные идут раньше строчных в Unicode)
print("Apple" < "apple")  # True

# Цифры идут раньше букв
print("1" < "a")     # True
print("123" < "abc") # True

# Пробелы
print("a" < "a ")    # True (пробел добавляет символ)
print(" " < "a")     # True (пробел идёт раньше букв)

# Практические примеры
# Проверка пароля
password = input("Пароль: ")
if password == "secret123":
    print("Доступ разрешён")
else:
    print("Неверный пароль")

# Сравнение без учёта регистра
word1 = "Python"
word2 = "python"
if word1.lower() == word2.lower():
    print("Слова одинаковые")  # ✅

# Проверка диапазона
letter = input("Введите букву: ")
if "a" <= letter <= "z":
    print("Строчная латинская буква")
elif "A" <= letter <= "Z":
    print("Заглавная латинская буква")

# Сортировка (позже в курсе)
names = ["Яна", "Анна", "Борис"]
names.sort()
print(names)  # ['Анна', 'Борис', 'Яна']

# Проверка порядка
name1 = "Алиса"
name2 = "Борис"
if name1 < name2:
    print(f"{name1} идёт раньше в алфавитном порядке")
```

### Комбинирование операций

**Примеры:**

```python
# Конкатенация и повторение
separator = "=" * 20
title = "Заголовок"
header = separator + "\n" + title + "\n" + separator
print(header)
# ====================
# Заголовок
# ====================

# Создание таблицы
row_separator = "+" + "-" * 10 + "+" + "-" * 15 + "+"
print(row_separator)
print("| Имя      | Возраст       |")
print(row_separator)
print("| Иван     | 25            |")
print(row_separator)

# Форматирование вывода
name = "Python"
version = "3.11"
stars = "*" * 30
message = stars + "\n" + name + " " + version + "\n" + stars
print(message)
# ******************************
# Python 3.11
# ******************************

# Объединение с условиями
score = 85
if score >= 90:
    grade = "A"
elif score >= 80:
    grade = "B"
else:
    grade = "C"

result = "Оценка: " + grade + " (" + str(score) + " баллов)"
print(result)  # Оценка: B (85 баллов)

# Создание шаблона
template = "=" * 50 + "\n"
template += "Имя: {name}\n"
template += "Возраст: {age}\n"
template += "=" * 50
# Позже можно использовать с .format() или f-строками
```

### Важные замечания

```python
# ❌ Частые ошибки

# 1. Сложение строки и числа
age = 25
# print("Мне " + age + " лет")  # TypeError!
print("Мне " + str(age) + " лет")  # ✅

# 2. Умножение строки на float
# print("Ha" * 2.5)  # TypeError!
print("Ha" * int(2.5))  # ✅ HaHa

# 3. Неправильное сравнение
print("10" > "9")   # False! (сравнение строк, не чисел)
print(10 > 9)       # True (сравнение чисел)
print(int("10") > int("9"))  # True ✅

# 4. Изменяемость
text = "Hello"
# text[0] = "J"  # TypeError! Строки неизменяемы
text = "J" + text[1:]  # ✅ Создаём новую строку

# ✅ Лучшие практики

# Используйте f-строки вместо конкатенации (удобнее)
name = "Иван"
age = 25
# Старый способ
message1 = "Меня зовут " + name + ", мне " + str(age) + " лет"
# Новый способ (лучше!)
message2 = f"Меня зовут {name}, мне {age} лет"

# Используйте join() для множественной конкатенации
words = ["Python", "is", "awesome"]
# Плохо (неэффективно)
sentence = words[0] + " " + words[1] + " " + words[2]
# Хорошо
sentence = " ".join(words)  # Python is awesome
```

**Итог:**
- `+` — склеивает строки (конкатенация)
- `*` — повторяет строку N раз
- Сравнение строк — лексикографическое (по алфавиту)
- Нельзя напрямую комбинировать строки и числа — нужно `str()`
- Для сложного форматирования лучше использовать f-строки

## `5.6` (`*`) Форматирование:  
### `format()`  
Метод `format()` вставляет значения в строку по местам-заполнителям, указанным в фигурных скобках `{}`. Можно использовать позиционные или именованные аргументы, указывая внутри скобок номера или имена: 
```python
"Hello, {}!".format("Alice")  # Hello, Alice!
"{1}, {0}".format('first', 'second')  # second, first
"{name} is {age}".format(name="Bob", age=25)  # Bob is 25
```
Форматирование внутри фигурных скобок позволяет задавать выравнивание, ширину, точность и другие параметры:
```python
"{:>10}".format("cat")    # "       cat" (выравнивание по правому краю, ширина 10)
"{:.3}".format("caterpillar")  # "cat" (обрезка до 3 символов)
"{:0^9}".format(123)      # "000123000" (выравнивание с заполнением нулями)
```

### `f-строки` 
`F-строки` появились в Python 3.6 и позволяют вставлять выражения прямо в строку с префиксом f:
```python
name = "Alice"
age = 30
print(f"Hello, {name}! You are {age} years old.")  # Hello, Alice! You are 30 years old.
```
Также внутри фигурных скобок можно использовать форматирование:
```python
print(f"{123:0>9}")  # '000000123' (выравнивание по правому краю с заполнением нулями)
print(f"{123:.2f}")   # '123.00' (формат с двумя десятичными знаками)
```

## `5.7` (`**`) Как строки хранятся в памяти компьютера. Команды `ord()`, `chr()`
Компьютер работает только с числами (битами и байтами). Каждый символ (буква, цифра, знак) имеет свой числовой код. Эта система кодирования называется **Unicode**.

**Unicode** — универсальная таблица соответствия символов и чисел:
- `A` → 65
- `a` → 97
- `0` → 48
- `А` (кириллица) → 1040
- `😀` (эмодзи) → 128512

**Функции для работы с кодами:**
- `ord(символ)` — возвращает Unicode-код символа (число)
- `chr(код)` — возвращает символ по его коду

**Примеры:**

```python
# ord() — символ → код
print(ord("A"))    # 65
print(ord("a"))    # 97
print(ord("0"))    # 48
print(ord("А"))    # 1040 (кириллица)
print(ord(" "))    # 32 (пробел)
print(ord("!"))    # 33
print(ord("😀"))   # 128512

# chr() — код → символ
print(chr(65))     # A
print(chr(97))     # a
print(chr(1040))   # А
print(chr(128512)) # 😀

# Почему заглавные буквы "меньше" строчных?
print(ord("A"), ord("a"))  # 65 97
print("A" < "a")           # True (65 < 97)

# Практическое применение — шифр Цезаря (сдвиг букв)
letter = "A"
shift = 3
new_code = ord(letter) + shift
encrypted = chr(new_code)
print(f"{letter} → {encrypted}")  # A → D

# Проверка типа символа
char = "5"
if ord("0") <= ord(char) <= ord("9"):
    print("Это цифра")

# Генерация последовательности символов
for i in range(65, 91):  # A-Z
    print(chr(i), end=" ")
# A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

# Расстояние между символами
print(ord("z") - ord("a"))  # 25 (26 букв: 0-25)
```

## `5.8` (`**`) Кодировки
[Смотрим, как устроены кодировки](https://www.youtube.com/watch?v=4MFcmreAUhs)

**Кодировка** — это способ преобразования символов в байты (и обратно) для хранения и передачи данных.

**Основные кодировки:**

1. **ASCII** (American Standard Code for Information Interchange)
   - Самая старая, 128 символов (0-127)
   - Только английские буквы, цифры, базовые знаки
   - 1 символ = 1 байт

2. **UTF-8** (Unicode Transformation Format - 8 bit)
   - Современный стандарт, поддерживает все языки мира
   - Совместима с ASCII (первые 128 символов)
   - Переменная длина: 1-4 байта на символ
   - **Стандарт в Python 3**

3. **Windows-1251** (CP1251)
   - Устаревшая, для кириллицы в Windows
   - 1 символ = 1 байт
   - Может вызывать проблемы с кодировкой

**Важно:** В Python 3 все строки по умолчанию в Unicode (UTF-8). Проблемы с кодировками обычно возникают при чтении/записи файлов.

**Примеры:**

```python
# Строка в Python 3 — это Unicode
text = "Привет, мир!"
print(type(text))  # <class 'str'>

# Преобразование строки в байты (encode)
text = "Hello"
bytes_utf8 = text.encode("utf-8")
print(bytes_utf8)  # b'Hello'
print(type(bytes_utf8))  # <class 'bytes'>

# Кириллица в разных кодировках
text = "Привет"
print(text.encode("utf-8"))       # b'\xd0\x9f\xd1\x80\xd0\xb8\xd0\xb2\xd0\xb5\xd1\x82'
print(text.encode("windows-1251")) # b'\xcf\xf0\xe8\xe2\xe5\xf2'

# Преобразование байтов в строку (decode)
bytes_data = b'Hello'
text = bytes_data.decode("utf-8")
print(text)  # Hello

# Проблема с неправильной кодировкой
text = "Привет"
wrong_bytes = text.encode("utf-8")
try:
    # Пытаемся декодировать UTF-8 как Windows-1251
    wrong_text = wrong_bytes.decode("windows-1251")
    print(wrong_text)  # Ð?Ñ?ивеÑ? (кракозябры!)
except:
    print("Ошибка декодирования")

# Размер в байтах
text_en = "Hello"  # 5 символов
text_ru = "Привет"  # 6 символов

print(len(text_en.encode("utf-8")))  # 5 байт (ASCII)
print(len(text_ru.encode("utf-8")))  # 12 байт (по 2 байта на символ кириллицы)

# Работа с файлами (правильная кодировка)
# Запись файла
with open("file.txt", "w", encoding="utf-8") as f:
    f.write("Привет, мир!")

# Чтение файла
with open("file.txt", "r", encoding="utf-8") as f:
    content = f.read()
    print(content)  # Привет, мир!

# ❌ Если не указать кодировку — могут быть проблемы
# (на Windows по умолчанию cp1251, на Linux/Mac — utf-8)
```

**Практические советы:**

1. **Всегда используйте UTF-8** для файлов и баз данных
2. При открытии файлов явно указывайте `encoding="utf-8"`
3. Если видите кракозябры — проблема в кодировке
4. В Python 3 строки по умолчанию Unicode — это хорошо!

**Частые проблемы:**

```python
# Проблема: файл создан в Windows-1251, читаем как UTF-8
# Решение: указать правильную кодировку
with open("old_file.txt", "r", encoding="windows-1251") as f:
    content = f.read()

# Проблема: нельзя декодировать байты
bytes_data = b'\xff\xfe'
try:
    text = bytes_data.decode("utf-8")
except UnicodeDecodeError:
    print("Неверная кодировка!")
    # Попробовать другую кодировку или игнорировать ошибки
    text = bytes_data.decode("utf-8", errors="ignore")
```

**Итог:**
- Компьютер хранит символы как числа (Unicode-коды)
- `ord()` и `chr()` — конвертация между символами и кодами
- UTF-8 — современный стандарт, используйте его везде
- При работе с файлами всегда указывайте `encoding="utf-8"`

----

# `6` Циклы
[Циклы в Python](https://youtu.be/vMD6-jzgDvI?si=NClQpvFFZSddk-ae)

## `6.1` For loop
### `6.1.1` Как написать for loop в `Python`?
**Цикл `for`** — конструкция для многократного выполнения блока кода. В Python цикл `for` перебирает элементы последовательности (строка, список, диапазон чисел и т.д.).

**Структура:**
```python
for переменная in последовательность:
    # код, который повторяется
    # переменная принимает значения из последовательности
```

**Как работает:**
1. Берётся первый элемент из последовательности
2. Значение присваивается переменной
3. Выполняется блок кода с отступом
4. Берётся следующий элемент
5. Повторяется до конца последовательности

**Примеры:**

```python
# Пример 1: Перебор чисел
for i in range(5):  # 0, 1, 2, 3, 4
    print(i)
# 0
# 1
# 2
# 3
# 4

# Пример 2: Перебор строки (посимвольно)
for letter in "Python":
    print(letter)
# P
# y
# t
# h
# o
# n

# Пример 3: Перебор списка
fruits = ["яблоко", "банан", "апельсин"]
for fruit in fruits:
    print(fruit)
# яблоко
# банан
# апельсин

# Пример 4: Использование переменной цикла
for i in range(1, 6):  # 1, 2, 3, 4, 5
    print(f"Число: {i}, квадрат: {i**2}")
# Число: 1, квадрат: 1
# Число: 2, квадрат: 4
# Число: 3, квадрат: 9
# Число: 4, квадрат: 16
# Число: 5, квадрат: 25

# Пример 5: Накопление суммы
total = 0
for i in range(1, 11):  # 1 до 10
    total += i
print(f"Сумма чисел от 1 до 10: {total}")  # 55

# Пример 6: Подсчёт символов
text = "Hello, World!"
count = 0
for char in text:
    if char == "o":
        count += 1
print(f"Букв 'o': {count}")  # 2

# Пример 7: Таблица умножения
number = 5
for i in range(1, 11):
    print(f"{number} × {i} = {number * i}")

# Пример 8: Вложенные циклы
for i in range(1, 4):
    for j in range(1, 4):
        print(f"i={i}, j={j}")
# i=1, j=1
# i=1, j=2
# i=1, j=3
# i=2, j=1
# ...

# Пример 9: Условия внутри цикла
for i in range(1, 11):
    if i % 2 == 0:
        print(f"{i} — чётное")
    else:
        print(f"{i} — нечётное")
```

### `6.1.2` Функция `range`. `Range` с несколькими параметрами и отрицательным шагом генерации
`range()` — встроенная функция, которая генерирует последовательность целых чисел. Используется в циклах для повторения кода N раз.

**Варианты использования:**
1. `range(stop)` — от 0 до stop-1
2. `range(start, stop)` — от start до stop-1
3. `range(start, stop, step)` — от start до stop-1 с шагом step

**Важно:**
- Конечное значение (`stop`) **не включается**
- По умолчанию начинается с 0
- По умолчанию шаг = 1
- Шаг может быть отрицательным (для обратного отсчёта)

**Примеры:**

```python
# 1. range(stop) — от 0 до stop-1
for i in range(5):
    print(i, end=" ")  # 0 1 2 3 4
print()

# 2. range(start, stop) — от start до stop-1
for i in range(3, 8):
    print(i, end=" ")  # 3 4 5 6 7
print()

# 3. range(start, stop, step) — с шагом
for i in range(0, 10, 2):  # Чётные от 0 до 9
    print(i, end=" ")  # 0 2 4 6 8
print()

for i in range(1, 10, 2):  # Нечётные от 1 до 9
    print(i, end=" ")  # 1 3 5 7 9
print()

# Отрицательный шаг — обратный отсчёт
for i in range(10, 0, -1):  # От 10 до 1
    print(i, end=" ")  # 10 9 8 7 6 5 4 3 2 1
print()

for i in range(5, -1, -1):  # От 5 до 0
    print(i, end=" ")  # 5 4 3 2 1 0
print()

# Обратный отсчёт с шагом -2
for i in range(20, 0, -2):
    print(i, end=" ")  # 20 18 16 14 12 10 8 6 4 2
print()

# Пустой диапазон
for i in range(5, 5):
    print(i)  # Ничего не выведется

for i in range(5, 2):  # start > stop при положительном шаге
    print(i)  # Ничего не выведется

# Преобразование range в список (для просмотра)
print(list(range(5)))           # [0, 1, 2, 3, 4]
print(list(range(2, 8)))        # [2, 3, 4, 5, 6, 7]
print(list(range(0, 10, 3)))    # [0, 3, 6, 9]
print(list(range(10, 0, -2)))   # [10, 8, 6, 4, 2]

# Практические примеры

# Обратный отсчёт
print("Запуск ракеты:")
for i in range(10, 0, -1):
    print(i)
print("Пуск!")

# Таблица степеней двойки
for i in range(0, 11):
    print(f"2^{i} = {2**i}")

# Печать чисел кратных 5 от 0 до 50
for i in range(0, 51, 5):
    print(i, end=" ")  # 0 5 10 15 20 25 30 35 40 45 50
print()

# Итерация по индексам строки
text = "Python"
for i in range(len(text)):
    print(f"Индекс {i}: {text[i]}")
# Индекс 0: P
# Индекс 1: y
# Индекс 2: t
# Индекс 3: h
# Индекс 4: o
# Индекс 5: n

# Шаг больше диапазона
for i in range(0, 10, 100):
    print(i)  # 0 (только одна итерация)

# Дробный шаг (нельзя!)
# for i in range(0, 10, 0.5):  # TypeError!
# Решение — умножить на 10 и делить внутри цикла
for i in range(0, 100, 5):
    print(i / 10, end=" ")  # 0.0 0.5 1.0 1.5 ... 9.5
print()
```

### `6.1.3` `_` в цикле for
Символ `_` (подчёркивание) используется как имя переменной цикла, когда само значение не важно — нужно только количество повторений. Это **соглашение**, говорящее "эта переменная не используется".

**Когда использовать:**
- Нужно повторить действие N раз
- Значение счётчика не используется в коде
- Делает код понятнее — сразу видно, что переменная игнорируется

**Примеры:**

```python
# Повторить 5 раз (без использования переменной)
for _ in range(5):
    print("Привет!")
# Привет!
# Привет!
# Привет!
# Привет!
# Привет!

# Вместо:
for i in range(5):
    print("Привет!")  # i не используется — лучше написать _

# Ввод нескольких чисел
numbers = []
for _ in range(3):
    num = int(input("Введите число: "))
    numbers.append(num)
print(numbers)

# Рисование паттернов
for _ in range(10):
    print("*" * 20)

# Генерация случайных чисел
import random
for _ in range(5):
    print(random.randint(1, 100))

# Повторение вопроса
attempts = 3
for _ in range(attempts):
    password = input("Введите пароль: ")
    if password == "secret":
        print("Доступ разрешён")
        break
else:
    print("Превышено количество попыток")

# Множественный ввод
print("Введите 5 имён:")
names = []
for _ in range(5):
    name = input()
    names.append(name)

# Когда _ НЕ нужен (используется переменная)
for i in range(5):
    print(f"Итерация {i}")  # i используется — не заменяем на _

for i in range(1, 6):
    print(f"Квадрат {i}: {i**2}")  # i используется

# Вложенные циклы с _
for _ in range(3):
    for _ in range(5):
        print("*", end="")
    print()  # Переход на новую строку
# *****
# *****
# *****
```

### `6.1.4` Концепция `флага` (сигнала)
**Флаг (flag)** — это переменная (обычно логическая), которая хранит состояние или сигнализирует о наступлении события. Используется для отслеживания условий внутри цикла.

**Типичные применения:**
- Проверка выполнения условия хотя бы раз
- Поиск элемента в последовательности
- Контроль состояния программы
- Выход из цикла при определённом условии

**Паттерн:**
1. Установить флаг в начальное значение (обычно `False`)
2. Изменить флаг при наступлении события
3. Проверить значение флага после цикла

**Примеры:**

```python
# Пример 1: Поиск элемента
number = int(input("Введите число: "))
found = False  # Флаг "найдено"

for i in range(1, 11):
    if i == number:
        found = True
        break

if found:
    print("Число найдено в диапазоне 1-10")
else:
    print("Число не найдено")

# Пример 2: Проверка условия для всех элементов
numbers = [2, 4, 6, 8, 10]
all_even = True  # Флаг "все чётные"

for num in numbers:
    if num % 2 != 0:
        all_even = False
        break

if all_even:
    print("Все числа чётные")
else:
    print("Есть нечётные числа")

# Пример 3: Проверка наличия хотя бы одного элемента
text = "Hello123"
has_digit = False  # Флаг "есть цифра"

for char in text:
    if char.isdigit():
        has_digit = True
        break

if has_digit:
    print("Строка содержит цифры")
else:
    print("Нет цифр")

# Пример 4: Валидация пароля
password = input("Пароль: ")
has_upper = False
has_lower = False
has_digit = False

for char in password:
    if char.isupper():
        has_upper = True
    if char.islower():
        has_lower = True
    if char.isdigit():
        has_digit = True

# Проверка всех флагов
if has_upper and has_lower and has_digit and len(password) >= 8:
    print("Пароль надёжный")
else:
    print("Пароль должен содержать:")
    if not has_upper:
        print("- заглавные буквы")
    if not has_lower:
        print("- строчные буквы")
    if not has_digit:
        print("- цифры")
    if len(password) < 8:
        print("- минимум 8 символов")

# Пример 5: Игра "Угадай число"
import random
secret = random.randint(1, 10)
guessed = False  # Флаг "угадал"

for attempt in range(3):
    guess = int(input(f"Попытка {attempt + 1}: "))
    if guess == secret:
        print("Поздравляю! Вы угадали!")
        guessed = True
        break
    elif guess < secret:
        print("Больше")
    else:
        print("Меньше")

if not guessed:
    print(f"Вы проиграли. Было загадано: {secret}")

# Пример 6: Поиск простого числа
number = int(input("Проверить число на простоту: "))
is_prime = True  # Флаг "простое число"

if number < 2:
    is_prime = False
else:
    for i in range(2, number):
        if number % i == 0:
            is_prime = False
            break

if is_prime:
    print(f"{number} — простое число")
else:
    print(f"{number} — не простое число")

# Пример 7: Множественные флаги
text = "Python 3.11!"
has_letters = False
has_numbers = False
has_special = False

for char in text:
    if char.isalpha():
        has_letters = True
    elif char.isdigit():
        has_numbers = True
    elif not char.isspace():
        has_special = True

print(f"Буквы: {has_letters}")
print(f"Цифры: {has_numbers}")
print(f"Спецсимволы: {has_special}")

# Пример 8: Контроль состояния
students = ["Анна", "Борис", "Вера", "Глеб"]
target = "Вера"
position_found = False
position = 0

for i, student in enumerate(students):
    if student == target:
        position = i
        position_found = True
        break

if position_found:
    print(f"{target} найден(а) на позиции {position}")
else:
    print(f"{target} не найден(а)")

# Без флага можно использовать else у цикла (продвинутое):
for i, student in enumerate(students):
    if student == target:
        print(f"{target} найден(а) на позиции {i}")
        break
else:  # Выполнится, если break не сработал
    print(f"{target} не найден(а)")
```

**Итог:**
- `for` перебирает элементы последовательности
- `range()` генерирует числа: `range(stop)`, `range(start, stop)`, `range(start, stop, step)`
- `_` используется, когда переменная цикла не нужна
- Флаг — переменная для отслеживания события в цикле

## `6.2` While loop
### `6.2.1` Как написать while loop в `Python`?
**Цикл `while`** — конструкция для повторения кода, пока условие истинно (`True`). В отличие от `for`, который перебирает элементы, `while` работает на основе условия.

**Структура:**
```python
while условие:
    # код, который повторяется
    # пока условие True
```

**Как работает:**
1. Проверяется условие
2. Если `True` — выполняется блок кода
3. Снова проверяется условие
4. Повторяется, пока условие не станет `False`
5. Если условие сразу `False` — блок не выполнится ни разу

**Важно:** Нужно обеспечить изменение условия внутри цикла, иначе получится бесконечный цикл!

**Примеры:**

```python
# Пример 1: Простой счётчик
i = 0
while i < 5:
    print(i)
    i += 1  # Обязательно изменяем i!
# 0
# 1
# 2
# 3
# 4
```

```python
# Пример 2: Обратный отсчёт
count = 5
while count > 0:
    print(count)
    count -= 1
print("Пуск!")
# 5
# 4
# 3
# 2
# 1
# Пуск!
```

```python
# Пример 3: Накопление суммы
total = 0
i = 1
while i <= 10:
    total += i
    i += 1
print(f"Сумма чисел от 1 до 10: {total}")  # 55
```

```python
# Пример 4: Ввод до корректного значения
age = -1
while age < 0:
    age = int(input("Введите возраст (положительное число): "))
    if age < 0:
        print("Возраст не может быть отрицательным")
print(f"Ваш возраст: {age}")

# Пример 5: Игра "Угадай число"
import random
secret = random.randint(1, 10)
guess = 0

while guess != secret:
    guess = int(input("Угадайте число от 1 до 10: "))
    if guess < secret:
        print("Больше!")
    elif guess > secret:
        print("Меньше!")

print("Правильно! Вы угадали!")
```

```python
# Пример 6: Меню программы
choice = ""
while choice != "выход":
    print("\nМеню:")
    print("1. Показать информацию")
    print("2. Настройки")
    print("Введите 'выход' для завершения")
    
    choice = input("Ваш выбор: ").lower()
    
    if choice == "1":
        print("Информация отображена")
    elif choice == "2":
        print("Настройки открыты")
    elif choice == "выход":
        print("До свидания!")
    else:
        print("Неверный выбор")
```

```python
# Пример 7: Валидация ввода
password = ""
while len(password) < 8:
    password = input("Пароль (минимум 8 символов): ")
    if len(password) < 8:
        print(f"Слишком короткий! Введено {len(password)} символов")
print("Пароль принят")
```

```python
# Пример 8: Сумма чисел до отрицательного
total = 0
number = 0

print("Вводите положительные числа. Отрицательное число завершит ввод.")
while number >= 0:
    number = int(input("Число: "))
    if number >= 0:
        total += number

print(f"Сумма: {total}")
```

```python
# Пример 9: Факториал
n = int(input("Факториал числа: "))
factorial = 1
i = 1

while i <= n:
    factorial *= i
    i += 1

print(f"{n}! = {factorial}")
```

```python
# Пример 10: Деление пополам
number = 100
count = 0

while number > 1:
    number = number // 2
    count += 1
    print(f"Шаг {count}: {number}")

print(f"Понадобилось {count} делений")
```

```python
# Пример 11: Поиск цифр в числе
number = int(input("Введите число: "))
digit_count = 0

# Работаем с копией
temp = abs(number)  # Убираем знак
while temp > 0:
    temp = temp // 10
    digit_count += 1

if number == 0:
    digit_count = 1

print(f"Количество цифр: {digit_count}")
```

```python
# Пример 12: Условие с несколькими переменными
balance = 100
attempts = 3

while balance > 0 and attempts > 0:
    withdraw = int(input(f"Баланс: {balance}. Сколько снять? "))
    
    if withdraw <= balance:
        balance -= withdraw
        print(f"Выдано {withdraw}. Остаток: {balance}")
    else:
        attempts -= 1
        print(f"Недостаточно средств. Попыток осталось: {attempts}")

if balance == 0:
    print("Баланс исчерпан")
if attempts == 0:
    print("Превышено количество попыток")
```

**Сравнение while и for:**

```python
# Одинаковый результат разными способами

# for — когда знаем количество итераций
for i in range(5):
    print(i)

# while — то же самое
i = 0
while i < 5:
    print(i)
    i += 1

# for удобнее для перебора
for num in [1, 2, 3, 4, 5]:
    print(num)

# while нужен для условных повторений
password = ""
while password != "secret":
    password = input("Пароль: ")
```

### `6.2.2` Бесконечные циклы
**Бесконечный цикл** — это цикл, условие которого никогда не становится `False`. Цикл выполняется бесконечно, пока программа не будет принудительно остановлена.

**Когда возникает:**
- Условие всегда истинно: `while True:`
- Забыли изменить переменную условия
- Логическая ошибка в условии

**Когда используется намеренно:**
- Серверы и программы, которые должны работать постоянно
- Игровые циклы
- Меню с выходом по команде
- Обработка событий

**Как остановить:**
- `break` — выход из цикла программно
- `Ctrl + C` — принудительная остановка в терминале

**Примеры:**

```python
# ❌ Случайные бесконечные циклы (ошибки)

# Забыли изменить переменную
i = 0
while i < 5:
    print(i)
    # Забыли i += 1 — бесконечный цикл!

# Неправильное условие
count = 10
while count > 0:
    print(count)
    count += 1  # Увеличиваем вместо уменьшения!

# Условие никогда не меняется
x = 5
while x != 10:
    print(x)
    # x не изменяется — бесконечный цикл!
```

```python
# ✅ Намеренные бесконечные циклы (с выходом)

# Пример 1: while True с break
while True:
    command = input("Команда (или 'выход'): ")
    if command == "выход":
        break
    print(f"Выполнена команда: {command}")
print("Программа завершена")
```

```python
# Пример 2: Калькулятор с бесконечным циклом
while True:
    print("\nКалькулятор")
    print("Введите 'q' для выхода")
    
    first = input("Первое число: ")
    if first == "q":
        break
    
    second = input("Второе число: ")
    if second == "q":
        break
    
    operation = input("Операция (+, -, *, /): ")
    if operation == "q":
        break
    
    first = float(first)
    second = float(second)
    
    if operation == "+":
        print(f"Результат: {first + second}")
    elif operation == "-":
        print(f"Результат: {first - second}")
    elif operation == "*":
        print(f"Результат: {first * second}")
    elif operation == "/":
        if second != 0:
            print(f"Результат: {first / second}")
        else:
            print("Деление на ноль!")
```

```python
# Пример 3: Игра с повторениями
while True:
    print("\n--- Новая игра ---")
    
    # Игровая логика
    import random
    secret = random.randint(1, 10)
    attempts = 0
    
    while True:
        guess = int(input("Угадайте число (1-10): "))
        attempts += 1
        
        if guess == secret:
            print(f"Угадали за {attempts} попыток!")
            break
        elif guess < secret:
            print("Больше")
        else:
            print("Меньше")
    
    again = input("Играть ещё? (да/нет): ")
    if again.lower() != "да":
        break

print("Спасибо за игру!")
```

```python
# Пример 4: Сервер (упрощённо)
print("Сервер запущен. Ctrl+C для остановки")
request_count = 0

while True:
    # Симуляция обработки запроса
    request_count += 1
    print(f"Обработан запрос #{request_count}")
    
    # В реальности здесь ожидание запроса
    import time
    time.sleep(1)  # Задержка 1 секунда
    
    # Условие остановки для примера
    if request_count >= 10:
        print("Достигнут лимит запросов")
        break
```

```python
# Пример 5: Чат-бот
print("Чат-бот запущен. Напишите 'пока' для выхода.")

while True:
    message = input("Вы: ")
    
    if message.lower() == "пока":
        print("Бот: До встречи!")
        break
    elif "привет" in message.lower():
        print("Бот: Здравствуйте!")
    elif "как дела" in message.lower():
        print("Бот: Отлично, спасибо!")
    else:
        print("Бот: Интересно...")
```

```python
# Пример 6: Меню с множественным выбором
while True:
    print("\n=== Главное меню ===")
    print("1. Новая игра")
    print("2. Загрузить")
    print("3. Настройки")
    print("4. Выход")
    
    choice = input("Выберите пункт: ")
    
    if choice == "1":
        print("Новая игра начата")
    elif choice == "2":
        print("Игра загружена")
    elif choice == "3":
        print("Настройки открыты")
    elif choice == "4":
        print("Выход из программы")
        break
    else:
        print("Неверный выбор!")
```

```python
# Пример 7: Обработка ошибок ввода
while True:
    try:
        age = int(input("Введите возраст: "))
        if age < 0:
            print("Возраст не может быть отрицательным")
            continue
        if age > 150:
            print("Введите реальный возраст")
            continue
        print(f"Возраст принят: {age}")
        break
    except ValueError:
        print("Введите число!")
```

```python
# Пример 8: Счётчик с условием выхода
counter = 0
while True:
    counter += 1
    print(f"Итерация {counter}")
    
    if counter >= 10:
        print("Достигнут лимит итераций")
        break
    
    if counter % 3 == 0:
        print("Кратно 3!")
```

```python
# Пример 9: Накопление данных
numbers = []
print("Вводите числа. Введите 0 для завершения.")

while True:
    num = int(input("Число: "))
    if num == 0:
        break
    numbers.append(num)

if numbers:
    print(f"Введено чисел: {len(numbers)}")
    print(f"Сумма: {sum(numbers)}")
    print(f"Среднее: {sum(numbers) / len(numbers)}")
else:
    print("Числа не были введены")
```

**Опасности бесконечных циклов:**

```python
# ❌ Зависание программы
# while True:
#     print("Бесконечно...")
# Программа зависнет, придётся закрывать принудительно

# ✅ Всегда добавляйте условие выхода
max_iterations = 1000
count = 0

while True:
    count += 1
    # ... код ...
    
    if count > max_iterations:
        print("Превышен лимит итераций!")
        break
```

**Итог:**
- `while` повторяет код, пока условие `True`
- Обязательно изменяйте переменные условия, иначе зависнет
- `while True:` с `break` — стандартный паттерн для бесконечных циклов с выходом
- Используйте для меню, игр, серверов, валидации ввода

### `6.2.3` (`*`) Операторы: `break`, `continue`, `else`. Кейсы применения
#### **Оператор `break` — досрочный выход из цикла**

`break` прерывает цикл и переходит к коду после него. Полезен, когда нужно остановить цикл при выполнении условия.

```python
# Базовый пример
for i in range(10):
    if i == 5:
        break
    print(i)
# Выведет: 0 1 2 3 4

# Поиск элемента в списке
users = ["Alice", "Bob", "Charlie", "David"]
search = "Charlie"

for user in users:
    if user == search:
        print(f"Найден: {user}")
        break
# Выведет: Найден: Charlie

# Бесконечный цикл с break
while True:
    command = input("Введите команду (exit для выхода): ")
    if command == "exit":
        break
    print(f"Выполняю: {command}")
```

#### **Оператор `continue` — пропуск текущей итерации**

`continue` пропускает оставшийся код в текущей итерации и переходит к следующей. Удобно для игнорирования определённых условий.

```python
# Базовый пример
for i in range(5):
    if i == 3:
        continue
    print(i)
# Выведет: 0 1 2 4

# Пропуск чётных чисел
for num in range(10):
    if num % 2 == 0:
        continue
    print(num)
# Выведет: 1 3 5 7 9

# Фильтрация данных
prices = [100, -50, 200, 0, 150]
for price in prices:
    if price <= 0:
        continue
    discount = price * 0.1
    print(f"Цена: {price}, скидка: {discount}")
# Выведет только положительные цены со скидками
```

#### **Блок `else` с циклами — выполнение при нормальном завершении**

`else` после цикла выполняется, только если цикл завершился **без `break`**.

```python
# Базовый пример
for i in range(3):
    if i == 5:
        break
else:
    print("Цикл выполнен до конца")
# Выведет: Цикл выполнен до конца (break не сработал)

# Поиск с проверкой результата
numbers = [1, 3, 5, 7, 9]
target = 4

for num in numbers:
    if num == target:
        print(f"Число {target} найдено")
        break
else:
    print(f"Число {target} не найдено")
# Выведет: Число 4 не найдено

# Проверка простого числа
n = 17
for i in range(2, n):
    if n % i == 0:
        print(f"{n} не является простым числом")
        break
else:
    print(f"{n} — простое число")
# Выведет: 17 — простое число
```

**Кейсы применения:**

- **`break`:** поиск элемента (выход при первом совпадении), досрочный выход при ошибке, выход из бесконечных циклов
- **`continue`:** фильтрация данных (пропуск невалидных значений), уменьшение вложенности кода, пропуск ненужных итераций
- **`else` с циклом:** проверка результата поиска (найден/не найден), валидация данных, выполнение действий при полном прохождении цикла


## `6.3` Вложенные циклы
### `6.3.1` Что такое вложенные циклы?
**Вложенные циклы** — это циклы внутри других циклов. Внешний цикл выполняет одну итерацию, а внутренний за это время выполняет все свои итерации полностью.

**Структура:**
```python
for переменная1 in последовательность1:
    # Внешний цикл
    for переменная2 in последовательность2:
        # Внутренний цикл
        # Этот код выполнится множество раз
```

**Как работает:**
1. Внешний цикл начинает первую итерацию
2. Внутренний цикл выполняет ВСЕ свои итерации
3. Внешний цикл переходит ко второй итерации
4. Внутренний цикл снова выполняет ВСЕ свои итерации
5. И так далее

**Количество итераций:** Если внешний цикл выполняется N раз, а внутренний M раз, то общее количество итераций = N × M.

**Примеры:**

```python
# Пример 1: Базовый вложенный цикл
for i in range(3):  # Внешний: 3 итерации
    for j in range(2):  # Внутренний: 2 итерации
        print(f"i={i}, j={j}")

# Вывод:
# i=0, j=0
# i=0, j=1
# i=1, j=0
# i=1, j=1
# i=2, j=0
# i=2, j=1
# Всего: 3 × 2 = 6 итераций
```

```python
# Пример 2: Таблица умножения
for i in range(1, 6):  # Числа 1-5
    for j in range(1, 6):  # Числа 1-5
        print(f"{i} × {j} = {i * j}")
    print()  # Пустая строка после каждого числа
```

```python
# Пример 3: Печать прямоугольника из звёздочек
rows = 4
cols = 6

for i in range(rows):
    for j in range(cols):
        print("*", end="")
    print()  # Переход на новую строку

# Вывод:
# ******
# ******
# ******
# ******
```

```python
# Пример 4: Треугольник
n = 5
for i in range(1, n + 1):  # Строки
    for j in range(i):  # Количество звёздочек = номер строки
        print("*", end="")
    print()

# Вывод:
# *
# **
# ***
# ****
# *****
```

```python
# Пример 5: Таблица умножения (красиво)
print("Таблица умножения:")
print("-" * 40)

for i in range(1, 11):
    for j in range(1, 11):
        print(f"{i * j:4}", end="")  # :4 — ширина 4 символа
    print()
```

```python
# Пример 6: Перебор элементов двумерного списка (матрицы)
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

print("Элементы матрицы:")
for row in matrix:  # Перебираем строки
    for element in row:  # Перебираем элементы в строке
        print(element, end=" ")
    print()

# Вывод:
# 1 2 3
# 4 5 6
# 7 8 9
```

```python
# Пример 7: Поиск в двумерном списке
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

target = 5
found = False

for i in range(len(matrix)):
    for j in range(len(matrix[i])):
        if matrix[i][j] == target:
            print(f"Найдено: {target} на позиции [{i}][{j}]")
            found = True
            break
    if found:
        break
```

**Важные моменты:**

```python
# Следите за производительностью!
# O(n²) — квадратичная сложность
for i in range(1000):
    for j in range(1000):
        pass  # 1,000,000 итераций!

# Используйте осознанно
# Не всегда нужны вложенные циклы, иногда достаточно одного

# Именование переменных
# i, j, k — стандартные имена для вложенных циклов
# Для ясности можно использовать row, col или более описательные имена
```

**Итог:**
- Вложенные циклы — это циклы внутри циклов
- Общее количество итераций = произведение итераций всех циклов
- Внутренний цикл полностью выполняется на каждой итерации внешнего
- Используются для работы с таблицами, матрицами, комбинациями, паттернами
- Будьте осторожны с производительностью при большом количестве итераций

### `6.3.2` (`*`) Как работают операторы `break`, `continue`, `else` во вложенных циклах
#### **Оператор `break` во вложенных циклах**

`break` прерывает **только тот цикл, в котором он вызван**. Внешний цикл продолжает работать.

```python
# break прерывает только внутренний цикл
for i in range(3):
    print(f"Внешний цикл: i={i}")
    for j in range(3):
        if j == 1:
            break  # Выходит только из внутреннего цикла
        print(f"  Внутренний цикл: j={j}")
# Выведет:
# Внешний цикл: i=0
#   Внутренний цикл: j=0
# Внешний цикл: i=1
#   Внутренний цикл: j=0
# Внешний цикл: i=2
#   Внутренний цикл: j=0
```

**Выход из всех циклов сразу — использование флага:**

```python
# Флаг для выхода из всех циклов
found = False
for i in range(3):
    for j in range(3):
        if i == 1 and j == 1:
            found = True
            break  # Выход из внутреннего
    if found:
        break  # Выход из внешнего
    print(f"i={i} завершён")
# Выведет только: i=0 завершён
```

**Альтернатива — использование функции и return:**

```python
def find_in_matrix(matrix, target):
    for i, row in enumerate(matrix):
        for j, value in enumerate(row):
            if value == target:
                return (i, j)  # Выход из всех циклов сразу
    return None

matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
result = find_in_matrix(matrix, 5)
print(result)  # (1, 1)
```

#### **Оператор `continue` во вложенных циклах**

`continue` действует **только на текущий цикл** — пропускает остаток текущей итерации и переходит к следующей.

```python
# continue во внутреннем цикле
for i in range(3):
    for j in range(3):
        if j == 1:
            continue  # Пропускает только j=1 во внутреннем цикле
        print(f"i={i}, j={j}")
# Выведет:
# i=0, j=0
# i=0, j=2
# i=1, j=0
# i=1, j=2
# i=2, j=0
# i=2, j=2

# continue во внешнем цикле
for i in range(3):
    if i == 1:
        continue  # Пропускает всю итерацию при i=1
    for j in range(2):
        print(f"i={i}, j={j}")
# Выведет:
# i=0, j=0
# i=0, j=1
# i=2, j=0
# i=2, j=1
```

#### **Блок `else` во вложенных циклах**

`else` выполняется, только если цикл завершился **без `break`**. Каждый цикл имеет свой собственный `else`.

```python
# else для внутреннего цикла
for i in range(2):
    for j in range(3):
        if j == 5:  # Условие не выполнится
            break
    else:
        print(f"Внутренний цикл i={i} завершён без break")
# Выведет:
# Внутренний цикл i=0 завершён без break
# Внутренний цикл i=1 завершён без break

# break во внутреннем цикле отменяет его else
for i in range(2):
    for j in range(3):
        if j == 1:
            break  # else внутреннего цикла не выполнится
    else:
        print(f"Внутренний цикл i={i} завершён")
# Ничего не выведет (break сработал в обеих итерациях)

# Комбинация else для обоих циклов
for i in range(2):
    for j in range(2):
        print(f"i={i}, j={j}")
    else:
        print(f"  Внутренний цикл для i={i} завершён")
else:
    print("Внешний цикл завершён")
# Выведет:
# i=0, j=0
# i=0, j=1
#   Внутренний цикл для i=0 завершён
# i=1, j=0
# i=1, j=1
#   Внутренний цикл для i=1 завершён
# Внешний цикл завершён
```

**Практический пример — поиск в двумерном массиве:**

```python
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
target = 5
found = False

for i, row in enumerate(matrix):
    for j, value in enumerate(row):
        if value == target:
            print(f"Найдено {target} на позиции ({i}, {j})")
            found = True
            break
    if found:
        break
else:
    print(f"Значение {target} не найдено")
# Выведет: Найдено 5 на позиции (1, 1)
```

**Ключевые моменты:**

- `break` и `continue` влияют только на тот цикл, где они вызваны
- Для выхода из всех циклов используйте флаг или функцию с `return`
- `else` у каждого цикла работает независимо
- `else` не выполняется, если сработал `break` в соответствующем цикле

----

# `7` Типы данных 2 (Списки)
## `7.1` Что такое список? Функция `list()`. Изменяемость списков.
**Список (list)** — упорядоченная изменяемая коллекция элементов. Может хранить данные любых типов: числа, строки, другие списки и т.д.

**Создание списка:**
```python
# Пустой список
my_list = []
# Список с элементами
numbers = [1, 2, 3, 4, 5]
# Смешанные типы
mixed = [1, "текст", 3.14, True]
```

**На что похож в других языках:**
- **Java, C#** — `ArrayList` (динамический массив)
- **C++** — `std::vector`
- **JavaScript** — `Array`
- **PHP** — `array` (индексированный массив)

**Функция `list()`:**
Преобразует другие последовательности (строки, кортежи, range) в список.

**Изменяемость:**
Списки **изменяемы** — можно добавлять, удалять, изменять элементы после создания.

**Примеры:**

```python
# Создание списков
empty_list = []
numbers = [1, 2, 3, 4, 5]
fruits = ["яблоко", "банан", "апельсин"]
mixed = [1, "два", 3.0, True, [5, 6]]

print(numbers)  # [1, 2, 3, 4, 5]
print(type(numbers))  # <class 'list'>
```

```python
# Функция list() — преобразование в список
text = "Python"
letters = list(text)
print(letters)  # ['P', 'y', 't', 'h', 'o', 'n']

numbers_range = list(range(5))
print(numbers_range)  # [0, 1, 2, 3, 4]

tuple_data = (1, 2, 3)
list_data = list(tuple_data)
print(list_data)  # [1, 2, 3]
```

```python
# Изменяемость списков
numbers = [1, 2, 3]
print(numbers)  # [1, 2, 3]

# Изменение элемента
numbers[0] = 10
print(numbers)  # [10, 2, 3]

# Добавление элемента
numbers.append(4)
print(numbers)  # [10, 2, 3, 4]

# Удаление элемента
numbers.remove(2)
print(numbers)  # [10, 3, 4]
```

```python
# Сравнение с неизменяемыми строками
# Строки — неизменяемы
text = "Hello"
# text[0] = "J"  # TypeError! Нельзя изменить

# Списки — изменяемы
letters = ["H", "e", "l", "l", "o"]
letters[0] = "J"
print(letters)  # ['J', 'e', 'l', 'l', 'o']
```

```python
# Вложенные списки (списки внутри списков)
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]
print(matrix[0])  # [1, 2, 3]
print(matrix[1][1])  # 5
```

## `7.2` Функции `len()`, `in` для списков
### `len()` — длина списка
Возвращает количество элементов в списке.

### `in` — проверка наличия элемента
Проверяет, содержится ли элемент в списке. Возвращает `True` или `False`.

**Примеры:**

```python
# len() — длина списка
numbers = [1, 2, 3, 4, 5]
print(len(numbers))  # 5

fruits = ["яблоко", "банан"]
print(len(fruits))  # 2

empty = []
print(len(empty))  # 0

nested = [[1, 2], [3, 4], [5, 6]]
print(len(nested))  # 3 (три списка внутри)
```

```python
# in — проверка наличия элемента
numbers = [1, 2, 3, 4, 5]

print(3 in numbers)  # True
print(10 in numbers)  # False

fruits = ["яблоко", "банан", "апельсин"]
print("банан" in fruits)  # True
print("груша" in fruits)  # False
```

```python
# not in — проверка отсутствия
numbers = [1, 2, 3, 4, 5]

print(10 not in numbers)  # True
print(3 not in numbers)  # False
```

```python
# Использование в условиях
shopping_list = ["молоко", "хлеб", "яйца"]
item = input("Что купить? ")

if item in shopping_list:
    print(f"{item} уже в списке")
else:
    shopping_list.append(item)
    print(f"{item} добавлен в список")
```

```python
# Подсчёт элементов
numbers = [1, 2, 3, 2, 4, 2, 5]
count = 0

for num in numbers:
    if num == 2:
        count += 1

print(f"Число 2 встречается {count} раз")  # 3 раза
```

```python
# Проверка нескольких условий
allowed_users = ["admin", "user1", "user2"]
username = input("Имя пользователя: ")

if username in allowed_users:
    print("Доступ разрешён")
else:
    print("Доступ запрещён")
```

## `7.3` Индексы
**Индекс** — порядковый номер элемента в списке. Нумерация начинается с 0.

**Особенности:**
- Положительные индексы: 0, 1, 2, ... (слева направо)
- Отрицательные индексы: -1, -2, -3, ... (справа налево)
- `-1` — последний элемент
- Выход за границы списка вызывает `IndexError`

**Примеры:**

```python
# Положительные индексы
fruits = ["яблоко", "банан", "апельсин", "груша", "киви"]
#         0         1         2           3        4

print(fruits[0])  # яблоко (первый)
print(fruits[1])  # банан
print(fruits[4])  # киви (последний)
```

```python
# Отрицательные индексы
fruits = ["яблоко", "банан", "апельсин", "груша", "киви"]
#         -5        -4       -3          -2       -1

print(fruits[-1])  # киви (последний)
print(fruits[-2])  # груша (предпоследний)
print(fruits[-5])  # яблоко (первый)
```

```python
# Изменение элементов по индексу
numbers = [1, 2, 3, 4, 5]
numbers[0] = 10
print(numbers)  # [10, 2, 3, 4, 5]

numbers[-1] = 50
print(numbers)  # [10, 2, 3, 4, 50]
```

```python
# Ошибка при выходе за границы
numbers = [1, 2, 3]
# print(numbers[10])  # IndexError: list index out of range
# print(numbers[-10])  # IndexError: list index out of range
```

```python
# Безопасный доступ с проверкой
numbers = [1, 2, 3]
index = 5

if 0 <= index < len(numbers):
    print(numbers[index])
else:
    print("Индекс вне диапазона")
```

```python
# Доступ к вложенным спискам
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

print(matrix[0])     # [1, 2, 3] — первая строка
print(matrix[1][2])  # 6 — вторая строка, третий элемент
print(matrix[-1][-1])  # 9 — последняя строка, последний элемент
```

```python
# Получение первого и последнего элемента
numbers = [10, 20, 30, 40, 50]

first = numbers[0]
last = numbers[-1]

print(f"Первый: {first}, Последний: {last}")  # Первый: 10, Последний: 50
```

```python
# Изменение среднего элемента
numbers = [1, 2, 3, 4, 5]
middle_index = len(numbers) // 2
numbers[middle_index] = 100

print(numbers)  # [1, 2, 100, 4, 5]
```

## `7.4` Slices
**Срезы (slices)** — способ получить подсписок (часть списка).

**Синтаксис:**
```python
список[start:stop:step]
```
- `start` — начальный индекс (включительно)
- `stop` — конечный индекс (не включительно)
- `step` — шаг (по умолчанию 1)

**Особенности:**
- Если параметр опущен, используется значение по умолчанию
- Отрицательные индексы работают
- Выход за границы не вызывает ошибку (вернёт пустой список или часть)

**Примеры:**

```python
# Базовые срезы
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

print(numbers[2:5])   # [2, 3, 4] — с 2 по 4 (5 не включается)
print(numbers[0:3])   # [0, 1, 2] — первые 3 элемента
print(numbers[5:10])  # [5, 6, 7, 8, 9] — с 5 до конца
```

```python
# Опущенные параметры
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

print(numbers[:5])    # [0, 1, 2, 3, 4] — с начала до 5
print(numbers[5:])    # [5, 6, 7, 8, 9] — с 5 до конца
print(numbers[:])     # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] — весь список (копия)
```

```python
# Срезы с шагом
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

print(numbers[::2])    # [0, 2, 4, 6, 8] — каждый второй
print(numbers[1::2])   # [1, 3, 5, 7, 9] — каждый второй, начиная с 1
print(numbers[::3])    # [0, 3, 6, 9] — каждый третий
```

```python
# Отрицательные индексы в срезах
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

print(numbers[-5:])     # [5, 6, 7, 8, 9] — последние 5
print(numbers[:-3])     # [0, 1, 2, 3, 4, 5, 6] — все кроме последних 3
print(numbers[-7:-2])   # [3, 4, 5, 6, 7] — с -7 до -2
```

```python
# Отрицательный шаг (разворот)
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

print(numbers[::-1])   # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] — развернуть список
print(numbers[::-2])   # [9, 7, 5, 3, 1] — каждый второй с конца
print(numbers[7:2:-1]) # [7, 6, 5, 4, 3] — с 7 до 3 в обратном порядке
```

```python
# Практические примеры

# Первая половина списка
numbers = [1, 2, 3, 4, 5, 6, 7, 8]
first_half = numbers[:len(numbers)//2]
print(first_half)  # [1, 2, 3, 4]

# Вторая половина списка
second_half = numbers[len(numbers)//2:]
print(second_half)  # [5, 6, 7, 8]

# Каждый третий элемент
every_third = numbers[::3]
print(every_third)  # [1, 4, 7]
```

```python
# Удаление элементов через срезы
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# Удалить первые 3 элемента
numbers = numbers[3:]
print(numbers)  # [3, 4, 5, 6, 7, 8, 9]

# Удалить последние 2 элемента
numbers = numbers[:-2]
print(numbers)  # [3, 4, 5, 6, 7]
```

```python
# Замена части списка через срез
numbers = [0, 1, 2, 3, 4, 5]
numbers[1:4] = [10, 20, 30]
print(numbers)  # [0, 10, 20, 30, 4, 5]

# Можно заменить на меньшее количество элементов
numbers[2:5] = [100]
print(numbers)  # [0, 10, 100, 5]
```

```python
# Копирование списка
original = [1, 2, 3, 4, 5]
copy = original[:]  # Срез создаёт копию

copy[0] = 100
print(original)  # [1, 2, 3, 4, 5] — не изменился
print(copy)      # [100, 2, 3, 4, 5]
```

```python
# Пустые срезы
numbers = [1, 2, 3, 4, 5]

print(numbers[10:20])  # [] — выход за границы даёт пустой список
print(numbers[3:1])    # [] — start > stop
print(numbers[5:])     # [] — начало за пределами списка
```

## `7.5` Функции `sum()`, `min()`, `max()`

### `sum()` — сумма элементов
Возвращает сумму всех элементов списка (работает только с числами).

### `min()` — минимальный элемент
Возвращает наименьший элемент списка.

### `max()` — максимальный элемент
Возвращает наибольший элемент списка.

**Примеры:**

```python
# sum() — сумма элементов
numbers = [1, 2, 3, 4, 5]
print(sum(numbers))  # 15

prices = [100, 250, 75, 320]
total = sum(prices)
print(f"Итого: {total} руб")  # Итого: 745 руб

# Пустой список
print(sum([]))  # 0
```

```python
# sum() с начальным значением
numbers = [1, 2, 3, 4, 5]
print(sum(numbers, 10))  # 25 (15 + 10)

# Добавление к существующей сумме
existing_total = 100
new_items = [50, 25, 75]
updated_total = existing_total + sum(new_items)
print(updated_total)  # 250
```

```python
# min() — минимальный элемент
numbers = [5, 2, 8, 1, 9]
print(min(numbers))  # 1

temperatures = [-5, 3, -10, 0, 7]
print(min(temperatures))  # -10

# min() со строками (лексикографически)
words = ["яблоко", "банан", "апельсин"]
print(min(words))  # апельсин (по алфавиту)
```

```python
# max() — максимальный элемент
numbers = [5, 2, 8, 1, 9]
print(max(numbers))  # 9

scores = [85, 92, 78, 95, 88]
highest_score = max(scores)
print(f"Лучший результат: {highest_score}")  # 95
```

```python
# Комбинированное использование
numbers = [12, 45, 7, 23, 56, 89, 34]

print(f"Сумма: {sum(numbers)}")        # 266
print(f"Минимум: {min(numbers)}")      # 7
print(f"Максимум: {max(numbers)}")     # 89
print(f"Среднее: {sum(numbers) / len(numbers):.2f}")  # 38.00
```

```python
# Практический пример — анализ оценок
grades = [85, 90, 78, 92, 88, 95, 82]

total = sum(grades)
average = total / len(grades)
highest = max(grades)
lowest = min(grades)

print(f"Всего оценок: {len(grades)}")
print(f"Средний балл: {average:.2f}")
print(f"Лучшая оценка: {highest}")
print(f"Худшая оценка: {lowest}")
print(f"Разница: {highest - lowest}")
```

```python
# Ошибки — пустой список
# print(min([]))  # ValueError: min() arg is an empty sequence
# print(max([]))  # ValueError: max() arg is an empty sequence

# Безопасная проверка
numbers = []
if numbers:
    print(f"Минимум: {min(numbers)}")
else:
    print("Список пуст")
```

```python
# min() и max() с несколькими аргументами
print(min(5, 2, 8, 1, 9))  # 1
print(max(5, 2, 8, 1, 9))  # 9

# Сравнение трёх чисел
a, b, c = 10, 25, 15
print(f"Наименьшее: {min(a, b, c)}")  # 10
print(f"Наибольшее: {max(a, b, c)}")  # 25
```

## `7.6` Конкатенация и другие математические операции
### Конкатенация (`+`) — склеивание списков
Объединяет два списка в один новый список.

### Повторение (`*`) — дублирование списка
Повторяет список указанное количество раз.

### Сравнение списков
Списки можно сравнивать операторами `==`, `!=`, `<`, `>` (лексикографически).

**Примеры:**

```python
# Конкатенация списков
list1 = [1, 2, 3]
list2 = [4, 5, 6]
combined = list1 + list2
print(combined)  # [1, 2, 3, 4, 5, 6]

# Исходные списки не изменяются
print(list1)  # [1, 2, 3]
print(list2)  # [4, 5, 6]
```

```python
# Объединение нескольких списков
fruits = ["яблоко", "банан"]
vegetables = ["морковь", "капуста"]
berries = ["клубника", "малина"]

all_food = fruits + vegetables + berries
print(all_food)
# ['яблоко', 'банан', 'морковь', 'капуста', 'клубника', 'малина']
```

```python
# Добавление элемента через конкатенацию
numbers = [1, 2, 3]
numbers = numbers + [4]
print(numbers)  # [1, 2, 3, 4]

# Добавление в начало
numbers = [0] + numbers
print(numbers)  # [0, 1, 2, 3, 4]
```

```python
# Повторение списка
zeros = [0] * 5
print(zeros)  # [0, 0, 0, 0, 0]

pattern = [1, 2] * 3
print(pattern)  # [1, 2, 1, 2, 1, 2]

# Создание начального списка
grid = [[0] * 3] * 2  # Осторожно! Создаёт ссылки на один список
print(grid)  # [[0, 0, 0], [0, 0, 0]]
```

```python
# Пустой список при умножении на 0
numbers = [1, 2, 3] * 0
print(numbers)  # []

# Отрицательные числа тоже дают пустой список
numbers = [1, 2, 3] * -5
print(numbers)  # []
```

```python
# Сравнение списков — равенство
list1 = [1, 2, 3]
list2 = [1, 2, 3]
list3 = [1, 2, 4]

print(list1 == list2)  # True (одинаковые элементы)
print(list1 == list3)  # False
print(list1 != list3)  # True
```

```python
# Лексикографическое сравнение
print([1, 2, 3] < [1, 2, 4])   # True (3 < 4)
print([1, 2] < [1, 2, 3])      # True (короче)
print([2, 1] > [1, 2, 3])      # True (2 > 1 на первой позиции)

words1 = ["apple", "banana"]
words2 = ["apple", "cherry"]
print(words1 < words2)  # True ("banana" < "cherry")
```

```python
# Практические примеры

# Объединение данных из разных источников
morning_tasks = ["Завтрак", "Душ", "Зарядка"]
evening_tasks = ["Ужин", "Чтение", "Сон"]
all_tasks = morning_tasks + evening_tasks

print("План на день:")
for i, task in enumerate(all_tasks, 1):
    print(f"{i}. {task}")
```

```python
# Создание шахматной доски
row_black = ["□", "■"] * 4
row_white = ["■", "□"] * 4
board = [row_black, row_white] * 4

for row in board:
    print(" ".join(row))
```

```python
# Проверка, является ли список палиндромом
numbers = [1, 2, 3, 2, 1]
if numbers == numbers[::-1]:
    print("Палиндром")
else:
    print("Не палиндром")
```

```python
# Создание диапазона с повторяющимися элементами
sequence = list(range(1, 4)) * 2
print(sequence)  # [1, 2, 3, 1, 2, 3]
```

```python
# Нельзя складывать списки с другими типами!
# numbers = [1, 2, 3]
# result = numbers + 4  # TypeError!

# Правильно:
numbers = [1, 2, 3]
result = numbers + [4]
print(result)  # [1, 2, 3, 4]
```

## `7.7` Методы списков (можно посмотреть все, но укажу, которые точно надо знать):  
Методы — это функции, которые принадлежат объекту списка и вызываются через точку: `список.метод()`.

### `append()` — добавление элемента в конец

```python
# Добавление одного элемента в конец
numbers = [1, 2, 3]
numbers.append(4)
print(numbers)  # [1, 2, 3, 4]

numbers.append(5)
print(numbers)  # [1, 2, 3, 4, 5]
```

```python
# Добавление разных типов
mixed = [1, "два"]
mixed.append(3.0)
mixed.append(True)
mixed.append([5, 6])  # Добавляет список как один элемент
print(mixed)  # [1, 'два', 3.0, True, [5, 6]]
```

### `extend()` — добавление нескольких элементов

```python
# Добавление элементов из другого списка
numbers = [1, 2, 3]
numbers.extend([4, 5, 6])
print(numbers)  # [1, 2, 3, 4, 5, 6]
```

```python
# Объединение нескольких списков
list1 = [1, 2]
list2 = [3, 4]
list3 = [5, 6]

list1.extend(list2)
list1.extend(list3)
print(list1)  # [1, 2, 3, 4, 5, 6]
```

### Оператор `del` — удаление по индексу

```python
# Удаление элемента по индексу
numbers = [1, 2, 3, 4, 5]
del numbers[2]  # Удалить элемент с индексом 2
print(numbers)  # [1, 2, 4, 5]
```

```python
# Удаление первого и последнего элемента
numbers = [10, 20, 30, 40, 50]
del numbers[0]   # Удалить первый
del numbers[-1]  # Удалить последний
print(numbers)  # [20, 30, 40]
```

### `remove()` — удаление первого вхождения значения

```python
# Удаление элемента по значению
fruits = ["яблоко", "банан", "апельсин", "банан"]
fruits.remove("банан")  # Удаляет первое вхождение
print(fruits)  # ['яблоко', 'апельсин', 'банан']
```

```python
# Если элемента нет — ошибка
numbers = [1, 2, 3, 4, 5]
# numbers.remove(10)  # ValueError: 10 not in list

# Безопасное удаление с проверкой
if 10 in numbers:
    numbers.remove(10)
else:
    print("Элемент не найден")
```

```python
# Удаление всех вхождений через цикл
numbers = [1, 2, 3, 2, 4, 2, 5]
while 2 in numbers:
    numbers.remove(2)
print(numbers)  # [1, 3, 4, 5]
```

### `pop()` — удаление и возврат элемента

```python
# pop() без аргумента — удаляет последний элемент
numbers = [1, 2, 3, 4, 5]
last = numbers.pop()
print(last)     # 5
print(numbers)  # [1, 2, 3, 4]
```

```python
# pop() с индексом — удаляет элемент по индексу
numbers = [10, 20, 30, 40, 50]
element = numbers.pop(2)  # Удалить элемент с индексом 2
print(element)  # 30
print(numbers)  # [10, 20, 40, 50]
```

```python
# Удаление первого элемента
numbers = [1, 2, 3, 4, 5]
first = numbers.pop(0)
print(first)    # 1
print(numbers)  # [2, 3, 4, 5]
```

### `reverse()` — разворот списка

```python
# Разворот списка на месте
numbers = [1, 2, 3, 4, 5]
numbers.reverse()
print(numbers)  # [5, 4, 3, 2, 1]
```

```python
# reverse() изменяет исходный список
original = [1, 2, 3]
original.reverse()
print(original)  # [3, 2, 1] — изменился!

# Если нужно сохранить оригинал — используйте срез
original = [1, 2, 3]
reversed_copy = original[::-1]
print(original)       # [1, 2, 3] — не изменился
print(reversed_copy)  # [3, 2, 1]
```

```python
# Разворот строк в списке
words = ["привет", "мир", "python"]
words.reverse()
print(words)  # ['python', 'мир', 'привет']
```

### `copy()` — копирование списка

```python
# Создание копии списка
original = [1, 2, 3, 4, 5]
copy = original.copy()

copy[0] = 100
print(original)  # [1, 2, 3, 4, 5] — не изменился
print(copy)      # [100, 2, 3, 4, 5]
```

```python
# Без copy() — создаётся ссылка, а не копия
original = [1, 2, 3]
reference = original  # Это НЕ копия!

reference[0] = 100
print(original)   # [100, 2, 3] — изменился!
print(reference)  # [100, 2, 3]
```

```python
# Альтернативные способы копирования
original = [1, 2, 3, 4, 5]

# Через срез
copy1 = original[:]

# Через list()
copy2 = list(original)

# Через copy()
copy3 = original.copy()

# Все три способа создают независимые копии
```

```python
# Внимание! copy() делает поверхностную копию
original = [[1, 2], [3, 4]]
copy = original.copy()

copy[0][0] = 100  # Изменяем вложенный список
print(original)  # [[100, 2], [3, 4]] — тоже изменился!
print(copy)      # [[100, 2], [3, 4]]

# Для вложенных структур нужен deepcopy
import copy as cp
deep = cp.deepcopy(original)
```

### `clear()` — очистка списка

```python
# Удаление всех элементов
numbers = [1, 2, 3, 4, 5]
numbers.clear()
print(numbers)  # []
```

```python
# clear() vs присваивание нового списка
list1 = [1, 2, 3]
list1.clear()  # Очищает список
print(list1)   # []

list2 = [1, 2, 3]
list2 = []  # Создаёт новый пустой список
print(list2)  # []
```

```python
# Очистка в цикле
todos = ["Задача 1", "Задача 2", "Задача 3"]

while todos:
    print(f"Осталось задач: {len(todos)}")
    print(f"Текущая задача: {todos[0]}")
    input("Нажмите Enter для завершения задачи...")
    todos.pop(0)
    
print("Все задачи выполнены!")
todos.clear()  # На всякий случай
```

### `sort()` — сортировка списка

```python
# Сортировка по возрастанию
numbers = [5, 2, 8, 1, 9, 3]
numbers.sort()
print(numbers)  # [1, 2, 3, 5, 8, 9]
```

```python
# Сортировка по убыванию
numbers = [5, 2, 8, 1, 9, 3]
numbers.sort(reverse=True)
print(numbers)  # [9, 8, 5, 3, 2, 1]
```

```python
# Сортировка строк (по алфавиту)
fruits = ["банан", "яблоко", "апельсин", "груша"]
fruits.sort()
print(fruits)  # ['апельсин', 'банан', 'груша', 'яблоко']
```

```python
# sort() изменяет исходный список
original = [3, 1, 4, 1, 5]
original.sort()
print(original)  # [1, 1, 3, 4, 5] — изменился!

# Если нужно сохранить оригинал — используйте sorted()
original = [3, 1, 4, 1, 5]
sorted_copy = sorted(original)
print(original)      # [3, 1, 4, 1, 5] — не изменился
print(sorted_copy)   # [1, 1, 3, 4, 5]
```

```python
# Сортировка по длине строк
words = ["python", "код", "программирование", "язык"]
words.sort(key=len)
print(words)  # ['код', 'язык', 'python', 'программирование']
```

```python
# Сортировка по нескольким критериям
students = [
    ("Анна", 85),
    ("Борис", 92),
    ("Вера", 85),
    ("Глеб", 78)
]

# Сортировка по оценке
students.sort(key=lambda x: x[1])
print(students)
# [('Глеб', 78), ('Анна', 85), ('Вера', 85), ('Борис', 92)]
```

```python
# Сортировка с игнорированием регистра
words = ["Python", "java", "C++", "ruby"]
words.sort(key=str.lower)
print(words)  # ['C++', 'java', 'Python', 'ruby']
```

```python
# Практический пример — сортировка оценок
grades = [78, 92, 85, 67, 95, 88, 73]

print("Исходные оценки:", grades)

grades.sort()
print("По возрастанию:", grades)

grades.sort(reverse=True)
print("По убыванию:", grades)

print(f"Лучшая оценка: {grades[0]}")
print(f"Худшая оценка: {grades[-1]}")
```

```python
# Нельзя сортировать смешанные типы!
# mixed = [1, "два", 3]
# mixed.sort()  # TypeError: '<' not supported between instances of 'str' and 'int'
```

## `7.8` Уметь перебирать списки через for
Цикл `for` позволяет перебрать все элементы списка по очереди. Это самый распространённый способ работы со списками.

**Варианты перебора:**
1. По элементам: `for element in list:`
2. По индексам: `for i in range(len(list)):`
3. С индексами и элементами: `for i, element in enumerate(list):`

**Примеры:**

```python
# Базовый перебор по элементам
fruits = ["яблоко", "банан", "апельсин"]

for fruit in fruits:
    print(fruit)
# яблоко
# банан
# апельсин
```

```python
# Перебор чисел
numbers = [1, 2, 3, 4, 5]
total = 0

for num in numbers:
    total += num

print(f"Сумма: {total}")  # Сумма: 15
```

```python
# Перебор с условиями
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

print("Чётные числа:")
for num in numbers:
    if num % 2 == 0:
        print(num, end=" ")
# Чётные числа: 2 4 6 8 10
```

```python
# Изменение элементов при переборе по индексам
numbers = [1, 2, 3, 4, 5]

for i in range(len(numbers)):
    numbers[i] = numbers[i] * 2

print(numbers)  # [2, 4, 6, 8, 10]
```

```python
# enumerate() — перебор с индексами и элементами
fruits = ["яблоко", "банан", "апельсин"]

for index, fruit in enumerate(fruits):
    print(f"{index}: {fruit}")
# 0: яблоко
# 1: банан
# 2: апельсин
```

```python
# enumerate() с начальным индексом
tasks = ["Завтрак", "Работа", "Обед", "Спорт"]

print("План на день:")
for num, task in enumerate(tasks, start=1):
    print(f"{num}. {task}")
# 1. Завтрак
# 2. Работа
# 3. Обед
# 4. Спорт
```

```python
# Поиск элемента в списке
numbers = [10, 20, 30, 40, 50]
target = 30
found = False

for num in numbers:
    if num == target:
        found = True
        break

if found:
    print(f"Число {target} найдено")
else:
    print(f"Число {target} не найдено")
```

```python
# Подсчёт элементов с условием
grades = [85, 92, 78, 95, 88, 73, 90]
excellent_count = 0

for grade in grades:
    if grade >= 90:
        excellent_count += 1

print(f"Отличных оценок: {excellent_count}")  # 3
```

```python
# Создание нового списка на основе существующего
numbers = [1, 2, 3, 4, 5]
squares = []

for num in numbers:
    squares.append(num ** 2)

print(squares)  # [1, 4, 9, 16, 25]
```

```python
# Фильтрация списка
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
even_numbers = []

for num in numbers:
    if num % 2 == 0:
        even_numbers.append(num)

print(even_numbers)  # [2, 4, 6, 8, 10]
```

```python
# Перебор вложенных списков
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

print("Элементы матрицы:")
for row in matrix:
    for element in row:
        print(element, end=" ")
    print()
# 1 2 3
# 4 5 6
# 7 8 9
```

```python
# Поиск максимального элемента вручную
numbers = [23, 45, 12, 67, 34, 89, 15]
max_num = numbers[0]  # Предполагаем, что первый — максимальный

for num in numbers:
    if num > max_num:
        max_num = num

print(f"Максимум: {max_num}")  # 89
```

```python
# Подсчёт вхождений элемента
numbers = [1, 2, 3, 2, 4, 2, 5, 2]
target = 2
count = 0

for num in numbers:
    if num == target:
        count += 1

print(f"Число {target} встречается {count} раз")  # 4 раза
```

```python
# Перебор с несколькими действиями
shopping_list = ["молоко", "хлеб", "яйца", "сыр"]
prices = [80, 40, 120, 250]

total = 0
print("Чек:")
for i in range(len(shopping_list)):
    item = shopping_list[i]
    price = prices[i]
    print(f"{item}: {price} руб")
    total += price

print(f"Итого: {total} руб")
```

```python
# Перебор двух списков одновременно с zip()
names = ["Анна", "Борис", "Вера"]
ages = [25, 30, 28]

for name, age in zip(names, ages):
    print(f"{name}: {age} лет")
# Анна: 25 лет
# Борис: 30 лет
# Вера: 28 лет
```

```python
# Изменение списка во время перебора (осторожно!)
numbers = [1, 2, 3, 4, 5]

# ❌ Неправильно — не модифицируйте список во время перебора по элементам
# for num in numbers:
#     if num % 2 == 0:
#         numbers.remove(num)  # Может пропустить элементы!

# ✅ Правильно — используйте копию или перебор по индексам в обратном порядке
for i in range(len(numbers) - 1, -1, -1):
    if numbers[i] % 2 == 0:
        numbers.pop(i)

print(numbers)  # [1, 3, 5]
```

```python
# Перебор с накоплением результата
words = ["python", "java", "ruby", "go"]
long_words = []

for word in words:
    if len(word) > 4:
        long_words.append(word)

print(long_words)  # ['python']
```

**Итог:**
- Перебор по элементам: `for element in list:` — самый простой и распространённый
- Перебор по индексам: `for i in range(len(list)):` — когда нужно изменять элементы
- `enumerate()`: `for i, element in enumerate(list):` — когда нужны и индекс, и элемент
- `zip()`: `for x, y in zip(list1, list2):` — для перебора нескольких списков одновременно
- Будьте осторожны при изменении списка во время перебора!






























## `7.9` (`*`) Распаковка списков

Распаковка списков позволяет одновременно присвоить элементы списка нескольким переменным. Это упрощает работу с данными и делает код более читаемым.

### **Базовая распаковка**

Количество переменных должно совпадать с количеством элементов.

```python
colors = ["red", "green", "blue"]
first, second, third = colors
print(first, second, third)  # red green blue

# С кортежами работает так же
point = (10, 20)
x, y = point
print(x, y)  # 10 20

# Ошибка при несовпадении количества
numbers = [1, 2, 3]
a, b = numbers  # ValueError: too many values to unpack
```

### **Распаковка с оператором `*` (звёздочка)**

Оператор `*` собирает несколько элементов в список.

```python
# Первый, последний и всё между ними
numbers = [1, 2, 3, 4, 5]
first, *middle, last = numbers
print(first)   # 1
print(middle)  # [2, 3, 4]
print(last)    # 5

# Только первый и остальные
head, *tail = numbers
print(head)  # 1
print(tail)  # [2, 3, 4, 5]

# Только последний и остальные
*init, last = numbers
print(init)  # [1, 2, 3, 4]
print(last)  # 5

# Игнорирование средних элементов
first, *_, last = numbers
print(first)  # 1
print(last)   # 5
# _ показывает, что средние элементы нас не интересуют
```

### **Распаковка при объединении списков**

```python
list1 = [1, 2]
list2 = [3, 4]
list3 = [5, 6]

# Объединение списков
merged = [*list1, *list2]
print(merged)  # [1, 2, 3, 4]

# Добавление элементов в начало и конец
extended = [0, *list1, *list2, 7]
print(extended)  # [0, 1, 2, 3, 4, 7]

# Объединение нескольких списков
all_lists = [*list1, *list2, *list3]
print(all_lists)  # [1, 2, 3, 4, 5, 6]
```

### **Распаковка в функциях**

```python
# Передача элементов списка как аргументов
def calculate(a, b, c):
    return a + b + c

values = [10, 20, 30]
result = calculate(*values)  # Эквивалентно calculate(10, 20, 30)
print(result)  # 60

# Создание копии списка
original = [1, 2, 3]
copy = [*original]
print(copy)  # [1, 2, 3]
print(copy is original)  # False (это другой объект)
```

### **Практические примеры**

```python
# Обмен значений без временной переменной
a, b = 10, 20
a, b = b, a
print(a, b)  # 20 10

# Работа с файлами CSV
data = "Иван,Петров,30"
first_name, last_name, age = data.split(',')
print(first_name)  # Иван
print(age)         # 30

# Распаковка вложенных структур
users = [("Alice", 25), ("Bob", 30), ("Charlie", 35)]
for name, age in users:
    print(f"{name} — {age} лет")
# Выведет:
# Alice — 25 лет
# Bob — 30 лет
# Charlie — 35 лет

# Пропуск ненужных значений
coordinates = (10, 20, 30, 40)
x, y, *_ = coordinates
print(x, y)  # 10 20
```


## `7.10` (*) Методы `split()`, `join()`
Эти методы используются для преобразования строк в списки и обратно.

### **Метод `split()` — разбиение строки на список**
Разбивает строку на подстроки по разделителю. Без аргумента разбивает по пробелам.

```python
# Разбиение по запятой
text = "яблоко,банан,апельсин"
fruits = text.split(',')
print(fruits)  # ['яблоко', 'банан', 'апельсин']

# Разбиение по точке с запятой
text = "раз,два;три.четыре"
parts = text.split(';')
print(parts)  # ['раз,два', 'три.четыре']

# Разбиение по пробелам (по умолчанию)
text = "один два три"
words = text.split()
print(words)  # ['один', 'два', 'три']

# Несколько пробелов обрабатываются как один
text = "один    два     три"
words = text.split()
print(words)  # ['один', 'два', 'три']

# Ограничение количества разбиений
text = "a,b,c,d,e"
result = text.split(',', 2)  # Разбить максимум 2 раза
print(result)  # ['a', 'b', 'c,d,e']
```

### **Метод `join()` — объединение списка в строку**

Объединяет элементы списка в строку, вставляя между ними разделитель.

```python
# Объединение через запятую и пробел
words = ['яблоко', 'банан', 'апельсин']
result = ", ".join(words)
print(result)  # "яблоко, банан, апельсин"

# Объединение через дефис
chars = list("Python")
result = "-".join(chars)
print(result)  # "P-y-t-h-o-n"

# Объединение с переносом строки
lines = ['строка 1', 'строка 2', 'строка 3']
text = "\n".join(lines)
print(text)
# Выведет:
# строка 1
# строка 2
# строка 3

# Объединение без разделителя
letters = ['H', 'e', 'l', 'l', 'o']
word = "".join(letters)
print(word)  # "Hello"
```

### **Практические комбинации `split()` и `join()`**

```python
# Очистка строки от лишних пробелов
text = "  много    пробелов   здесь  "
cleaned = " ".join(text.split())
print(cleaned)  # "много пробелов здесь"

# Замена разделителя
csv_data = "яблоко,банан,апельсин"
tsv_data = "\t".join(csv_data.split(','))
print(tsv_data)  # "яблоко	банан	апельсин"

# Работа с путями файлов
path_parts = ['home', 'user', 'documents', 'file.txt']
path = "/".join(path_parts)
print(path)  # "home/user/documents/file.txt"

# Парсинг CSV-подобных данных
data = "Иван,Петров,30,Москва"
fields = data.split(',')
name, surname, age, city = fields
print(f"{name} {surname}, {age} лет, {city}")
# Выведет: Иван Петров, 30 лет, Москва

# Создание строки из чисел
numbers = [1, 2, 3, 4, 5]
# join работает только со строками!
result = ", ".join(str(n) for n in numbers)
print(result)  # "1, 2, 3, 4, 5"

# Разбиение по нескольким разделителям (через replace)
text = "один,два;три.четыре"
normalized = text.replace(',', ' ').replace(';', ' ').replace('.', ' ')
words = normalized.split()
print(words)  # ['один', 'два', 'три', 'четыре']
```

### **Важные моменты**

```python
# split() возвращает список строк
text = "1,2,3"
numbers = text.split(',')
print(type(numbers[0]))  # <class 'str'> (не int!)

# join() работает только со строками
numbers = [1, 2, 3]
# result = ",".join(numbers)  # TypeError!
result = ",".join(map(str, numbers))  # Правильно
print(result)  # "1,2,3"

# Пустая строка между разделителями
text = "a,,b"
parts = text.split(',')
print(parts)  # ['a', '', 'b'] (пустая строка сохраняется)

# Разделитель не удаляется полностью
text = "a,b,c,"
parts = text.split(',')
print(parts)  # ['a', 'b', 'c', ''] (последний элемент пустой)
```

**Кейсы применения:**

- **`split()`:** парсинг CSV/TSV, разбиение строк по словам, обработка пользовательского ввода, работа с путями
- **`join()`:** формирование строк из списков, создание CSV, объединение строк с разделителем, форматирование вывода


## `7.11` (*) Списочные выражения (list comprehensions)
`List comprehension` — это компактный и читаемый способ создания списков на основе существующих итерируемых объектов. Позволяет заменить циклы `for` одной строкой кода.

### **Базовый синтаксис**

```python
# Общая структура: [выражение for элемент in итерируемый_объект]

# Простое создание списка
nums = [n for n in range(1, 6)]
print(nums)  # [1, 2, 3, 4, 5]

# Эквивалент через обычный цикл:
nums = []
for n in range(1, 6):
    nums.append(n)
```

### **Преобразование элементов**

```python
# Возведение в квадрат
nums = [1, 2, 3, 4, 5]
squares = [n * n for n in nums]
print(squares)  # [1, 4, 9, 16, 25]

# Преобразование в строки
numbers = [1, 2, 3]
strings = [str(n) for n in numbers]
print(strings)  # ['1', '2', '3']

# Применение методов
words = ["hello", "world", "python"]
uppercase = [word.upper() for word in words]
print(uppercase)  # ['HELLO', 'WORLD', 'PYTHON']

# Вычисления с несколькими операциями
prices = [100, 200, 300]
with_tax = [price * 1.2 for price in prices]
print(with_tax)  # [120.0, 240.0, 360.0]
```

### **Фильтрация с условием `if`**

```python
# Только нечётные числа
nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]
odd = [n for n in nums if n % 2 == 1]
print(odd)  # [1, 3, 5, 7, 9]

# Квадраты только нечётных чисел
odd_squares = [n * n for n in nums if n % 2 == 1]
print(odd_squares)  # [1, 9, 25, 49, 81]

# Фильтрация строк
words = ["apple", "banana", "kiwi", "strawberry"]
short_words = [w for w in words if len(w) <= 5]
print(short_words)  # ['apple', 'kiwi']

# Несколько условий
numbers = range(1, 21)
result = [n for n in numbers if n % 2 == 0 if n > 10]
print(result)  # [12, 14, 16, 18, 20]
```

### **Условное выражение `if-else`**

```python
# Разная логика для чётных и нечётных
result = ["чётное" if x % 2 == 0 else "нечётное" for x in range(5)]
print(result)  # ['чётное', 'нечётное', 'чётное', 'нечётное', 'чётное']

# Преобразование значений
numbers = [1, -2, 3, -4, 5]
absolute = [n if n >= 0 else -n for n in numbers]
print(absolute)  # [1, 2, 3, 4, 5]

# Замена None
values = [10, None, 20, None, 30]
cleaned = [v if v is not None else 0 for v in values]
print(cleaned)  # [10, 0, 20, 0, 30]
```

### **Вложенные циклы**

```python
# Создание всех пар
pairs = [(x, y) for x in [1, 2, 3] for y in ['a', 'b']]
print(pairs)  # [(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b'), (3, 'a'), (3, 'b')]

# Матрица (список списков)
matrix = [[x for x in range(1, 4)] for y in range(3)]
print(matrix)  # [[1, 2, 3], [1, 2, 3], [1, 2, 3]]

# Таблица умножения
table = [[i * j for j in range(1, 4)] for i in range(1, 4)]
print(table)  # [[1, 2, 3], [2, 4, 6], [3, 6, 9]]

# Развёртывание вложенного списка (flatten)
nested = [[1, 2], [3, 4], [5, 6]]
flat = [item for sublist in nested for item in sublist]
print(flat)  # [1, 2, 3, 4, 5, 6]

# С условием во вложенном цикле
result = [(x, y) for x in range(3) for y in range(3) if x != y]
print(result)  # [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1)]
```

### **Практические примеры**

```python
# Извлечение значений из словарей
users = [
    {"name": "Alice", "age": 25},
    {"name": "Bob", "age": 30},
    {"name": "Charlie", "age": 35}
]
names = [user["name"] for user in users]
print(names)  # ['Alice', 'Bob', 'Charlie']

# Фильтрация и преобразование
adults = [user["name"] for user in users if user["age"] >= 30]
print(adults)  # ['Bob', 'Charlie']

# Обработка файла (построчно)
lines = ["  line 1  ", "line 2", "  line 3  "]
cleaned = [line.strip() for line in lines if line.strip()]
print(cleaned)  # ['line 1', 'line 2', 'line 3']

# Создание множества уникальных значений
numbers = [1, 2, 2, 3, 3, 3, 4]
unique = list({n for n in numbers})  # Set comprehension
print(unique)  # [1, 2, 3, 4]
```

### **Сравнение с обычным циклом**

```python
# List comprehension (одна строка)
squares = [x**2 for x in range(10) if x % 2 == 0]

# Эквивалент через цикл (4 строки)
squares = []
for x in range(10):
    if x % 2 == 0:
        squares.append(x**2)

print(squares)  # [0, 4, 16, 36, 64]
```

**Когда использовать:**
- Простые преобразования и фильтрация данных
- Создание новых списков на основе существующих
- Когда логика помещается в одну строку и остаётся читаемой

**Когда НЕ использовать:**
- Сложная логика, которую трудно читать в одну строку
- Когда нужны побочные эффекты (лучше использовать обычный цикл)
- Глубоко вложенные comprehensions (более 2 уровней)

## `7.12` Вложенные списки
**Вложенные списки** — это списки, содержащие другие списки в качестве элементов. Часто используются для представления двумерных структур: матриц, таблиц, игровых полей, координатных сеток.

**Структура:**
```python
matrix = [
    [элемент00, элемент01, элемент02],  # строка 0
    [элемент10, элемент11, элемент12],  # строка 1
    [элемент20, элемент21, элемент22]   # строка 2
]
```

**Доступ к элементам:**
- `matrix[i]` — получить строку с индексом i
- `matrix[i][j]` — получить элемент в строке i, столбце j

**Примеры:**

```python
# Создание вложенного списка (матрицы 3×3)
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

print(matrix)
# [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
```

```python
# Доступ к элементам
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

print(matrix[0])      # [1, 2, 3] — первая строка
print(matrix[1][2])   # 6 — вторая строка, третий элемент
print(matrix[-1][-1]) # 9 — последняя строка, последний элемент
```

```python
# Изменение элементов
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

matrix[0][0] = 100
matrix[1][1] = 200
print(matrix)
# [[100, 2, 3], [4, 200, 6], [7, 8, 9]]
```

```python
# Создание матрицы с одинаковыми значениями
# ❌ Неправильно — создаёт ссылки на один список!
rows = 3
cols = 3
matrix = [[0] * cols] * rows
matrix[0][0] = 1
print(matrix)
# [[1, 0, 0], [1, 0, 0], [1, 0, 0]] — изменились все строки!

# ✅ Правильно — используем list comprehension
matrix = [[0] * cols for _ in range(rows)]
matrix[0][0] = 1
print(matrix)
# [[1, 0, 0], [0, 0, 0], [0, 0, 0]] — изменилась только первая строка
```

```python
# Перебор всех элементов (вложенные циклы)
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

print("Все элементы:")
for row in matrix:
    for element in row:
        print(element, end=" ")
    print()
# 1 2 3
# 4 5 6
# 7 8 9
```

```python
# Перебор с индексами
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

for i in range(len(matrix)):
    for j in range(len(matrix[i])):
        print(f"[{i}][{j}] = {matrix[i][j]}")
# [0][0] = 1
# [0][1] = 2
# [0][2] = 3
# ...
```

```python
# Сумма всех элементов матрицы
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

total = 0
for row in matrix:
    for element in row:
        total += element

print(f"Сумма: {total}")  # 45

# Или через list comprehension
total = sum(sum(row) for row in matrix)
print(f"Сумма: {total}")  # 45
```

```python
# Транспонирование матрицы (строки ↔ столбцы)
matrix = [
    [1, 2, 3],
    [4, 5, 6]
]

# С циклами
transposed = []
for j in range(len(matrix[0])):  # Перебираем столбцы
    row = []
    for i in range(len(matrix)):  # Перебираем строки
        row.append(matrix[i][j])
    transposed.append(row)

print(transposed)
# [[1, 4], [2, 5], [3, 6]]

# С list comprehension
transposed = [[matrix[i][j] for i in range(len(matrix))] for j in range(len(matrix[0]))]
print(transposed)
# [[1, 4], [2, 5], [3, 6]]
```

```python
# Игровое поле (крестики-нолики)
board = [
    [" ", " ", " "],
    [" ", " ", " "],
    [" ", " ", " "]
]

# Сделать ход
board[0][0] = "X"
board[1][1] = "O"
board[0][2] = "X"

# Вывести поле
for row in board:
    print("|".join(row))
    print("-" * 5)
# X| |X
# -----
#  |O| 
# -----
#  | | 
```

```python
# Таблица учеников с оценками
students = [
    ["Анна", 85, 90, 78],
    ["Борис", 92, 88, 95],
    ["Вера", 78, 85, 82]
]

print("Имя      | Оценки")
print("-" * 25)
for student in students:
    name = student[0]
    grades = student[1:]
    avg = sum(grades) / len(grades)
    print(f"{name:8} | {grades} → Средний: {avg:.1f}")
# Имя      | Оценки
# -------------------------
# Анна     | [85, 90, 78] → Средний: 84.3
# Борис    | [92, 88, 95] → Средний: 91.7
# Вера     | [78, 85, 82] → Средний: 81.7
```

```python
# Поиск элемента в матрице
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

target = 5
found = False

for i in range(len(matrix)):
    for j in range(len(matrix[i])):
        if matrix[i][j] == target:
            print(f"Найдено: {target} на позиции [{i}][{j}]")
            found = True
            break
    if found:
        break
```

```python
# Создание таблицы умножения
size = 5
table = [[i * j for j in range(1, size + 1)] for i in range(1, size + 1)]

for row in table:
    print(" ".join(f"{num:3}" for num in row))
#   1   2   3   4   5
#   2   4   6   8  10
#   3   6   9  12  15
#   4   8  12  16  20
#   5  10  15  20  25
```

```python
# Матрица координат
coords = [
    [(x, y) for x in range(3)]
    for y in range(3)
]

for row in coords:
    print(row)
# [(0, 0), (1, 0), (2, 0)]
# [(0, 1), (1, 1), (2, 1)]
# [(0, 2), (1, 2), (2, 2)]
```

```python
# Поиск максимума в каждой строке
matrix = [
    [10, 45, 23],
    [67, 12, 89],
    [34, 78, 56]
]

for i, row in enumerate(matrix):
    max_val = max(row)
    print(f"Строка {i}: максимум = {max_val}")
# Строка 0: максимум = 45
# Строка 1: максимум = 89
# Строка 2: максимум = 78
```

```python
# Проверка диагоналей (квадратная матрица)
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

# Главная диагональ
main_diagonal = [matrix[i][i] for i in range(len(matrix))]
print(f"Главная диагональ: {main_diagonal}")  # [1, 5, 9]

# Побочная диагональ
n = len(matrix)
side_diagonal = [matrix[i][n - 1 - i] for i in range(n)]
print(f"Побочная диагональ: {side_diagonal}")  # [3, 5, 7]
```

```python
# Фильтрация элементов матрицы
matrix = [
    [10, 5, 23],
    [8, 15, 3],
    [20, 12, 18]
]

# Найти все элементы > 10
large_elements = [element for row in matrix for element in row if element > 10]
print(large_elements)  # [23, 15, 20, 12, 18]
```

```python
# Практический пример — расписание
schedule = [
    ["Понедельник", "Математика", "Физика", "История"],
    ["Вторник", "Литература", "Химия", "Английский"],
    ["Среда", "Биология", "География", "Физкультура"]
]

print("Расписание:")
for day in schedule:
    day_name = day[0]
    subjects = ", ".join(day[1:])
    print(f"{day_name}: {subjects}")
# Понедельник: Математика, Физика, История
# Вторник: Литература, Химия, Английский
# Среда: Биология, География, Физкультура
```

```python
# Три уровня вложенности (куб 2×2×2)
cube = [
    [[1, 2], [3, 4]],
    [[5, 6], [7, 8]]
]

print(cube[0][1][0])  # 3
# [0] — первый слой
# [1] — вторая строка в слое
# [0] — первый элемент в строке
```

**Итог:**
- Вложенные списки — списки внутри списков
- Доступ через двойную индексацию: `matrix[row][col]`
- Для создания используйте list comprehension: `[[0] * cols for _ in range(rows)]`
- Перебор через вложенные циклы или двойной list comprehension
- Применение: матрицы, таблицы, игровые поля, координаты, расписания

## `7.13` (*) Сортировка: `sorted()` и параметр `key`

Функция `sorted()` создаёт **новый** отсортированный список из любого итерируемого объекта, не изменяя оригинал. Параметр `key` позволяет задать критерий сортировки.

### **Базовая сортировка**

```python
# Числа по возрастанию (по умолчанию)
numbers = [5, 2, 8, 1, 9]
result = sorted(numbers)
print(result)  # [1, 2, 5, 8, 9]
print(numbers)  # [5, 2, 8, 1, 9] (оригинал не изменился)

# Строки по алфавиту
words = ["banana", "apple", "cherry"]
result = sorted(words)
print(result)  # ['apple', 'banana', 'cherry']

# В обратном порядке
result = sorted(numbers, reverse=True)
print(result)  # [9, 8, 5, 2, 1]

# Сортировка строки (возвращает список символов)
text = "python"
result = sorted(text)
print(result)  # ['h', 'n', 'o', 'p', 't', 'y']
print(''.join(sorted(text)))  # 'hnopty'
```

### **Параметр `key` — функция для вычисления критерия**

`key` принимает функцию, которая применяется к каждому элементу для определения значения сортировки.

```python
# Сортировка строк по длине
words = ["apple", "pie", "banana", "kiwi"]
result = sorted(words, key=len)
print(result)  # ['pie', 'kiwi', 'apple', 'banana']

# Сортировка без учёта регистра
words = ["Banana", "apple", "Cherry", "date"]
result = sorted(words, key=str.lower)
print(result)  # ['apple', 'Banana', 'Cherry', 'date']

# Сортировка чисел по абсолютному значению
numbers = [-5, 2, -8, 1, 9, -3]
result = sorted(numbers, key=abs)
print(result)  # [1, 2, -3, -5, -8, 9]

# Сортировка по последнему символу
words = ["hello", "world", "python", "code"]
result = sorted(words, key=lambda x: x[-1])
print(result)  # ['code', 'hello', 'python', 'world']
```

### **Сортировка кортежей и списков**

```python
# По умолчанию — по первому элементу
pairs = [(3, 'three'), (1, 'one'), (2, 'two')]
result = sorted(pairs)
print(result)  # [(1, 'one'), (2, 'two'), (3, 'three')]

# По второму элементу
result = sorted(pairs, key=lambda x: x[1])
print(result)  # [(1, 'one'), (3, 'three'), (2, 'two')]

# Сортировка по нескольким критериям (кортеж в key)
students = [
    ('Alice', 85, 20),
    ('Bob', 92, 19),
    ('Charlie', 85, 21),
    ('David', 92, 18)
]
# Сначала по оценке (убывание), потом по возрасту (возрастание)
result = sorted(students, key=lambda x: (-x[1], x[2]))
print(result)
# [('David', 92, 18), ('Bob', 92, 19), ('Alice', 85, 20), ('Charlie', 85, 21)]
```

### **Сортировка объектов**

```python
class Student:
    def __init__(self, name, grade, age):
        self.name = name
        self.grade = grade
        self.age = age
    
    def __repr__(self):
        return f"Student({self.name}, {self.grade}, {self.age})"

students = [
    Student('Alice', 85, 20),
    Student('Bob', 92, 19),
    Student('Charlie', 78, 21)
]

# По оценке
by_grade = sorted(students, key=lambda s: s.grade)
print(by_grade)
# [Student(Charlie, 78, 21), Student(Alice, 85, 20), Student(Bob, 92, 19)]

# По имени
by_name = sorted(students, key=lambda s: s.name)
print(by_name)
# [Student(Alice, 85, 20), Student(Bob, 92, 19), Student(Charlie, 78, 21)]

# По оценке (убывание), затем по имени (возрастание)
result = sorted(students, key=lambda s: (-s.grade, s.name))
print(result)
# [Student(Bob, 92, 19), Student(Alice, 85, 20), Student(Charlie, 78, 21)]
```

### **Сложные случаи сортировки**

```python
# Сортировка словаря по значениям
scores = {'Alice': 85, 'Bob': 92, 'Charlie': 78}
sorted_items = sorted(scores.items(), key=lambda x: x[1], reverse=True)
print(sorted_items)  # [('Bob', 92), ('Alice', 85), ('Charlie', 78)]

# Преобразование обратно в словарь (с Python 3.7+ порядок сохраняется)
sorted_dict = dict(sorted_items)
print(sorted_dict)  # {'Bob': 92, 'Alice': 85, 'Charlie': 78}

# Сортировка строк по количеству гласных
def count_vowels(word):
    return sum(1 for char in word.lower() if char in 'aeiou')

words = ["hello", "world", "python", "code"]
result = sorted(words, key=count_vowels)
print(result)  # ['world', 'python', 'code', 'hello']

# Естественная сортировка (числа в строках)
import re

def natural_key(text):
    return [int(c) if c.isdigit() else c.lower() for c in re.split('(\d+)', text)]

files = ['file1.txt', 'file10.txt', 'file2.txt', 'file20.txt']
result = sorted(files, key=natural_key)
print(result)  # ['file1.txt', 'file2.txt', 'file10.txt', 'file20.txt']
```

### **`sorted()` vs `list.sort()`**

```python
# sorted() — создаёт новый список
numbers = [3, 1, 2]
new_list = sorted(numbers)
print(numbers)   # [3, 1, 2] (не изменился)
print(new_list)  # [1, 2, 3]

# list.sort() — изменяет на месте, возвращает None
numbers = [3, 1, 2]
result = numbers.sort()
print(numbers)  # [1, 2, 3] (изменился)
print(result)   # None

# sort() также поддерживает key и reverse
numbers = [3, 1, 2]
numbers.sort(reverse=True)
print(numbers)  # [3, 2, 1]
```

### **Стабильная сортировка**

Python использует **стабильную** сортировку — элементы с одинаковыми ключами сохраняют исходный порядок.

```python
students = [
    ('Alice', 85),
    ('Bob', 85),
    ('Charlie', 85)
]
# Все имеют одинаковую оценку
result = sorted(students, key=lambda x: x[1])
print(result)
# [('Alice', 85), ('Bob', 85), ('Charlie', 85)]
# Порядок сохранился, как в исходном списке
```

**Когда использовать:**
- `sorted()` — когда нужен новый список или сортировка любого итерируемого объекта
- `list.sort()` — когда нужно отсортировать существующий список и сэкономить память
- `key` — для любой нестандартной сортировки (по атрибутам, длине, сложным критериям)
- `reverse=True` — для обратного порядка

----

# `8` Функции 1
## `8.1` Что такое функциональное программирование?
**Функциональное программирование (ФП)** — это парадигма программирования, в которой вычисления рассматриваются как применение и композицию функций. Программа строится из функций, которые принимают данные и возвращают результат, не изменяя внешнее состояние.

**Основные принципы ФП:**
1. **Функции — первоклассные объекты** — их можно передавать как аргументы, возвращать из других функций, присваивать переменным
2. **Чистые функции (pure functions)** — результат зависит только от входных данных, нет побочных эффектов (не изменяют глобальные переменные, файлы, базы данных)
3. **Неизменяемость данных (immutability)** — данные не изменяются после создания, создаются новые
4. **Отсутствие состояния** — функции не зависят от внешнего контекста
5. **Декларативность** — описываем "что делать", а не "как делать"

**Python и ФП:**
Python — **мультипарадигменный язык**. Он поддерживает:
- Императивное программирование (последовательность команд)
- Объектно-ориентированное программирование (классы, объекты)
- Функциональное программирование (функции высшего порядка, lambda, map, filter, reduce)

Python не является чисто функциональным языком (как Haskell или Lisp), но активно использует идеи ФП.

**Примеры концепций ФП в Python:**

```python
# Чистая функция — результат зависит только от входных данных
def add(a, b):
    return a + b

print(add(2, 3))  # 5 — всегда одинаковый результат для одинаковых аргументов
```

```python
# Нечистая функция — зависит от внешнего состояния
total = 0

def add_to_total(value):
    global total
    total += value  # Изменяет глобальное состояние — побочный эффект!
    return total
```

```python
# Неизменяемость — создаём новые данные вместо изменения старых
numbers = [1, 2, 3]

# Императивный стиль (изменяем список)
numbers.append(4)

# Функциональный стиль (создаём новый список)
new_numbers = numbers + [4]
```

**Зачем изучать ФП:**
- Код становится более предсказуемым и тестируемым
- Легче избежать ошибок, связанных с изменяемым состоянием
- Проще распараллеливать вычисления
- Код более выразительный и лаконичный

## `8.2` Что такое функция? Как объявить функцию в Python?
**Функция** — это именованный блок кода, который выполняет определённую задачу. Функция может принимать данные (параметры), обрабатывать их и возвращать результат.

**Зачем нужны функции:**
1. **Переиспользование кода** — пишем один раз, используем много раз
2. **Структурирование программы** — разделяем сложную задачу на простые части
3. **Читаемость** — код с функциями понятнее
4. **Тестирование** — легче проверить отдельную функцию
5. **Абстракция** — скрываем детали реализации
6. **Избежание дублирования** — принцип DRY (Don't Repeat Yourself)

**Синтаксис объявления функции:**
```python
def имя_функции(параметры):
    """Документация функции (опционально)"""
    # тело функции
    # код, который выполняется при вызове
    return результат  # опционально
```

**Компоненты функции:**
- `def` — ключевое слово для объявления функции
- `имя_функции` — идентификатор функции (правила как для переменных)
- `параметры` — входные данные (могут отсутствовать)
- `docstring` — строка документации (необязательна, но рекомендуется)
- `тело функции` — код с отступом (обязательно минимум одна строка)
- `return` — возврат результата (опционально)

**Вызов функции:**
```python
результат = имя_функции(аргументы)
```

**Примеры:**

```python
# Простейшая функция без параметров и без return
def greet():
    print("Привет, мир!")

# Вызов функции
greet()  # Привет, мир!
```

```python
# Функция с параметром
def greet_person(name):
    print(f"Привет, {name}!")

greet_person("Анна")   # Привет, Анна!
greet_person("Борис")  # Привет, Борис!
```

```python
# Функция с return
def add(a, b):
    result = a + b
    return result

sum_result = add(5, 3)
print(sum_result)  # 8
```

```python
# Функция с несколькими параметрами
def calculate_rectangle_area(width, height):
    area = width * height
    return area

area = calculate_rectangle_area(5, 10)
print(f"Площадь: {area}")  # Площадь: 50
```

```python
# Функция с docstring (документацией)
def multiply(a, b):
    """
    Умножает два числа.
    
    Параметры:
        a (int/float): первое число
        b (int/float): второе число
    
    Возвращает:
        int/float: произведение a и b
    """
    return a * b

result = multiply(4, 7)
print(result)  # 28

# Просмотр документации
print(multiply.__doc__)
```

```python
# Функция может вызывать другие функции
def square(x):
    return x * x

def sum_of_squares(a, b):
    return square(a) + square(b)

result = sum_of_squares(3, 4)
print(result)  # 9 + 16 = 25
```

**Правила именования функций:**
- Используйте `snake_case` (слова через подчёркивание)
- Имя должно быть глаголом или глагольной фразой (функция что-то **делает**)
- Имя должно описывать действие функции

```python
# ✅ Хорошие имена
def calculate_total():
    pass

def get_user_age():
    pass

def is_valid_email():
    pass

def send_notification():
    pass

# ❌ Плохие имена
def calc():  # Слишком короткое, неясное
    pass

def data():  # Существительное, непонятно что делает
    pass

def func1():  # Бессмысленное имя
    pass
```

**Порядок выполнения:**

```python
print("1. Начало программы")

def my_function():
    print("3. Внутри функции")

print("2. Функция объявлена, но ещё не вызвана")

my_function()  # Вызов функции

print("4. После вызова функции")

# Вывод:
# 1. Начало программы
# 2. Функция объявлена, но ещё не вызвана
# 3. Внутри функции
# 4. После вызова функции
```

**Важно:**
- Функцию нужно **объявить** перед тем, как её **вызвать**
- Код внутри функции выполняется только при вызове
- Функция может быть вызвана многократно

## `8.3` Функции с и без параметров
Функции могут принимать **параметры (аргументы)** — входные данные для обработки. Параметры указываются в скобках при объявлении функции.

**Типы функций:**
1. **Без параметров** — функция не принимает данные извне
2. **С одним параметром** — принимает одно значение
3. **С несколькими параметрами** — принимает несколько значений

### Функции без параметров

**Когда использовать:**
- Функция выполняет фиксированное действие
- Данные берутся изнутри функции или из внешних источников
- Функция не зависит от входных данных

```python
# Функция без параметров
def print_header():
    print("=" * 40)
    print("      Добро пожаловать!")
    print("=" * 40)

print_header()
# ========================================
#       Добро пожаловать!
# ========================================
```

```python
# Функция с вводом внутри
def ask_name():
    name = input("Как вас зовут? ")
    print(f"Привет, {name}!")

ask_name()
```

```python
# Функция, возвращающая константу
def get_pi():
    return 3.141592653589793

pi = get_pi()
print(pi)  # 3.141592653589793
```

### Функции с одним параметром

**Когда использовать:**
- Функция обрабатывает одно значение
- Нужна гибкость — одна и та же функция с разными данными

```python
# Функция с одним параметром
def greet(name):
    print(f"Привет, {name}!")

greet("Анна")   # Привет, Анна!
greet("Борис")  # Привет, Борис!
```

```python
# Функция с return и одним параметром
def square(x):
    return x ** 2

print(square(5))   # 25
print(square(10))  # 100
```

```python
# Преобразование данных
def to_uppercase(text):
    return text.upper()

result = to_uppercase("python")
print(result)  # PYTHON
```

### Функции с несколькими параметрами

**Когда использовать:**
- Функция обрабатывает несколько связанных значений
- Нужны разные данные для вычисления результата

```python
# Функция с двумя параметрами
def add(a, b):
    return a + b

result = add(5, 3)
print(result)  # 8
```

```python
# Функция с тремя параметрами
def calculate_average(a, b, c):
    total = a + b + c
    average = total / 3
    return average

avg = calculate_average(80, 90, 85)
print(f"Средний балл: {avg}")  # Средний балл: 85.0
```

```python
# Функция с разными типами параметров
def create_greeting(name, age, city):
    return f"Меня зовут {name}, мне {age} лет, живу в {city}"

message = create_greeting("Иван", 25, "Москва")
print(message)  # Меня зовут Иван, мне 25 лет, живу в Москва
```

**Порядок параметров важен:**

```python
def introduce(name, age):
    print(f"{name} — {age} лет")

introduce("Анна", 25)  # Анна — 25 лет
introduce(25, "Анна")  # 25 — Анна лет (неправильно!)
```

**Сравнение:**

```python
# Без параметров — жёстко заданное поведение
def print_hello():
    print("Hello!")

print_hello()  # Всегда выводит "Hello!"

# С параметром — гибкое поведение
def print_message(message):
    print(message)

print_message("Hello!")    # Hello!
print_message("Привет!")   # Привет!
print_message("Bonjour!")  # Bonjour!
```

**Практические примеры:**

```python
# Без параметров — информационная функция
def show_menu():
    print("1. Новая игра")
    print("2. Загрузить")
    print("3. Выход")

show_menu()
```

```python
# С параметрами — универсальная функция
def calculate_discount(price, discount_percent):
    discount_amount = price * discount_percent / 100
    final_price = price - discount_amount
    return final_price

price1 = calculate_discount(1000, 10)  # 900.0
price2 = calculate_discount(500, 20)   # 400.0
```

## `8.4` Разница аргумента и параметра
**Параметры** и **аргументы** — это близкие, но разные понятия:

- **Параметр (parameter)** — переменная в определении функции. Это "шаблон" того, что функция ожидает получить.
- **Аргумент (argument)** — конкретное значение, которое передаётся функции при вызове.

**Простыми словами:**
- **Параметр** — это "заготовка" (переменная в объявлении функции)
- **Аргумент** — это "наполнение" (реальное значение при вызове)

**Аналогия:**
Представьте функцию как форму для печенья:
- **Параметр** — форма (абстрактный шаблон)
- **Аргумент** — тесто, которое вы кладёте в форму (конкретные данные)

**Пример:**

```python
# Объявление функции
def greet(name):  # name — это ПАРАМЕТР
    print(f"Привет, {name}!")

# Вызов функции
greet("Анна")  # "Анна" — это АРГУМЕНТ
greet("Борис")  # "Борис" — это АРГУМЕНТ
```

**Визуальное объяснение:**

```python
def add(a, b):  # a и b — ПАРАМЕТРЫ (placeholders)
    return a + b

result = add(5, 3)  # 5 и 3 — АРГУМЕНТЫ (actual values)
#            ↑  ↑
#            |  |
#     аргументы передаются в параметры
```

**Типы аргументов:**

### 1. Позиционные аргументы
Передаются в том же порядке, что и параметры.

```python
def introduce(name, age, city):
    print(f"{name}, {age} лет, {city}")

introduce("Анна", 25, "Москва")
# "Анна" → name
# 25 → age
# "Москва" → city
```

### 2. Именованные аргументы (keyword arguments)
Указываются с именем параметра, порядок не важен.

```python
def introduce(name, age, city):
    print(f"{name}, {age} лет, {city}")

# Порядок может быть любым
introduce(city="Москва", name="Анна", age=25)
introduce(age=30, name="Борис", city="Санкт-Петербург")
```

### 3. Смешанные аргументы
Сначала позиционные, потом именованные.

```python
def introduce(name, age, city):
    print(f"{name}, {age} лет, {city}")

# Сначала позиционные, затем именованные
introduce("Анна", 25, city="Москва")
introduce("Борис", age=30, city="Казань")

# ❌ Ошибка — именованные должны быть после позиционных
# introduce(name="Анна", 25, "Москва")  # SyntaxError
```

**Параметры по умолчанию (default parameters):**

```python
# Параметр с значением по умолчанию
def greet(name, greeting="Привет"):
    print(f"{greeting}, {name}!")

greet("Анна")           # Привет, Анна! (используется значение по умолчанию)
greet("Борис", "Здравствуйте")  # Здравствуйте, Борис!
```

```python
# Несколько параметров по умолчанию
def create_user(name, age=18, country="Россия"):
    print(f"Пользователь: {name}, {age} лет, {country}")

create_user("Анна")                      # Возраст 18, Россия
create_user("Борис", 25)                 # Возраст 25, Россия
create_user("Вера", 30, "Украина")       # Возраст 30, Украина
create_user("Глеб", country="Казахстан") # Возраст 18, Казахстан
```

**Важные правила:**

```python
# ✅ Правильно — параметры по умолчанию в конце
def func(a, b, c=10):
    pass

# ❌ Ошибка — обязательный параметр после параметра по умолчанию
# def func(a, b=5, c):  # SyntaxError
#     pass
```

**Практический пример:**

```python
def calculate_price(base_price, tax=0.2, discount=0):
    """
    Вычисляет финальную цену с учётом налога и скидки.
    
    Параметры:
        base_price (float): базовая цена
        tax (float): налог в процентах (по умолчанию 20%)
        discount (float): скидка в процентах (по умолчанию 0%)
    """
    price_with_tax = base_price * (1 + tax)
    final_price = price_with_tax * (1 - discount)
    return final_price

# Разные способы вызова
print(calculate_price(1000))                    # 1200.0 (только базовая цена)
print(calculate_price(1000, 0.1))               # 1100.0 (налог 10%)
print(calculate_price(1000, 0.2, 0.1))          # 1080.0 (налог 20%, скидка 10%)
print(calculate_price(1000, discount=0.15))     # 1020.0 (налог по умолчанию, скидка 15%)
```

**Итог:**
- **Параметр** — переменная в определении функции (шаблон)
- **Аргумент** — значение при вызове функции (данные)
- **Позиционные аргументы** — порядок важен
- **Именованные аргументы** — порядок не важен
- **Параметры по умолчанию** — необязательные значения

## `8.5` Разные виды `return`
`return` — оператор для возврата результата из функции. После выполнения `return` функция **немедленно завершается**, и управление возвращается в место вызова.

**Основные концепции:**
1. `return` может возвращать значение любого типа
2. `return` без значения возвращает `None`
3. Функция без `return` тоже возвращает `None`
4. `return` прерывает выполнение функции
5. Можно вернуть несколько значений (кортеж)

### 1. Return с значением

```python
# Возврат числа
def get_age():
    return 25

age = get_age()
print(age)  # 25
print(type(age))  # <class 'int'>
```

```python
# Возврат результата вычисления
def add(a, b):
    return a + b

result = add(10, 5)
print(result)  # 15
```

```python
# Возврат строки
def get_greeting():
    return "Привет, мир!"

message = get_greeting()
print(message)  # Привет, мир!
```

### 2. Return без значения (возврат None)

```python
# return без значения
def say_hello():
    print("Привет!")
    return  # Явный выход из функции

result = say_hello()
print(result)  # None
```

```python
# Функция без return — неявно возвращает None
def print_message():
    print("Сообщение")

result = print_message()
print(result)  # None
```

### 3. Return прерывает функцию

```python
# Код после return не выполняется
def example():
    print("До return")
    return 42
    print("После return")  # Это никогда не выполнится!

result = example()
# Вывод:
# До return
```

```python
# Досрочный выход из функции
def check_age(age):
    if age < 18:
        return "Несовершеннолетний"  # Выход из функции
    return "Совершеннолетний"

print(check_age(15))  # Несовершеннолетний
print(check_age(25))  # Совершеннолетний
```

```python
# Множественные return для разных условий
def get_grade(score):
    if score >= 90:
        return "Отлично"
    elif score >= 70:
        return "Хорошо"
    elif score >= 50:
        return "Удовлетворительно"
    else:
        return "Неудовлетворительно"

print(get_grade(95))  # Отлично
print(get_grade(65))  # Удовлетворительно
```

### 4. Return нескольких значений

```python
# Возврат нескольких значений (кортеж)
def get_user_info():
    name = "Анна"
    age = 25
    city = "Москва"
    return name, age, city  # Возвращает кортеж

# Распаковка значений
user_name, user_age, user_city = get_user_info()
print(user_name)  # Анна
print(user_age)   # 25
print(user_city)  # Москва

# Или получить кортеж целиком
info = get_user_info()
print(info)  # ('Анна', 25, 'Москва')
print(type(info))  # <class 'tuple'>
```

```python
# Возврат результата нескольких вычислений
def calculate(a, b):
    sum_result = a + b
    diff_result = a - b
    product_result = a * b
    return sum_result, diff_result, product_result

s, d, p = calculate(10, 5)
print(f"Сумма: {s}, Разность: {d}, Произведение: {p}")
# Сумма: 15, Разность: 5, Произведение: 50
```

### 5. Return различных типов данных

```python
# Возврат списка
def get_numbers():
    return [1, 2, 3, 4, 5]

numbers = get_numbers()
print(numbers)  # [1, 2, 3, 4, 5]
```

```python
# Возврат словаря
def get_person():
    return {
        "name": "Анна",
        "age": 25,
        "city": "Москва"
    }

person = get_person()
print(person["name"])  # Анна
```

```python
# Возврат булева значения
def is_even(number):
    return number % 2 == 0

print(is_even(4))  # True
print(is_even(7))  # False
```

### 6. Return в циклах

```python
# Return прерывает не только функцию, но и цикл внутри неё
def find_first_even(numbers):
    for num in numbers:
        if num % 2 == 0:
            return num  # Выход из цикла и функции
    return None  # Если чётное не найдено

result = find_first_even([1, 3, 5, 8, 10, 12])
print(result)  # 8 (первое чётное)

result = find_first_even([1, 3, 5, 7])
print(result)  # None
```

```python
# Поиск элемента в списке
def find_index(lst, target):
    for i in range(len(lst)):
        if lst[i] == target:
            return i  # Возврат индекса при нахождении
    return -1  # Элемент не найден

numbers = [10, 20, 30, 40, 50]
print(find_index(numbers, 30))  # 2
print(find_index(numbers, 100))  # -1
```

### 7. Return выражений

```python
# Можно возвращать результат выражения напрямую
def is_adult(age):
    return age >= 18  # Возвращает True или False

print(is_adult(25))  # True
print(is_adult(15))  # False
```

```python
# Возврат результата вызова другой функции
def square(x):
    return x ** 2

def sum_of_squares(a, b):
    return square(a) + square(b)  # Возврат результата вычисления

print(sum_of_squares(3, 4))  # 25
```

**Важные замечания:**

```python
# ❌ Частая ошибка — print вместо return
def add_wrong(a, b):
    print(a + b)  # Печатает, но НЕ возвращает!

result = add_wrong(5, 3)  # Выведет 8
print(result)  # None (функция ничего не вернула)

# ✅ Правильно — return
def add_correct(a, b):
    return a + b

result = add_correct(5, 3)
print(result)  # 8
```

```python
# Return можно использовать с условными выражениями (тернарный оператор)
def get_status(age):
    return "Взрослый" if age >= 18 else "Ребёнок"

print(get_status(20))  # Взрослый
print(get_status(10))  # Ребёнок
```

**Итог:**
- `return` возвращает результат из функции
- `return` без значения или отсутствие `return` возвращает `None`
- `return` немедленно завершает функцию
- Можно вернуть несколько значений (кортеж)
- Можно возвращать любые типы данных
- `return` работает в циклах, досрочно завершая функцию

----

# `9` Типы данных 3
## `9.1` Кортежи
### `9.1.1` Что такое кортежи?
`Кортеж (tuple)` — это неизменяемая упорядоченная коллекция элементов в Python. Это как список, но его нельзя изменить после создания. Кортежи создаются с помощью круглых скобок `()` или просто через запятую. 

Кортежи могут содержать элементы любых типов: числа, строки, другие кортежи, списки и т.д. Они сохраняют порядок элементов и позволяют обращаться к ним по индексу (как в списках).

**Когда использовать кортежи:**
- Когда данные не должны изменяться (координаты, даты, настройки)
- Для возврата нескольких значений из функции
- Как ключи в словарях (списки нельзя использовать)
- Когда важна производительность

**Примеры:**

```python
# Разные способы создания кортежей
coordinates = (10, 20)                    # с круглыми скобками
person = ("Анна", 25, "Москва")          # разные типы данных
empty_tuple = ()                          # пустой кортеж
single_element = (42,)                    # один элемент (запятая обязательна!)
single_wrong = (42)                       # это НЕ кортеж, это просто число в скобках
without_brackets = 1, 2, 3                # кортеж без скобок

print(type(single_element))  # <class 'tuple'>
print(type(single_wrong))    # <class 'int'>
```

```python
# Доступ к элементам (работает как в списках)
colors = ("красный", "синий", "зеленый", "желтый")

print(colors[0])        # красный (первый элемент)
print(colors[-1])       # желтый (последний элемент)
print(colors[1:3])      # ('синий', 'зеленый') - срез
print(len(colors))      # 4

# Вложенные кортежи
matrix = ((1, 2, 3), (4, 5, 6), (7, 8, 9))
print(matrix[0])        # (1, 2, 3)
print(matrix[0][1])     # 2
```

### `9.1.2` В чем их плюсы и минусы? Свойства. Отличие от списков 
**Основные свойства кортежей:**

1. **Неизменяемость (immutable)** — после создания кортежа нельзя:
   - Изменить элементы
   - Добавить новые элементы
   - Удалить элементы
   - Это главное отличие от списков!

2. **Упорядоченность** — элементы всегда в том порядке, в котором их создали

3. **Индексируемость** — можно обращаться по индексу: `my_tuple[0]`

4. **Могут содержать любые типы данных**, включая изменяемые объекты (списки, словари)

5. **Хешируемость** — можно использовать как ключи словаря (если все элементы тоже хешируемые)

**Плюсы кортежей:**
- ⚡ **Быстрее списков** — занимают меньше памяти, быстрее итерация
- 🔒 **Безопасность данных** — защита от случайного изменения
- 🔑 **Можно использовать как ключи словаря** (списки нельзя)
- 📦 **Меньше памяти** — кортежи более компактны
- ✅ **Идеальны для константных данных** — координаты, RGB-цвета, даты

**Минусы кортежей:**
- ❌ **Нельзя изменять** — для динамических данных неудобно
- 📉 **Мало методов** — всего 2 метода (у списков их около 11)
- 🔧 **Менее гибкие** — нужно создавать новый кортеж для изменений

**Сравнение кортежей и списков:**

| Характеристика | Кортеж `()` | Список `[]` |
|----------------|-------------|-------------|
| Изменяемость | Неизменяемый | Изменяемый |
| Скорость | Быстрее | Медленнее |
| Память | Меньше | Больше |
| Методы | 2 метода | ~11 методов |
| Ключ словаря | Можно | Нельзя |
| Использование | Константные данные | Динамические данные |

**Примеры:**

```python
# Демонстрация неизменяемости
my_tuple = (1, 2, 3)
my_list = [1, 2, 3]

# Попытка изменить кортеж
try:
    my_tuple[0] = 10
except TypeError as e:
    print(f"Ошибка: {e}")
    # Ошибка: 'tuple' object does not support item assignment

# Список можно изменить
my_list[0] = 10
print(my_list)  # [10, 2, 3]

# Чтобы "изменить" кортеж, нужно создать новый
my_tuple = (10,) + my_tuple[1:]
print(my_tuple)  # (10, 2, 3)
```

```python
# Кортеж как ключ словаря (полезно для координат, многомерных данных)
# GPS координаты городов
locations = {
    (55.7558, 37.6173): "Москва",
    (59.9343, 30.3351): "Санкт-Петербург",
    (51.5074, -0.1278): "Лондон"
}
print(locations[(55.7558, 37.6173)])  # Москва

# Список нельзя использовать как ключ
try:
    bad_dict = {[55, 37]: "Москва"}
except TypeError as e:
    print(f"Ошибка: {e}")
    # Ошибка: unhashable type: 'list'

# Сравнение производительности (для интереса)
import sys
tuple_data = (1, 2, 3, 4, 5)
list_data = [1, 2, 3, 4, 5]
print(f"Размер кортежа: {sys.getsizeof(tuple_data)} байт")  # меньше
print(f"Размер списка: {sys.getsizeof(list_data)} байт")    # больше
```

### `9.1.3` Функции `len()`, `in` для кортежей и другие по типу `sum()`
Кортежи поддерживают большинство встроенных функций Python для работы с последовательностями. Эти функции НЕ изменяют кортеж, а только читают или вычисляют значения.

**Основные функции:**
- `len()` — длина кортежа (количество элементов)
- `in` / `not in` — проверка наличия элемента
- `sum()` — сумма числовых элементов
- `min()` — минимальный элемент
- `max()` — максимальный элемент
- `sorted()` — возвращает отсортированный **список** (не изменяет кортеж!)
- `tuple()` — преобразование в кортеж
- `any()` — True, если хотя бы один элемент True
- `all()` — True, если все элементы True

**Примеры:**

```python
numbers = (5, 2, 8, 1, 9, 2)

# Базовые функции
print(len(numbers))        # 6 - количество элементов
print(3 in numbers)        # False - тройки нет
print(8 in numbers)        # True - восьмерка есть
print(5 not in numbers)    # False - пятерка есть

# Математические функции (работают только с числами)
print(sum(numbers))        # 27 - сумма всех элементов
print(min(numbers))        # 1 - минимальное значение
print(max(numbers))        # 9 - максимальное значение
print(sum(numbers) / len(numbers))  # 4.5 - среднее значение

# Можно использовать с другими типами данных
words = ("яблоко", "банан", "арбуз")
print(min(words))          # 'арбуз' - минимум по алфавиту
print(max(words))          # 'яблоко' - максимум по алфавиту
```

```python
# sorted() возвращает СПИСОК, не кортеж!
data = (40, 10, 30, 20, 50)

sorted_list = sorted(data)
print(sorted_list)              # [10, 20, 30, 40, 50] - это список!
print(type(sorted_list))        # <class 'list'>

# Оригинальный кортеж не изменился
print(data)                     # (40, 10, 30, 20, 50)

# Чтобы получить отсортированный кортеж
sorted_tuple = tuple(sorted(data))
print(sorted_tuple)             # (10, 20, 30, 40, 50)
print(type(sorted_tuple))       # <class 'tuple'>

# Сортировка в обратном порядке
reverse_sorted = tuple(sorted(data, reverse=True))
print(reverse_sorted)           # (50, 40, 30, 20, 10)

# any() и all() - полезны для проверок
conditions = (True, True, False, True)
print(any(conditions))          # True - хотя бы один True
print(all(conditions))          # False - не все True

prices = (100, 200, 300, 400)
print(all(price > 50 for price in prices))   # True - все цены > 50
print(any(price > 350 for price in prices))  # True - есть цены > 350
```

### `9.1.4` Методы кортежей:  
У кортежей очень мало методов — всего 2! Это связано с их неизменяемостью. Все методы, которые изменяют данные (как `append()`, `remove()` у списков), у кортежей отсутствуют.

**Два метода кортежей:**

#### `index(value, start, stop)`
Возвращает индекс **первого** вхождения элемента. Можно указать диапазон поиска.
- Если элемент не найден → `ValueError`
- Параметры `start` и `stop` опциональны

#### `count(value)`
Возвращает количество вхождений элемента в кортеж.
- Всегда возвращает число (0 или больше)
- Никогда не вызывает ошибку

#### `join()` — это метод строки!
Хотя `join()` это не метод кортежа, его часто используют с кортежами строк. Он объединяет элементы в одну строку с разделителем.

**Примеры:**

```python
# index() - поиск индекса элемента
fruits = ("яблоко", "банан", "яблоко", "груша", "яблоко", "киви")

print(fruits.index("банан"))      # 1 - банан на позиции 1
print(fruits.index("яблоко"))     # 0 - первое яблоко на позиции 0
print(fruits.index("яблоко", 1))  # 2 - ищем яблоко начиная с индекса 1

# Если элемента нет - ошибка
try:
    print(fruits.index("апельсин"))
except ValueError as e:
    print(f"Ошибка: {e}")
    # Ошибка: tuple.index(x): x not in tuple

# Безопасный поиск
fruit_to_find = "манго"
if fruit_to_find in fruits:
    print(fruits.index(fruit_to_find))
else:
    print(f"{fruit_to_find} не найден")  # манго не найден

# count() - подсчет вхождений
print(fruits.count("яблоко"))     # 3 - яблоко встречается 3 раза
print(fruits.count("банан"))      # 1 - банан встречается 1 раз
print(fruits.count("манго"))      # 0 - манго нет в кортеже

# Практический пример: проверка дубликатов
numbers = (1, 2, 3, 2, 4, 2, 5)
for num in set(numbers):  # set убирает дубликаты
    count = numbers.count(num)
    if count > 1:
        print(f"Число {num} повторяется {count} раз(а)")
# Число 2 повторяется 3 раз(а)
```

```python
# join() - это метод СТРОКИ, но часто используется с кортежами
words = ("Python", "это", "круто")

# Объединение через пробел
sentence = " ".join(words)
print(sentence)  # Python это круто

# Разные разделители
print("-".join(words))           # Python-это-круто
print(", ".join(words))          # Python, это, круто
print("".join(words))            # Pythonэтокруто

# Практическое применение: создание CSV строки
person_data = ("Анна", "25", "Москва", "Программист")
csv_line = ",".join(person_data)
print(csv_line)  # Анна,25,Москва,Программист

# Создание пути к файлу
path_parts = ("home", "user", "documents", "file.txt")
file_path = "/".join(path_parts)
print(file_path)  # home/user/documents/file.txt

# ВАЖНО: join() работает только со строками!
mixed_tuple = ("Python", 3, "версия")
try:
    result = " ".join(mixed_tuple)
except TypeError as e:
    print(f"Ошибка: {e}")
    # Ошибка: sequence item 1: expected str instance, int found

# Решение: преобразовать все в строки
result = " ".join(str(item) for item in mixed_tuple)
print(result)  # Python 3 версия
```

### `9.1.5` Распаковка кортежей
`Распаковка (unpacking)` — это удобный способ присвоить элементы кортежа отдельным переменным за одну операцию. Это одна из самых полезных особенностей кортежей в Python!

**Основные правила распаковки:**
1. Количество переменных должно совпадать с количеством элементов (или использовать `*`)
2. Можно использовать `*` для сбора нескольких элементов в список
3. Можно использовать `_` для игнорирования ненужных значений
4. Работает с любыми итерируемыми объектами (списки, строки и т.д.)

**Когда использовать:**
- Возврат нескольких значений из функции
- Обмен значениями переменных
- Работа с парами ключ-значение
- Чтение структурированных данных

**Примеры:**

```python
# Базовая распаковка
point = (10, 20)
x, y = point
print(f"x = {x}, y = {y}")  # x = 10, y = 20

# Распаковка с несколькими элементами
person = ("Иван", 30, "Программист", "Москва")
name, age, job, city = person
print(f"{name}, {age} лет, {job}, живет в {city}")
# Иван, 30 лет, Программист, живет в Москве

# Обмен значениями (очень удобно!)
a = 5
b = 10
a, b = b, a  # обмен без временной переменной!
print(f"a = {a}, b = {b}")  # a = 10, b = 5

# Ошибка если количество переменных не совпадает
try:
    x, y = (1, 2, 3)  # 2 переменные, 3 значения
except ValueError as e:
    print(f"Ошибка: {e}")
    # Ошибка: too many values to unpack (expected 2)

# Возврат нескольких значений из функции
def get_user_info():
    return ("Мария", 28, "maria@example.com")  # возвращаем кортеж

name, age, email = get_user_info()  # распаковываем результат
print(f"{name}, {age}, {email}")
```

```python
# Распаковка с * (звездочка) - сбор остальных элементов
numbers = (1, 2, 3, 4, 5, 6)

# Первый элемент и все остальные
first, *rest = numbers
print(first)  # 1
print(rest)   # [2, 3, 4, 5, 6] - это список!

# Первый, последний и все средние
first, *middle, last = numbers
print(first)   # 1
print(middle)  # [2, 3, 4, 5] - список
print(last)    # 6

# Только первые два и остальные
first, second, *others = numbers
print(first, second)  # 1 2
print(others)         # [3, 4, 5, 6]

# Игнорирование элементов с помощью _
data = ("Москва", 12500000, "Россия", "+7")
city, _, country, _ = data  # игнорируем население и код
print(f"{city}, {country}")  # Москва, Россия

# Игнорирование нескольких элементов
first, *_, last = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
print(first, last)  # 1 10 (все средние элементы проигнорированы)

# Практический пример: разбор строки CSV
csv_line = "Анна,25,Москва,Программист,Python"
# Преобразуем строку в кортеж и распаковываем
name, age, city, *skills = csv_line.split(",")
print(f"{name} ({age}) из {city}")     # Анна (25) из Москва
print(f"Навыки: {', '.join(skills)}")  # Навыки: Программист, Python

# Распаковка в циклах (очень удобно!)
employees = [
    ("Иван", "Разработчик", 100000),
    ("Мария", "Дизайнер", 80000),
    ("Петр", "Менеджер", 90000)
]

for name, position, salary in employees:
    print(f"{name} - {position}: {salary} руб")
# Иван - Разработчик: 100000 руб
# Мария - Дизайнер: 80000 руб
# Петр - Менеджер: 90000 руб

# Распаковка словарей (возвращает кортежи)
prices = {"яблоко": 50, "банан": 30, "груша": 60}
for product, price in prices.items():
    print(f"{product}: {price} руб")
```

**Итоговые советы по работе с кортежами:**

✅ Используйте кортежи когда:
- Данные не должны изменяться
- Нужна высокая производительность
- Нужны ключи для словаря
- Функция возвращает несколько значений

❌ Не используйте кортежи когда:
- Данные часто изменяются
- Нужно добавлять/удалять элементы
- Нужны методы типа `append()`, `sort()`, `remove()`






















## `9.2` Множества
### `9.2.1` Что такое множества? Свойства множеств
`Множество (set)` — это неупорядоченная коллекция **уникальных** элементов в Python. Это математическая структура данных, которая автоматически удаляет дубликаты и не сохраняет порядок элементов.

Множества создаются с помощью фигурных скобок `{}` или функции `set()`. Важно: пустые скобки `{}` создают словарь, для пустого множества используйте `set()`.

**Основные свойства множеств:**

1. **Уникальность элементов** — дубликаты автоматически удаляются
2. **Неупорядоченность** — нет индексов, нельзя обращаться по позиции
3. **Изменяемость** — можно добавлять и удалять элементы
4. **Хешируемые элементы** — множество может содержать только неизменяемые типы (числа, строки, кортежи), нельзя добавить список или другое множество
5. **Быстрый поиск** — проверка наличия элемента работает очень быстро (O(1))
6. **Математические операции** — поддерживает операции объединения, пересечения, разности

**Когда использовать множества:**
- Удаление дубликатов из списка
- Проверка наличия элемента (быстрее, чем в списке)
- Математические операции (объединение, пересечение)
- Работа с уникальными значениями

**Примеры:**

```python
# Создание множеств
numbers = {1, 2, 3, 4, 5}
fruits = {"яблоко", "банан", "груша"}
mixed = {1, "hello", 3.14, (1, 2)}  # разные типы

# Пустое множество (ВАЖНО!)
empty_set = set()        # правильно
empty_dict = {}          # это словарь, НЕ множество!
print(type(empty_set))   # <class 'set'>
print(type(empty_dict))  # <class 'dict'>

# Автоматическое удаление дубликатов
numbers_with_dupes = {1, 2, 2, 3, 3, 3, 4, 5, 5}
print(numbers_with_dupes)  # {1, 2, 3, 4, 5} - дубликаты удалены!

# Создание из списка (удаление дубликатов)
my_list = [1, 2, 2, 3, 3, 3, 4, 5, 5]
unique_numbers = set(my_list)
print(unique_numbers)  # {1, 2, 3, 4, 5}

# Обратно в список
back_to_list = list(unique_numbers)
print(back_to_list)  # [1, 2, 3, 4, 5] (порядок может измениться!)

# Неупорядоченность - нет индексов!
colors = {"красный", "синий", "зеленый"}
# print(colors[0])  # TypeError: 'set' object is not subscriptable
```

```python
# Множество может содержать только хешируемые (неизменяемые) элементы
valid_set = {1, "text", 3.14, (1, 2), True}  # OK

# Попытка добавить изменяемый объект
try:
    invalid_set = {1, 2, [3, 4]}  # список - изменяемый!
except TypeError as e:
    print(f"Ошибка: {e}")
    # Ошибка: unhashable type: 'list'

try:
    invalid_set = {1, 2, {3, 4}}  # множество - изменяемое!
except TypeError as e:
    print(f"Ошибка: {e}")
    # Ошибка: unhashable type: 'set'

# Практическое применение: удаление дубликатов
emails = ["user@mail.com", "admin@mail.com", "user@mail.com", "guest@mail.com", "admin@mail.com"]
unique_emails = list(set(emails))
print(f"Уникальных email: {len(unique_emails)}")  # 3
print(unique_emails)  # ['guest@mail.com', 'admin@mail.com', 'user@mail.com']

# Быстрая проверка уникальности
def has_duplicates(items):
    return len(items) != len(set(items))

print(has_duplicates([1, 2, 3, 4]))     # False - дубликатов нет
print(has_duplicates([1, 2, 2, 3, 4]))  # True - есть дубликаты
```

### `9.2.2` Функции `len()`, `in` для множеств и другие по типу `sum()`
Множества поддерживают большинство встроенных функций Python для работы с коллекциями. Проверка наличия элемента (`in`) в множестве работает **намного быстрее**, чем в списке, особенно для больших коллекций.

**Основные функции:**
- `len()` — количество элементов в множестве
- `in` / `not in` — проверка наличия элемента (очень быстрая!)
- `sum()` — сумма числовых элементов
- `min()` — минимальный элемент
- `max()` — максимальный элемент
- `sorted()` — возвращает отсортированный список (не изменяет множество)
- `any()` — True, если хотя бы один элемент True
- `all()` — True, если все элементы True

**Примеры:**

```python
numbers = {5, 2, 8, 1, 9, 3}

# Базовые функции
print(len(numbers))        # 6 - количество элементов
print(3 in numbers)        # True - тройка есть (очень быстрая проверка!)
print(7 in numbers)        # False - семерки нет
print(10 not in numbers)   # True - десятки нет

# Математические функции
print(sum(numbers))        # 28 - сумма всех элементов
print(min(numbers))        # 1 - минимальное значение
print(max(numbers))        # 9 - максимальное значение
print(sum(numbers) / len(numbers))  # 4.67 - среднее значение

# Работа со строками
words = {"яблоко", "банан", "арбуз", "груша"}
print(min(words))          # 'арбуз' - минимум по алфавиту
print(max(words))          # 'яблоко' - максимум по алфавиту
print(len(words))          # 4

# Преимущество множеств: скорость проверки 'in'
# Для больших коллекций множество работает в тысячи раз быстрее!
large_list = list(range(1000000))
large_set = set(large_list)

# В множестве проверка мгновенная, в списке - медленная
print(999999 in large_set)   # очень быстро!
print(999999 in large_list)  # медленно для больших списков
```

```python
# sorted() возвращает отсортированный список
data = {40, 10, 30, 20, 50}

sorted_list = sorted(data)
print(sorted_list)              # [10, 20, 30, 40, 50] - список!
print(type(sorted_list))        # <class 'list'>

# Оригинальное множество не изменилось
print(data)                     # {40, 10, 50, 20, 30} (порядок произвольный)

# Сортировка в обратном порядке
reverse_sorted = sorted(data, reverse=True)
print(reverse_sorted)           # [50, 40, 30, 20, 10]

# any() и all()
conditions = {True, True, False, True}
print(any(conditions))          # True - есть хотя бы один True
print(all(conditions))          # False - не все True

ages = {18, 25, 30, 45}
print(all(age >= 18 for age in ages))   # True - все совершеннолетние
print(any(age > 40 for age in ages))    # True - есть кто-то старше 40

# Практический пример: проверка прав доступа
admin_ids = {1, 5, 10, 15, 20}
user_id = 10

if user_id in admin_ids:
    print("Доступ разрешен")  # Доступ разрешен
else:
    print("Доступ запрещен")
```


### `9.2.3` Методы множеств (можно посмотреть все, но укажу, который точно надо знать):  
У множеств много полезных методов для изменения и работы с данными. В отличие от кортежей, множества изменяемые, поэтому у них есть методы для добавления и удаления элементов.

#### Методы добавления элементов:

**`add(element)`**
Добавляет один элемент во множество. Если элемент уже есть — ничего не происходит (ошибки не будет).

**Примеры:**

```python
# add() - добавление одного элемента
fruits = {"яблоко", "банан"}
print(fruits)  # {'яблоко', 'банан'}

fruits.add("груша")
print(fruits)  # {'яблоко', 'банан', 'груша'}

# Добавление существующего элемента - ничего не произойдет
fruits.add("яблоко")
print(fruits)  # {'яблоко', 'банан', 'груша'} - без изменений

# add() добавляет только один элемент
fruits.add("киви")
print(fruits)  # {'яблоко', 'банан', 'груша', 'киви'}

# Практический пример: сбор уникальных значений
visited_pages = set()
user_actions = ["home", "about", "home", "products", "about", "contact"]

for page in user_actions:
    visited_pages.add(page)

print(f"Уникальных страниц посещено: {len(visited_pages)}")  # 4
print(visited_pages)  # {'home', 'about', 'products', 'contact'}
```

#### Методы удаления элементов:

**`remove(element)`**
Удаляет элемент из множества. Если элемента нет — вызывает ошибку `KeyError`.

**`discard(element)`**
Удаляет элемент из множества. Если элемента нет — ничего не происходит (ошибки не будет).

**`pop()`**
Удаляет и возвращает случайный элемент. Если множество пустое — вызывает ошибку `KeyError`.

**`clear()`**
Удаляет все элементы из множества (делает его пустым).

**Примеры:**

```python
# remove() - удаление элемента (с ошибкой если нет)
colors = {"красный", "синий", "зеленый", "желтый"}

colors.remove("синий")
print(colors)  # {'красный', 'зеленый', 'желтый'}

# Попытка удалить несуществующий элемент
try:
    colors.remove("фиолетовый")
except KeyError as e:
    print(f"Ошибка: элемент {e} не найден")
    # Ошибка: элемент 'фиолетовый' не найден

# discard() - безопасное удаление (без ошибки)
colors.discard("зеленый")
print(colors)  # {'красный', 'желтый'}

# Если элемента нет - ничего не происходит, ошибки нет
colors.discard("фиолетовый")  # OK, ошибки не будет
print(colors)  # {'красный', 'желтый'}

# Когда использовать remove() vs discard()?
# remove() - когда уверены, что элемент есть
# discard() - когда не уверены, нужна безопасность
```

```python
# pop() - удаление случайного элемента
numbers = {1, 2, 3, 4, 5}
removed = numbers.pop()
print(f"Удален элемент: {removed}")  # может быть любое число
print(numbers)  # осталось 4 элемента

# pop() полезен когда нужно постепенно опустошить множество
tasks = {"задача1", "задача2", "задача3"}
while tasks:
    current_task = tasks.pop()
    print(f"Выполняется: {current_task}")
print("Все задачи выполнены!")

# Ошибка при pop() из пустого множества
empty_set = set()
try:
    empty_set.pop()
except KeyError:
    print("Ошибка: множество пустое!")

# clear() - полная очистка множества
fruits = {"яблоко", "банан", "груша", "киви"}
print(f"До очистки: {len(fruits)} элементов")  # 4
fruits.clear()
print(f"После очистки: {len(fruits)} элементов")  # 0
print(fruits)  # set() - пустое множество
```

#### Математические операции между множествами:

**Теория:**
Множества поддерживают классические математические операции из теории множеств. Каждая операция имеет как метод, так и оператор.

**Основные операции:**

| Операция | Метод | Оператор | Описание |
|----------|-------|----------|----------|
| Объединение | `union()` | `\|` | Все элементы из обоих множеств |
| Пересечение | `intersection()` | `&` | Только общие элементы |
| Разность | `difference()` | `-` | Элементы из первого, которых нет во втором |
| Симметричная разность | `symmetric_difference()` | `^` | Элементы, которые есть только в одном множестве |
| Обновление | `update()` | `\|=` | Добавить элементы из другого множества |
| Пересечение с обновлением | `intersection_update()` | `&=` | Оставить только общие элементы |
| Разность с обновлением | `difference_update()` | `-=` | Удалить элементы другого множества |
| Симм. разность с обновлением | `symmetric_difference_update()` | `^=` | Оставить уникальные для каждого |

**Примеры:**

```python
# Объединение (union) - все уникальные элементы из обоих множеств
set1 = {1, 2, 3, 4}
set2 = {3, 4, 5, 6}

# Метод union()
union_result = set1.union(set2)
print(union_result)  # {1, 2, 3, 4, 5, 6}

# Оператор |
union_result = set1 | set2
print(union_result)  # {1, 2, 3, 4, 5, 6}

# Можно объединить несколько множеств
set3 = {7, 8, 9}
all_together = set1 | set2 | set3
print(all_together)  # {1, 2, 3, 4, 5, 6, 7, 8, 9}

# Пересечение (intersection) - только общие элементы
intersection_result = set1.intersection(set2)
print(intersection_result)  # {3, 4}

intersection_result = set1 & set2
print(intersection_result)  # {3, 4}

# Разность (difference) - элементы из первого множества, которых нет во втором
difference_result = set1.difference(set2)
print(difference_result)  # {1, 2} - есть в set1, но нет в set2

difference_result = set1 - set2
print(difference_result)  # {1, 2}

# Обратная разность
difference_result = set2 - set1
print(difference_result)  # {5, 6} - есть в set2, но нет в set1

# Симметричная разность (symmetric_difference) - элементы, которые есть только в одном из множеств
sym_diff = set1.symmetric_difference(set2)
print(sym_diff)  # {1, 2, 5, 6} - все кроме общих

sym_diff = set1 ^ set2
print(sym_diff)  # {1, 2, 5, 6}
```

```python
# Методы с обновлением (изменяют исходное множество)
set1 = {1, 2, 3}
set2 = {3, 4, 5}

# update() - добавляет элементы из другого множества
set1.update(set2)
print(set1)  # {1, 2, 3, 4, 5} - set1 изменился!

# То же с оператором |=
set1 = {1, 2, 3}
set1 |= set2
print(set1)  # {1, 2, 3, 4, 5}

# intersection_update() - оставляет только общие элементы
set1 = {1, 2, 3, 4}
set2 = {3, 4, 5, 6}
set1.intersection_update(set2)
print(set1)  # {3, 4} - в set1 остались только общие

# difference_update() - удаляет элементы другого множества
set1 = {1, 2, 3, 4}
set2 = {3, 4, 5, 6}
set1.difference_update(set2)
print(set1)  # {1, 2} - из set1 удалили элементы, которые есть в set2

# Практический пример: анализ пользователей
yesterday_users = {"user1", "user2", "user3", "user4", "user5"}
today_users = {"user3", "user4", "user5", "user6", "user7"}

# Все уникальные пользователи за 2 дня
all_users = yesterday_users | today_users
print(f"Всего пользователей: {len(all_users)}")  # 7

# Постоянные пользователи (были оба дня)
regular_users = yesterday_users & today_users
print(f"Постоянных: {len(regular_users)}")  # 3
print(regular_users)  # {'user3', 'user4', 'user5'}

# Ушедшие пользователи (были вчера, но нет сегодня)
left_users = yesterday_users - today_users
print(f"Ушло: {len(left_users)}")  # 2
print(left_users)  # {'user1', 'user2'}

# Новые пользователи (не было вчера, есть сегодня)
new_users = today_users - yesterday_users
print(f"Новых: {len(new_users)}")  # 2
print(new_users)  # {'user6', 'user7'}
```

#### Методы проверки отношений между множествами:

**`issubset(other)` или `<=`**
Проверяет, является ли множество подмножеством другого (все элементы первого есть во втором).

**`issuperset(other)` или `>=`**
Проверяет, является ли множество надмножеством другого (содержит все элементы другого множества).

**`isdisjoint(other)`**
Проверяет, не имеют ли множества общих элементов (пересечение пустое).

**Примеры:**

```python
# issubset() - проверка подмножества
set_a = {1, 2, 3}
set_b = {1, 2, 3, 4, 5}
set_c = {1, 2, 6}

# Метод issubset()
print(set_a.issubset(set_b))  # True - все элементы set_a есть в set_b
print(set_c.issubset(set_b))  # False - элемент 6 не входит в set_b

# Оператор <=
print(set_a <= set_b)  # True
print(set_c <= set_b)  # False

# Строгое подмножество (не равны) - оператор 
print(set_a < set_b)   # True - подмножество и не равны
print(set_a < set_a)   # False - множество не является строгим подмножеством самого себя

# issuperset() - проверка надмножества (обратная операция)
print(set_b.issuperset(set_a))  # True - set_b содержит все элементы set_a
print(set_b.issuperset(set_c))  # False

# Оператор >=
print(set_b >= set_a)  # True
print(set_b >= set_c)  # False

# Строгое надмножество - оператор >
print(set_b > set_a)   # True - надмножество и не равны
print(set_b > set_b)   # False
```

```python
# isdisjoint() - проверка на отсутствие общих элементов
set1 = {1, 2, 3}
set2 = {4, 5, 6}
set3 = {3, 4, 5}

print(set1.isdisjoint(set2))  # True - нет общих элементов
print(set1.isdisjoint(set3))  # False - есть общий элемент 3

# Практический пример: управление доступом
admins = {"alice", "bob"}
moderators = {"charlie", "diana"}
users = {"alice", "eve", "frank"}

# Проверка прав доступа
user_name = "alice"
if user_name in admins:
    print(f"{user_name} - администратор")
elif user_name in moderators:
    print(f"{user_name} - модератор")
else:
    print(f"{user_name} - обычный пользователь")

# Проверка пересечения ролей (не должны пересекаться)
if admins.isdisjoint(moderators):
    print("✓ Роли не пересекаются")
else:
    print("✗ Ошибка: один человек имеет несколько ролей!")

# Проверка: все модераторы тоже пользователи?
if moderators.issubset(users):
    print("Все модераторы зарегистрированы как пользователи")
else:
    print("Некоторые модераторы не в списке пользователей")

# Практический пример: анализ навыков
required_skills = {"Python", "SQL", "Git"}
candidate1_skills = {"Python", "SQL", "Git", "Docker"}
candidate2_skills = {"Python", "JavaScript", "HTML"}

print("Кандидат 1:")
if required_skills.issubset(candidate1_skills):
    print("✓ Подходит - есть все необходимые навыки")
else:
    missing = required_skills - candidate1_skills
    print(f"✗ Не подходит. Нужно изучить: {missing}")

print("\nКандидат 2:")
if required_skills.issubset(candidate2_skills):
    print("✓ Подходит - есть все необходимые навыки")
else:
    missing = required_skills - candidate2_skills
    print(f"✗ Не подходит. Нужно изучить: {missing}")
    # ✗ Не подходит. Нужно изучить: {'Git', 'SQL'}
```

**Итоговая шпаргалка по методам множеств:**

**Добавление:**
- `add(elem)` — добавить один элемент

**Удаление:**
- `remove(elem)` — удалить элемент (ошибка если нет)
- `discard(elem)` — удалить элемент (без ошибки)
- `pop()` — удалить случайный элемент
- `clear()` — удалить все элементы

**Операции с множествами:**
- `union()` или `|` — объединение
- `intersection()` или `&` — пересечение
- `difference()` или `-` — разность
- `symmetric_difference()` или `^` — симметричная разность

**Операции с изменением:**
- `update()` или `|=` — добавить элементы
- `intersection_update()` или `&=` — оставить общие
- `difference_update()` или `-=` — удалить элементы
- `symmetric_difference_update()` или `^=` — оставить уникальные

**Проверки:**
- `issubset()` или `<=` — подмножество?
- `issuperset()` или `>=` — надмножество?
- `isdisjoint()` — нет общих элементов?


































### `9.2.3` (`*`) Генераторы множеств (`set comprehensions`)

`Set comprehension` — это компактный способ создания множества на основе итерируемого объекта с фильтрацией и преобразованием элементов. Синтаксис похож на list comprehension, но используются **фигурные скобки** `{}`.

#### **Синтаксис**

```python
{expression for item in iterable if condition}
```

#### **Базовые примеры**

```python
# Создание множества из квадратов чисел
numbers = [1, 2, 3, 4, 5]
squares = {x**2 for x in numbers}
print(squares)  # {1, 4, 9, 16, 25}

# Автоматическое удаление дубликатов
numbers = [1, 2, 2, 3, 3, 3, 4]
unique = {x for x in numbers}
print(unique)  # {1, 2, 3, 4}

# Преобразование в верхний регистр
words = ["hello", "world", "python", "hello"]
uppercase = {word.upper() for word in words}
print(uppercase)  # {'HELLO', 'WORLD', 'PYTHON'}
```

#### **Фильтрация с условием**

```python
# Только чётные числа
numbers = [13, 21, 14, 24, 53, 62]
even_numbers = {num for num in numbers if num % 2 == 0}
print(even_numbers)  # {24, 62, 14} (порядок может отличаться)

# Только длинные слова
words = ["cat", "elephant", "dog", "giraffe", "ant"]
long_words = {word for word in words if len(word) > 3}
print(long_words)  # {'elephant', 'giraffe'}

# Положительные числа из смешанного списка
numbers = [-5, 3, -2, 8, 0, -1, 7]
positive = {n for n in numbers if n > 0}
print(positive)  # {8, 3, 7}
```

#### **Преобразование элементов**

```python
# Длины уникальных слов
words = ["hello", "world", "hi", "python"]
lengths = {len(word) for word in words}
print(lengths)  # {2, 5, 6}

# Первые буквы слов
sentence = "the quick brown fox jumps over the lazy dog"
first_letters = {word[0] for word in sentence.split()}
print(first_letters)  # {'b', 'd', 'f', 'j', 'l', 'o', 'q', 't'}

# Абсолютные значения
numbers = [-5, 3, -3, 5, -7, 7]
absolutes = {abs(n) for n in numbers}
print(absolutes)  # {3, 5, 7}
```

#### **Извлечение уникальных значений из сложных структур**

```python
# Уникальные возрасты из списка словарей
users = [
    {"name": "Alice", "age": 25},
    {"name": "Bob", "age": 30},
    {"name": "Charlie", "age": 25},
    {"name": "David", "age": 35}
]
ages = {user["age"] for user in users}
print(ages)  # {25, 30, 35}

# Уникальные расширения файлов
files = ["doc.txt", "image.png", "script.py", "data.txt", "photo.png"]
extensions = {file.split('.')[-1] for file in files}
print(extensions)  # {'txt', 'png', 'py'}

# Уникальные символы в строке
text = "hello world"
chars = {char for char in text if char != ' '}
print(chars)  # {'h', 'e', 'l', 'o', 'w', 'r', 'd'}
```

#### **Вложенные циклы в set comprehension**

```python
# Уникальные произведения пар чисел
numbers1 = [2, 3]
numbers2 = [4, 5]
products = {x * y for x in numbers1 for y in numbers2}
print(products)  # {8, 10, 12, 15}

# Уникальные координаты сетки (без дубликатов)
grid = {(x, y) for x in range(3) for y in range(3) if x != y}
print(grid)  # {(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1)}
```

#### **Практические примеры**

```python
# Поиск уникальных слов в тексте (без учёта регистра)
text = "Hello world hello Python python World"
unique_words = {word.lower() for word in text.split()}
print(unique_words)  # {'hello', 'world', 'python'}

# Извлечение доменов из списка email'ов
emails = ["user1@gmail.com", "user2@yahoo.com", "user3@gmail.com"]
domains = {email.split('@')[1] for email in emails}
print(domains)  # {'gmail.com', 'yahoo.com'}

# Уникальные цифры в числе
number = 1122334455
digits = {int(d) for d in str(number)}
print(digits)  # {1, 2, 3, 4, 5}

# Фильтрация валидных email (простая проверка)
emails = ["user@example.com", "invalid", "test@test.org", "bad@"]
valid = {email for email in emails if '@' in email and '.' in email.split('@')[-1]}
print(valid)  # {'user@example.com', 'test@test.org'}
```

#### **Сравнение с list comprehension**

```python
numbers = [1, 2, 2, 3, 3, 3]

# List comprehension — сохраняет дубликаты
list_result = [x for x in numbers]
print(list_result)  # [1, 2, 2, 3, 3, 3]

# Set comprehension — удаляет дубликаты
set_result = {x for x in numbers}
print(set_result)  # {1, 2, 3}

# Преобразование set обратно в list
unique_list = list(set_result)
print(unique_list)  # [1, 2, 3] (или другой порядок)
```

**Когда использовать:**
- Нужны только уникальные элементы
- Порядок элементов не важен
- Требуется быстрая проверка принадлежности элемента
- Извлечение уникальных значений из данных

**Особенности:**
- Автоматически удаляет дубликаты
- Элементы неупорядочены (порядок не гарантируется)
- Элементы должны быть хешируемыми (нельзя добавить списки или словари)
- Быстрее list comprehension для проверки наличия элемента

### `9.2.4` (`**`) `frozenset`
`frozenset` — это неизменяемый (immutable) аналог множества (`set`). Как и множество, он хранит уникальные элементы, но после создания его нельзя изменить (добавлять или удалять элементы).

Основные особенности:
- Можно использовать как ключи в словарях или элементы других множеств (т.к. хешируем).
- Создаётся из итерируемого объекта: `frozenset(iterable)`.

```python
s = frozenset([1, 2, 2, 3])
print(s)  # frozenset({1, 2, 3})

# Попытка изменить вызовет ошибку:
# s.add(4)  # AttributeError: 'frozenset' object has no attribute 'add'
```

#### **frozenset как элемент множества**

```python
# Множество множеств (только с frozenset)
set_of_sets = {
    frozenset([1, 2]),
    frozenset([3, 4]),
    frozenset([1, 2])  # Дубликат, будет удалён
}
print(set_of_sets)  # {frozenset({1, 2}), frozenset({3, 4})}

# Нельзя добавить обычный set
# set_of_sets.add({5, 6})  # TypeError: unhashable type: 'set'
```

#### **Практические примеры**

```python
# Хранение неизменяемых групп пользователей
user_groups = {
    'alice': frozenset(['admin', 'editor']),
    'bob': frozenset(['viewer']),
    'charlie': frozenset(['admin', 'viewer', 'editor'])
}

# Проверка прав доступа
if 'admin' in user_groups['alice']:
    print("Alice имеет права администратора")  # Выведет

# Поиск пользователей с определёнными правами
admin_users = [user for user, groups in user_groups.items() if 'admin' in groups]
print(admin_users)  # ['alice', 'charlie']

# Граф связей (неизменяемые рёбра)
graph = {
    frozenset(['A', 'B']): 5,  # Ребро A-B с весом 5
    frozenset(['B', 'C']): 3,
    frozenset(['A', 'C']): 7
}

# Поиск веса ребра
edge = frozenset(['A', 'B'])
print(graph[edge])  # 5

# Кеширование результатов для наборов параметров
cache = {}

def calculate(params):
    frozen_params = frozenset(params.items())
    if frozen_params not in cache:
        # Сложные вычисления
        result = sum(params.values()) * 2
        cache[frozen_params] = result
    return cache[frozen_params]

print(calculate({'a': 1, 'b': 2}))  # 6
print(calculate({'a': 1, 'b': 2}))  # 6 (из кеша)
```

#### **Преобразование между set и frozenset**

```python
# set → frozenset
s = {1, 2, 3}
fs = frozenset(s)
print(fs)  # frozenset({1, 2, 3})

# frozenset → set
fs = frozenset([4, 5, 6])
s = set(fs)
s.add(7)
print(s)  # {4, 5, 6, 7}

# frozenset остался неизменным
print(fs)  # frozenset({4, 5, 6})
```

**Когда использовать frozenset:**
- Нужно неизменяемое множество (для гарантии целостности данных)
- Множество должно быть ключом словаря
- Множество должно быть элементом другого множества
- Требуется хешируемая коллекция уникальных элементов
- Передача данных, которые нельзя случайно изменить

**Ключевые особенности:**
- Неизменяемый (immutable) — нельзя добавлять/удалять элементы
- Хешируемый (hashable) — можно использовать как ключ или в множестве
- Поддерживает все операции чтения множеств
- Создаётся один раз и не меняется
- Немного быстрее обычного `set` в некоторых операциях из-за неизменяемости

[Видео про frozenset](https://www.youtube.com/watch?v=YatGF3voZH8)


## `9.3` Словари
### `9.3.1` (`*`) Что такое словари? Свойства словарей 
[Видео про dict](https://youtu.be/MZZSMaEAC2g?si=YvGzIOcgZDZGICoG)

Словарь (`dict`) — это изменяемая коллекция, которая хранит данные в виде пар **ключ-значение**. Каждому уникальному ключу соответствует одно значение.

```python
# Создание словаря
person = {
    'name': 'Alice',
    'age': 30,
    'city': 'Moscow'
}

# Доступ к значению по ключу
print(person['name'])  # 'Alice'

# Добавление/изменение элемента
person['email'] = 'alice@example.com'  # Добавление
person['age'] = 31                      # Изменение

print(person)
# {'name': 'Alice', 'age': 31, 'city': 'Moscow', 'email': 'alice@example.com'}
```

**Основные свойства словарей:**

1. **Неупорядоченность** (до Python 3.7) / **Сохранение порядка вставки** (с Python 3.7+)
2. **Ключи уникальны** — дублирующиеся ключи перезаписываются
3. **Ключи должны быть неизменяемыми** (hashable) — строки, числа, кортежи
4. **Значения могут быть любыми** — включая другие словари, списки, объекты
5. **Быстрый доступ по ключу — O(1)** — не нужно перебирать элементы!

```python
# Ключи уникальны — дубликат перезаписывается
data = {'a': 1, 'b': 2, 'a': 3}
print(data)  # {'a': 3, 'b': 2}

# Значения могут повторяться
scores = {'Alice': 100, 'Bob': 85, 'Charlie': 100}
print(scores)  # {'Alice': 100, 'Bob': 85, 'Charlie': 100}

# Значения могут быть любого типа
mixed = {
    'name': 'Alice',
    'scores': [85, 90, 95],
    'active': True,
    'address': {'city': 'Moscow', 'street': 'Main St'}
}
```

**Главное преимущество — мгновенный поиск по ключу:**

```python
# Список — нужно перебирать все элементы (медленно для больших данных)
users_list = [
    ('alice', 'Alice'),
    ('bob', 'Bob'),
    ('charlie', 'Charlie')
    # ... 10000 элементов
]
# Чтобы найти пользователя, нужно перебрать весь список
for username, name in users_list:
    if username == 'charlie':
        print(name)  # Долго!

# Словарь — мгновенный доступ по ключу (быстро!)
users_dict = {
    'alice': 'Alice',
    'bob': 'Bob',
    'charlie': 'Charlie'
    # ... 10000 элементов
}
# Прямой доступ без перебора
print(users_dict['charlie'])  # Мгновенно!
```

### `9.3.2` Что может быть ключом словаря, а что нет?
Ключом словаря может быть только **хешируемый (неизменяемый)** объект. Python должен иметь возможность вычислить хеш ключа и этот хеш не должен меняться со временем.

**Могут быть ключами (неизменяемые типы):**
- ✅ Числа: `int`, `float`, `complex`
- ✅ Строки: `str`
- ✅ Кортежи: `tuple` (если содержат только неизменяемые элементы)
- ✅ Булевы значения: `True`, `False`
- ✅ `None`
- ✅ Frozenset (замороженное множество)

**НЕ могут быть ключами (изменяемые типы):**
- ❌ Списки: `list`
- ❌ Множества: `set`
- ❌ Словари: `dict`
- ❌ Любые другие изменяемые объекты

**Почему важна неизменяемость:**
Словарь использует хеш-таблицу для быстрого поиска. Если ключ изменится после добавления в словарь, его хеш тоже изменится, и словарь "потеряет" этот элемент.

**Примеры:**

```python
# Правильные ключи (неизменяемые типы)
valid_dict = {
    42: "число",
    3.14: "число с плавающей точкой",
    "name": "строка",
    (1, 2): "кортеж",
    True: "булево значение",
    None: "значение None"
}
print(valid_dict)

# Строки - самый популярный тип ключей
person = {
    "name": "Иван",
    "age": 30,
    "city": "Москва"
}

# Числа как ключи (например, ID)
users = {
    1001: "Анна",
    1002: "Петр",
    1003: "Мария"
}

# Кортежи как ключи (координаты, составные ключи)
locations = {
    (55.7558, 37.6173): "Москва",
    (59.9343, 30.3351): "Санкт-Петербург"
}
print(locations[(55.7558, 37.6173)])  # Москва

# Составные ключи (несколько значений)
schedule = {
    ("понедельник", 9): "Математика",
    ("понедельник", 10): "Физика",
    ("вторник", 9): "Химия"
}
print(schedule[("понедельник", 9)])  # Математика
```

```python
# Неправильные ключи (изменяемые типы)

# Список как ключ - ОШИБКА
try:
    bad_dict = {[1, 2]: "список"}
except TypeError as e:
    print(f"Ошибка: {e}")
    # Ошибка: unhashable type: 'list'

# Множество как ключ - ОШИБКА
try:
    bad_dict = {{1, 2}: "множество"}
except TypeError as e:
    print(f"Ошибка: {e}")
    # Ошибка: unhashable type: 'set'

# Словарь как ключ - ОШИБКА
try:
    bad_dict = {{"key": "value"}: "словарь"}
except TypeError as e:
    print(f"Ошибка: {e}")
    # Ошибка: unhashable type: 'dict'

# Кортеж с изменяемыми элементами - ОШИБКА
try:
    bad_dict = {(1, [2, 3]): "кортеж со списком"}
except TypeError as e:
    print(f"Ошибка: {e}")
    # Ошибка: unhashable type: 'list'

# Решение: преобразовать список в кортеж
my_list = [1, 2, 3]
my_tuple = tuple(my_list)  # преобразуем в кортеж
good_dict = {my_tuple: "теперь работает"}
print(good_dict)  # {(1, 2, 3): 'теперь работает'}

# Практический пример: использование разных типов ключей
# База данных с разными идентификаторами
database = {
    # ID пользователя (число)
    12345: {"name": "Иван", "role": "admin"},
    
    # Email (строка)
    "user@example.com": {"name": "Мария", "role": "user"},
    
    # Координаты (кортеж)
    (55.75, 37.61): {"city": "Москва", "population": 12500000},
    
    # Дата (кортеж)
    (2024, 1, 15): {"event": "Презентация", "participants": 50}
}

print(database[12345])  # {'name': 'Иван', 'role': 'admin'}
print(database["user@example.com"])  # {'name': 'Мария', 'role': 'user'}
```

### `9.3.3` Функции `len()`, `in` для словарей и другие по типу `sum()`
Словари поддерживают встроенные функции Python. Важно понимать, что оператор `in` проверяет наличие **ключа**, а не значения. Некоторые функции работают только с ключами или значениями.

**Основные функции:**
- `len()` — количество пар ключ-значение
- `in` / `not in` — проверка наличия **ключа** (не значения!)
- `max()` / `min()` — максимальный/минимальный **ключ**
- `sum()` — сумма **ключей** (если ключи числовые)
- `sorted()` — отсортированный список **ключей**
- `any()` / `all()` — проверка **ключей**

**Примеры:**

```python
# Базовые функции
prices = {
    "яблоко": 50,
    "банан": 30,
    "груша": 60,
    "киви": 80
}

# len() - количество элементов (пар ключ-значение)
print(len(prices))  # 4

# in - проверка наличия КЛЮЧА (не значения!)
print("яблоко" in prices)      # True - ключ есть
print("манго" in prices)        # False - ключа нет
print(50 in prices)             # False - 50 это значение, не ключ!
print("яблоко" not in prices)  # False

# Проверка значения (нужен метод values())
print(50 in prices.values())    # True - значение 50 есть

# max() и min() - работают с КЛЮЧАМИ
print(max(prices))  # яблоко - максимальный ключ по алфавиту
print(min(prices))  # банан - минимальный ключ по алфавиту

# sorted() - отсортированный список КЛЮЧЕЙ
sorted_keys = sorted(prices)
print(sorted_keys)  # ['банан', 'груша', 'киви', 'яблоко']

# Сортировка по значениям (нужен параметр key)
sorted_by_price = sorted(prices.items(), key=lambda x: x[1])
print(sorted_by_price)
# [('банан', 30), ('яблоко', 50), ('груша', 60), ('киви', 80)]
```

```python
# Функции с числовыми ключами
scores = {1: 100, 2: 85, 3: 92, 4: 78}

# sum() - сумма КЛЮЧЕЙ
print(sum(scores))  # 10 (1+2+3+4)

# Сумма ЗНАЧЕНИЙ
print(sum(scores.values()))  # 355 (100+85+92+78)

# max() и min() с числовыми ключами
print(max(scores))  # 4 - максимальный ключ
print(min(scores))  # 1 - минимальный ключ

# Максимальное и минимальное значение
print(max(scores.values()))  # 100
print(min(scores.values()))  # 78

# Ключ с максимальным значением
max_key = max(scores, key=scores.get)
print(f"Максимальный балл у участника {max_key}: {scores[max_key]}")
# Максимальный балл у участника 1: 100

# any() и all() - работают с ключами
empty_dict = {}
dict_with_zero = {0: "value", 1: "another"}
dict_with_all = {1: "a", 2: "b", 3: "c"}

print(any(empty_dict))         # False - пустой словарь
print(any(dict_with_zero))     # True - есть хотя бы один True ключ (1)
print(all(dict_with_zero))     # False - не все ключи True (0 это False)
print(all(dict_with_all))      # True - все ключи True (числа > 0)

# Практический пример: анализ продаж
sales = {
    "январь": 10000,
    "февраль": 12000,
    "март": 15000,
    "апрель": 11000
}

print(f"Всего месяцев: {len(sales)}")
print(f"Общая выручка: {sum(sales.values())} руб")
print(f"Средняя выручка: {sum(sales.values()) / len(sales)} руб")
print(f"Лучший месяц: {max(sales, key=sales.get)} ({max(sales.values())} руб)")
print(f"Худший месяц: {min(sales, key=sales.get)} ({min(sales.values())} руб)")
```

### `9.3.4` Методы словарей (можно посмотреть все, но укажу, который точно надо знать):  
У словарей много полезных методов для получения, изменения и удаления данных. Важно понимать разницу между методами, которые возвращают представления (views) и те, которые возвращают копии данных.

#### Получение элемента из словаря

**Способ 1: Квадратные скобки `[]`**
Прямой доступ к элементу по ключу. Если ключа нет — вызывает ошибку `KeyError`.

**Способ 2: Метод `get(key, default=None)`**
Безопасный доступ к элементу. Если ключа нет — возвращает значение по умолчанию (None или указанное).

**Примеры:**

```python
person = {
    "name": "Иван",
    "age": 30,
    "city": "Москва"
}

# Способ 1: квадратные скобки []
print(person["name"])  # Иван
print(person["age"])   # 30

# Если ключа нет - ошибка
try:
    print(person["phone"])
except KeyError as e:
    print(f"Ошибка: ключ {e} не найден")
    # Ошибка: ключ 'phone' не найден

# Способ 2: метод get() - БЕЗОПАСНЫЙ
print(person.get("name"))      # Иван
print(person.get("phone"))     # None - ключа нет, вернул None
print(person.get("phone", "не указан"))  # не указан - свое значение по умолчанию

# Когда использовать что?
# [] - когда уверены, что ключ есть
# get() - когда не уверены, нужна безопасность

# Практический пример
config = {
    "host": "localhost",
    "port": 8080,
    "debug": True
}

# Обязательные параметры - через []
host = config["host"]
port = config["port"]

# Опциональные параметры - через get()
timeout = config.get("timeout", 30)  # если нет, используем 30
max_connections = config.get("max_connections", 100)

print(f"Сервер: {host}:{port}, timeout={timeout}")
# Сервер: localhost:8080, timeout=30
```

#### Удаление элемента из словаря

**Способ 1: Оператор `del`**
Удаляет элемент по ключу. Если ключа нет — ошибка `KeyError`.

**Способ 2: Метод `pop(key, default)`**
Удаляет и возвращает значение. Можно указать значение по умолчанию, если ключа нет.

**Способ 3: Метод `popitem()`**
Удаляет и возвращает последнюю пару (ключ, значение). С Python 3.7+ порядок гарантирован.

**Примеры:**

```python
# del - удаление элемента
data = {"a": 1, "b": 2, "c": 3, "d": 4}

del data["b"]
print(data)  # {'a': 1, 'c': 3, 'd': 4}

# Если ключа нет - ошибка
try:
    del data["z"]
except KeyError as e:
    print(f"Ошибка: ключ {e} не найден")

# pop() - удаляет и возвращает значение
data = {"a": 1, "b": 2, "c": 3}
removed_value = data.pop("b")
print(f"Удалено значение: {removed_value}")  # 2
print(data)  # {'a': 1, 'c': 3}

# pop() с значением по умолчанию
result = data.pop("z", "не найден")
print(result)  # не найден - ошибки нет!

# popitem() - удаляет и возвращает последнюю пару
data = {"first": 1, "second": 2, "third": 3}
last_item = data.popitem()
print(last_item)  # ('third', 3) - кортеж (ключ, значение)
print(data)       # {'first': 1, 'second': 2}

# Практический пример: очистка устаревших данных
cache = {
    "user_1": {"name": "Иван", "time": 100},
    "user_2": {"name": "Мария", "time": 200},
    "user_3": {"name": "Петр", "time": 50}
}

# Удаляем устаревшую запись
if "user_3" in cache:
    old_data = cache.pop("user_3")
    print(f"Удалена запись: {old_data}")
```

#### `keys()`, `values()`, `items()`

**Теория:**
Эти методы возвращают специальные объекты-представления (view objects), которые динамически отображают содержимое словаря. Они не создают копии данных!

- `keys()` — представление всех ключей
- `values()` — представление всех значений
- `items()` — представление всех пар (ключ, значение) как кортежей

**Примеры:**

```python
person = {
    "name": "Иван",
    "age": 30,
    "city": "Москва",
    "job": "Программист"
}

# keys() - все ключи
keys = person.keys()
print(keys)        # dict_keys(['name', 'age', 'city', 'job'])
print(type(keys))  # <class 'dict_keys'> - это НЕ список!

# Преобразование в список
keys_list = list(keys)
print(keys_list)   # ['name', 'age', 'city', 'job']

# values() - все значения
values = person.values()
print(values)      # dict_values(['Иван', 30, 'Москва', 'Программист'])

values_list = list(values)
print(values_list)  # ['Иван', 30, 'Москва', 'Программист']

# items() - пары (ключ, значение)
items = person.items()
print(items)  # dict_items([('name', 'Иван'), ('age', 30), ...])

items_list = list(items)
print(items_list)  # [('name', 'Иван'), ('age', 30), ...]

# Каждая пара - это кортеж
for key, value in items:
    print(f"{key}: {value}")
# name: Иван
# age: 30
# city: Москва
# job: Программист
```

```python
# View objects - динамическое представление
scores = {"Alice": 85, "Bob": 92}
keys_view = scores.keys()

print(keys_view)  # dict_keys(['Alice', 'Bob'])

# Изменяем словарь
scores["Charlie"] = 78

# View автоматически обновляется!
print(keys_view)  # dict_keys(['Alice', 'Bob', 'Charlie'])

# Практические примеры
prices = {
    "яблоко": 50,
    "банан": 30,
    "груша": 60,
    "киви": 80
}

# Все товары
print("Товары:", ", ".join(prices.keys()))
# Товары: яблоко, банан, груша, киви

# Общая стоимость
total = sum(prices.values())
print(f"Общая стоимость: {total} руб")  # 220 руб

# Средняя цена
average = sum(prices.values()) / len(prices)
print(f"Средняя цена: {average} руб")  # 55.0 руб

# Самый дорогой товар
max_price = max(prices.values())
expensive_item = [item for item, price in prices.items() if price == max_price]
print(f"Самый дорогой: {expensive_item[0]} - {max_price} руб")
# Самый дорогой: киви - 80 руб
```

#### `update()`

**Теория:**
Метод `update()` обновляет словарь, добавляя пары ключ-значение из другого словаря. Если ключ уже существует — значение обновляется. Можно передать другой словарь или последовательность пар.

**Примеры:**

```python
# Базовое использование update()
user = {
    "name": "Иван",
    "age": 30
}

# Добавляем новые данные
user.update({"city": "Москва", "job": "Программист"})
print(user)
# {'name': 'Иван', 'age': 30, 'city': 'Москва', 'job': 'Программист'}

# Обновляем существующие значения
user.update({"age": 31, "city": "Санкт-Петербург"})
print(user)
# {'name': 'Иван', 'age': 31, 'city': 'Санкт-Петербург', 'job': 'Программист'}

# update() с несколькими парами ключ=значение
user.update(email="ivan@mail.com", phone="+7123456789")
print(user)
# Добавились email и phone

# update() с последовательностью кортежей
new_data = [("hobby", "футбол"), ("pet", "кот")]
user.update(new_data)
print(user)

# Практический пример: настройки приложения
default_config = {
    "theme": "light",
    "language": "ru",
    "notifications": True,
    "sound": True
}

user_config = {
    "theme": "dark",
    "sound": False
}

# Объединяем: пользовательские настройки перезаписывают дефолтные
config = default_config.copy()
config.update(user_config)
print(config)
# {'theme': 'dark', 'language': 'ru', 'notifications': True, 'sound': False}
```

#### `setdefault()`

**Теория:**
Метод `setdefault(key, default=None)` возвращает значение ключа. Если ключа нет — добавляет его со значением по умолчанию и возвращает это значение. Отличается от `get()` тем, что **изменяет словарь**.

**Примеры:**

```python
# setdefault() - получение с добавлением
person = {"name": "Иван", "age": 30}

# Ключ существует - просто возвращает значение
name = person.setdefault("name", "Неизвестно")
print(name)    # Иван
print(person)  # {'name': 'Иван', 'age': 30} - не изменился

# Ключа нет - добавляет его со значением по умолчанию
city = person.setdefault("city", "Москва")
print(city)    # Москва
print(person)  # {'name': 'Иван', 'age': 30, 'city': 'Москва'} - добавился!

# Без значения по умолчанию - использует None
job = person.setdefault("job")
print(job)     # None
print(person)  # Добавился 'job': None

# Разница между get() и setdefault()
test_dict = {"a": 1}

# get() НЕ изменяет словарь
value1 = test_dict.get("b", 2)
print(test_dict)  # {'a': 1} - не изменился

# setdefault() ИЗМЕНЯЕТ словарь
value2 = test_dict.setdefault("b", 2)
print(test_dict)  # {'a': 1, 'b': 2} - добавился ключ 'b'!
```

```python
# Практический пример: подсчет элементов
text = "hello world hello python"
word_count = {}

for word in text.split():
    # Если слова нет - создаем со значением 0, потом увеличиваем
    word_count.setdefault(word, 0)
    word_count[word] += 1

print(word_count)  # {'hello': 2, 'world': 1, 'python': 1}

# Более элегантный способ с setdefault
text = "hello world hello python"
word_count = {}

for word in text.split():
    word_count[word] = word_count.setdefault(word, 0) + 1

print(word_count)

# Группировка данных
students = [
    {"name": "Иван", "group": "A"},
    {"name": "Мария", "group": "B"},
    {"name": "Петр", "group": "A"},
    {"name": "Анна", "group": "B"}
]

groups = {}
for student in students:
    group_name = student["group"]
    # Если группы нет - создаем пустой список
    groups.setdefault(group_name, []).append(student["name"])

print(groups)
# {'A': ['Иван', 'Петр'], 'B': ['Мария', 'Анна']}
```

#### `clear()` и `copy()`

**`clear()`** — удаляет все элементы из словаря (делает пустым).

**`copy()`** — создает **поверхностную** копию словаря.

**Примеры:**

```python
# clear() - очистка словаря
data = {"a": 1, "b": 2, "c": 3}
print(f"До: {len(data)} элементов")  # 3

data.clear()
print(f"После: {len(data)} элементов")  # 0
print(data)  # {} - пустой словарь

# copy() - создание копии
original = {"name": "Иван", "age": 30}
copy = original.copy()

# Изменяем копию
copy["age"] = 31
copy["city"] = "Москва"

print(original)  # {'name': 'Иван', 'age': 30} - не изменился!
print(copy)      # {'name': 'Иван', 'age': 31, 'city': 'Москва'}

# ВАЖНО: copy() делает поверхностную копию!
original = {
    "name": "Иван",
    "scores": [85, 90, 95]  # вложенный список
}

shallow_copy = original.copy()

# Изменяем вложенный список в копии
shallow_copy["scores"].append(100)

# Оригинал тоже изменился!
print(original)       # {'name': 'Иван', 'scores': [85, 90, 95, 100]}
print(shallow_copy)   # {'name': 'Иван', 'scores': [85, 90, 95, 100]}

# Для глубокой копии используйте deepcopy
import copy as copy_module

deep_copy = copy_module.deepcopy(original)
deep_copy["scores"].append(105)

print(original)    # [85, 90, 95, 100] - не изменился
print(deep_copy)   # [85, 90, 95, 100, 105] - изменилась только копия
```

### `9.3.5` Уметь перебирать словари через for
Существует несколько способов перебора словаря. Можно перебирать ключи, значения или пары ключ-значение. С Python 3.7+ словари сохраняют порядок добавления элементов.

**Способы перебора:**
1. По умолчанию — перебор ключей
2. `dict.keys()` — явный перебор ключей
3. `dict.values()` — перебор значений
4. `dict.items()` — перебор пар (ключ, значение)

**Примеры:**

```python
person = {
    "name": "Иван",
    "age": 30,
    "city": "Москва",
    "job": "Программист"
}

# Способ 1: перебор ключей (по умолчанию)
print("Ключи:")
for key in person:
    print(key)
# name
# age
# city
# job

# Способ 2: перебор ключей (явно через keys())
print("\nКлючи через keys():")
for key in person.keys():
    print(key)
# То же самое

# Способ 3: перебор значений
print("\nЗначения:")
for value in person.values():
    print(value)
# Иван
# 30
# Москва
# Программист

# Способ 4: перебор пар ключ-значение (самый полезный!)
print("\nПары ключ-значение:")
for key, value in person.items():
    print(f"{key}: {value}")
# name: Иван
# age: 30
# city: Москва
# job: Программист
```

```python
# Практические примеры перебора

# Пример 1: форматированный вывод
prices = {
    "яблоко": 50,
    "банан": 30,
    "груша": 60,
    "киви": 80
}

print("=== ПРАЙС-ЛИСТ ===")
for product, price in prices.items():
    print(f"{product.capitalize()}: {price} руб.")
# === ПРАЙС-ЛИСТ ===
# Яблоко: 50 руб.
# Банан: 30 руб.
# ...

# Пример 2: подсчет статистики
grades = {
    "Иван": [85, 90, 88],
    "Мария": [92, 95, 89],
    "Петр": [78, 82, 85]
}

print("=== СРЕДНИЕ БАЛЛЫ ===")
for student, scores in grades.items():
    average = sum(scores) / len(scores)
    print(f"{student}: {average:.1f}")
# === СРЕДНИЕ БАЛЛЫ ===
# Иван: 87.7
# Мария: 92.0
# Петр: 81.7

# Пример 3: фильтрация при переборе
inventory = {
    "яблоки": 5,
    "бананы": 0,
    "груши": 12,
    "киви": 0,
    "апельсины": 8
}

print("Товары в наличии:")
for item, quantity in inventory.items():
    if quantity > 0:
        print(f"- {item}: {quantity} шт.")
# Товары в наличии:
# - яблоки: 5 шт.
# - груши: 12 шт.
# - апельсины: 8 шт.

# Пример 4: создание нового словаря на основе существующего
celsius = {"утро": 15, "день": 25, "вечер": 20}

# Преобразуем в Фаренгейты
fahrenheit = {}
for time, temp_c in celsius.items():
    temp_f = temp_c * 9/5 + 32
    fahrenheit[time] = temp_f

print(fahrenheit)
# {'утро': 59.0, 'день': 77.0, 'вечер': 68.0}
```

```python
# Перебор с enumerate() - добавление индекса
colors = {"red": "красный", "green": "зеленый", "blue": "синий"}

for index, (eng, rus) in enumerate(colors.items(), start=1):
    print(f"{index}. {eng} - {rus}")
```

```python
# 1. red - красный
# 2. green - зеленый
# 3. blue - синий

# Перебор нескольких словарей одновременно с zip()
names = {1: "Иван", 2: "Мария", 3: "Петр"}
ages = {1: 30, 2: 25, 3: 35}
cities = {1: "Москва", 2: "СПб", 3: "Казань"}

print("=== ИНФОРМАЦИЯ О ПОЛЬЗОВАТЕЛЯХ ===")
for (id1, name), (id2, age), (id3, city) in zip(names.items(), ages.items(), cities.items()):
    print(f"ID {id1}: {name}, {age} лет, {city}")
# === ИНФОРМАЦИЯ О ПОЛЬЗОВАТЕЛЯХ ===
# ID 1: Иван, 30 лет, Москва
# ID 2: Мария, 25 лет, СПб
# ID 3: Петр, 35 лет, Казань

# Перебор с условиями и накоплением
sales = {
    "январь": 10000,
    "февраль": 12000,
    "март": 8000,
    "апрель": 15000,
    "май": 11000
}

total = 0
best_month = ""
best_sales = 0

for month, amount in sales.items():
    total += amount
    if amount > best_sales:
        best_sales = amount
        best_month = month
    
    # Отметка для хороших месяцев
    mark = "⭐" if amount > 11000 else ""
    print(f"{month}: {amount} руб {mark}")

print(f"\nОбщая выручка: {total} руб")
print(f"Лучший месяц: {best_month} ({best_sales} руб)")
# январь: 10000 руб 
# февраль: 12000 руб ⭐
# март: 8000 руб 
# апрель: 15000 руб ⭐
# май: 11000 руб 
# 
# Общая выручка: 56000 руб
# Лучший месяц: апрель (15000 руб)
```

### `9.3.6` Вложенные словари
`Вложенные словари` — это словари, значениями которых являются другие словари (или списки, кортежи и т.д.). Они используются для представления сложных иерархических структур данных, таких как базы данных, JSON-объекты, конфигурации.

**Структура вложенного словаря:**
```python
{
    "ключ1": {
        "подключ1": значение,
        "подключ2": значение
    },
    "ключ2": {
        "подключ1": значение,
        "подключ2": значение
    }
}
```

**Доступ к элементам:**
- Первый уровень: `dict["ключ1"]`
- Второй уровень: `dict["ключ1"]["подключ1"]`
- Третий уровень: `dict["ключ1"]["подключ2"]["подподключ"]`

**Примеры:**

```python
# Простой вложенный словарь - информация о пользователях
users = {
    "user1": {
        "name": "Иван",
        "age": 30,
        "city": "Москва"
    },
    "user2": {
        "name": "Мария",
        "age": 25,
        "city": "Санкт-Петербург"
    },
    "user3": {
        "name": "Петр",
        "age": 35,
        "city": "Казань"
    }
}

# Доступ к элементам
print(users["user1"])  # {'name': 'Иван', 'age': 30, 'city': 'Москва'}
print(users["user1"]["name"])  # Иван
print(users["user2"]["age"])   # 25

# Изменение значений во вложенном словаре
users["user1"]["age"] = 31
users["user1"]["job"] = "Программист"
print(users["user1"])
# {'name': 'Иван', 'age': 31, 'city': 'Москва', 'job': 'Программист'}

# Добавление нового пользователя
users["user4"] = {
    "name": "Анна",
    "age": 28,
    "city": "Новосибирск"
}

# Безопасный доступ с get()
print(users.get("user5", {}).get("name", "Не найден"))  # Не найден
```

```python
# Более сложная структура - школьная база данных
school = {
    "class_10A": {
        "teacher": "Иванова И.И.",
        "students": {
            "student1": {"name": "Алексей", "grades": [5, 4, 5, 5]},
            "student2": {"name": "Ольга", "grades": [4, 4, 5, 4]},
            "student3": {"name": "Дмитрий", "grades": [3, 4, 4, 3]}
        }
    },
    "class_10B": {
        "teacher": "Петров П.П.",
        "students": {
            "student1": {"name": "Елена", "grades": [5, 5, 5, 5]},
            "student2": {"name": "Сергей", "grades": [4, 3, 4, 4]}
        }
    }
}

# Доступ к глубоко вложенным элементам
print(school["class_10A"]["teacher"])  # Иванова И.И.
print(school["class_10A"]["students"]["student1"]["name"])  # Алексей
print(school["class_10A"]["students"]["student1"]["grades"])  # [5, 4, 5, 5]

# Изменение оценок
school["class_10A"]["students"]["student1"]["grades"].append(5)
print(school["class_10A"]["students"]["student1"]["grades"])  # [5, 4, 5, 5, 5]

# Вычисление средней оценки
grades = school["class_10A"]["students"]["student1"]["grades"]
average = sum(grades) / len(grades)
print(f"Средняя оценка Алексея: {average:.2f}")  # 4.80
```

```python
# Перебор вложенных словарей
company = {
    "IT": {
        "manager": "Иванов",
        "employees": ["Петров", "Сидоров", "Козлов"]
    },
    "HR": {
        "manager": "Смирнова",
        "employees": ["Попова", "Новикова"]
    },
    "Sales": {
        "manager": "Волков",
        "employees": ["Соколов", "Лебедев", "Орлов", "Медведев"]
    }
}

# Перебор отделов и сотрудников
print("=== СТРУКТУРА КОМПАНИИ ===")
for department, info in company.items():
    print(f"\n{department}:")
    print(f"  Менеджер: {info['manager']}")
    print(f"  Сотрудников: {len(info['employees'])}")
    print(f"  Список: {', '.join(info['employees'])}")

# === СТРУКТУРА КОМПАНИИ ===
# 
# IT:
#   Менеджер: Иванов
#   Сотрудников: 3
#   Список: Петров, Сидоров, Козлов
# 
# HR:
#   Менеджер: Смирнова
#   Сотрудников: 2
#   Список: Попова, Новикова
# ...

# Подсчет общего количества сотрудников
total_employees = sum(len(dept["employees"]) for dept in company.values())
print(f"\nВсего сотрудников в компании: {total_employees}")  # 9
```

```python
# Практический пример: интернет-магазин
store = {
    "electronics": {
        "smartphones": {
            "iPhone 14": {"price": 80000, "stock": 5},
            "Samsung S23": {"price": 70000, "stock": 3},
            "Xiaomi 13": {"price": 50000, "stock": 10}
        },
        "laptops": {
            "MacBook Pro": {"price": 150000, "stock": 2},
            "Dell XPS": {"price": 120000, "stock": 4}
        }
    },
    "clothing": {
        "shirts": {
            "Polo": {"price": 3000, "stock": 20},
            "T-shirt": {"price": 1500, "stock": 50}
        },
        "jeans": {
            "Levi's": {"price": 5000, "stock": 15},
            "Wrangler": {"price": 4000, "stock": 12}
        }
    }
}

# Вывод каталога с форматированием
print("=== КАТАЛОГ МАГАЗИНА ===\n")
for category, subcategories in store.items():
    print(f"📁 {category.upper()}")
    for subcategory, products in subcategories.items():
        print(f"  📂 {subcategory.capitalize()}")
        for product, details in products.items():
            status = "✅ В наличии" if details["stock"] > 0 else "❌ Нет в наличии"
            print(f"    • {product}: {details['price']} руб. (Остаток: {details['stock']} шт.) {status}")
    print()

# Поиск товара по всем категориям
def find_product(store, product_name):
    for category, subcategories in store.items():
        for subcategory, products in subcategories.items():
            if product_name in products:
                return {
                    "category": category,
                    "subcategory": subcategory,
                    "details": products[product_name]
                }
    return None

# Поиск товара
search_result = find_product(store, "iPhone 14")
if search_result:
    print(f"Найдено: {search_result['category']} → {search_result['subcategory']}")
    print(f"Цена: {search_result['details']['price']} руб.")
    print(f"В наличии: {search_result['details']['stock']} шт.")
```

**Итоговые советы по работе со словарями:**

✅ **Выбор способа доступа:**
- `dict[key]` — когда уверены, что ключ существует
- `dict.get(key, default)` — когда ключ может отсутствовать
- `dict.setdefault(key, default)` — когда нужно добавить ключ, если его нет

✅ **Удаление элементов:**
- `del dict[key]` — быстрое удаление (ошибка если нет ключа)
- `dict.pop(key, default)` — удаление с возвратом значения
- `dict.popitem()` — удаление последней пары

✅ **Перебор:**
- `for key in dict:` — перебор ключей
- `for value in dict.values():` — перебор значений
- `for key, value in dict.items():` — перебор пар (самый удобный!)

✅ **Вложенные словари:**
- Используйте для иерархических данных
- Используйте `get()` для безопасного доступа
- Создавайте вспомогательные функции для глубокого доступа

❌ **Частые ошибки:**
- Забывать, что `in` проверяет ключи, а не значения
- Изменять словарь во время перебора (может вызвать ошибку)
- Путать `copy()` (поверхностная) и `deepcopy()` (глубокая)

### `9.3.7` (`*`) Генераторы словарей или `dict comprehensions`
Dict comprehension — это компактный способ создания словаря на основе итерируемого объекта с возможностью преобразования и фильтрации.

**Синтаксис:**
```python
{ключ: значение for элемент in итерируемый_объект if условие}
```

**Пример 1: Создание словаря из списка**

```python
# Создать словарь: число → квадрат числа
numbers = [1, 2, 3, 4, 5]
squares = {num: num**2 for num in numbers}
print(squares)  # {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}

# С фильтрацией — только чётные числа
even_squares = {num: num**2 for num in numbers if num % 2 == 0}
print(even_squares)  # {2: 4, 4: 16}
```

**Пример 2: Преобразование данных**

```python
# Список имён → словарь: имя → длина имени
names = ['Alice', 'Bob', 'Charlie']
name_lengths = {name: len(name) for name in names}
print(name_lengths)  # {'Alice': 5, 'Bob': 3, 'Charlie': 7}

# Инвертирование словаря (ключи ↔ значения)
original = {'a': 1, 'b': 2, 'c': 3}
inverted = {value: key for key, value in original.items()}
print(inverted)  # {1: 'a', 2: 'b', 3: 'c'}
```

Dict comprehension создаёт словарь за одну строку, избегая циклов и временных переменных.

### `9.3.8` (`*`) Что такое коллекции и последовательности?
#### **Коллекции (Collections)**

Коллекции — это структуры данных для хранения групп объектов. В Python основные типы коллекций: списки (`list`), кортежи (`tuple`), множества (`set`), словари (`dict`).

```python
# Основные коллекции
fruits_list = ['apple', 'banana', 'cherry']      # Список
coordinates = (10, 20, 30)                       # Кортеж
unique_numbers = {1, 2, 3, 4, 5}                # Множество
person = {'name': 'Alice', 'age': 30}           # Словарь

# Общие операции для всех коллекций
print(len(fruits_list))          # 3 (длина)
print('apple' in fruits_list)    # True (проверка вхождения)
for item in fruits_list:         # Итерация
    print(item)
```

#### **Последовательности (Sequences)**

Последовательности — это **упорядоченные** коллекции, где элементы имеют позицию (индекс) и доступны по этой позиции. К ним относятся: списки, кортежи, строки, range.

```python
# Последовательности поддерживают индексацию и срезы
numbers = [10, 20, 30, 40, 50]   # Список — последовательность
text = "Python"                   # Строка — последовательность

# Индексация
print(numbers[0])      # 10 (первый элемент)
print(text[-1])        # 'n' (последний элемент)

# Срезы
print(numbers[1:4])    # [20, 30, 40]
print(text[:3])        # 'Pyt'

# НЕ последовательности — нет индексов
unique_set = {10, 20, 30}        # Множество
# print(unique_set[0])           # TypeError! У множества нет индексов

person_dict = {'name': 'Bob'}    # Словарь
# print(person_dict[0])          # KeyError! У словаря доступ по ключу, не по индексу
```

**Главное отличие:**

- **Последовательности** = коллекции с **порядком** и **индексами** (список, кортеж, строка)
- **Остальные коллекции** = нет гарантированного порядка или доступа по индексу (множество, словарь)

```python
# Порядок важен в последовательностях
list1 = [1, 2, 3]
list2 = [3, 2, 1]
print(list1 == list2)  # False (разный порядок)

# Порядок не важен в множествах
set1 = {1, 2, 3}
set2 = {3, 2, 1}
print(set1 == set2)    # True (важны только элементы)
```

**Все коллекции в Python итерируемы** (их можно перебрать в цикле), но только последовательности поддерживают индексацию и срезы.

----

# `10` (`*`) Управление памятью
[Must Have Video](https://youtu.be/8GpI0PAGniA?si=GVxdfcmtYRZfeJzv)

## `10.1` Устройство памяти в общем
[Как устроена память?](https://www.youtube.com/watch?v=Wh22_O8jXVQ)

## `10.2` Устройства памяти в Python
[Как устроена память в Python?](https://www.youtube.com/watch?v=1CHLo4bY7P4)

## `10.3` Переменные в Python. Как работают ссылки в Python  
В Python **переменные — это ссылки (указатели) на объекты в памяти**, а не сами данные. Переменная хранит адрес объекта, а не его значение.

```python
# Переменная — это ссылка на объект
x = 42
# x не содержит число 42, а указывает на объект со значением 42 в памяти

y = x
# y теперь указывает на тот же объект, что и x

print(id(x))  # Например: 140234567890
print(id(y))  # 140234567890 (тот же адрес!)
print(x is y) # True (обе переменные указывают на один объект)
```

**Поведение с неизменяемыми объектами:**

```python
a = 10
b = a          # b указывает на тот же объект
print(a is b)  # True

a = 20         # a теперь указывает на новый объект (10 → 20)
print(a is b)  # False (a и b указывают на разные объекты)
print(a)       # 20
print(b)       # 10 (не изменилась!)
```

**Поведение с изменяемыми объектами:**

```python
list1 = [1, 2, 3]
list2 = list1          # list2 указывает на тот же список
print(list1 is list2)  # True (одна и та же ссылка)

list1.append(4)        # Изменяем список через list1
print(list1)           # [1, 2, 3, 4]
print(list2)           # [1, 2, 3, 4] (тоже изменился!)

# Чтобы создать независимую копию:
list3 = list1.copy()   # или list3 = list1[:]
list3.append(5)
print(list1)           # [1, 2, 3, 4] (не изменился)
print(list3)           # [1, 2, 3, 4, 5]
```

**Передача аргументов в функции:**

```python
# Неизменяемые объекты
def change_number(x):
    x = 100        # Создаётся новый объект, исходный не меняется

num = 10
change_number(num)
print(num)         # 10 (не изменилось)

# Изменяемые объекты
def change_list(lst):
    lst.append(4)  # Изменяется тот же объект

my_list = [1, 2, 3]
change_list(my_list)
print(my_list)     # [1, 2, 3, 4] (изменилось!)
```

**Ключевые моменты:**

- Переменная = ссылка (указатель) на объект в памяти
- Присваивание `a = b` копирует ссылку, а не объект
- Неизменяемые объекты безопасны — изменение создаёт новый объект
- Изменяемые объекты — изменение влияет на все ссылки
- Используйте `copy()` или `deepcopy()` для создания независимых копий

## `10.4` Изменяемые и неизменяемые типы данных. `copy()` & `deepcopy()`
В Python все типы данных делятся на две категории по возможности изменения после создания:

- **Неизменяемые (immutable)** — после создания объект нельзя изменить. Любая «модификация» создаёт новый объект.
- **Изменяемые (mutable)** — объект можно изменять на месте без создания нового.

### **Неизменяемые типы (Immutable)**

**Основные неизменяемые типы:** `int`, `float`, `str`, `tuple`, `bool`, `frozenset`, `bytes`

```python
# Числа (int, float)
x = 10
print(id(x))    # Адрес 1
x = x + 5       # Создаётся НОВЫЙ объект со значением 15
print(id(x))    # Адрес 2 (другой объект!)

# Строки (str)
text = "hello"
print(id(text))       # Адрес 1
text = text + " world"  # Создаётся НОВАЯ строка
print(id(text))       # Адрес 2 (другой объект!)

# При попытке изменить символ — ошибка
s = "Python"
# s[0] = 'J'  # TypeError: 'str' object does not support item assignment

# Кортежи (tuple)
coords = (10, 20)
print(id(coords))     # Адрес 1
# coords[0] = 15      # TypeError: 'tuple' object does not support item assignment
coords = (15, 20)     # Создаётся НОВЫЙ кортеж
print(id(coords))     # Адрес 2 (другой объект!)
```

**Что происходит при "изменении":**

```python
# Каждая операция создаёт новый объект
x = 5
print(id(x))     # Адрес A

x = x + 1        # x = 6 — это НОВЫЙ объект
print(id(x))     # Адрес B (изменился!)

x += 1           # x = 7 — снова НОВЫЙ объект
print(id(x))     # Адрес C (изменился!)

# Строки работают так же
name = "Alice"
print(id(name))        # Адрес 1
name = name.upper()    # Создаётся новая строка "ALICE"
print(id(name))        # Адрес 2 (изменился!)
```

**Почему это важно — передача в функцию:**

```python
def modify_number(n):
    print(f"До изменения внутри функции: {id(n)}")
    n = n + 10  # Создаётся НОВЫЙ объект
    print(f"После изменения внутри функции: {id(n)}")
    return n

x = 5
print(f"До вызова функции: {id(x)}")
result = modify_number(x)
print(f"После вызова функции: {id(x)}")
print(f"x = {x}")  # 5 (не изменился!)
print(f"result = {result}")  # 15

# Вывод:
# До вызова функции: адрес A
# До изменения внутри функции: адрес A (та же ссылка)
# После изменения внутри функции: адрес B (новый объект!)
# После вызова функции: адрес A (x не изменился)
```


### **Изменяемые типы (Mutable)**

**Основные изменяемые типы:** `list`, `dict`, `set`, `bytearray`

```python
# Списки (list)
numbers = [1, 2, 3]
print(id(numbers))      # Адрес 1
numbers.append(4)       # Изменяем на месте
print(id(numbers))      # Адрес 1 (тот же объект!)
numbers[0] = 100        # Изменяем элемент
print(id(numbers))      # Адрес 1 (всё ещё тот же!)

# Словари (dict)
person = {'name': 'Alice', 'age': 30}
print(id(person))       # Адрес 1
person['city'] = 'Moscow'  # Добавляем ключ
print(id(person))       # Адрес 1 (тот же объект!)
person['age'] = 31      # Изменяем значение
print(id(person))       # Адрес 1 (тот же объект!)

# Множества (set)
tags = {'python', 'coding'}
print(id(tags))         # Адрес 1
tags.add('tutorial')    # Добавляем элемент
print(id(tags))         # Адрес 1 (тот же объект!)
```

**Опасность изменяемых объектов — общие ссылки:**

```python
# Две переменные указывают на ОДИН список
list1 = [1, 2, 3]
list2 = list1          # Копируется ссылка, НЕ объект!

print(list1 is list2)  # True (один и тот же объект)
print(id(list1))       # Адрес A
print(id(list2))       # Адрес A (тот же!)

# Изменение через одну переменную влияет на другую
list1.append(4)
print(list1)           # [1, 2, 3, 4]
print(list2)           # [1, 2, 3, 4] (тоже изменился!)

# Изменение через list2
list2[0] = 100
print(list1)           # [100, 2, 3, 4] (изменился!)
print(list2)           # [100, 2, 3, 4]
```

**Как создать независимую копию:**

```python
# Способ 1: метод copy()
original = [1, 2, 3]
copy1 = original.copy()
copy1.append(4)
print(original)  # [1, 2, 3] (не изменился)
print(copy1)     # [1, 2, 3, 4]

# Способ 2: срез [:]
copy2 = original[:]
copy2.append(5)
print(original)  # [1, 2, 3] (не изменился)
print(copy2)     # [1, 2, 3, 5]

# Способ 3: list()
copy3 = list(original)
copy3.append(6)
print(original)  # [1, 2, 3] (не изменился)
print(copy3)     # [1, 2, 3, 6]
```

**Передача в функцию — изменяемые объекты:**

```python
def modify_list(lst):
    lst.append(4)  # Изменяет ОРИГИНАЛЬНЫЙ список!
    print(f"Внутри функции: {lst}")

my_list = [1, 2, 3]
print(f"До вызова: {my_list}")
modify_list(my_list)
print(f"После вызова: {my_list}")  # [1, 2, 3, 4] (изменился!)

# Вывод:
# До вызова: [1, 2, 3]
# Внутри функции: [1, 2, 3, 4]
# После вызова: [1, 2, 3, 4]
```

**Как защититься от изменения:**

```python
def modify_list_safe(lst):
    local_copy = lst.copy()  # Создаём локальную копию
    local_copy.append(4)
    return local_copy

my_list = [1, 2, 3]
result = modify_list_safe(my_list)
print(my_list)  # [1, 2, 3] (не изменился!)
print(result)   # [1, 2, 3, 4]
```

### **Поверхностное и глубокое копирование: `copy()` vs `deepcopy()`**

Когда внутри списка есть другие изменяемые объекты (списки, словари), обычное копирование создаёт **поверхностную копию** — копируется только внешний уровень, а вложенные объекты остаются общими.

#### **Поверхностное копирование (shallow copy) — `.copy()`**

```python
# Проблема с вложенными списками
original = [[1, 2], [3, 4]]
shallow = original.copy()

print(id(original))       # Адрес A
print(id(shallow))        # Адрес B (разные объекты)
print(id(original[0]))    # Адрес C
print(id(shallow[0]))     # Адрес C (ОДИН И ТОТ ЖЕ вложенный список!)

# Изменяем вложенный список
shallow[0].append(999)

print(original)  # [[1, 2, 999], [3, 4]] (изменился!)
print(shallow)   # [[1, 2, 999], [3, 4]]

# Почему? Визуализация:
# original -> [список1, список2]
#               ↓        ↓
# shallow  -> [список1, список2]  # Те же самые вложенные списки!
```

**Когда `.copy()` работает нормально:**

```python
# С простыми элементами (неизменяемыми)
numbers = [1, 2, 3]
copy_num = numbers.copy()
copy_num[0] = 999
print(numbers)   # [1, 2, 3] (не изменился)
print(copy_num)  # [999, 2, 3]

# Работает, потому что числа неизменяемы — присваивание создаёт новый объект
```

#### **Глубокое копирование (deep copy) — `copy.deepcopy()`**

```python
import copy

# Глубокое копирование рекурсивно копирует ВСЕ уровни
original = [[1, 2], [3, 4]]
deep = copy.deepcopy(original)

print(id(original))       # Адрес A
print(id(deep))           # Адрес B (разные объекты)
print(id(original[0]))    # Адрес C
print(id(deep[0]))        # Адрес D (РАЗНЫЕ вложенные списки!)

# Изменяем вложенный список
deep[0].append(999)

print(original)  # [[1, 2], [3, 4]] (НЕ изменился!)
print(deep)      # [[1, 2, 999], [3, 4]]

# Визуализация:
# original -> [список1_orig, список2_orig]
# deep     -> [список1_copy, список2_copy]  # Полностью независимые копии!
```

**Сложный пример со словарями:**

```python
import copy

# Вложенные структуры
original = {
    'user': 'Alice',
    'scores': [85, 90, 95],
    'settings': {'theme': 'dark', 'notifications': True}
}

# Поверхностная копия
shallow = original.copy()
shallow['scores'].append(100)          # Изменяем список
shallow['settings']['theme'] = 'light' # Изменяем словарь

print(original['scores'])    # [85, 90, 95, 100] (изменился!)
print(original['settings'])  # {'theme': 'light', ...} (изменился!)

# Глубокая копия
deep = copy.deepcopy(original)
deep['scores'].append(200)
deep['settings']['theme'] = 'blue'

print(original['scores'])    # [85, 90, 95, 100] (НЕ изменился)
print(original['settings'])  # {'theme': 'light', ...} (НЕ изменился)
```

**Когда использовать что:**

```python
# copy() — для простых одноуровневых структур
simple_list = [1, 2, 3, 4]
simple_copy = simple_list.copy()  # Достаточно

# deepcopy() — для вложенных структур
nested_list = [[1, 2], [3, 4], {'a': [5, 6]}]
nested_copy = copy.deepcopy(nested_list)  # Необходимо!

# Проверка: есть ли вложенные изменяемые объекты?
data = [1, 'text', (1, 2), 3.14]  # Только неизменяемые элементы
safe_copy = data.copy()  # copy() достаточно

data2 = [1, [2, 3], {'key': 'value'}]  # Есть вложенные изменяемые
safe_copy2 = copy.deepcopy(data2)  # Нужен deepcopy()
```

**Визуальное сравнение:**

```python
import copy

original = [[1, 2], [3, 4]]

# Присваивание (=) — общая ссылка
ref = original
ref[0].append(999)
print(original)  # [[1, 2, 999], [3, 4]] — изменился!

# Поверхностная копия (.copy()) — копируется только первый уровень
original = [[1, 2], [3, 4]]
shallow = original.copy()
shallow[0].append(999)
print(original)  # [[1, 2, 999], [3, 4]] — изменился!

# Глубокая копия (deepcopy()) — полностью независимая копия
original = [[1, 2], [3, 4]]
deep = copy.deepcopy(original)
deep[0].append(999)
print(original)  # [[1, 2], [3, 4]] — НЕ изменился!
```


### **Сравнительная таблица**

| Операция | Неизменяемые | Изменяемые |
|----------|--------------|------------|
| Изменение значения | Создаётся новый объект | Объект меняется на месте |
| `id()` после изменения | Меняется | Не меняется |
| Безопасность при передаче | Безопасно | Может измениться |
| Можно использовать как ключ словаря | Да | Нет |
| Копирование `=` | Безопасно | Опасно (общая ссылка) |
| `.copy()` | Не нужно | Копирует 1 уровень |
| `deepcopy()` | Не нужно | Копирует все уровни |


### **Практические примеры**

```python
# Пример 1: Дефолтные аргументы функции (частая ошибка!)
def add_item(item, lst=[]):  # ОПАСНО! [] создаётся ОДИН раз
    lst.append(item)
    return lst

print(add_item(1))  # [1]
print(add_item(2))  # [1, 2] (Ожидали [2]!)
print(add_item(3))  # [1, 2, 3] (Ожидали [3]!)

# Правильно:
def add_item_safe(item, lst=None):
    if lst is None:
        lst = []  # Создаём новый список при каждом вызове
    lst.append(item)
    return lst

print(add_item_safe(1))  # [1]
print(add_item_safe(2))  # [2]
print(add_item_safe(3))  # [3]

# Пример 2: Кеширование неизменяемых объектов
a = 257
b = 257
print(a is b)  # False (большие числа — разные объекты)

x = 5
y = 5
print(x is y)  # True (маленькие числа кешируются Python!)

s1 = "hello"
s2 = "hello"
print(s1 is s2)  # True (строки тоже кешируются)

# Пример 3: Изменяемые объекты в кортеже
t = ([1, 2], [3, 4])
# t[0] = [5, 6]  # TypeError (кортеж неизменяем)
t[0].append(999)  # Но список внутри можно изменить!
print(t)  # ([1, 2, 999], [3, 4])
```

**Ключевые правила:**

1. **Неизменяемые типы безопасны** — изменение создаёт новый объект, оригинал не трогается
2. **Изменяемые типы опасны** — изменение влияет на все ссылки
3. **При присваивании `a = b`** копируется ссылка, а не объект
4. **`.copy()` — поверхностное копирование** — копирует только первый уровень (быстрее)
5. **`deepcopy()` — глубокое копирование** — копирует все вложенные уровни (медленнее, но безопаснее)
6. **Остерегайтесь изменяемых дефолтных аргументов** в функциях
7. **Только неизменяемые типы** можно использовать как ключи словаря или элементы множества


## `10.5` Garbage collector. Слабые и сильные ссылки
[How it works?](https://youtu.be/3Kqal7QaCCM?si=0_M82_NFF5eECt7f)

### **Garbage Collector (Сборщик мусора)**

Garbage Collector (GC) — это механизм автоматического управления памятью в Python. Он отслеживает объекты и удаляет те, которые больше не используются, освобождая память.

**Как работает — подсчёт ссылок:**

Python считает, сколько переменных ссылается на каждый объект. Когда счётчик становится равным нулю, объект удаляется.

```python
# Создаём список — счётчик ссылок = 1
x = [1, 2, 3]

# Создаём ещё одну ссылку — счётчик = 2
y = x

# Удаляем одну ссылку — счётчик = 1
del x

# Удаляем последнюю ссылку — счётчик = 0
del y
# Объект [1, 2, 3] автоматически удалён из памяти

# Можно посмотреть счётчик ссылок
import sys
data = [1, 2, 3]
print(sys.getrefcount(data))  # Покажет количество ссылок
```

**Проблема циклических ссылок:**

Когда объекты ссылаются друг на друга, подсчёт ссылок не работает. Python GC обнаруживает и удаляет такие циклы автоматически.

```python
# Циклическая ссылка
list1 = []
list2 = []
list1.append(list2)  # list1 → list2
list2.append(list1)  # list2 → list1

del list1, list2
# GC автоматически обнаружит и удалит этот цикл

# Принудительный запуск сборки мусора
import gc
gc.collect()  # Удаляет недостижимые объекты
```

---

### **Сильные ссылки**

**Сильная ссылка** — обычная ссылка на объект. Пока есть хотя бы одна сильная ссылка, объект остаётся в памяти.

```python
data = {'name': 'Alice'}
backup = data  # Две сильные ссылки на один объект

del data  # Удалили одну ссылку
print(backup)  # {'name': 'Alice'} — объект всё ещё существует

del backup  # Удалили последнюю ссылку
# Теперь объект удалён из памяти
```

---

### **Слабые ссылки**

**Слабая ссылка** — ссылка, которая **не препятствует удалению объекта**. Если остались только слабые ссылки, GC может удалить объект.

```python
import weakref

# Создаём объект
data = [1, 2, 3, 4, 5]

# Создаём слабую ссылку
weak_ref = weakref.ref(data)

# Доступ через слабую ссылку (вызываем как функцию)
print(weak_ref())  # [1, 2, 3, 4, 5]

# Удаляем сильную ссылку
del data

# Объект удалён, слабая ссылка больше не работает
print(weak_ref())  # None
```

**Зачем нужны слабые ссылки — пример с кешем:**

```python
import weakref

# Обычный словарь — объекты никогда не удаляются (утечка памяти!)
cache = {}
big_data = [i for i in range(1000000)]
cache['key'] = big_data
del big_data
# Объект всё ещё в памяти через cache!

# Словарь со слабыми ссылками — объекты удаляются автоматически
cache_weak = weakref.WeakValueDictionary()
big_data2 = [i for i in range(1000000)]
cache_weak['key'] = big_data2
print('key' in cache_weak)  # True

del big_data2
# Объект удалён, память освобождена
print('key' in cache_weak)  # False
```

**Ограничения:**

Слабые ссылки работают не со всеми типами. Нельзя создать слабую ссылку на числа и строки.

```python
import weakref

# Работает
weak1 = weakref.ref([1, 2, 3])  # OK
weak2 = weakref.ref({'a': 1})   # OK

# Не работает
# weak3 = weakref.ref(42)      # TypeError
# weak4 = weakref.ref("text")  # TypeError
```

---

**Ключевые моменты:**

- **GC автоматически удаляет неиспользуемые объекты** — не нужно освобождать память вручную
- **Подсчёт ссылок** — когда счётчик = 0, объект удаляется
- **Сильная ссылка** — обычная ссылка, объект живёт пока она есть
- **Слабая ссылка** — не мешает удалению объекта, возвращает `None` после удаления
- **Используйте слабые ссылки** для кешей и временных данных, чтобы избежать утечек памяти

----

# `11` (`*`) Функции 2
## `11.1` Встроенные функции `type()`, `sorted()`, `reversed()`, `isinstance()`, `callable()`, `hasattr()`, `hash()`
### **`type()` — определение типа объекта**

```python
print(type(42))           # <class 'int'>
print(type("hello"))      # <class 'str'>
print(type([1, 2, 3]))    # <class 'list'>

# Сравнение типов
x = 10
if type(x) == int:
    print("x — это число")
```

### **`sorted()` — сортировка (создаёт новый список)**

```python
numbers = [5, 2, 8, 1, 9]
print(sorted(numbers))                    # [1, 2, 5, 8, 9]
print(sorted(numbers, reverse=True))      # [9, 8, 5, 2, 1]

# Сортировка по ключу
students = [("Alice", 85), ("Bob", 92)]
print(sorted(students, key=lambda x: x[1]))  # [('Alice', 85), ('Bob', 92)]
```

### **`reversed()` — реверс последовательности (возвращает итератор)**

```python
numbers = [1, 2, 3, 4, 5]
print(list(reversed(numbers)))  # [5, 4, 3, 2, 1]

# Со строками
print(''.join(reversed("Python")))  # nohtyP
```

### **`isinstance()` — проверка типа объекта**

```python
x = 42
print(isinstance(x, int))              # True
print(isinstance(x, str))              # False
print(isinstance(x, (int, float)))     # True (проверка нескольких типов)

# Использование
def process(data):
    if isinstance(data, str):
        return data.upper()
    elif isinstance(data, int):
        return data * 2

print(process("hello"))  # HELLO
print(process(5))        # 10
```

### **`callable()` — проверка, можно ли вызвать объект**

```python
def greet():
    return "Hello"

print(callable(greet))     # True (функция)
print(callable(42))        # False (число)
print(callable([1, 2]))    # False (список)

# Безопасный вызов
callback = lambda x: x * 2
if callable(callback):
    print(callback(5))  # 10
```

### **`hasattr()` — проверка наличия атрибута**

```python
text = "hello"
print(hasattr(text, 'upper'))   # True
print(hasattr(text, 'append'))  # False

class Person:
    def __init__(self, name):
        self.name = name

person = Person("Alice")
print(hasattr(person, 'name'))  # True
print(hasattr(person, 'age'))   # False
```

### **`hash()` — получение хеш-значения**

```python
# Работает с неизменяемыми объектами
print(hash(42))         # 42
print(hash("hello"))    # Число
print(hash((1, 2, 3)))  # Число

# Изменяемые объекты не хешируемы
try:
    hash([1, 2, 3])  # TypeError
except TypeError:
    print("Списки не хешируемы")

# Проверка, можно ли использовать как ключ словаря
def can_be_key(obj):
    try:
        hash(obj)
        return True
    except TypeError:
        return False

print(can_be_key("text"))   # True
print(can_be_key([1, 2]))   # False
```

**Когда использовать:**
- `type()` — узнать тип (лучше использовать `isinstance()` для проверок)
- `sorted()` — создать новый отсортированный список
- `reversed()` — итерация в обратном порядке
- `isinstance()` — проверка типа (работает с наследованием)
- `callable()` — проверка перед вызовом функции
- `hasattr()` — безопасная проверка атрибутов
- `hash()` — проверка хешируемости объекта

## `11.2` Позиционные и именованные аргументы
При вызове функции можно передавать аргументы двумя способами: по позиции (порядок важен) или по имени (порядок не важен).

### **Позиционные аргументы**

Аргументы передаются в том порядке, в котором определены параметры функции.

```python
def greet(name, age):
    print(f"Привет, {name}! Тебе {age} лет.")

# Порядок важен!
greet("Alice", 25)  # Привет, Alice! Тебе 25 лет.
greet(25, "Alice")  # Привет, 25! Тебе Alice лет. (неправильно!)
```

### **Именованные аргументы (keyword arguments)**

Аргументы передаются с указанием имени параметра. Порядок не важен.

```python
def greet(name, age):
    print(f"Привет, {name}! Тебе {age} лет.")

# Порядок не важен
greet(name="Alice", age=25)  # Привет, Alice! Тебе 25 лет.
greet(age=25, name="Alice")  # Привет, Alice! Тебе 25 лет. (тот же результат)
```

### **Комбинирование**

Можно комбинировать оба способа, но позиционные должны идти **перед** именованными.

```python
def create_user(username, email, age, city):
    print(f"{username}, {email}, {age}, {city}")

# Сначала позиционные, потом именованные
create_user("alice", "alice@mail.com", age=25, city="Moscow")
# alice, alice@mail.com, 25, Moscow

# Ошибка: именованный аргумент перед позиционным
# create_user(username="alice", "alice@mail.com", 25, "Moscow")  # SyntaxError
```

### **Практические примеры**

```python
# Позиционные — короче, но менее понятно
def calculate(a, b, operation):
    if operation == "add":
        return a + b
    elif operation == "multiply":
        return a * b

result = calculate(5, 10, "add")  # Что значит "add"? Неочевидно
print(result)  # 15

# Именованные — длиннее, но понятнее
result = calculate(a=5, b=10, operation="add")  # Понятно, что делаем
print(result)  # 15

# Для функций с множеством параметров именованные аргументы улучшают читаемость
def send_email(to, subject, body, cc=None, bcc=None, attachments=None):
    print(f"To: {to}, Subject: {subject}")

# Непонятно
send_email("user@mail.com", "Hello", "Text", None, None, ["file.pdf"])

# Понятно
send_email(
    to="user@mail.com",
    subject="Hello",
    body="Text",
    attachments=["file.pdf"]
)
```

## `11.3` Аргументы по умолчанию
Параметры функции могут иметь значения по умолчанию. Если аргумент не передан, используется значение по умолчанию.

### **Базовое использование**

```python
def greet(name, greeting="Привет"):
    print(f"{greeting}, {name}!")

greet("Alice")              # Привет, Alice! (используется умолчание)
greet("Bob", "Здравствуй")  # Здравствуй, Bob! (передано значение)
```

### **Параметры по умолчанию должны идти после обязательных**

```python
# Правильно: обязательные → по умолчанию
def create_user(username, age=18, city="Moscow"):
    print(f"{username}, {age}, {city}")

create_user("Alice")                    # Alice, 18, Moscow
create_user("Bob", 25)                  # Bob, 25, Moscow
create_user("Charlie", city="SPb")      # Charlie, 18, SPb

# Неправильно: параметр по умолчанию перед обязательным
# def wrong(age=18, username):  # SyntaxError
#     pass
```

### **Множественные параметры по умолчанию**

```python
def configure_server(host="localhost", port=8080, debug=False):
    print(f"Server: {host}:{port}, Debug: {debug}")

configure_server()                              # Server: localhost:8080, Debug: False
configure_server("192.168.1.1")                 # Server: 192.168.1.1:8080, Debug: False
configure_server(port=3000)                     # Server: localhost:3000, Debug: False
configure_server("0.0.0.0", debug=True)         # Server: 0.0.0.0:8080, Debug: True
configure_server(debug=True, port=5000)         # Server: localhost:5000, Debug: True
```

### **ВАЖНО: изменяемые объекты как значения по умолчанию (частая ошибка!)**

```python
# ОПАСНО! Список создаётся ОДИН раз при определении функции
def add_item(item, items=[]):  
    items.append(item)
    return items

print(add_item(1))  # [1]
print(add_item(2))  # [1, 2] (Ожидали [2]!)
print(add_item(3))  # [1, 2, 3] (Ожидали [3]!)

# ПРАВИЛЬНО: используйте None
def add_item_correct(item, items=None):
    if items is None:
        items = []  # Создаём новый список каждый раз
    items.append(item)
    return items

print(add_item_correct(1))  # [1]
print(add_item_correct(2))  # [2]
print(add_item_correct(3))  # [3]
```

### **Практические примеры**

```python
# Функция для форматирования имени
def format_name(first, last, middle=None):
    if middle:
        return f"{first} {middle} {last}"
    return f"{first} {last}"

print(format_name("John", "Doe"))              # John Doe
print(format_name("John", "Doe", "Smith"))     # John Smith Doe

# Функция с настройками по умолчанию
def download_file(url, timeout=30, retries=3, verify_ssl=True):
    print(f"Скачиваю {url}")
    print(f"Timeout: {timeout}s, Retries: {retries}, SSL: {verify_ssl}")

download_file("https://example.com/file.zip")
# Скачиваю https://example.com/file.zip
# Timeout: 30s, Retries: 3, SSL: True

download_file("https://example.com/file.zip", timeout=60, verify_ssl=False)
# Скачиваю https://example.com/file.zip
# Timeout: 60s, Retries: 3, SSL: False

# Расчёт скидки
def calculate_price(base_price, discount=0, tax=0.2):
    price_after_discount = base_price * (1 - discount)
    final_price = price_after_discount * (1 + tax)
    return final_price

print(calculate_price(100))                # 120.0 (без скидки)
print(calculate_price(100, discount=0.1))  # 108.0 (со скидкой 10%)
print(calculate_price(100, 0.2, 0.15))     # 92.0 (скидка 20%, налог 15%)
```

**Ключевые правила:**
- **Позиционные аргументы** — передаются по порядку
- **Именованные аргументы** — передаются по имени, порядок не важен
- **Позиционные должны идти перед именованными** при вызове
- **Параметры по умолчанию должны идти после обязательных** при определении
- **НЕ используйте изменяемые объекты** (списки, словари) как значения по умолчанию — используйте `None`

## `11.4` Функции высшего порядка
`Функции высшего порядка (Higher-Order Functions)` — это функции, которые принимают другие функции как аргументы или возвращают функции как результат. В Python функции являются объектами первого класса, поэтому их можно передавать и возвращать как обычные переменные.

### **Функции как аргументы**

```python
def apply_operation(x, y, operation):
    """Применяет функцию operation к x и y"""
    return operation(x, y)

def add(a, b):
    return a + b

def multiply(a, b):
    return a * b

# Передаём функции как аргументы
print(apply_operation(5, 3, add))       # 8
print(apply_operation(5, 3, multiply))  # 15
```

### **Функции как возвращаемое значение**

```python
def create_multiplier(factor):
    """Возвращает функцию, которая умножает на factor"""
    def multiplier(x):
        return x * factor
    return multiplier

# Создаём разные функции-умножители
double = create_multiplier(2)
triple = create_multiplier(3)

print(double(5))   # 10
print(triple(5))   # 15
```

### **Практический пример**

```python
def process_list(numbers, transformer):
    """Применяет функцию transformer к каждому элементу"""
    result = []
    for num in numbers:
        result.append(transformer(num))
    return result

def square(x):
    return x ** 2

numbers = [1, 2, 3, 4, 5]
print(process_list(numbers, square))  # [1, 4, 9, 16, 25]
print(process_list(numbers, abs))     # [1, 2, 3, 4, 5]
```

## `11.5` `lambda` функции
`lambda` — это анонимная (безымянная) функция, которая определяется в одну строку. Используется для простых операций, где не нужно полноценное определение функции.

**Синтаксис:** `lambda аргументы: выражение`

### **Базовое использование**

```python
# Обычная функция
def square(x):
    return x ** 2

# То же самое через lambda
square_lambda = lambda x: x ** 2

print(square(5))         # 25
print(square_lambda(5))  # 25

# Lambda с несколькими аргументами
add = lambda a, b: a + b
print(add(3, 7))  # 10

# Lambda без аргументов
get_pi = lambda: 3.14159
print(get_pi())  # 3.14159
```

### **Lambda в функциях высшего порядка**

```python
# Сортировка по длине строки
words = ["apple", "pie", "banana", "kiwi"]
sorted_words = sorted(words, key=lambda w: len(w))
print(sorted_words)  # ['pie', 'kiwi', 'apple', 'banana']

# Сортировка кортежей по второму элементу
students = [("Alice", 85), ("Bob", 92), ("Charlie", 78)]
sorted_students = sorted(students, key=lambda x: x[1])
print(sorted_students)  # [('Charlie', 78), ('Alice', 85), ('Bob', 92)]

# Фильтрация чётных чисел
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
evens = list(filter(lambda x: x % 2 == 0, numbers))
print(evens)  # [2, 4, 6, 8, 10]
```

### **Ограничения lambda**

```python
# Lambda — только одно выражение, нельзя использовать:
# - несколько строк
# - операторы (if, for, while как операторы)
# - присваивания

# Можно: тернарный оператор
absolute = lambda x: x if x >= 0 else -x
print(absolute(-5))  # 5

# Нельзя: несколько строк
# lambda x: 
#     result = x * 2  # SyntaxError
#     return result
```

### **Когда использовать lambda**

```python
# Хорошо: короткие одноразовые функции
numbers = [1, 2, 3, 4, 5]
doubled = list(map(lambda x: x * 2, numbers))
print(doubled)  # [2, 4, 6, 8, 10]

# Плохо: сложная логика (лучше обычная функция)
# result = filter(lambda x: x > 0 and x < 100 and x % 2 == 0 and x % 3 != 0, numbers)

# Лучше:
def is_valid(x):
    return x > 0 and x < 100 and x % 2 == 0 and x % 3 != 0

result = filter(is_valid, numbers)
```

## `11.6` `map()`, `filter()`, `reduce()`. Кейсы их применения
### **`map()` — применение функции к каждому элементу**

```python
# Синтаксис: map(function, iterable)

numbers = [1, 2, 3, 4, 5]

# Возведение в квадрат
squared = list(map(lambda x: x ** 2, numbers))
print(squared)  # [1, 4, 9, 16, 25]

# Преобразование в строки
strings = list(map(str, numbers))
print(strings)  # ['1', '2', '3', '4', '5']

# Работа со строками
words = ["hello", "world", "python"]
uppercase = list(map(str.upper, words))
print(uppercase)  # ['HELLO', 'WORLD', 'PYTHON']

# map() с несколькими последовательностями
a = [1, 2, 3]
b = [10, 20, 30]
sums = list(map(lambda x, y: x + y, a, b))
print(sums)  # [11, 22, 33]
```

**Кейсы применения `map()`:**
- Преобразование типов данных
- Применение операций ко всем элементам
- Извлечение атрибутов из объектов

```python
# Практический пример: обработка цен
prices = [100, 200, 150, 300]
with_tax = list(map(lambda p: p * 1.2, prices))
print(with_tax)  # [120.0, 240.0, 180.0, 360.0]

# Извлечение имён
users = [
    {"name": "Alice", "age": 25},
    {"name": "Bob", "age": 30}
]
names = list(map(lambda u: u["name"], users))
print(names)  # ['Alice', 'Bob']
```

### **`filter()` — фильтрация элементов**

```python
# Синтаксис: filter(function, iterable)
# Оставляет только элементы, для которых function вернула True

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Только чётные
evens = list(filter(lambda x: x % 2 == 0, numbers))
print(evens)  # [2, 4, 6, 8, 10]

# Только положительные
values = [-5, 3, -2, 8, 0, -1, 7]
positives = list(filter(lambda x: x > 0, values))
print(positives)  # [3, 8, 7]

# Фильтрация строк
words = ["apple", "banana", "kiwi", "strawberry"]
short = list(filter(lambda w: len(w) <= 5, words))
print(short)  # ['apple', 'kiwi']
```

**Кейсы применения `filter()`:**
- Отбор элементов по условию
- Удаление невалидных данных
- Поиск подходящих элементов

```python
# Практический пример: валидация email
emails = ["user@mail.com", "invalid", "test@test.org", "bad@"]
valid = list(filter(lambda e: '@' in e and '.' in e.split('@')[-1], emails))
print(valid)  # ['user@mail.com', 'test@test.org']

# Фильтрация взрослых пользователей
users = [
    {"name": "Alice", "age": 25},
    {"name": "Bob", "age": 17},
    {"name": "Charlie", "age": 30}
]
adults = list(filter(lambda u: u["age"] >= 18, users))
print(adults)  # [{'name': 'Alice', 'age': 25}, {'name': 'Charlie', 'age': 30}]
```

### **`reduce()` — свёртка последовательности в одно значение**

```python
from functools import reduce

# Синтаксис: reduce(function, iterable, initial_value)
# Применяет function последовательно: result = f(f(f(a, b), c), d)

numbers = [1, 2, 3, 4, 5]

# Сумма всех элементов
total = reduce(lambda acc, x: acc + x, numbers)
print(total)  # 15

# То же самое с начальным значением
total = reduce(lambda acc, x: acc + x, numbers, 0)
print(total)  # 15

# Произведение всех элементов
product = reduce(lambda acc, x: acc * x, numbers)
print(product)  # 120

# Поиск максимума
maximum = reduce(lambda acc, x: acc if acc > x else x, numbers)
print(maximum)  # 5
```

**Кейсы применения `reduce()`:**
- Вычисление общей суммы, произведения
- Поиск минимума/максимума
- Объединение данных в одну структуру

```python
from functools import reduce

# Практический пример: подсчёт общей корзины
cart = [
    {"item": "Apple", "price": 50},
    {"item": "Banana", "price": 30},
    {"item": "Orange", "price": 40}
]
total_price = reduce(lambda acc, item: acc + item["price"], cart, 0)
print(total_price)  # 120

# Слияние словарей
dicts = [{"a": 1}, {"b": 2}, {"c": 3}]
merged = reduce(lambda acc, d: {**acc, **d}, dicts, {})
print(merged)  # {'a': 1, 'b': 2, 'c': 3}

# Построение строки
words = ["Hello", "World", "Python"]
sentence = reduce(lambda acc, word: acc + " " + word, words)
print(sentence)  # Hello World Python
```

### **Комбинирование map, filter, reduce**

```python
from functools import reduce

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Задача: сумма квадратов чётных чисел
result = reduce(
    lambda acc, x: acc + x,
    map(lambda x: x ** 2,
        filter(lambda x: x % 2 == 0, numbers)
    ),
    0
)
print(result)  # 220 (2²+4²+6²+8²+10² = 4+16+36+64+100)

# Более читаемый вариант
evens = filter(lambda x: x % 2 == 0, numbers)
squared = map(lambda x: x ** 2, evens)
total = reduce(lambda acc, x: acc + x, squared, 0)
print(total)  # 220
```

## `11.7` `any()`, `all()`, `zip()`, `enumerate()`  
### **`any()` — проверка наличия хотя бы одного `True`**

```python
# Возвращает True, если хотя бы один элемент True

# С булевыми значениями
print(any([False, False, True]))   # True
print(any([False, False, False]))  # False
print(any([True, True, True]))     # True

# С числами (0 = False, остальное = True)
print(any([0, 0, 0]))      # False
print(any([0, 0, 5]))      # True
print(any([1, 2, 3]))      # True

# С пустыми коллекциями
print(any([]))             # False
print(any([0]))            # False

# Практическое использование
numbers = [2, 4, 6, 8, 9]
has_odd = any(n % 2 != 0 for n in numbers)
print(has_odd)  # True (есть 9)

# Проверка наличия слова в списке
words = ["apple", "banana", "cherry"]
has_long_word = any(len(word) > 6 for word in words)
print(has_long_word)  # False
```

### **`all()` — проверка, что все элементы `True`**

```python
# Возвращает True, если ВСЕ элементы True

# С булевыми значениями
print(all([True, True, True]))    # True
print(all([True, False, True]))   # False
print(all([False, False, False])) # False

# С числами
print(all([1, 2, 3]))      # True (все ненулевые)
print(all([1, 0, 3]))      # False (есть 0)

# С пустыми коллекциями
print(all([]))             # True (пустая последовательность)

# Практическое использование
numbers = [2, 4, 6, 8, 10]
all_even = all(n % 2 == 0 for n in numbers)
print(all_even)  # True

# Валидация данных
ages = [18, 25, 30, 17]
all_adults = all(age >= 18 for age in ages)
print(all_adults)  # False (есть 17)

# Проверка, что все строки не пустые
strings = ["hello", "world", "python"]
all_non_empty = all(len(s) > 0 for s in strings)
print(all_non_empty)  # True
```

### **`zip()` — объединение нескольких последовательностей**

```python
# Объединяет элементы из нескольких последовательностей в кортежи

# Базовое использование
names = ["Alice", "Bob", "Charlie"]
ages = [25, 30, 35]

for name, age in zip(names, ages):
    print(f"{name} — {age} лет")
# Alice — 25 лет
# Bob — 30 лет
# Charlie — 35 лет

# Преобразование в список кортежей
pairs = list(zip(names, ages))
print(pairs)  # [('Alice', 25), ('Bob', 30), ('Charlie', 35)]

# Три и более последовательности
cities = ["Moscow", "SPb", "Kazan"]
combined = list(zip(names, ages, cities))
print(combined)  # [('Alice', 25, 'Moscow'), ('Bob', 30, 'SPb'), ('Charlie', 35, 'Kazan')]

# Разная длина — обрезается по минимальной
a = [1, 2, 3, 4, 5]
b = ['a', 'b', 'c']
result = list(zip(a, b))
print(result)  # [(1, 'a'), (2, 'b'), (3, 'c')]
```

**Практические примеры `zip()`:**

```python
# Создание словаря
keys = ["name", "age", "city"]
values = ["Alice", 25, "Moscow"]
user = dict(zip(keys, values))
print(user)  # {'name': 'Alice', 'age': 25, 'city': 'Moscow'}

# Распаковка (unzip)
pairs = [(1, 'a'), (2, 'b'), (3, 'c')]
numbers, letters = zip(*pairs)
print(numbers)  # (1, 2, 3)
print(letters)  # ('a', 'b', 'c')

# Параллельная обработка списков
prices = [100, 200, 150]
quantities = [2, 1, 3]
totals = [p * q for p, q in zip(prices, quantities)]
print(totals)  # [200, 200, 450]
```

### **`enumerate()` — получение индекса и элемента**

```python
# Возвращает кортежи (индекс, элемент)

# Базовое использование
fruits = ["apple", "banana", "cherry"]

for index, fruit in enumerate(fruits):
    print(f"{index}: {fruit}")
# 0: apple
# 1: banana
# 2: cherry

# Преобразование в список
indexed = list(enumerate(fruits))
print(indexed)  # [(0, 'apple'), (1, 'banana'), (2, 'cherry')]

# Начать с другого индекса
for index, fruit in enumerate(fruits, start=1):
    print(f"{index}. {fruit}")
# 1. apple
# 2. banana
# 3. cherry
```

**Практические примеры `enumerate()`:**

```python
# Поиск индекса элемента
words = ["hello", "world", "python"]
for i, word in enumerate(words):
    if word == "python":
        print(f"Найдено на позиции {i}")  # Найдено на позиции 2

# Изменение элементов по индексу
numbers = [10, 20, 30, 40]
for i, num in enumerate(numbers):
    numbers[i] = num * 2
print(numbers)  # [20, 40, 60, 80]

# Нумерованный список
tasks = ["Купить молоко", "Написать код", "Почитать книгу"]
for i, task in enumerate(tasks, start=1):
    print(f"{i}. {task}")
# 1. Купить молоко
# 2. Написать код
# 3. Почитать книгу

# Создание словаря с индексами
items = ["apple", "banana", "cherry"]
indexed_dict = {i: item for i, item in enumerate(items)}
print(indexed_dict)  # {0: 'apple', 1: 'banana', 2: 'cherry'}
```

**Когда использовать:**
- `any()` — проверка существования хотя бы одного подходящего элемента
- `all()` — проверка, что все элементы удовлетворяют условию
- `zip()` — параллельная обработка нескольких списков, создание пар/троек
- `enumerate()` — когда нужен и индекс, и значение элемента


# `12` Работа с файлами
### `12.0.1` Потоковый ввод и вывод данных
**Стандартные потоки** — это каналы для обмена данными между программой и внешним миром. В Python есть три основных потока:

- **stdin (standard input)** — стандартный поток ввода (клавиатура, файл, другая программа)
- **stdout (standard output)** — стандартный поток вывода (экран/консоль, файл)
- **stderr (standard error)** — стандартный поток ошибок (экран/консоль для ошибок)

Эти потоки находятся в модуле `sys`:
```python
import sys
sys.stdin   # поток ввода
sys.stdout  # поток вывода
sys.stderr  # поток ошибок
```

**Зачем нужны потоки?**
- Более быстрый ввод/вывод (важно для больших данных и спортивного программирования)
- Чтение данных из файлов или других программ без использования `input()`
- Перенаправление вывода в файл или другую программу
- Работа с большими объемами данных построчно (экономия памяти)
- Решение задач на платформах типа Codeforces, LeetCode

**Связь с обычными функциями:**
- `input()` внутри читает из `sys.stdin`
- `print()` внутри пишет в `sys.stdout`

**Основные методы stdin:**
- `sys.stdin.readline()` — читает одну строку (с `\n` в конце)
- `sys.stdin.readlines()` — читает все строки в список
- `sys.stdin.read()` — читает весь ввод как одну строку
- `for line in sys.stdin:` — читает построчно (экономит память)

**Основные методы stdout:**
- `sys.stdout.write(text)` — выводит текст (без автоматического `\n`)
- `sys.stdout.flush()` — принудительно выводит данные на экран

**Примеры:**

```python
import sys

# Сравнение обычного способа и потоков

# Обычный способ
name = input("Введите имя: ")
print(f"Привет, {name}!")

# Через потоки (аналогично)
sys.stdout.write("Введите имя: ")
sys.stdout.flush()  # принудительный вывод
name = sys.stdin.readline().strip()  # .strip() убирает \n
sys.stdout.write(f"Привет, {name}!\n")

# ВАЖНО: readline() оставляет \n в конце, нужен .strip()!
```

```python
import sys

# Чтение нескольких чисел из строки
# Ввод: 5 10 15 20

# Обычный способ
numbers = list(map(int, input().split()))

# Через stdin
line = sys.stdin.readline().strip()
numbers = list(map(int, line.split()))
print(f"Сумма: {sum(numbers)}")
```

```python
import sys

# Типичная задача: чтение N строк
# Формат ввода:
# 3
# apple
# banana
# cherry

# Обычный способ
n = int(input())
fruits = [input().strip() for _ in range(n)]

# Через stdin (быстрее!)
n = int(sys.stdin.readline())
fruits = [sys.stdin.readline().strip() for _ in range(n)]
print(fruits)  # ['apple', 'banana', 'cherry']
```

```python
import sys

# Чтение всех строк до конца ввода (неизвестное количество)

# Способ 1: readlines() (загружает все в память)
lines = sys.stdin.readlines()
lines = [line.strip() for line in lines]

# Способ 2: построчно (эффективнее для больших данных!)
for line in sys.stdin:
    line = line.strip()
    # обработка каждой строки
    print(line)
```

```python
import sys

# Быстрый шаблон для задач (спортивное программирование)
# Заменяем input() на sys.stdin.readline для ускорения

input = sys.stdin.readline  # теперь input() работает быстрее!

# Решение задачи A + B
# Ввод:
# 1 2
# 3 4
# 5 6

for line in sys.stdin:
    a, b = map(int, line.split())
    print(a + b)  # можно использовать print или sys.stdout.write

# Вывод:
# 3
# 7
# 11
```

```python
import sys

# Перенаправление вывода в файл

# Сохраняем оригинальный stdout
original_stdout = sys.stdout

# Перенаправляем в файл
with open('output.txt', 'w', encoding='utf-8') as f:
    sys.stdout = f
    print("Это пойдет в файл, а не на экран")
    print("Все print() теперь пишут в файл")

# Восстанавливаем stdout
sys.stdout = original_stdout
print("Это снова на экране")
```

**Шпаргалка по stdin/stdout:**

**Чтение:**
```python
import sys

sys.stdin.readline()              # одна строка с \n
sys.stdin.readline().strip()      # одна строка без \n
sys.stdin.readlines()             # все строки списком
sys.stdin.read()                  # весь текст сразу
for line in sys.stdin:            # построчно (экономит память)
```

**Запись:**
```python
import sys

sys.stdout.write("текст")         # без автоматического \n
sys.stdout.write("текст\n")       # с \n вручную
print("текст")                    # аналог write с автоматическим \n
```

**Быстрый шаблон:**
```python
import sys
input = sys.stdin.readline        # ускоряем input()

n = int(input())
numbers = list(map(int, input().split()))
print(sum(numbers))
```

**Когда использовать:**
- ✅ `input()` / `print()` — обычные программы, малые данные
- ✅ `sys.stdin` / `sys.stdout` — большие данные, задачи на скорость, файлы, спортивное программирование

**Важно:**
- `readline()` оставляет `\n` → всегда используйте `.strip()`
- `for line in sys.stdin:` — самый эффективный способ для больших данных
- Замена `input = sys.stdin.readline` ускоряет работу программы


## `12.1` TXT
[Базовая работа с файлами](https://www.youtube.com/watch?v=t-xQAhLNYSs)

### `12.1.1` (`*`) Что такое контекстный менеджер?
[Контекстный менеджер](https://www.youtube.com/watch?v=ycVlsU_c4Mg)

`Контекстный менеджер` — это механизм в Python, который автоматически выполняет определённые действия до и после блока кода. Используется с ключевым словом `with` и гарантирует, что ресурсы будут корректно освобождены даже при возникновении ошибок.

**Зачем нужен:**
- Автоматически закрывает файлы
- Освобождает ресурсы (соединения, блокировки)
- Выполняет cleanup-код даже при ошибках
- Делает код короче и безопаснее

**Без контекстного менеджера (плохо):**

```python
# Открываем файл вручную
file = open('data.txt', 'r')

try:
    content = file.read()
    print(content)
finally:
    file.close()  # ОБЯЗАТЕЛЬНО нужно закрыть!
    # Если забыть — утечка ресурсов

# Проблемы:
# 1. Легко забыть закрыть файл
# 2. Много кода для простой операции
# 3. Нужно помнить про try-finally
```

**С контекстным менеджером (хорошо):**

```python
# Контекстный менеджер автоматически закроет файл
with open('data.txt', 'r') as file:
    content = file.read()
    print(content)
# Файл автоматически закрыт здесь, даже если была ошибка!

# Преимущества:
# 1. Короче и понятнее
# 2. Файл всегда закроется
# 3. Работает даже при ошибках
```

**Как это работает:**

```python
# 1. При входе в блок with — открывается файл
# 2. Выполняется код внутри блока
# 3. При выходе из блока — файл закрывается автоматически

with open('data.txt', 'r') as file:  # ← Открытие (вход)
    content = file.read()             # ← Работа с файлом
    print(content)
# ← Автоматическое закрытие (выход)

# Даже если произошла ошибка
with open('data.txt', 'r') as file:
    content = file.read()
    raise ValueError("Ошибка!")  # Ошибка!
    # Файл всё равно будет закрыт
```

**Практические примеры:**

**Работа с файлами:**

```python
# Чтение файла
with open('input.txt', 'r', encoding='utf-8') as f:
    data = f.read()
    print(data)
# Файл закрыт

# Запись в файл
with open('output.txt', 'w', encoding='utf-8') as f:
    f.write("Hello, World!")
# Файл закрыт и сохранён

# Работа с несколькими файлами
with open('input.txt', 'r') as f_in, open('output.txt', 'w') as f_out:
    content = f_in.read()
    f_out.write(content.upper())
# Оба файла закрыты
```

**Сравнение с ручным управлением:**

```python
# БЕЗ контекстного менеджера — опасно!
f = open('data.txt', 'w')
f.write("some data")
# Если программа упадёт здесь, файл не закроется!
# Данные могут не сохраниться!
f.close()

# С контекстным менеджером — безопасно
with open('data.txt', 'w') as f:
    f.write("some data")
    # Даже если ошибка здесь, файл сохранится и закроется
# Файл гарантированно закрыт и сохранён
```

**Что происходит за кулисами:**

```python
# Когда мы пишем:
with open('file.txt', 'r') as f:
    content = f.read()

# Python делает примерно это:
f = open('file.txt', 'r')
try:
    content = f.read()
finally:
    f.close()  # Всегда выполнится

# Но контекстный менеджер делает это автоматически!
```

**Создание простого контекстного менеджера:**

```python
from contextlib import contextmanager

@contextmanager
def timer():
    """Измеряет время выполнения кода"""
    import time
    start = time.time()
    print("Таймер запущен")
    
    try:
        yield  # Здесь выполняется код внутри with
    finally:
        elapsed = time.time() - start
        print(f"Время выполнения: {elapsed:.2f} сек")

# Использование
with timer():
    # Код, время выполнения которого измеряем
    total = sum(range(1000000))
    print(f"Сумма: {total}")

# Вывод:
# Таймер запущен
# Сумма: 499999500000
# Время выполнения: 0.05 сек
```

**Другие примеры контекстных менеджеров:**

```python
# Временное изменение директории
import os
from contextlib import contextmanager

@contextmanager
def change_dir(path):
    """Временно меняет директорию"""
    original = os.getcwd()
    os.chdir(path)
    print(f"Перешли в {path}")
    
    try:
        yield
    finally:
        os.chdir(original)
        print(f"Вернулись в {original}")

# Использование
print(f"Начальная директория: {os.getcwd()}")
with change_dir('/tmp'):
    print(f"Внутри with: {os.getcwd()}")
print(f"После with: {os.getcwd()}")

# Вывод:
# Начальная директория: /home/user
# Перешли в /tmp
# Внутри with: /tmp
# Вернулись в /home/user
# После with: /home/user
```

**Ключевые моменты:**
- **`with`** — ключевое слово для использования контекстного менеджера
- **Автоматическое освобождение ресурсов** — не нужно вручную закрывать файлы
- **Безопасность** — ресурсы освобождаются даже при ошибках
- **Читаемость** — код короче и понятнее
- **Основное применение** — работа с файлами, но можно использовать для любых ресурсов

**Когда использовать:**
- Работа с файлами (всегда!)
- Работа с БД соединениями
- Блокировки в многопоточности
- Временные изменения состояния
- Любые ресурсы, требующие cleanup

### `12.1.2` Какие есть функции и методы для работы с TXT в Python?
Для работы с текстовыми файлами в Python используется встроенная функция `open()`, которая возвращает файловый объект. Этот объект имеет методы для чтения и записи данных.

**Основная функция:**
```python
open(file, mode='r', encoding=None)
```

**Параметры:**
- `file` — путь к файлу (строка)
- `mode` — режим открытия файла (по умолчанию `'r'`)
- `encoding` — кодировка (рекомендуется `'utf-8'` для русского текста)

**Режимы открытия файла:**

| Режим | Описание | Что делает |
|-------|----------|------------|
| `'r'` | Read (чтение) | Открывает для чтения. Ошибка если файла нет |
| `'w'` | Write (запись) | Открывает для записи. Создает новый или **перезаписывает** существующий |
| `'a'` | Append (добавление) | Открывает для добавления в конец. Создает файл если его нет |
| `'x'` | Exclusive creation | Создает новый файл. Ошибка если файл уже существует |
| `'r+'` | Read + Write | Чтение и запись |
| `'w+'` | Write + Read | Запись и чтение (перезаписывает файл) |
| `'a+'` | Append + Read | Добавление и чтение |

**Дополнительные модификаторы:**
- `'b'` — бинарный режим (например, `'rb'`, `'wb'` для изображений, видео)
- `'t'` — текстовый режим (по умолчанию, можно не указывать)

**Основные методы файлового объекта:**

**Чтение:**
- `read(size)` — читает весь файл или `size` символов
- `readline()` — читает одну строку
- `readlines()` — читает все строки в список
- Итерация: `for line in file:` — читает построчно

**Запись:**
- `write(text)` — записывает строку (не добавляет `\n` автоматически!)
- `writelines(lines)` — записывает список строк

**Управление:**
- `close()` — закрывает файл (освобождает ресурсы)
- `flush()` — принудительно записывает буфер на диск
- `seek(position)` — перемещает указатель в файле
- `tell()` — возвращает текущую позицию указателя

**Примеры:**

#### Открытие и закрытие файла

```python
# Способ 1: вручную (НЕ рекомендуется!)
file = open('example.txt', 'r', encoding='utf-8')
content = file.read()
file.close()  # ВАЖНО: нужно закрыть файл!

# Проблема: если произойдет ошибка, файл не закроется

# Способ 2: с контекстным менеджером (ПРАВИЛЬНО!)
with open('example.txt', 'r', encoding='utf-8') as file:
    content = file.read()
# Файл автоматически закроется после блока with

print(content)
```

#### Методы чтения файла

```python
# read() - читает весь файл целиком
with open('example.txt', 'r', encoding='utf-8') as file:
    content = file.read()  # вся строка
    print(content)

# read(size) - читает определенное количество символов
with open('example.txt', 'r', encoding='utf-8') as file:
    first_10_chars = file.read(10)  # первые 10 символов
    print(first_10_chars)

# readline() - читает одну строку
with open('example.txt', 'r', encoding='utf-8') as file:
    line1 = file.readline()  # первая строка с \n
    line2 = file.readline()  # вторая строка с \n
    print(line1.strip())  # .strip() убирает \n
    print(line2.strip())

# readlines() - читает все строки в список
with open('example.txt', 'r', encoding='utf-8') as file:
    lines = file.readlines()  # ['строка1\n', 'строка2\n', ...]
    print(lines)
    
# Убрать \n из всех строк
lines = [line.strip() for line in lines]
print(lines)  # ['строка1', 'строка2', ...]

# Построчное чтение (самый эффективный способ!)
with open('example.txt', 'r', encoding='utf-8') as file:
    for line in file:  # читает по одной строке (экономит память)
        print(line.strip())  # обработка каждой строки
```

#### Методы записи в файл

```python
# write() - записывает строку
with open('output.txt', 'w', encoding='utf-8') as file:
    file.write("Первая строка\n")  # \n нужно добавлять вручную!
    file.write("Вторая строка\n")
    file.write("Третья строка")

# writelines() - записывает список строк
lines = ["строка 1\n", "строка 2\n", "строка 3\n"]
with open('output.txt', 'w', encoding='utf-8') as file:
    file.writelines(lines)  # НЕ добавляет \n автоматически!

# Запись с форматированием
name = "Иван"
age = 30
with open('user.txt', 'w', encoding='utf-8') as file:
    file.write(f"Имя: {name}\n")
    file.write(f"Возраст: {age}\n")

# Режим 'a' - добавление в конец файла
with open('log.txt', 'a', encoding='utf-8') as file:
    file.write("Новая запись в лог\n")  # добавляется в конец
```

#### Практические примеры

```python
# Пример 1: Чтение и подсчет слов в файле
with open('text.txt', 'r', encoding='utf-8') as file:
    content = file.read()
    words = content.split()
    print(f"Количество слов: {len(words)}")

# Пример 2: Чтение файла построчно и фильтрация
with open('data.txt', 'r', encoding='utf-8') as file:
    for line in file:
        line = line.strip()
        if line:  # пропускаем пустые строки
            print(line.upper())  # выводим в верхнем регистре

# Пример 3: Копирование файла
with open('source.txt', 'r', encoding='utf-8') as source:
    with open('destination.txt', 'w', encoding='utf-8') as dest:
        content = source.read()
        dest.write(content)

# Пример 4: Запись списка в файл
fruits = ["яблоко", "банан", "груша", "киви"]
with open('fruits.txt', 'w', encoding='utf-8') as file:
    for fruit in fruits:
        file.write(fruit + '\n')  # добавляем \n вручную

# Пример 5: Чтение файла в список
with open('fruits.txt', 'r', encoding='utf-8') as file:
    fruits = [line.strip() for line in file]  # читаем и убираем \n
print(fruits)  # ['яблоко', 'банан', 'груша', 'киви']
```

#### Обработка ошибок при работе с файлами

```python
# Проверка существования файла
import os

filename = 'data.txt'

if os.path.exists(filename):
    with open(filename, 'r', encoding='utf-8') as file:
        content = file.read()
        print(content)
else:
    print(f"Файл {filename} не найден")

# Обработка исключений
try:
    with open('nonexistent.txt', 'r', encoding='utf-8') as file:
        content = file.read()
except FileNotFoundError:
    print("Ошибка: файл не найден")
except PermissionError:
    print("Ошибка: нет прав доступа к файлу")
except Exception as e:
    print(f"Произошла ошибка: {e}")

# Безопасная запись (режим 'x')
try:
    with open('new_file.txt', 'x', encoding='utf-8') as file:
        file.write("Содержимое нового файла")
    print("Файл успешно создан")
except FileExistsError:
    print("Файл уже существует, не перезаписываем")
```

#### Дополнительные полезные методы

```python
# seek() и tell() - управление позицией в файле
with open('example.txt', 'r', encoding='utf-8') as file:
    print(file.tell())  # 0 - начало файла
    
    file.read(10)  # читаем 10 символов
    print(file.tell())  # 10 - текущая позиция
    
    file.seek(0)  # возвращаемся в начало
    print(file.tell())  # 0
    
    content = file.read()  # читаем с начала

# flush() - принудительная запись
with open('buffer.txt', 'w', encoding='utf-8') as file:
    file.write("Данные")
    file.flush()  # сразу записываем на диск
    # без flush() данные могут остаться в буфере
```

**Шпаргалка по работе с TXT файлами:**

**Открытие файла:**
```python
with open('file.txt', 'r', encoding='utf-8') as file:
    # работа с файлом
# файл автоматически закрывается
```

**Чтение:**
```python
file.read()           # весь файл
file.read(10)         # 10 символов
file.readline()       # одна строка с \n
file.readlines()      # все строки списком
for line in file:     # построчно (лучше всего!)
```

**Запись:**
```python
file.write("текст")        # записать строку (без \n!)
file.write("текст\n")      # записать с переносом
file.writelines(lines)     # записать список строк
```

**Режимы:**
```python
'r'  # чтение (файл должен существовать)
'w'  # запись (перезаписывает файл!)
'a'  # добавление в конец
'x'  # создание нового (ошибка если существует)
```

**Важные советы:**
- ✅ Всегда используйте `encoding='utf-8'` для русского текста
- ✅ Используйте контекстный менеджер `with` — файл закроется автоматически
- ✅ `write()` не добавляет `\n` автоматически — добавляйте вручную!
- ✅ `readline()` и `readlines()` оставляют `\n` — используйте `.strip()`
- ✅ Для больших файлов используйте `for line in file:` вместо `read()`
- ❌ Не забывайте про режим: `'w'` полностью перезаписывает файл!


## `12.2` (`*`) JSON
[Видео про JSON](https://www.youtube.com/watch?v=-51jxlQaxyA)

### `12.2.1` Что такое JSON? Для чего он нужен?
`JSON (JavaScript Object Notation)` — это текстовый формат для хранения и передачи структурированных данных. Он легко читается человеком и компьютером, поэтому широко используется для обмена данными между приложениями.

**Основные характеристики:**
- Текстовый формат (строка)
- Язык-независимый (работает везде)
- Простая и понятная структура
- Поддерживает вложенность

**Пример JSON:**

```json
{
  "name": "Alice",
  "age": 25,
  "city": "Moscow",
  "skills": ["Python", "JavaScript", "SQL"],
  "active": true,
  "address": {
    "street": "Main St",
    "building": 10
  }
}
```

**Для чего нужен JSON:**
- **API и веб-сервисы** — обмен данными между клиентом и сервером
- **Конфигурационные файлы** — хранение настроек приложений
- **Хранение данных** — сохранение структурированной информации
- **Логирование** — структурированные логи
- **Передача данных** — между разными языками программирования

**Где используется:**
```python
# REST API
# GET /api/users/123
# Response: {"id": 123, "name": "Alice", "email": "alice@mail.com"}

# Конфигурация
# config.json: {"debug": true, "port": 8080, "database": "localhost"}

# Сохранение данных
# data.json: [{"product": "Laptop", "price": 1000}, {"product": "Mouse", "price": 20}]
```

### `12.2.2` Какие есть функции и методы для работы с JSON в Python?
Python имеет встроенный модуль `json` для работы с JSON-данными.

**Основные функции:**
**`json.dumps()` — сериализация Python → JSON (строка)**

```python
import json

# Python объект → JSON строка
data = {
    "name": "Alice",
    "age": 25,
    "skills": ["Python", "SQL"]
}

json_string = json.dumps(data)
print(json_string)  # {"name": "Alice", "age": 25, "skills": ["Python", "SQL"]}
print(type(json_string))  # <class 'str'>

# С форматированием (pretty print)
json_formatted = json.dumps(data, indent=4)
print(json_formatted)
# {
#     "name": "Alice",
#     "age": 25,
#     "skills": [
#         "Python",
#         "SQL"
#     ]
# }

# Сортировка ключей
json_sorted = json.dumps(data, indent=2, sort_keys=True)
print(json_sorted)
# {
#   "age": 25,
#   "name": "Alice",
#   "skills": [
#     "Python",
#     "SQL"
#   ]
# }
```

**`json.loads()` — десериализация JSON (строка) → Python**

```python
import json

# JSON строка → Python объект
json_string = '{"name": "Bob", "age": 30, "active": true}'
data = json.loads(json_string)

print(data)  # {'name': 'Bob', 'age': 30, 'active': True}
print(type(data))  # <class 'dict'>
print(data["name"])  # Bob

# С вложенными структурами
json_complex = '''
{
    "user": "Alice",
    "scores": [85, 90, 95],
    "settings": {
        "theme": "dark",
        "notifications": true
    }
}
'''
parsed = json.loads(json_complex)
print(parsed["scores"])  # [85, 90, 95]
print(parsed["settings"]["theme"])  # dark
```

**`json.dump()` — запись в файл**

```python
import json

# Запись Python объекта в JSON файл
data = {
    "products": [
        {"name": "Laptop", "price": 1000},
        {"name": "Mouse", "price": 20}
    ]
}

# Сохранение в файл
with open('data.json', 'w', encoding='utf-8') as file:
    json.dump(data, file, indent=4, ensure_ascii=False)

# Файл data.json:
# {
#     "products": [
#         {
#             "name": "Laptop",
#             "price": 1000
#         },
#         {
#             "name": "Mouse",
#             "price": 20
#         }
#     ]
# }
```

**`json.load()` — чтение из файла**

```python
import json

# Чтение JSON из файла
with open('data.json', 'r', encoding='utf-8') as file:
    data = json.load(file)

print(data)  # {'products': [{'name': 'Laptop', 'price': 1000}, ...]}
print(data["products"][0]["name"])  # Laptop
```

**Параметры функций:**

```python
import json

data = {"name": "Анна", "city": "Москва"}

# indent — отступы для читаемости
json.dumps(data, indent=2)

# sort_keys — сортировка ключей
json.dumps(data, sort_keys=True)

# ensure_ascii — кириллица и спецсимволы
json.dumps(data, ensure_ascii=False)  # {"name": "Анна", ...}
json.dumps(data, ensure_ascii=True)   # {"name": "\u0410\u043d\u043d\u0430", ...}

# separators — разделители
json.dumps(data, separators=(',', ':'))  # Компактный вывод без пробелов
# {"name":"Анна","city":"Москва"}
```

**Обработка ошибок:**

```python
import json

# Невалидный JSON
invalid_json = '{"name": "Alice", "age": 25'  # Отсутствует }

try:
    data = json.loads(invalid_json)
except json.JSONDecodeError as e:
    print(f"Ошибка парсинга JSON: {e}")
    # Ошибка парсинга JSON: Expecting ',' delimiter: line 1 column 29 (char 28)

# Проверка валидности JSON
def is_valid_json(json_string):
    try:
        json.loads(json_string)
        return True
    except json.JSONDecodeError:
        return False

print(is_valid_json('{"name": "Alice"}'))  # True
print(is_valid_json('{"name": Alice}'))    # False (нет кавычек)
```

### `12.2.3` Как происходит конвертация типов данных при сериализации?
При преобразовании Python ↔ JSON типы данных автоматически конвертируются.

**Таблица соответствия типов:**

| Python | JSON | Обратно в Python |
|--------|------|------------------|
| `dict` | `object` | `dict` |
| `list`, `tuple` | `array` | `list` |
| `str` | `string` | `str` |
| `int`, `float` | `number` | `int`, `float` |
| `True` | `true` | `True` |
| `False` | `false` | `False` |
| `None` | `null` | `None` |

**Примеры конвертации:**

```python
import json

# Python → JSON
data = {
    "name": "Alice",           # str → string
    "age": 25,                 # int → number
    "height": 1.65,            # float → number
    "active": True,            # bool → true/false
    "address": None,           # None → null
    "skills": ["Python", "SQL"], # list → array
    "scores": (85, 90, 95),    # tuple → array
    "metadata": {"key": "value"} # dict → object
}

json_str = json.dumps(data, indent=2)
print(json_str)
# {
#   "name": "Alice",
#   "age": 25,
#   "height": 1.65,
#   "active": true,
#   "address": null,
#   "skills": ["Python", "SQL"],
#   "scores": [85, 90, 95],
#   "metadata": {"key": "value"}
# }

# JSON → Python
parsed = json.loads(json_str)
print(type(parsed["skills"]))   # <class 'list'> (был list)
print(type(parsed["scores"]))   # <class 'list'> (был tuple, стал list!)
print(parsed["address"])        # None (был null)
print(parsed["active"])         # True (был true)
```

**Важные моменты конвертации:**
**1. Кортежи становятся списками**

```python
import json

data = {"numbers": (1, 2, 3)}  # tuple
json_str = json.dumps(data)
parsed = json.loads(json_str)

print(type(parsed["numbers"]))  # <class 'list'> (потерялся тип tuple!)
print(parsed["numbers"])        # [1, 2, 3]
```

 **2. Множества не поддерживаются**

```python
import json

data = {"tags": {"python", "coding"}}  # set

try:
    json.dumps(data)
except TypeError as e:
    print(f"Ошибка: {e}")
    # Ошибка: Object of type set is not JSON serializable

# Решение: конвертировать в list
data_fixed = {"tags": list(data["tags"])}
print(json.dumps(data_fixed))  # {"tags": ["python", "coding"]}
```

**3. Пользовательские объекты не поддерживаются**

```python
import json

class User:
    def __init__(self, name, age):
        self.name = name
        self.age = age

user = User("Alice", 25)

try:
    json.dumps(user)
except TypeError as e:
    print(f"Ошибка: {e}")
    # Ошибка: Object of type User is not JSON serializable

# Решение 1: конвертировать в словарь вручную
user_dict = {"name": user.name, "age": user.age}
print(json.dumps(user_dict))  # {"name": "Alice", "age": 25}

# Решение 2: использовать __dict__
print(json.dumps(user.__dict__))  # {"name": "Alice", "age": 25}

# Решение 3: кастомный encoder
class UserEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, User):
            return {"name": obj.name, "age": obj.age}
        return super().default(obj)

print(json.dumps(user, cls=UserEncoder))  # {"name": "Alice", "age": 25}
```

**4. Специальные числа**

```python
import json

# Infinity и NaN не поддерживаются по умолчанию
data = {"value": float('inf')}

try:
    json.dumps(data)
except ValueError as e:
    print(f"Ошибка: {e}")
    # Ошибка: Out of range float values are not JSON compliant

# Разрешить специальные значения
json_str = json.dumps(data, allow_nan=True)
print(json_str)  # {"value": Infinity}
```

**Практические примеры:**

```python
import json

# Работа с API
response_data = {
    "status": "success",
    "users": [
        {"id": 1, "name": "Alice", "active": True},
        {"id": 2, "name": "Bob", "active": False}
    ],
    "total": 2
}

# Отправка данных
json_response = json.dumps(response_data)
print(json_response)

# Получение данных
parsed_response = json.loads(json_response)
for user in parsed_response["users"]:
    if user["active"]:
        print(f"Активный пользователь: {user['name']}")

# Сохранение конфигурации
config = {
    "debug": True,
    "port": 8080,
    "database": {
        "host": "localhost",
        "name": "mydb"
    }
}

with open('config.json', 'w') as f:
    json.dump(config, f, indent=4)

# Чтение конфигурации
with open('config.json', 'r') as f:
    loaded_config = json.load(f)
    print(f"Порт: {loaded_config['port']}")
    print(f"БД: {loaded_config['database']['host']}")
```

**Ключевые моменты:**
- `json.dumps()` / `json.loads()` — работа со строками
- `json.dump()` / `json.load()` — работа с файлами
- JSON поддерживает: dict, list, str, int, float, bool, None
- JSON НЕ поддерживает: set, tuple (конвертируется в list), пользовательские объекты
- Используйте `indent` для читаемости, `ensure_ascii=False` для кириллицы


## `12.3` CSV
[Видео про CSV](https://www.youtube.com/watch?v=q5uM4VKywbA)

### `12.3.1` Что такое CSV? Для чего он нужен?
**CSV (Comma-Separated Values)** — это текстовый формат для хранения табличных данных, где значения разделены запятыми (или другими разделителями).

**Структура CSV файла:**
```
имя,возраст,город
Иван,30,Москва
Мария,25,Санкт-Петербург
Петр,35,Казань
```

Первая строка обычно содержит **заголовки** (названия столбцов), а остальные строки — **данные**.

**Особенности CSV:**
- Простой текстовый формат (можно открыть блокнотом)
- Легко читается и пишется программами
- Компактный размер файла
- Универсальный — поддерживается Excel, Google Sheets, базами данных
- Можно использовать разные разделители: `,` `;` `\t` (табуляция) `|`

**Для чего нужен CSV:**
- 📊 **Экспорт/импорт данных** из Excel, Google Sheets, баз данных
- 📈 **Обмен данными** между разными программами и системами
- 💾 **Хранение табличных данных** (пользователи, продажи, логи)
- 🔬 **Анализ данных** — популярный формат для data science
- 📋 **Отчеты и статистика** — легко обрабатывать и генерировать

**Примеры использования:**
- Экспорт списка пользователей из базы данных
- Загрузка прайс-листов товаров
- Логи событий и аналитика
- Обмен данными между компаниями
- Датасеты для машинного обучения

**Примеры CSV файлов:**

```csv
# Простой CSV с запятой
product,price,quantity
Apple,50,100
Banana,30,200
Orange,45,150
```

```csv
# CSV с точкой с запятой (часто в русской локали Excel)
название;цена;количество
Яблоко;50;100
Банан;30;200
Апельсин;45;150
```

```csv
# CSV с кавычками (когда в данных есть запятые)
name,description,price
"Smith, John","Manager, Sales Department",5000
"Doe, Jane","Developer, IT",6000
```

### `12.3.2` Какие есть функции и методы для работы с CSV в Python?
В Python есть встроенный модуль `csv` для работы с CSV файлами. Он предоставляет удобные функции для чтения и записи табличных данных.

**Основные объекты модуля csv:**

**Для чтения:**
- `csv.reader(file, delimiter=',')` — читает CSV построчно, возвращает списки
- `csv.DictReader(file, delimiter=',')` — читает CSV, возвращает словари (ключи — заголовки)

**Для записи:**
- `csv.writer(file, delimiter=',')` — записывает данные в CSV
- `csv.DictWriter(file, fieldnames, delimiter=',')` — записывает словари в CSV

**Основные параметры:**
- `delimiter` — разделитель (по умолчанию `,`)
- `quotechar` — символ для кавычек (по умолчанию `"`)
- `lineterminator` — символ конца строки (по умолчанию `\r\n`)
- `skipinitialspace` — пропускать пробелы после разделителя

#### Чтение CSV с csv.reader

**Примеры:**

```python
import csv

# csv.reader - читает CSV как списки строк
with open('data.csv', 'r', encoding='utf-8') as file:
    reader = csv.reader(file)
    
    # Читаем первую строку (заголовки)
    headers = next(reader)
    print(f"Заголовки: {headers}")
    
    # Читаем остальные строки
    for row in reader:
        print(row)  # каждая строка - это список

# Пример вывода:
# Заголовки: ['name', 'age', 'city']
# ['Иван', '30', 'Москва']
# ['Мария', '25', 'Санкт-Петербург']
```

```python
import csv

# Чтение CSV с другим разделителем
with open('data.csv', 'r', encoding='utf-8') as file:
    reader = csv.reader(file, delimiter=';')  # точка с запятой
    
    for row in reader:
        print(row)

# Чтение всех данных сразу
with open('data.csv', 'r', encoding='utf-8') as file:
    reader = csv.reader(file)
    data = list(reader)  # список всех строк
    
print(f"Всего строк: {len(data)}")
print(f"Первая строка: {data[0]}")
```

#### Чтение CSV с csv.DictReader (удобнее!)

```python
import csv

# csv.DictReader - читает CSV как словари
# Первая строка автоматически становится ключами
with open('users.csv', 'r', encoding='utf-8') as file:
    reader = csv.DictReader(file)
    
    for row in reader:
        # row - это словарь {'name': 'Иван', 'age': '30', 'city': 'Москва'}
        print(f"Имя: {row['name']}, Возраст: {row['age']}, Город: {row['city']}")

# Пример вывода:
# Имя: Иван, Возраст: 30, Город: Москва
# Имя: Мария, Возраст: 25, Город: Санкт-Петербург

# DictReader с другим разделителем
with open('data.csv', 'r', encoding='utf-8') as file:
    reader = csv.DictReader(file, delimiter=';')
    
    for row in reader:
        print(row)  # словарь для каждой строки
```

#### Запись CSV с csv.writer

```python
import csv

# csv.writer - запись списков в CSV
with open('output.csv', 'w', encoding='utf-8', newline='') as file:
    writer = csv.writer(file)
    
    # Записываем заголовки
    writer.writerow(['name', 'age', 'city'])
    
    # Записываем данные
    writer.writerow(['Иван', 30, 'Москва'])
    writer.writerow(['Мария', 25, 'Санкт-Петербург'])
    writer.writerow(['Петр', 35, 'Казань'])

# ВАЖНО: newline='' нужен для корректной записи в Windows!

# Запись нескольких строк сразу
data = [
    ['Анна', 28, 'Новосибирск'],
    ['Олег', 32, 'Екатеринбург'],
    ['Елена', 27, 'Самара']
]

with open('output.csv', 'w', encoding='utf-8', newline='') as file:
    writer = csv.writer(file)
    writer.writerow(['name', 'age', 'city'])  # заголовки
    writer.writerows(data)  # writerows для списка строк

# Запись с другим разделителем
with open('output.csv', 'w', encoding='utf-8', newline='') as file:
    writer = csv.writer(file, delimiter=';')
    writer.writerow(['название', 'цена', 'количество'])
    writer.writerow(['Яблоко', 50, 100])
```

#### Запись CSV с csv.DictWriter (удобнее!)

```python
import csv

# csv.DictWriter - запись словарей в CSV
data = [
    {'name': 'Иван', 'age': 30, 'city': 'Москва'},
    {'name': 'Мария', 'age': 25, 'city': 'Санкт-Петербург'},
    {'name': 'Петр', 'age': 35, 'city': 'Казань'}
]

with open('users.csv', 'w', encoding='utf-8', newline='') as file:
    # Указываем названия полей (заголовки)
    fieldnames = ['name', 'age', 'city']
    writer = csv.DictWriter(file, fieldnames=fieldnames)
    
    # Записываем заголовки
    writer.writeheader()
    
    # Записываем строки
    for row in data:
        writer.writerow(row)

# Или записываем все сразу
with open('users.csv', 'w', encoding='utf-8', newline='') as file:
    fieldnames = ['name', 'age', 'city']
    writer = csv.DictWriter(file, fieldnames=fieldnames)
    
    writer.writeheader()
    writer.writerows(data)  # writerows для списка словарей
```

#### Практические примеры

```python
import csv

# Пример 1: Фильтрация данных из CSV
with open('users.csv', 'r', encoding='utf-8') as file:
    reader = csv.DictReader(file)
    
    # Находим всех старше 30 лет
    adults = [row for row in reader if int(row['age']) > 30]

print(f"Найдено {len(adults)} пользователей старше 30 лет")

# Пример 2: Обработка и сохранение в новый CSV
with open('prices.csv', 'r', encoding='utf-8') as infile:
    reader = csv.DictReader(infile)
    
    with open('discounted.csv', 'w', encoding='utf-8', newline='') as outfile:
        fieldnames = ['product', 'old_price', 'new_price']
        writer = csv.DictWriter(outfile, fieldnames=fieldnames)
        writer.writeheader()
        
        for row in reader:
            # Применяем скидку 10%
            old_price = float(row['price'])
            new_price = old_price * 0.9
            
            writer.writerow({
                'product': row['product'],
                'old_price': old_price,
                'new_price': round(new_price, 2)
            })

# Пример 3: Подсчет статистики из CSV
with open('sales.csv', 'r', encoding='utf-8') as file:
    reader = csv.DictReader(file)
    
    total_sales = 0
    product_count = 0
    
    for row in reader:
        total_sales += float(row['amount'])
        product_count += 1
    
    average = total_sales / product_count if product_count > 0 else 0
    
print(f"Всего продаж: {total_sales} руб")
print(f"Количество товаров: {product_count}")
print(f"Средний чек: {average:.2f} руб")
```

```python
import csv

# Пример 4: Объединение нескольких CSV файлов
output_data = []

# Читаем первый файл
with open('file1.csv', 'r', encoding='utf-8') as file:
    reader = csv.DictReader(file)
    output_data.extend(list(reader))

# Читаем второй файл
with open('file2.csv', 'r', encoding='utf-8') as file:
    reader = csv.DictReader(file)
    output_data.extend(list(reader))

# Записываем объединенные данные
with open('combined.csv', 'w', encoding='utf-8', newline='') as file:
    if output_data:
        fieldnames = output_data[0].keys()
        writer = csv.DictWriter(file, fieldnames=fieldnames)
        writer.writeheader()
        writer.writerows(output_data)

print(f"Объединено {len(output_data)} записей")
```

**Шпаргалка по работе с CSV:**

**Чтение:**
```python
import csv

# Как списки (простой способ)
with open('data.csv', 'r', encoding='utf-8') as file:
    reader = csv.reader(file, delimiter=',')
    for row in reader:
        print(row)  # список: ['value1', 'value2', ...]

# Как словари (удобнее!)
with open('data.csv', 'r', encoding='utf-8') as file:
    reader = csv.DictReader(file, delimiter=',')
    for row in reader:
        print(row)  # словарь: {'col1': 'value1', 'col2': 'value2', ...}
```

**Запись:**
```python
import csv

# Запись списков
with open('output.csv', 'w', encoding='utf-8', newline='') as file:
    writer = csv.writer(file, delimiter=',')
    writer.writerow(['header1', 'header2'])  # заголовки
    writer.writerow(['value1', 'value2'])    # данные

# Запись словарей (удобнее!)
with open('output.csv', 'w', encoding='utf-8', newline='') as file:
    fieldnames = ['name', 'age']
    writer = csv.DictWriter(file, fieldnames=fieldnames)
    writer.writeheader()
    writer.writerow({'name': 'Иван', 'age': 30})
```

**Основные методы:**
- `reader.next()` или `next(reader)` — читает следующую строку
- `writer.writerow(row)` — записывает одну строку
- `writer.writerows(rows)` — записывает несколько строк
- `writer.writeheader()` — записывает заголовки (только DictWriter)

**Важные советы:**
- ✅ Используйте `encoding='utf-8'` для корректной работы с русским текстом
- ✅ Используйте `newline=''` при записи (особенно важно для Windows!)
- ✅ `DictReader` и `DictWriter` удобнее, чем обычные `reader` и `writer`
- ✅ Для чтения больших файлов используйте построчную обработку (не `list(reader)`)
- ✅ Проверяйте разделитель: `,` или `;` (зависит от локали Excel)
- ⚠️ Все данные из CSV читаются как **строки** — преобразуйте типы вручную: `int()`, `float()`

----

# `13` Работа с датой и временем
## `13.1` Посмотреть модуль `datetime` и различные типы данных в нем: `date`, `time`, etc.
Модуль `datetime` предоставляет классы для работы с датами и временем в Python. Это встроенный модуль, его не нужно устанавливать.

**Основные типы данных в модуле datetime:**

1. **`date`** — работа только с датами (год, месяц, день)
2. **`time`** — работа только со временем (час, минута, секунда, микросекунда)
3. **`datetime`** — работа с датой и временем вместе
4. **`timedelta`** — разница между датами/временем (интервал)
5. **`tzinfo`** — абстрактный класс для работы с временными зонами
6. **`timezone`** — конкретная реализация временной зоны

**Импорт модуля:**
```python
import datetime

# Или импортировать конкретные классы
from datetime import date, time, datetime, timedelta
```

### Класс `date` — работа с датами

**Примеры:**

```python
from datetime import date

# Создание даты
d1 = date(2024, 12, 25)  # 25 декабря 2024
print(d1)  # 2024-12-25

# Текущая дата
today = date.today()
print(f"Сегодня: {today}")  # 2025-10-12

# Атрибуты даты
print(f"Год: {today.year}")      # 2025
print(f"Месяц: {today.month}")   # 10
print(f"День: {today.day}")      # 12

# День недели
print(f"День недели: {today.weekday()}")  # 0-6 (Пн-Вс), 0 = понедельник
print(f"ISO день недели: {today.isoweekday()}")  # 1-7 (Пн-Вс), 1 = понедельник

# Замена значений
new_date = today.replace(year=2026, month=1)
print(f"Новая дата: {new_date}")  # 2026-01-12
```

### Класс `time` — работа со временем

```python
from datetime import time

# Создание времени
t1 = time(14, 30, 45)  # 14:30:45
print(t1)  # 14:30:45

# С микросекундами
t2 = time(14, 30, 45, 123456)  # 14:30:45.123456
print(t2)

# Атрибуты времени
print(f"Час: {t1.hour}")        # 14
print(f"Минута: {t1.minute}")   # 30
print(f"Секунда: {t1.second}")  # 45
print(f"Микросекунды: {t2.microsecond}")  # 123456

# Замена значений
new_time = t1.replace(hour=16, minute=0)
print(f"Новое время: {new_time}")  # 16:00:45
```

### Класс `datetime` — дата и время вместе

```python
from datetime import datetime

# Создание datetime
dt1 = datetime(2024, 12, 25, 14, 30, 45)
print(dt1)  # 2024-12-25 14:30:45

# Текущие дата и время
now = datetime.now()
print(f"Сейчас: {now}")  # 2025-10-12 15:30:45.123456

# Только дата (без времени)
utc_now = datetime.utcnow()  # UTC время
print(f"UTC: {utc_now}")

# Атрибуты datetime
print(f"Год: {now.year}")
print(f"Месяц: {now.month}")
print(f"День: {now.day}")
print(f"Час: {now.hour}")
print(f"Минута: {now.minute}")
print(f"Секунда: {now.second}")
print(f"Микросекунды: {now.microsecond}")

# Получить только дату или только время
print(f"Только дата: {now.date()}")  # date объект
print(f"Только время: {now.time()}")  # time объект

# Замена значений
new_dt = now.replace(year=2026, hour=10, minute=0, second=0, microsecond=0)
print(f"Новый datetime: {new_dt}")
```

## `13.2` На дате можно изучить `repr()` и посмотреть разницу с `str()`
**`str()`** — строковое представление для пользователей (человекочитаемое)
**`repr()`** — техническое представление для разработчиков (можно воссоздать объект)

Разница особенно заметна на объектах `datetime`.

**Примеры:**

```python
from datetime import date, datetime

d = date(2024, 12, 25)
dt = datetime(2024, 12, 25, 14, 30, 45)

# str() - для пользователей (красиво)
print(str(d))   # 2024-12-25
print(str(dt))  # 2024-12-25 14:30:45

# repr() - для разработчиков (технически)
print(repr(d))   # datetime.date(2024, 12, 25)
print(repr(dt))  # datetime.datetime(2024, 12, 25, 14, 30, 45)

# repr() показывает, как создать такой же объект!
# Можно скопировать и выполнить:
new_date = eval(repr(d))  # создаст точно такую же дату
print(new_date)  # 2024-12-25

# Практическое применение
dates = [date(2024, 1, 1), date(2024, 6, 15), date(2024, 12, 31)]

print("С str():")
for d in dates:
    print(str(d))
# 2024-01-01
# 2024-06-15
# 2024-12-31

print("\nС repr():")
for d in dates:
    print(repr(d))
# datetime.date(2024, 1, 1)
# datetime.date(2024, 6, 15)
# datetime.date(2024, 12, 31)
```

## `13.3` Методы форматирования и создания дат
### `strftime()` — преобразование даты/времени в строку

**Теория:**
`strftime()` (string format time) — форматирует дату/время в строку по заданному шаблону.

**Основные коды форматирования:**

| Код | Описание | Пример |
|-----|----------|---------|
| `%Y` | Год (4 цифры) | 2024 |
| `%y` | Год (2 цифры) | 24 |
| `%m` | Месяц (01-12) | 12 |
| `%d` | День (01-31) | 25 |
| `%H` | Час 24ч (00-23) | 14 |
| `%I` | Час 12ч (01-12) | 02 |
| `%M` | Минута (00-59) | 30 |
| `%S` | Секунда (00-59) | 45 |
| `%p` | AM/PM | PM |
| `%A` | День недели (полное) | Monday |
| `%a` | День недели (сокр.) | Mon |
| `%B` | Месяц (полное) | December |
| `%b` | Месяц (сокр.) | Dec |
| `%w` | День недели (0-6) | 1 |
| `%j` | День года (001-366) | 359 |

**Примеры:**

```python
from datetime import datetime

now = datetime.now()

# Различные форматы
print(now.strftime("%Y-%m-%d"))           # 2025-10-12
print(now.strftime("%d.%m.%Y"))           # 12.10.2025
print(now.strftime("%d/%m/%y"))           # 12/10/25
print(now.strftime("%H:%M:%S"))           # 15:30:45
print(now.strftime("%d.%m.%Y %H:%M"))     # 12.10.2025 15:30

# С текстом
print(now.strftime("Сегодня %d %B %Y года"))  # Сегодня 12 October 2025 года
print(now.strftime("%A, %d %B"))              # Sunday, 12 October

# 12-часовой формат с AM/PM
print(now.strftime("%I:%M %p"))           # 03:30 PM

# Полный формат
print(now.strftime("%Y-%m-%d %H:%M:%S"))  # 2025-10-12 15:30:45
```

### `strptime()` — преобразование строки в дату/время

**Теория:**
`strptime()` (string parse time) — создает объект datetime из строки по заданному шаблону.

**Примеры:**

```python
from datetime import datetime

# Парсинг различных форматов
date_str1 = "2024-12-25"
dt1 = datetime.strptime(date_str1, "%Y-%m-%d")
print(dt1)  # 2024-12-25 00:00:00

date_str2 = "25.12.2024"
dt2 = datetime.strptime(date_str2, "%d.%m.%Y")
print(dt2)  # 2024-12-25 00:00:00

date_str3 = "25/12/24 14:30"
dt3 = datetime.strptime(date_str3, "%d/%m/%y %H:%M")
print(dt3)  # 2024-12-25 14:30:00

# Практический пример: обработка пользовательского ввода
user_input = "15.06.2024"
try:
    birthday = datetime.strptime(user_input, "%d.%m.%Y")
    print(f"Дата рождения: {birthday.date()}")
except ValueError:
    print("Неверный формат даты! Используйте ДД.ММ.ГГГГ")
```

### `isoformat()` и `fromisoformat()` — ISO 8601 формат

**Теория:**
ISO 8601 — международный стандарт формата даты и времени: `YYYY-MM-DD` или `YYYY-MM-DDTHH:MM:SS`

**Примеры:**

```python
from datetime import datetime, date

# isoformat() - преобразование в ISO формат
now = datetime.now()
iso_str = now.isoformat()
print(iso_str)  # 2025-10-12T15:30:45.123456

d = date(2024, 12, 25)
print(d.isoformat())  # 2024-12-25

# fromisoformat() - создание из ISO строки
dt_from_iso = datetime.fromisoformat("2024-12-25T14:30:45")
print(dt_from_iso)  # 2024-12-25 14:30:45

date_from_iso = date.fromisoformat("2024-12-25")
print(date_from_iso)  # 2024-12-25

# Практическое применение: сохранение в JSON
import json

data = {
    "event": "Meeting",
    "timestamp": datetime.now().isoformat()
}
json_str = json.dumps(data)
print(json_str)

# Чтение обратно
loaded_data = json.loads(json_str)
timestamp = datetime.fromisoformat(loaded_data["timestamp"])
print(f"Событие в: {timestamp}")
```

### `combine()` — объединение даты и времени

```python
from datetime import date, time, datetime

# Объединение date и time в datetime
d = date(2024, 12, 25)
t = time(14, 30, 45)

dt = datetime.combine(d, t)
print(dt)  # 2024-12-25 14:30:45

# Практический пример
today = date.today()
work_start = time(9, 0)
work_end = time(18, 0)

start_datetime = datetime.combine(today, work_start)
end_datetime = datetime.combine(today, work_end)

print(f"Рабочий день: {start_datetime} - {end_datetime}")
```

### `now()` — текущая дата и время

```python
from datetime import datetime, date

# Текущая дата и время
now = datetime.now()
print(f"Сейчас: {now}")

# Только текущая дата
today = date.today()
print(f"Сегодня: {today}")

# Можно сразу форматировать
print(f"Сегодня: {datetime.now().strftime('%d.%m.%Y %H:%M')}")
```

## `13.4` Что такое начало эпохи?
**Unix Epoch (начало эпохи)** — это момент времени **1 января 1970 года, 00:00:00 UTC**. Это точка отсчета для многих компьютерных систем.

**Unix timestamp (временная метка)** — количество секунд, прошедших с начала эпохи (может быть отрицательным для дат до 1970 года).

**Зачем это нужно:**
- Единый способ представления времени в разных системах
- Удобно для хранения в базах данных (одно число вместо даты)
- Легко сравнивать и вычислять разницу
- Не зависит от временных зон

**Примеры:**

```python
from datetime import datetime
import time

# Текущий timestamp (секунды с 1970-01-01)
current_timestamp = time.time()
print(f"Текущий timestamp: {current_timestamp}")  # 1728745845.123456

# Преобразование datetime в timestamp
dt = datetime(2024, 12, 25, 14, 30, 45)
timestamp = dt.timestamp()
print(f"Timestamp: {timestamp}")  # 1735133445.0

# Преобразование timestamp в datetime
dt_from_timestamp = datetime.fromtimestamp(timestamp)
print(f"Datetime: {dt_from_timestamp}")  # 2024-12-25 14:30:45

# Начало эпохи
epoch = datetime.fromtimestamp(0)
print(f"Начало эпохи (локальное): {epoch}")  # 1970-01-01 (+ ваш часовой пояс)

epoch_utc = datetime.utcfromtimestamp(0)
print(f"Начало эпохи (UTC): {epoch_utc}")  # 1970-01-01 00:00:00

# Практический пример: измерение времени выполнения
start = time.time()
# Какой-то код
sum([i**2 for i in range(1000000)])
end = time.time()
print(f"Время выполнения: {end - start:.4f} секунд")
```

## `13.5` Что такое `timedelta` и зачем оно нужно?
`timedelta` — это класс для представления **разницы** между двумя датами/временем. Это интервал или продолжительность.

**Можно создать timedelta с:**
- `days` — дни
- `seconds` — секунды
- `microseconds` — микросекунды
- `milliseconds` — миллисекунды
- `minutes` — минуты
- `hours` — часы
- `weeks` — недели

**Зачем нужен:**
- Прибавление/вычитание времени к датам
- Вычисление разницы между датами
- Проверка сроков и дедлайнов
- Планирование задач

**Примеры:**

```python
from datetime import datetime, timedelta

# Создание timedelta
one_day = timedelta(days=1)
one_week = timedelta(weeks=1)
two_hours = timedelta(hours=2)
mixed = timedelta(days=1, hours=3, minutes=30)

print(one_day)   # 1 day, 0:00:00
print(two_hours) # 2:00:00
print(mixed)     # 1 day, 3:30:00

# Арифметика с датами
now = datetime.now()

# Прибавление
tomorrow = now + timedelta(days=1)
next_week = now + timedelta(weeks=1)
in_two_hours = now + timedelta(hours=2)

print(f"Завтра: {tomorrow.strftime('%d.%m.%Y')}")
print(f"Через неделю: {next_week.strftime('%d.%m.%Y')}")

# Вычитание
yesterday = now - timedelta(days=1)
last_month = now - timedelta(days=30)

print(f"Вчера: {yesterday.strftime('%d.%m.%Y')}")

# Разница между датами
birthday = datetime(2024, 6, 15)
today = datetime.now()
difference = today - birthday

print(f"Прошло дней: {difference.days}")
print(f"Прошло времени: {difference}")  # X days, HH:MM:SS

# Получение компонентов timedelta
print(f"Дни: {difference.days}")
print(f"Секунды: {difference.seconds}")  # секунды внутри дня (0-86399)
print(f"Всего секунд: {difference.total_seconds()}")
```

```python
from datetime import datetime, timedelta

# Практический пример 1: Проверка срока действия
token_created = datetime(2025, 10, 1, 12, 0, 0)
token_lifetime = timedelta(days=7)
token_expires = token_created + token_lifetime

now = datetime.now()
if now < token_expires:
    time_left = token_expires - now
    print(f"Токен действителен еще {time_left.days} дней")
else:
    print("Токен истек!")

# Практический пример 2: Расчет возраста
birthday = datetime(1995, 3, 15)
today = datetime.now()
age_delta = today - birthday
age_years = age_delta.days // 365
print(f"Возраст: {age_years} лет")

# Практический пример 3: Рабочие часы
work_start = datetime.now().replace(hour=9, minute=0, second=0, microsecond=0)
work_duration = timedelta(hours=8)
work_end = work_start + work_duration

print(f"Рабочий день: {work_start.strftime('%H:%M')} - {work_end.strftime('%H:%M')}")

# Практический пример 4: Напоминания
event_date = datetime(2025, 12, 25, 18, 0)
reminder_before = timedelta(days=1)
reminder_time = event_date - reminder_before

print(f"Событие: {event_date.strftime('%d.%m.%Y %H:%M')}")
print(f"Напоминание: {reminder_time.strftime('%d.%m.%Y %H:%M')}")
```

## `13.6` Посмотреть, что такое временные зоны и как с ними работать
**Временная зона (timezone)** — это регион Земли с одинаковым стандартным временем.

**Проблемы без временных зон:**
- `datetime.now()` возвращает локальное время без информации о зоне
- Невозможно правильно сравнивать время из разных регионов
- Проблемы при работе с международными приложениями

**Типы datetime:**
- **Naive (наивный)** — без информации о временной зоне
- **Aware (осведомленный)** — с информацией о временной зоне

**В Python есть два подхода:**
1. Встроенный модуль `datetime.timezone` (простой, но ограниченный)
2. Библиотека `pytz` или `zoneinfo` (полнофункциональная)

**Примеры:**

```python
from datetime import datetime, timezone, timedelta

# Naive datetime (без временной зоны)
naive_now = datetime.now()
print(f"Naive: {naive_now}")
print(f"Есть timezone? {naive_now.tzinfo}")  # None

# Aware datetime с UTC
utc_now = datetime.now(timezone.utc)
print(f"UTC: {utc_now}")
print(f"Есть timezone? {utc_now.tzinfo}")  # UTC

# Создание timezone со смещением
moscow_tz = timezone(timedelta(hours=3))  # UTC+3
moscow_now = datetime.now(moscow_tz)
print(f"Москва: {moscow_now}")

# Преобразование naive в aware
naive = datetime(2024, 12, 25, 14, 30)
aware_utc = naive.replace(tzinfo=timezone.utc)
print(f"Было naive: {naive}")
print(f"Стало aware: {aware_utc}")

# Преобразование между временными зонами
utc_time = datetime.now(timezone.utc)
moscow_tz = timezone(timedelta(hours=3))
moscow_time = utc_time.astimezone(moscow_tz)

print(f"UTC: {utc_time.strftime('%H:%M')}")
print(f"Москва: {moscow_time.strftime('%H:%M')}")
```

```python
# Использование zoneinfo (Python 3.9+)
from datetime import datetime
from zoneinfo import ZoneInfo

# Текущее время в разных зонах
utc = datetime.now(ZoneInfo("UTC"))
moscow = datetime.now(ZoneInfo("Europe/Moscow"))
new_york = datetime.now(ZoneInfo("America/New_York"))
tokyo = datetime.now(ZoneInfo("Asia/Tokyo"))

print(f"UTC:      {utc.strftime('%H:%M')}")
print(f"Москва:   {moscow.strftime('%H:%M')}")
print(f"Нью-Йорк: {new_york.strftime('%H:%M')}")
print(f"Токио:    {tokyo.strftime('%H:%M')}")

# Преобразование между зонами
event_utc = datetime(2024, 12, 25, 12, 0, tzinfo=ZoneInfo("UTC"))
event_moscow = event_utc.astimezone(ZoneInfo("Europe/Moscow"))
event_ny = event_utc.astimezone(ZoneInfo("America/New_York"))

print(f"Событие в UTC: {event_utc.strftime('%H:%M')}")
print(f"Событие в Москве: {event_moscow.strftime('%H:%M')}")
print(f"Событие в Нью-Йорке: {event_ny.strftime('%H:%M')}")
```

```python
# Практический пример: планирование встречи
from datetime import datetime
from zoneinfo import ZoneInfo

# Встреча назначена на 15:00 по Москве
meeting_moscow = datetime(2024, 12, 25, 15, 0, tzinfo=ZoneInfo("Europe/Moscow"))

# Во сколько это будет в других городах?
meeting_london = meeting_moscow.astimezone(ZoneInfo("Europe/London"))
meeting_ny = meeting_moscow.astimezone(ZoneInfo("America/New_York"))
meeting_tokyo = meeting_moscow.astimezone(ZoneInfo("Asia/Tokyo"))

print("Время встречи:")
print(f"Москва:   {meeting_moscow.strftime('%H:%M')}")
print(f"Лондон:   {meeting_london.strftime('%H:%M')}")
print(f"Нью-Йорк: {meeting_ny.strftime('%H:%M')}")
print(f"Токио:    {meeting_tokyo.strftime('%H:%M')}")

# Сохранение в БД (всегда используйте UTC!)
db_timestamp = meeting_moscow.astimezone(ZoneInfo("UTC"))
print(f"\nДля БД (UTC): {db_timestamp.isoformat()}")
```

**Итоговая шпаргалка:**

**Создание дат:**
```python
from datetime import date, time, datetime, timedelta

date(2024, 12, 25)                    # дата
time(14, 30, 45)                      # время
datetime(2024, 12, 25, 14, 30, 45)   # дата + время
date.today()                          # сегодня
datetime.now()                        # сейчас
```

**Форматирование:**
```python
dt.strftime("%d.%m.%Y %H:%M")        # в строку
datetime.strptime(s, "%d.%m.%Y")     # из строки
dt.isoformat()                        # в ISO формат
datetime.fromisoformat(s)             # из ISO формата
```

**Арифметика:**
```python
dt + timedelta(days=1)                # прибавить день
dt - timedelta(hours=2)               # вычесть 2 часа
dt1 - dt2                             # разница (timedelta)
```

**Временные зоны:**
```python
from zoneinfo import ZoneInfo

datetime.now(ZoneInfo("UTC"))         # UTC время
dt.astimezone(ZoneInfo("Europe/Moscow"))  # конвертация зоны
```

**Важные советы:**
- ✅ Всегда используйте `encoding='utf-8'` и aware datetime для серьезных проектов
- ✅ Храните время в БД в UTC, конвертируйте при отображении
- ✅ Используйте `isoformat()` для сериализации в JSON
- ✅ Для Python 3.9+ используйте `zoneinfo` вместо `pytz`
- ⚠️ `strptime()` и `strftime()` используют одинаковые коды формата














----

# `14` (`*`) Обработка исключений
[Видео про исключения](https://youtu.be/89wpfOAgrCk?si=b7ERcnzmtdMD_MuR)

## `14.1` Типы ошибок. Основные исключения в Python и их иерархия
### **Типы ошибок**
В Python существует три основных типа ошибок:

**1. Синтаксические ошибки (Syntax Errors)**
- Возникают при нарушении синтаксиса языка
- Код не запустится до исправления

```python
# SyntaxError
if True
    print("Hello")  # Забыли двоеточие
```

**2. Ошибки выполнения (Runtime Errors / Exceptions)**
- Возникают во время выполнения программы
- Синтаксически корректный код, но что-то пошло не так

```python
# ZeroDivisionError
result = 10 / 0

# FileNotFoundError
with open("несуществующий_файл.txt") as f:
    data = f.read()
```

**3. Логические ошибки (Logical Errors)**
- Программа работает без ошибок, но результат неверный
- Самые сложные для обнаружения

```python
# Хотели найти среднее, но забыли разделить
def average(numbers):
    return sum(numbers)  # Должно быть sum(numbers) / len(numbers)
```

### **Иерархия исключений в Python**
Все исключения в Python наследуются от базового класса `BaseException`:

```
BaseException
├── SystemExit
├── KeyboardInterrupt
├── GeneratorExit
└── Exception
    ├── StopIteration
    ├── ArithmeticError
    │   ├── ZeroDivisionError
    │   ├── OverflowError
    │   └── FloatingPointError
    ├── AttributeError
    ├── EOFError
    ├── ImportError
    │   └── ModuleNotFoundError
    ├── LookupError
    │   ├── IndexError
    │   └── KeyError
    ├── NameError
    ├── OSError
    │   ├── FileNotFoundError
    │   ├── PermissionError
    │   └── ConnectionError
    ├── RuntimeError
    │   └── RecursionError
    ├── TypeError
    ├── ValueError
    └── ...
```

### **Основные исключения**
| Исключение | Описание | Пример |
|------------|----------|---------|
| `Exception` | Базовый класс для большинства исключений | - |
| `ValueError` | Неправильное значение | `int("abc")` |
| `TypeError` | Неправильный тип данных | `"5" + 5` |
| `KeyError` | Ключ не найден в словаре | `d = {}; d["key"]` |
| `IndexError` | Индекс вне диапазона | `[1, 2][5]` |
| `AttributeError` | Атрибут не найден | `"text".nonexistent()` |
| `FileNotFoundError` | Файл не найден | `open("nope.txt")` |
| `ZeroDivisionError` | Деление на ноль | `1 / 0` |
| `ImportError` | Ошибка импорта | `import fake_module` |
| `NameError` | Переменная не определена | `print(x)` |

**Примеры:**
```python
# ValueError
age = int("двадцать")  # ValueError: invalid literal for int()

# TypeError
result = "Hello" + 5  # TypeError: can only concatenate str to str

# KeyError
user = {"name": "Alice"}
print(user["age"])  # KeyError: 'age'

# IndexError
numbers = [1, 2, 3]
print(numbers[10])  # IndexError: list index out of range

# AttributeError
text = "Python"
text.append("!")  # AttributeError: 'str' object has no attribute 'append'

# ZeroDivisionError
result = 100 / 0  # ZeroDivisionError: division by zero
```

## `14.2` `try-except`
Конструкция `try-except` позволяет перехватывать и обрабатывать исключения, чтобы программа не завершалась аварийно.

**Синтаксис:**
```python
try:
    # Код, который может вызвать ошибку
    risky_code()
except ExceptionType:
    # Код, который выполнится при ошибке
    handle_error()
```

### **Базовое использование**
**Пример 1: Обработка одного исключения**

```python
try:
    number = int(input("Введите число: "))
    result = 100 / number
    print(f"Результат: {result}")
except ZeroDivisionError:
    print("Ошибка: нельзя делить на ноль!")

# Ввод: 0
# Вывод: Ошибка: нельзя делить на ноль!
```

**Пример 2: Обработка нескольких исключений**

```python
try:
    number = int(input("Введите число: "))
    result = 100 / number
    print(f"Результат: {result}")
except ZeroDivisionError:
    print("Ошибка: деление на ноль!")
except ValueError:
    print("Ошибка: введите корректное число!")

# Ввод: "abc"
# Вывод: Ошибка: введите корректное число!
```

**Пример 3: Несколько исключений в одном блоке**

```python
try:
    data = {"name": "Alice"}
    print(data["age"])
except (KeyError, IndexError, TypeError) as e:
    print(f"Ошибка доступа к данным: {e}")

# Вывод: Ошибка доступа к данным: 'age'
```

### **Получение информации об ошибке**

```python
try:
    result = 10 / 0
except ZeroDivisionError as error:
    print(f"Произошла ошибка: {error}")
    print(f"Тип ошибки: {type(error).__name__}")

# Вывод:
# Произошла ошибка: division by zero
# Тип ошибки: ZeroDivisionError
```

### **Перехват всех исключений**
**⚠️ Не рекомендуется использовать без крайней необходимости!**

```python
try:
    risky_operation()
except Exception as e:
    print(f"Что-то пошло не так: {e}")

# Лучше ловить конкретные исключения
```

**Почему это плохо:**
- Скрывает неожиданные ошибки
- Усложняет отладку
- Может перехватить системные исключения

### **Практический пример: безопасное чтение файла**

```python
def read_file(filename):
    try:
        with open(filename, 'r', encoding='utf-8') as f:
            return f.read()
    except FileNotFoundError:
        print(f"Файл '{filename}' не найден")
        return None
    except PermissionError:
        print(f"Нет прав для чтения файла '{filename}'")
        return None
    except Exception as e:
        print(f"Неожиданная ошибка: {e}")
        return None

content = read_file("data.txt")
if content:
    print(content)
```

## `14.3` `else` & `finally` в `try-except`
### **Блок `else`**
Выполняется **только если** в блоке `try` не возникло исключений.

**Синтаксис:**
```python
try:
    # Код, который может вызвать ошибку
    risky_code()
except ExceptionType:
    # Обработка ошибки
    handle_error()
else:
    # Выполняется, если ошибок не было
    success_code()
```

**Пример:**
```python
try:
    number = int(input("Введите число: "))
    result = 100 / number
except (ValueError, ZeroDivisionError) as e:
    print(f"Ошибка: {e}")
else:
    print(f"Успешно! Результат: {result}")

# Ввод: 5
# Вывод: Успешно! Результат: 20.0

# Ввод: 0
# Вывод: Ошибка: division by zero
```

### **Блок `finally`**
Выполняется **всегда**, независимо от того, была ошибка или нет. Используется для очистки ресурсов (закрытие файлов, соединений и т.д.).

**Синтаксис:**
```python
try:
    risky_code()
except ExceptionType:
    handle_error()
finally:
    # Выполняется ВСЕГДА
    cleanup()
```

**Пример 1: Гарантированное закрытие файла**

```python
file = None
try:
    file = open("data.txt", "r")
    data = file.read()
    print(data)
except FileNotFoundError:
    print("Файл не найден")
finally:
    if file:
        file.close()
        print("Файл закрыт")

# Файл будет закрыт в любом случае
```

**Пример 2: Логирование попыток**

```python
def divide(a, b):
    try:
        result = a / b
    except ZeroDivisionError:
        print("Ошибка: деление на ноль")
        return None
    else:
        print(f"Деление успешно: {result}")
        return result
    finally:
        print("Операция завершена")

divide(10, 2)
# Вывод:
# Деление успешно: 5.0
# Операция завершена

divide(10, 0)
# Вывод:
# Ошибка: деление на ноль
# Операция завершена
```

### **Полная структура `try-except-else-finally`**
```python
try:
    # Основной код
    file = open("data.txt", "r")
    data = file.read()
    number = int(data)
except FileNotFoundError:
    # Если файл не найден
    print("Файл не существует")
except ValueError:
    # Если содержимое не число
    print("Файл содержит не число")
else:
    # Если ошибок не было
    print(f"Число успешно прочитано: {number}")
finally:
    # Выполняется всегда
    print("Попытка чтения завершена")
    if 'file' in locals() and file:
        file.close()
```

**Порядок выполнения:**
1. `try` — выполняется основной код
2. `except` — если возникла ошибка
3. `else` — если ошибок не было
4. `finally` — выполняется всегда в конце

## `14.4` Оператор `raise`
Оператор `raise` используется для **явного вызова исключения**.

**Синтаксис:**
```python
raise ExceptionType("Сообщение об ошибке")
```

### **Базовое использование**
**Пример 1: Вызов стандартного исключения**

```python
def set_age(age):
    if age < 0:
        raise ValueError("Возраст не может быть отрицательным")
    if age > 150:
        raise ValueError("Возраст слишком большой")
    print(f"Возраст установлен: {age}")

set_age(25)   # Возраст установлен: 25
set_age(-5)   # ValueError: Возраст не может быть отрицательным
```

**Пример 2: Проверка типов**

```python
def calculate_discount(price, discount):
    if not isinstance(price, (int, float)):
        raise TypeError("Цена должна быть числом")
    if not isinstance(discount, (int, float)):
        raise TypeError("Скидка должна быть числом")
    if discount < 0 or discount > 100:
        raise ValueError("Скидка должна быть от 0 до 100")
    
    return price * (1 - discount / 100)

print(calculate_discount(1000, 20))  # 800.0
print(calculate_discount("1000", 20))  # TypeError: Цена должна быть числом
```

### **Повторный вызов исключения**
Можно перехватить исключение, обработать его и вызвать снова:

```python
def process_data(data):
    try:
        result = int(data) / 0
    except ZeroDivisionError as e:
        print("Логирование: произошла ошибка деления на ноль")
        raise  # Повторно вызываем то же исключение

try:
    process_data("10")
except ZeroDivisionError:
    print("Обработка ошибки на верхнем уровне")

# Вывод:
# Логирование: произошла ошибка деления на ноль
# Обработка ошибки на верхнем уровне
```

### **Вызов исключения из другого исключения**
```python
try:
    result = int("abc")
except ValueError as e:
    raise RuntimeError("Не удалось обработать данные") from e

# RuntimeError: Не удалось обработать данные
# (связано с ValueError: invalid literal for int() with base 10: 'abc')
```

## `14.5` Кастомные ошибки  
Можно создавать собственные классы исключений для специфичных ошибок в вашем приложении.

**Базовый синтаксис:**
```python
class MyCustomError(Exception):
    pass
```

### **Простая кастомная ошибка**
**Пример 1:**

```python
class NegativeNumberError(Exception):
    """Исключение для отрицательных чисел"""
    pass

def square_root(number):
    if number < 0:
        raise NegativeNumberError("Нельзя извлечь корень из отрицательного числа")
    return number ** 0.5

try:
    print(square_root(16))  # 4.0
    print(square_root(-9))  # NegativeNumberError
except NegativeNumberError as e:
    print(f"Ошибка: {e}")
```

### **Кастомная ошибка с дополнительными данными**
**Пример 2:**

```python
class InsufficientFundsError(Exception):
    """Исключение при недостатке средств"""
    
    def __init__(self, balance, amount):
        self.balance = balance
        self.amount = amount
        self.shortage = amount - balance
        message = f"Недостаточно средств. Баланс: {balance}, требуется: {amount}"
        super().__init__(message)

class BankAccount:
    def __init__(self, balance):
        self.balance = balance
    
    def withdraw(self, amount):
        if amount > self.balance:
            raise InsufficientFundsError(self.balance, amount)
        self.balance -= amount
        return self.balance

# Использование
account = BankAccount(1000)

try:
    account.withdraw(500)   # OK
    print(f"Баланс: {account.balance}")
    account.withdraw(800)   # Ошибка
except InsufficientFundsError as e:
    print(e)
    print(f"Не хватает: {e.shortage} рублей")

# Вывод:
# Баланс: 500
# Недостаточно средств. Баланс: 500, требуется: 800
# Не хватает: 300 рублей
```

### **Иерархия кастомных исключений**
**Пример 3:**

```python
class ValidationError(Exception):
    """Базовое исключение для валидации"""
    pass

class EmailValidationError(ValidationError):
    """Ошибка валидации email"""
    pass

class PasswordValidationError(ValidationError):
    """Ошибка валидации пароля"""
    pass

def validate_email(email):
    if "@" not in email:
        raise EmailValidationError("Email должен содержать символ @")

def validate_password(password):
    if len(password) < 8:
        raise PasswordValidationError("Пароль должен быть не менее 8 символов")

def register_user(email, password):
    try:
        validate_email(email)
        validate_password(password)
        print("Пользователь зарегистрирован")
    except ValidationError as e:
        print(f"Ошибка валидации: {e}")

register_user("user.com", "12345")
# Вывод: Ошибка валидации: Email должен содержать символ @

register_user("user@mail.com", "12345")
# Вывод: Ошибка валидации: Пароль должен быть не менее 8 символов

register_user("user@mail.com", "strongpass123")
# Вывод: Пользователь зарегистрирован
```

### **Практический пример: API клиент**

```python
class APIError(Exception):
    """Базовая ошибка API"""
    pass

class ConnectionError(APIError):
    """Ошибка соединения"""
    pass

class AuthenticationError(APIError):
    """Ошибка аутентификации"""
    pass

class RateLimitError(APIError):
    """Превышен лимит запросов"""
    
    def __init__(self, retry_after):
        self.retry_after = retry_after
        super().__init__(f"Лимит превышен. Повторите через {retry_after} секунд")

def make_api_request(endpoint, token):
    # Симуляция API запроса
    if not token:
        raise AuthenticationError("Токен не предоставлен")
    
    if endpoint == "/rate_limited":
        raise RateLimitError(retry_after=60)
    
    return {"status": "success", "data": "..."}

# Использование
try:
    response = make_api_request("/users", token="abc123")
    print(response)
except AuthenticationError as e:
    print(f"Ошибка аутентификации: {e}")
except RateLimitError as e:
    print(f"Лимит запросов: {e}")
    print(f"Ожидание: {e.retry_after} сек")
except APIError as e:
    print(f"Ошибка API: {e}")
```

**Когда создавать кастомные исключения:**
- Для бизнес-логики приложения
- Когда стандартные исключения недостаточно информативны
- Для создания иерархии ошибок в больших проектах
- Когда нужно передавать дополнительные данные об ошибке

----

# `15` Рекурсия
[Большое видео про рекурсию](https://youtu.be/vRzXTtp-sFU?si=adkLr29CBax8Y5Lj)

## `15.1` Что такое рекурсия?
**Рекурсия** — это когда функция вызывает саму себя внутри своего тела. Это мощный метод программирования для решения задач, которые можно разбить на более мелкие подзадачи того же типа.

**Структура рекурсивной функции:**

1. **Базовый случай (base case)** — условие остановки рекурсии. Без него функция будет вызывать себя бесконечно!
2. **Рекурсивный случай (recursive case)** — вызов функции самой себя с измененными параметрами, приближающими к базовому случаю.

**Схема:**
```python
def recursive_function(параметры):
    if базовый_случай:
        return результат  # остановка рекурсии
    else:
        return recursive_function(новые_параметры)  # вызов самой себя
```

**Как работает рекурсия:**
- Каждый вызов функции создает новый **стек вызовов** (stack frame)
- Функция ждет результата от вложенного вызова
- Когда достигается базовый случай, результаты возвращаются обратно по цепочке
- Слишком глубокая рекурсия может вызвать `RecursionError` (переполнение стека)

**Примеры:**

```python
# Простейший пример: обратный отсчет
def countdown(n):
    if n == 0:  # базовый случай
        print("Пуск!")
        return
    print(n)
    countdown(n - 1)  # рекурсивный вызов

countdown(5)
# Вывод:
# 5
# 4
# 3
# 2
# 1
# Пуск!

# Как это работает:
# countdown(5) -> выводит 5, вызывает countdown(4)
#   countdown(4) -> выводит 4, вызывает countdown(3)
#     countdown(3) -> выводит 3, вызывает countdown(2)
#       countdown(2) -> выводит 2, вызывает countdown(1)
#         countdown(1) -> выводит 1, вызывает countdown(0)
#           countdown(0) -> выводит "Пуск!", возвращается
```

```python
# Классический пример: факториал
# n! = n × (n-1) × (n-2) × ... × 2 × 1
# 5! = 5 × 4 × 3 × 2 × 1 = 120

def factorial(n):
    # Базовый случай
    if n == 0 or n == 1:
        return 1
    # Рекурсивный случай
    return n * factorial(n - 1)

print(factorial(5))  # 120
print(factorial(3))  # 6

# Как работает factorial(5):
# factorial(5) = 5 * factorial(4)
#   factorial(4) = 4 * factorial(3)
#     factorial(3) = 3 * factorial(2)
#       factorial(2) = 2 * factorial(1)
#         factorial(1) = 1  # базовый случай
#       factorial(2) = 2 * 1 = 2
#     factorial(3) = 3 * 2 = 6
#   factorial(4) = 4 * 6 = 24
# factorial(5) = 5 * 24 = 120
```

```python
# Сумма чисел от 1 до n
def sum_numbers(n):
    if n == 0:  # базовый случай
        return 0
    return n + sum_numbers(n - 1)

print(sum_numbers(5))  # 1 + 2 + 3 + 4 + 5 = 15
print(sum_numbers(10))  # 55

# Степень числа
def power(base, exp):
    if exp == 0:  # базовый случай
        return 1
    return base * power(base, exp - 1)

print(power(2, 3))  # 2^3 = 8
print(power(5, 2))  # 5^2 = 25
```

```python
# Ошибка: рекурсия без базового случая
def infinite_recursion(n):
    print(n)
    infinite_recursion(n + 1)  # никогда не остановится!

# infinite_recursion(1)  # RecursionError: maximum recursion depth exceeded

# Правильная версия с базовым случаем
def safe_recursion(n, limit):
    if n >= limit:  # базовый случай
        return
    print(n)
    safe_recursion(n + 1, limit)

safe_recursion(1, 5)  # выведет 1, 2, 3, 4
```

## `15.2` Какие задачи решает рекурсия?
Рекурсия особенно полезна для задач, которые имеют **рекурсивную структуру** — могут быть разбиты на похожие подзадачи меньшего размера.

**Типичные задачи для рекурсии:**

1. **Математические вычисления** — факториал, степень, числа Фибоначчи
2. **Работа с деревьями и графами** — обход, поиск
3. **Работа с вложенными структурами** — файловые системы, JSON
4. **Алгоритмы "разделяй и властвуй"** — быстрая сортировка, бинарный поиск
5. **Комбинаторные задачи** — генерация перестановок, комбинаций
6. **Задачи с backtracking** — лабиринты, судоку, расстановка ферзей

**Когда использовать рекурсию:**
- ✅ Задача естественным образом делится на похожие подзадачи
- ✅ Работа с древовидными структурами
- ✅ Код становится проще и понятнее, чем с циклами

**Когда НЕ использовать:**
- ❌ Простые итеративные задачи (циклы проще и быстрее)
- ❌ Очень глубокая рекурсия (риск переполнения стека)
- ❌ Когда важна производительность (рекурсия медленнее циклов)

**Примеры задач:**

### 1. Числа Фибоначчи

```python
# Последовательность: 0, 1, 1, 2, 3, 5, 8, 13, 21, ...
# Каждое число — сумма двух предыдущих

def fibonacci(n):
    # Базовые случаи
    if n == 0:
        return 0
    if n == 1:
        return 1
    # Рекурсивный случай
    return fibonacci(n - 1) + fibonacci(n - 2)

print(fibonacci(6))  # 8
print(fibonacci(10))  # 55

# Последовательность первых n чисел
for i in range(8):
    print(fibonacci(i), end=" ")  # 0 1 1 2 3 5 8 13
```

### 2. Работа со списками

```python
# Сумма элементов списка
def sum_list(lst):
    if len(lst) == 0:  # базовый случай: пустой список
        return 0
    return lst[0] + sum_list(lst[1:])  # первый элемент + сумма остальных

print(sum_list([1, 2, 3, 4, 5]))  # 15

# Поиск максимума в списке
def find_max(lst):
    # Базовый случай: один элемент
    if len(lst) == 1:
        return lst[0]
    # Рекурсивный случай
    max_rest = find_max(lst[1:])  # максимум в остальных
    return lst[0] if lst[0] > max_rest else max_rest

print(find_max([3, 7, 2, 9, 1]))  # 9

# Переворот списка
def reverse_list(lst):
    if len(lst) == 0:  # базовый случай
        return []
    return [lst[-1]] + reverse_list(lst[:-1])

print(reverse_list([1, 2, 3, 4, 5]))  # [5, 4, 3, 2, 1]
```

### 3. Работа со строками

```python
# Проверка палиндрома (читается одинаково в обе стороны)
def is_palindrome(s):
    # Базовые случаи
    if len(s) <= 1:
        return True
    # Проверяем первый и последний символы
    if s[0] != s[-1]:
        return False
    # Рекурсивно проверяем середину
    return is_palindrome(s[1:-1])

print(is_palindrome("radar"))  # True
print(is_palindrome("hello"))  # False
print(is_palindrome("level"))  # True

# Подсчет символа в строке
def count_char(s, char):
    if len(s) == 0:  # базовый случай
        return 0
    count = 1 if s[0] == char else 0
    return count + count_char(s[1:], char)

print(count_char("hello world", "l"))  # 3
print(count_char("programming", "m"))  # 2
```

### 4. Вложенные структуры

```python
# Сумма всех чисел во вложенном списке
def sum_nested(lst):
    total = 0
    for item in lst:
        if isinstance(item, list):  # если элемент — список
            total += sum_nested(item)  # рекурсивный вызов
        else:
            total += item
    return total

nested = [1, [2, 3], [4, [5, 6]], 7]
print(sum_nested(nested))  # 28

# Подсчет всех элементов во вложенном списке
def count_all(lst):
    count = 0
    for item in lst:
        if isinstance(item, list):
            count += count_all(item)
        else:
            count += 1
    return count

print(count_all([1, [2, 3], [4, [5, 6]], 7]))  # 7 элементов
```

### 5. Обход каталогов (практический пример)

```python
import os

# Рекурсивный вывод всех файлов в директории
def list_files(path, indent=0):
    try:
        for item in os.listdir(path):
            item_path = os.path.join(path, item)
            print("  " * indent + item)
            
            if os.path.isdir(item_path):  # если это директория
                list_files(item_path, indent + 1)  # рекурсивно обходим
    except PermissionError:
        pass

# list_files("./my_folder")
# Вывод:
# file1.txt
# subfolder
#   file2.txt
#   nested_folder
#     file3.txt
```

### 6. Генерация всех комбинаций

```python
# Генерация всех подмножеств множества
def generate_subsets(lst):
    # Базовый случай: пустое множество
    if len(lst) == 0:
        return [[]]
    
    # Берем первый элемент
    first = lst[0]
    rest = lst[1:]
    
    # Рекурсивно генерируем подмножества для остальных
    subsets_without_first = generate_subsets(rest)
    
    # Добавляем первый элемент к каждому подмножеству
    subsets_with_first = [[first] + subset for subset in subsets_without_first]
    
    # Объединяем
    return subsets_without_first + subsets_with_first

print(generate_subsets([1, 2, 3]))
# [[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]
```

### Сравнение: рекурсия vs итерация

```python
# Факториал РЕКУРСИЕЙ
def factorial_recursive(n):
    if n <= 1:
        return 1
    return n * factorial_recursive(n - 1)

# Факториал ЦИКЛОМ (итеративно)
def factorial_iterative(n):
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result

print(factorial_recursive(5))  # 120
print(factorial_iterative(5))  # 120

# Рекурсия: красивее, нагляднее
# Итерация: быстрее, не переполняет стек
```

**Шпаргалка по рекурсии:**

**Структура рекурсивной функции:**
```python
def recursive_func(параметры):
    if базовый_случай:  # ОБЯЗАТЕЛЬНО!
        return результат
    return recursive_func(новые_параметры)
```

**Типичные паттерны:**

```python
# 1. Уменьшение числа
def func(n):
    if n == 0:
        return base_value
    return operation + func(n - 1)

# 2. Уменьшение списка
def func(lst):
    if len(lst) == 0:
        return base_value
    return operation(lst[0]) + func(lst[1:])

# 3. Уменьшение строки
def func(s):
    if len(s) == 0:
        return base_value
    return operation(s[0]) + func(s[1:])
```

**Важные советы:**
- ✅ **ВСЕГДА** определяйте базовый случай первым
- ✅ Убедитесь, что рекурсия приближается к базовому случаю
- ✅ Используйте рекурсию для древовидных структур и задач "разделяй и властвуй"
- ⚠️ Для простых задач циклы обычно лучше
- ⚠️ Глубокая рекурсия (>1000 уровней) может вызвать ошибку
- ⚠️ Рекурсия медленнее итерации из-за накладных расходов на вызовы функций

**Когда использовать рекурсию:**
- Работа с деревьями (файловые системы, DOM)
- Математические задачи с рекурсивным определением
- Задачи, где естественно "разбить на меньшие копии"
- Когда код становится намного проще и понятнее

----

# `16` Функции 3
## `16.1` Вложенные функции
**Вложенная функция (nested function)** — это функция, определенная внутри другой функции. Внутренняя функция имеет доступ к переменным внешней функции.

**Основные особенности:**

1. **Область видимости** — вложенная функция видит переменные внешней функции
2. **Инкапсуляция** — внутренняя функция недоступна снаружи внешней функции
3. **Организация кода** — помогает структурировать логику и избежать дублирования

**Зачем нужны вложенные функции:**
- 📦 **Инкапсуляция** — скрыть вспомогательные функции от внешнего кода
- 🔧 **Вспомогательные функции** — когда функция нужна только внутри другой
- 📝 **Избежание дублирования** — переиспользование кода внутри одной функции
- 🎯 **Читаемость** — группировка связанной логики

**Структура:**
```python
def outer_function():
    # код внешней функции
    
    def inner_function():
        # код внутренней функции
        pass
    
    # использование внутренней функции
    inner_function()
```

**Примеры:**

```python
# Простой пример вложенной функции
def greet(name):
    # Вложенная функция
    def get_message():
        return f"Привет, {name}!"
    
    # Используем вложенную функцию
    message = get_message()
    print(message)

greet("Иван")  # Привет, Иван!
greet("Мария")  # Привет, Мария!

# Попытка вызвать внутреннюю функцию снаружи
# get_message()  # NameError: name 'get_message' is not defined
```

```python
# Доступ к переменным внешней функции
def outer():
    x = 10  # переменная внешней функции
    
    def inner():
        # Внутренняя функция имеет доступ к x
        print(f"Значение x из outer: {x}")
    
    inner()

outer()  # Значение x из outer: 10
```

```python
# Практический пример: обработка данных с валидацией
def process_user_data(name, age):
    # Вложенные функции для валидации
    def validate_name():
        if not name or not isinstance(name, str):
            return False
        if len(name) < 2:
            return False
        return True
    
    def validate_age():
        if not isinstance(age, int):
            return False
        if age < 0 or age > 150:
            return False
        return True
    
    def format_output():
        return f"Пользователь: {name.title()}, возраст: {age} лет"
    
    # Проверяем данные
    if not validate_name():
        return "Ошибка: некорректное имя"
    
    if not validate_age():
        return "Ошибка: некорректный возраст"
    
    # Если всё хорошо, форматируем вывод
    return format_output()

print(process_user_data("иван", 25))  # Пользователь: Иван, возраст: 25 лет
print(process_user_data("А", 25))     # Ошибка: некорректное имя
print(process_user_data("Мария", 200))  # Ошибка: некорректный возраст
```

**Шпаргалка по вложенным функциям:**

**Базовая структура:**
```python
def outer():
    x = 10
    
    def inner():
        print(x)  # доступ к переменным outer
    
    inner()
```

**Ключевое слово `nonlocal`:**
```python
def outer():
    x = 10
    
    def inner():
        nonlocal x  # позволяет изменять x из outer
        x += 1
    
    inner()
    print(x)  # 11
```

**Возврат вложенной функции:**
```python
def outer(x):
    def inner(y):
        return x + y
    return inner

func = outer(10)
print(func(5))  # 15
```

**Области видимости (LEGB):**
- **L** (Local) — локальные переменные функции
- **E** (Enclosing) — переменные внешней функции
- **G** (Global) — глобальные переменные
- **B** (Built-in) — встроенные имена Python

**Важные советы:**
- ✅ Используйте вложенные функции для организации кода
- ✅ Скрывайте вспомогательные функции внутри основной
- ✅ Используйте `nonlocal` для изменения переменных внешней функции
- ✅ Возвращайте вложенные функции для создания специализированных функций
- ⚠️ Не злоупотребляйте вложенностью (1-2 уровня обычно достаточно)
- ⚠️ Вложенная функция не видна снаружи внешней функции

**Когда использовать:**
- Когда функция нужна только внутри другой функции
- Для инкапсуляции и сокрытия деталей реализации
- Для создания фабрик функций
- Для декораторов (более продвинутая тема)

## `16.2` (`*`) Замыкание. Зачем оно нужно?
**Замыкание (closure)** — это функция, которая "запоминает" и сохраняет доступ к переменным из внешней функции, даже после того, как внешняя функция завершила свою работу.

**Ключевые особенности замыкания:**

1. **Внутренняя функция** ссылается на переменные внешней функции
2. **Внешняя функция возвращает** внутреннюю функцию
3. **Переменные "запоминаются"** — внутренняя функция сохраняет доступ к ним
4. **Каждый вызов** внешней функции создает новое независимое замыкание

**Отличие от обычной вложенной функции:**
- Обычная вложенная функция — используется сразу внутри внешней
- Замыкание — внутренняя функция возвращается и используется позже

**Зачем нужны замыкания:**

- 🏭 **Фабрики функций** — создание специализированных функций с заданными параметрами
- 🔒 **Инкапсуляция данных** — скрытие внутреннего состояния без использования классов
- 💾 **Сохранение состояния** — функция "помнит" данные между вызовами
- 🎯 **Альтернатива глобальным переменным** — локальное состояние вместо глобального
- 🛠️ **Создание декораторов** — основа для паттерна декоратор
- 📊 **Каррирование** — частичное применение аргументов

**Примеры:**

```python
# Базовый пример замыкания
def make_multiplier(n):
    # n - переменная внешней функции
    
    def multiplier(x):
        # Внутренняя функция использует n
        return x * n
    
    # Возвращаем внутреннюю функцию
    return multiplier

# Создаем специализированные функции
double = make_multiplier(2)   # n = 2
triple = make_multiplier(3)   # n = 3
quadruple = make_multiplier(4)  # n = 4

# Каждая функция "запомнила" свое значение n
print(double(5))      # 10 (5 * 2)
print(triple(5))      # 15 (5 * 3)
print(quadruple(5))   # 20 (5 * 4)

# Функции независимы друг от друга
print(double(10))     # 20
print(triple(10))     # 30
```

```python
# Замыкание с изменяемым состоянием (счетчик)
def counter():
    count = 0  # "приватная" переменная
    
    def increment():
        nonlocal count  # разрешаем изменять count
        count += 1
        return count
    
    return increment

# Создаем независимые счетчики
counter1 = counter()
counter2 = counter()

# Каждый счетчик имеет свое состояние
print(counter1())  # 1
print(counter1())  # 2
print(counter1())  # 3

print(counter2())  # 1
print(counter2())  # 2

print(counter1())  # 4 (продолжает с 3)
```

```python
# Замыкание с несколькими операциями
def create_calculator(initial_value):
    value = initial_value
    
    def add(x):
        nonlocal value
        value += x
        return value
    
    def subtract(x):
        nonlocal value
        value -= x
        return value
    
    def get_value():
        return value
    
    def reset():
        nonlocal value
        value = initial_value
        return value
    
    # Возвращаем словарь с функциями
    return {
        'add': add,
        'subtract': subtract,
        'get': get_value,
        'reset': reset
    }

# Создаем калькулятор с начальным значением 10
calc = create_calculator(10)

print(calc['add'](5))       # 15
print(calc['add'](3))       # 18
print(calc['subtract'](8))  # 10
print(calc['get']())        # 10
print(calc['reset']())      # 10 (сброс к начальному)
```

```python
# Практический пример: генератор приветствий
def greeting_factory(greeting):
    """Создает функцию приветствия с заданным шаблоном"""
    
    def greet(name):
        return f"{greeting}, {name}!"
    
    return greet

# Создаем разные варианты приветствий
hello = greeting_factory("Привет")
good_morning = greeting_factory("Доброе утро")
welcome = greeting_factory("Добро пожаловать")

print(hello("Иван"))           # Привет, Иван!
print(good_morning("Мария"))   # Доброе утро, Мария!
print(welcome("Гость"))        # Добро пожаловать, Гость!
```

```python
# Замыкание для валидации с настраиваемыми правилами
def create_validator(min_length, max_length):
    """Создает функцию валидации с заданными ограничениями"""
    
    def validate(text):
        if len(text) < min_length:
            return False, f"Слишком короткое (минимум {min_length} символов)"
        if len(text) > max_length:
            return False, f"Слишком длинное (максимум {max_length} символов)"
        return True, "OK"
    
    return validate

# Создаем валидаторы для разных полей
validate_username = create_validator(3, 20)
validate_password = create_validator(8, 50)
validate_comment = create_validator(1, 500)

# Используем
print(validate_username("ab"))          # (False, 'Слишком короткое...')
print(validate_username("john123"))     # (True, 'OK')
print(validate_password("abc"))         # (False, 'Слишком короткое...')
print(validate_password("secure123"))   # (True, 'OK')
```

```python
# Замыкание для работы с историей операций
def create_history_tracker():
    """Создает функцию, которая запоминает историю вызовов"""
    history = []
    
    def track(action):
        from datetime import datetime
        timestamp = datetime.now().strftime("%H:%M:%S")
        history.append((timestamp, action))
        return f"[{timestamp}] {action}"
    
    def get_history():
        return history.copy()
    
    def clear_history():
        nonlocal history
        history = []
    
    return {
        'track': track,
        'get_history': get_history,
        'clear': clear_history
    }

# Создаем трекер
tracker = create_history_tracker()

# Отслеживаем действия
print(tracker['track']("Пользователь вошел в систему"))
print(tracker['track']("Открыт файл data.txt"))
print(tracker['track']("Выполнен поиск"))

# Получаем историю
for timestamp, action in tracker['get_history']():
    print(f"{timestamp}: {action}")

# [15:30:45] Пользователь вошел в систему
# [15:30:45] Открыт файл data.txt
# [15:30:45] Выполнен поиск
```

```python
# Замыкание для создания конвертеров единиц измерения
def create_converter(from_unit, to_unit, factor):
    """Создает функцию конвертации с заданным коэффициентом"""
    
    def convert(value):
        result = value * factor
        return f"{value} {from_unit} = {result:.2f} {to_unit}"
    
    return convert

# Создаем различные конвертеры
km_to_miles = create_converter("км", "миль", 0.621371)
celsius_to_fahrenheit = create_converter("°C", "°F", 1.8)  # упрощенно
kg_to_pounds = create_converter("кг", "фунтов", 2.20462)

print(km_to_miles(10))            # 10 км = 6.21 миль
print(kg_to_pounds(70))           # 70 кг = 154.32 фунтов
```

```python
# Замыкание с условной логикой
def create_discount_calculator(user_type):
    """Создает калькулятор скидки в зависимости от типа пользователя"""
    
    # Определяем процент скидки в зависимости от типа
    if user_type == "regular":
        discount_percent = 0
    elif user_type == "silver":
        discount_percent = 5
    elif user_type == "gold":
        discount_percent = 10
    elif user_type == "platinum":
        discount_percent = 15
    else:
        discount_percent = 0
    
    def calculate_price(original_price):
        discount = original_price * (discount_percent / 100)
        final_price = original_price - discount
        return {
            'original': original_price,
            'discount_percent': discount_percent,
            'discount_amount': discount,
            'final_price': final_price
        }
    
    return calculate_price

# Создаем калькуляторы для разных типов пользователей
regular_calc = create_discount_calculator("regular")
gold_calc = create_discount_calculator("gold")
platinum_calc = create_discount_calculator("platinum")

# Рассчитываем цены
print(regular_calc(1000))   # {'original': 1000, 'discount_percent': 0, ...}
print(gold_calc(1000))      # {'original': 1000, 'discount_percent': 10, ...}
print(platinum_calc(1000))  # {'original': 1000, 'discount_percent': 15, ...}
```

```python
# Замыкание с накоплением данных
def create_statistics():
    """Создает функцию для накопления и анализа статистики"""
    values = []
    
    def add_value(value):
        values.append(value)
        return len(values)
    
    def get_stats():
        if not values:
            return None
        
        return {
            'count': len(values),
            'sum': sum(values),
            'average': sum(values) / len(values),
            'min': min(values),
            'max': max(values)
        }
    
    def reset():
        nonlocal values
        values = []
    
    return {
        'add': add_value,
        'stats': get_stats,
        'reset': reset
    }

# Создаем статистику
stats = create_statistics()

# Добавляем значения
stats['add'](10)
stats['add'](20)
stats['add'](15)
stats['add'](25)

# Получаем статистику
print(stats['stats']())
# {'count': 4, 'sum': 70, 'average': 17.5, 'min': 10, 'max': 25}
```

```python
# Замыкание для создания цепочки фильтров
def create_filter(condition_name, condition_func):
    """Создает именованный фильтр с условием"""
    
    def filter_data(data):
        filtered = [item for item in data if condition_func(item)]
        return {
            'filter_name': condition_name,
            'original_count': len(data),
            'filtered_count': len(filtered),
            'data': filtered
        }
    
    return filter_data

# Создаем различные фильтры
positive_filter = create_filter("Положительные", lambda x: x > 0)
even_filter = create_filter("Четные", lambda x: x % 2 == 0)
large_filter = create_filter("Больше 10", lambda x: x > 10)

numbers = [-5, 2, 8, -3, 15, 4, -1, 20]

print(positive_filter(numbers))
# {'filter_name': 'Положительные', 'original_count': 8, 
#  'filtered_count': 5, 'data': [2, 8, 15, 4, 20]}

print(even_filter(numbers))
# {'filter_name': 'Четные', 'original_count': 8, 
#  'filtered_count': 4, 'data': [2, 8, 4, 20]}
```



## `16.3` (`*`) Паттерн Фабрика
**Паттерн Фабрика (Factory Pattern)** — это способ создания объектов или функций через централизованную функцию-создатель. Вместо прямого создания объектов, мы вызываем фабричную функцию, которая решает, что именно создать.

**Зачем нужен паттерн Фабрика:**

- 🏭 **Централизация создания** — вся логика создания в одном месте
- 🔄 **Гибкость** — легко добавлять новые типы объектов
- 🎯 **Скрытие сложности** — пользователь не знает детали создания
- 📦 **Единообразие** — одинаковый интерфейс для создания разных объектов
- 🧪 **Упрощение тестирования** — легко подменять создаваемые объекты

**В Python без классов фабрика может создавать:**
- Функции
- Словари (структуры данных)
- Кортежи
- Любые другие значения

**Примеры:**

```python
# Простая фабрика: создание звуков животных
def animal_factory(animal_type):
    """Фабрика звуков животных"""
    
    if animal_type == "dog":
        return "Гав-гав"
    elif animal_type == "cat":
        return "Мяу"
    elif animal_type == "cow":
        return "Му-у"
    elif animal_type == "duck":
        return "Кря-кря"
    else:
        return "Неизвестный звук"

# Используем фабрику
print(animal_factory("dog"))   # Гав-гав
print(animal_factory("cat"))   # Мяу
print(animal_factory("cow"))   # Му-у
print(animal_factory("bird"))  # Неизвестный звук

# Можно использовать в цикле
animals = ["dog", "cat", "duck", "cow"]
for animal in animals:
    sound = animal_factory(animal)
    print(f"{animal}: {sound}")
```

```python
# Фабрика функций: создание математических операций
def operation_factory(operation_type):
    """Фабрика математических операций"""
    
    if operation_type == "add":
        return lambda a, b: a + b
    elif operation_type == "subtract":
        return lambda a, b: a - b
    elif operation_type == "multiply":
        return lambda a, b: a * b
    elif operation_type == "divide":
        return lambda a, b: a / b if b != 0 else "Ошибка: деление на ноль"
    elif operation_type == "power":
        return lambda a, b: a ** b
    else:
        return lambda a, b: "Неизвестная операция"

# Создаем операции через фабрику
add = operation_factory("add")
multiply = operation_factory("multiply")
power = operation_factory("power")

# Используем созданные функции
print(add(5, 3))        # 8
print(multiply(4, 7))   # 28
print(power(2, 10))     # 1024

# Динамическое использование
operations = ["add", "subtract", "multiply", "divide"]
a, b = 20, 4

for op_type in operations:
    operation = operation_factory(op_type)
    result = operation(a, b)
    print(f"{a} {op_type} {b} = {result}")
# 20 add 4 = 24
# 20 subtract 4 = 16
# 20 multiply 4 = 80
# 20 divide 4 = 5.0
```

```python
# Фабрика структур данных: создание пользователей
def user_factory(user_type, name, email):
    """Фабрика пользователей с разными правами"""
    
    # Базовая структура пользователя
    user = {
        'name': name,
        'email': email,
        'type': user_type
    }
    
    # Добавляем права в зависимости от типа
    if user_type == "guest":
        user['permissions'] = ['read']
        user['max_downloads'] = 5
    elif user_type == "user":
        user['permissions'] = ['read', 'write']
        user['max_downloads'] = 50
    elif user_type == "moderator":
        user['permissions'] = ['read', 'write', 'delete']
        user['max_downloads'] = 200
    elif user_type == "admin":
        user['permissions'] = ['read', 'write', 'delete', 'manage_users']
        user['max_downloads'] = float('inf')
    else:
        user['permissions'] = []
        user['max_downloads'] = 0
    
    return user

# Создаем разных пользователей
guest = user_factory("guest", "Гость", "guest@example.com")
regular_user = user_factory("user", "Иван", "ivan@example.com")
admin = user_factory("admin", "Админ", "admin@example.com")

print(guest)
# {'name': 'Гость', 'email': 'guest@example.com', 'type': 'guest', 
#  'permissions': ['read'], 'max_downloads': 5}

print(admin)
# {'name': 'Админ', 'email': 'admin@example.com', 'type': 'admin', 
#  'permissions': ['read', 'write', 'delete', 'manage_users'], 'max_downloads': inf}
```

```python
# Фабрика с параметрами: создание валидаторов
def validator_factory(field_type, **options):
    """Фабрика валидаторов для разных типов полей"""
    
    if field_type == "email":
        def validate(value):
            return '@' in value and '.' in value
        return validate
    
    elif field_type == "phone":
        def validate(value):
            # Простая проверка: только цифры и длина
            digits = ''.join(c for c in value if c.isdigit())
            return len(digits) >= options.get('min_length', 10)
        return validate
    
    elif field_type == "age":
        min_age = options.get('min', 0)
        max_age = options.get('max', 150)
        
        def validate(value):
            return min_age <= value <= max_age
        return validate
    
    elif field_type == "text":
        min_len = options.get('min_length', 0)
        max_len = options.get('max_length', 1000)
        
        def validate(value):
            return min_len <= len(value) <= max_len
        return validate
    
    else:
        return lambda value: True  # всегда валидно

# Создаем валидаторы через фабрику
email_validator = validator_factory("email")
phone_validator = validator_factory("phone", min_length=11)
age_validator = validator_factory("age", min=18, max=100)
username_validator = validator_factory("text", min_length=3, max_length=20)

# Используем валидаторы
print(email_validator("test@example.com"))     # True
print(email_validator("invalid-email"))        # False
print(phone_validator("+7-999-123-45-67"))     # True
print(age_validator(25))                       # True
print(age_validator(15))                       # False
print(username_validator("john"))              # True
print(username_validator("ab"))                # False
```

```python
# Фабрика с использованием словаря (более элегантный подход)
def notification_factory(notification_type):
    """Фабрика уведомлений"""
    
    # Словарь с шаблонами уведомлений
    templates = {
        "welcome": "Добро пожаловать, {name}!",
        "goodbye": "До свидания, {name}! Будем рады видеть вас снова.",
        "order": "Ваш заказ #{order_id} принят. Сумма: {amount} руб.",
        "payment": "Платеж на сумму {amount} руб. успешно проведен.",
        "error": "Произошла ошибка: {error_message}"
    }
    
    # Получаем шаблон
    template = templates.get(notification_type, "Уведомление: {message}")
    
    # Возвращаем функцию, которая форматирует сообщение
    def create_notification(**kwargs):
        return template.format(**kwargs)
    
    return create_notification

# Создаем генераторы уведомлений
welcome_msg = notification_factory("welcome")
order_msg = notification_factory("order")
payment_msg = notification_factory("payment")

# Используем
print(welcome_msg(name="Иван"))
# Добро пожаловать, Иван!

print(order_msg(order_id=12345, amount=2500))
# Ваш заказ #12345 принят. Сумма: 2500 руб.

print(payment_msg(amount=1500))
# Платеж на сумму 1500 руб. успешно проведен.
```

```python
# Практический пример: фабрика отчетов
def report_factory(report_type, data):
    """Фабрика отчетов в разных форматах"""
    
    if report_type == "summary":
        def generate():
            total = sum(data.values())
            count = len(data)
            average = total / count if count > 0 else 0
            return f"Всего: {total}, Среднее: {average:.2f}, Элементов: {count}"
        return generate
    
    elif report_type == "detailed":
        def generate():
            lines = ["Детальный отчет:"]
            for key, value in data.items():
                lines.append(f"  {key}: {value}")
            lines.append(f"Итого: {sum(data.values())}")
            return "\n".join(lines)
        return generate
    
    elif report_type == "csv":
        def generate():
            lines = ["key,value"]
            for key, value in data.items():
                lines.append(f"{key},{value}")
            return "\n".join(lines)
        return generate
    
    else:
        return lambda: "Неизвестный тип отчета"

# Данные для отчета
sales_data = {
    "Январь": 10000,
    "Февраль": 12000,
    "Март": 15000,
    "Апрель": 11000
}

# Создаем разные отчеты
summary = report_factory("summary", sales_data)
detailed = report_factory("detailed", sales_data)
csv = report_factory("csv", sales_data)

print(summary())
# Всего: 48000, Среднее: 12000.00, Элементов: 4

print("\n" + detailed())
# Детальный отчет:
#   Январь: 10000
#   Февраль: 12000
#   Март: 15000
#   Апрель: 11000
# Итого: 48000

print("\n" + csv())
# key,value
# Январь,10000
# Февраль,12000
# Март,15000
# Апрель,11000
```

**Шпаргалка:**

**Замыкание:**
```python
def outer(x):
    def inner(y):
        return x + y  # inner "помнит" x
    return inner

func = outer(10)
print(func(5))  # 15
```

**Паттерн Фабрика:**
```python
def factory(type):
    if type == "A":
        return функция_A
    elif type == "B":
        return функция_B
    return функция_по_умолчанию

obj = factory("A")
```

**Важные советы:**
- ✅ Замыкание — для сохранения состояния между вызовами
- ✅ Фабрика — для централизованного создания объектов
- ✅ Используйте `nonlocal` для изменения переменных замыкания
- ✅ Замыкание = альтернатива классам для простых случаев
- ⚠️ Не злоупотребляйте — для сложной логики лучше использовать классы

## `16.4` (`*`) Локальные и глобальные переменные. Область видимости. Правило `LEGB`
В Python **локальные переменные** объявляются внутри функций и доступны только в этих функциях. **Глобальные переменные** находятся вне всех функций и доступны во всей программе. Если объявить переменную внутри функции с тем же именем, что и глобальная — внутри функции будет использоваться локальная версия, а глобальная вне функции.

**Область видимости** — определяет, где переменная "видна" и доступна для использования. Локальные переменные исчезают после завершения функции, глобальные — сохраняются на протяжении исполнения всей программы.

### LEGB правило поиска переменных
Python ищет переменные по цепочке областей видимости:
- **L**ocal (Локальная): внутри текущей функции или метода
- **E**nclosing (Вложенная): в родительских (внешних) функциях, если используется вложенность
- **G**lobal (Глобальная): на уровне всего модуля (файла)
- **B**uilt-in (Встроенная): специальные переменные и функции Python (например, `print`, `len`)

**Глобальная переменная:**
```python
x = "глобальная переменная"

def show():
    print(x)  # доступ к глобальной переменной
show()
print(x)      # доступ вне функции
```

**Локальная переменная:**
```python
def foo():
    y = "локальная переменная"
    print(y)
foo()
# print(y)  # Ошибка, вне функции переменная недоступна
```

**LEGB - вложенные функции:**
```python
def outer():
    a = "enclosing"
    def inner():
        print(a)  # ищет переменную во внешней функции (Enclosing)
    inner()
outer()
```

**Изменение глобальной переменной внутри функции:**
```python
global_var = 10

def update():
    global global_var
    global_var = 20  # изменится глобальная переменная
update()
print(global_var)    # 20
```

----

# `17` (`*`) Декораторы
[Видео про декораторы](https://youtu.be/VnuDMPQSMjs?si=waVjxvA83EmMDevm)

## `17.1` Что такое декоратор? Как написать свой декоратор?
### **Что такое декоратор?**
**Декоратор** — это функция, которая принимает другую функцию и расширяет её поведение без изменения исходного кода. Это паттерн проектирования, который позволяет "обернуть" функцию дополнительной логикой.

**Основные характеристики:**
- Декоратор — это функция высшего порядка (принимает функцию, возвращает функцию)
- Используется синтаксис `@decorator_name` перед определением функции
- Позволяет переиспользовать код
- Не изменяет исходную функцию

**Для чего нужны декораторы:**
- Логирование вызовов функций
- Измерение времени выполнения
- Проверка прав доступа
- Кэширование результатов
- Валидация входных данных
- Обработка ошибок

### **Базовый пример**
**Без декоратора:**

```python
def say_hello():
    print("Hello!")

def add_greeting(func):
    def wrapper():
        print("--- Начало ---")
        func()
        print("--- Конец ---")
    return wrapper

say_hello = add_greeting(say_hello)
say_hello()

# Вывод:
# --- Начало ---
# Hello!
# --- Конец ---
```

**С декоратором (синтаксический сахар):**
```python
def add_greeting(func):
    def wrapper():
        print("--- Начало ---")
        func()
        print("--- Конец ---")
    return wrapper

@add_greeting
def say_hello():
    print("Hello!")

say_hello()

# Вывод:
# --- Начало ---
# Hello!
# --- Конец ---
```

**`@add_greeting`** эквивалентно **`say_hello = add_greeting(say_hello)`**

### **Как написать свой декоратор**
**Шаблон декоратора:**

```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        # Код ДО вызова функции
        result = func(*args, **kwargs)
        # Код ПОСЛЕ вызова функции
        return result
    return wrapper
```

### **Пример 1: Декоратор для логирования**

```python
def logger(func):
    def wrapper(*args, **kwargs):
        print(f"Вызов функции: {func.__name__}")
        print(f"Аргументы: args={args}, kwargs={kwargs}")
        result = func(*args, **kwargs)
        print(f"Результат: {result}")
        return result
    return wrapper

@logger
def add(a, b):
    return a + b

@logger
def greet(name, greeting="Привет"):
    return f"{greeting}, {name}!"

add(5, 3)
# Вывод:
# Вызов функции: add
# Аргументы: args=(5, 3), kwargs={}
# Результат: 8

greet("Алиса", greeting="Здравствуй")
# Вывод:
# Вызов функции: greet
# Аргументы: args=('Алиса',), kwargs={'greeting': 'Здравствуй'}
# Результат: Здравствуй, Алиса!
```

### **Пример 2: Декоратор для измерения времени выполнения**

```python
import time

def timer(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"Функция {func.__name__} выполнилась за {end - start:.4f} секунд")
        return result
    return wrapper

@timer
def slow_function():
    time.sleep(2)
    return "Готово"

@timer
def calculate_sum(n):
    return sum(range(n))

slow_function()
# Вывод: Функция slow_function выполнилась за 2.0021 секунд

calculate_sum(1000000)
# Вывод: Функция calculate_sum выполнилась за 0.0234 секунд
```

### **Пример 3: Декоратор для проверки типов**

```python
def validate_positive(func):
    def wrapper(number):
        if number <= 0:
            raise ValueError("Число должно быть положительным")
        return func(number)
    return wrapper

@validate_positive
def calculate_square_root(n):
    return n ** 0.5

print(calculate_square_root(16))  # 4.0
print(calculate_square_root(-4))  # ValueError: Число должно быть положительным
```

### **Множественные декораторы**
Можно применять несколько декораторов к одной функции:

```python
@decorator1
@decorator2
@decorator3
def my_function():
    pass

# Эквивалентно:
# my_function = decorator1(decorator2(decorator3(my_function)))
```

**Пример:**

```python
def uppercase(func):
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        return result.upper()
    return wrapper

def add_exclamation(func):
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        return result + "!!!"
    return wrapper

@uppercase
@add_exclamation
def greet(name):
    return f"hello, {name}"

print(greet("Alice"))
# Вывод: HELLO, ALICE!!!

# Порядок выполнения:
# 1. greet("Alice") → "hello, Alice"
# 2. add_exclamation → "hello, Alice!!!"
# 3. uppercase → "HELLO, ALICE!!!"
```

## `17.2` (`**`) Есть ли что-то похожее в других языках?
Да, декораторы или похожие паттерны существуют во многих языках программирования. Концепция "обёртывания" функций является универсальной.

### **Java — Аннотации**
В Java используются **аннотации** — специальные метки, которые добавляют метаданные к коду. Они помечаются символом `@` перед именем класса, метода или поля.

**Примеры использования:**
- `@Override` — указывает, что метод переопределяет метод родительского класса
- `@Deprecated` — помечает устаревший код, который не рекомендуется использовать
- `@Autowired` — в Spring Framework автоматически внедряет зависимости
- `@GetMapping` — в Spring определяет HTTP GET endpoint для веб-сервиса

**Особенности:**
- Используются для метаданных, а не для модификации поведения
- Обрабатываются во время компиляции или выполнения программы
- Широко применяются в фреймворках (Spring, Hibernate, JUnit)
- Не изменяют логику напрямую, а указывают как должен работать фреймворк

### **C# — Атрибуты**
В C# есть **атрибуты** — аналог Java-аннотаций. Они записываются в квадратных скобках перед объявлением класса, метода или свойства.

**Примеры использования:**
- `[Obsolete]` — помечает устаревший код с предупреждением для разработчика
- `[HttpGet]` — в ASP.NET определяет HTTP GET метод для API
- `[Route]` — задаёт URL маршрут для контроллера
- `[Serializable]` — указывает, что объект можно сериализовать

**Особенности:**
- Похожи на Java-аннотации по назначению и синтаксису
- Используются для метаданных и рефлексии
- Применяются к классам, методам, свойствам, параметрам
- Фреймворки читают эти атрибуты через рефлексию для настройки поведения

### **TypeScript/JavaScript — Декораторы**
**TypeScript** поддерживает **декораторы** как экспериментальную функцию — это самая близкая к Python реализация. Используется синтаксис `@decorator` перед объявлением класса или метода.

**JavaScript** не имеет встроенного синтаксиса для декораторов, но широко использует **функции высшего порядка** — функции, которые принимают другие функции и возвращают новые с изменённым поведением. Это тот же принцип, что и в Python, но без синтаксического сахара `@`.

**Особенности TypeScript:**
- Экспериментальная функция, требует включения в конфигурации
- Синтаксис максимально похож на Python
- Используется для модификации классов и методов

**Особенности JavaScript:**
- Функции высшего порядка — основной способ обёртывания функций
- Нет специального синтаксиса, используется обычный вызов функций
- Широко применяется в React (Higher-Order Components)

### **Ruby — Методы-модификаторы**
В Ruby нет специального синтаксиса для декораторов, но есть мощное **метапрограммирование** и возможность изменять классы во время выполнения.

**Техника "monkey patching":**
- Можно переопределить любой метод в любом классе
- Используется `alias_method` для сохранения оригинального метода
- Затем переопределяется метод с вызовом оригинального внутри

**Особенности:**
- Очень гибкий подход, но может быть опасным
- Изменения видны глобально во всей программе
- Нет явного синтаксиса для декорирования
- Используется метапрограммирование и динамическая природа языка

### **PHP — Атрибуты**
Начиная с **PHP 8**, появились **атрибуты** — механизм похожий на Java-аннотации. Используется синтаксис `#[AttributeName]` перед функцией или классом.

**Примеры использования:**
- `#[Route]` — определяет маршрут для контроллера
- `#[Deprecated]` — помечает устаревший код
- Используется в современных фреймворках (Symfony, Laravel)

**Особенности:**
- Добавлены только в PHP 8 (2020 год)
- Похожи на Java-аннотации и C#-атрибуты
- Используются для метаданных, обрабатываются через рефлексию

### **Go — Функции высшего порядка**
В Go **нет встроенных декораторов** и специального синтаксиса для них. Но язык поддерживает функции как значения первого класса, что позволяет использовать **функции высшего порядка**.

**Подход:**
- Создаётся функция, которая принимает другую функцию
- Возвращается новая функция с расширенным поведением
- Нужно явно присваивать результат переменной

**Особенности:**
- Нет синтаксического сахара `@decorator`
- Более многословный подход
- Явное управление обёртыванием функций
- Типизация усложняет создание универсальных декораторов

### **Сравнительная таблица**
| Язык | Синтаксис | Название | Особенности |
|------|-----------|----------|-------------|
| **Python** | `@decorator` | Декораторы | Полноценные, модифицируют поведение во время выполнения |
| **Java** | `@Annotation` | Аннотации | Метаданные, обрабатываются компилятором/runtime |
| **C#** | `[Attribute]` | Атрибуты | Метаданные, используются через рефлексию |
| **TypeScript** | `@decorator` | Декораторы | Экспериментальная функция, похожа на Python |
| **JavaScript** | Функции высшего порядка | - | Нет синтаксического сахара |
| **Ruby** | `alias_method` | - | Monkey patching, метапрограммирование |
| **PHP** | `#[Attribute]` | Атрибуты | С PHP 8, похожи на Java |
| **Go** | Функции высшего порядка | - | Нет встроенного синтаксиса |


**Вывод:** 
Python-декораторы наиболее близки к TypeScript-декораторам по синтаксису и функциональности. Оба языка используют символ `@` и позволяют модифицировать поведение функций напрямую.

Java и C# используют похожую концепцию, но их аннотации/атрибуты больше предназначены для метаданных, которые затем обрабатываются фреймворками, а не для прямого изменения логики.

JavaScript и Go используют функции высшего порядка без специального синтаксиса — это более явный, но менее удобный подход.

Ruby идёт своим путём через метапрограммирование и динамическое изменение классов.

## `17.3` Атрибуты `__name__` & `__doc__`
Когда функция оборачивается декоратором, она теряет свои метаданные: имя, строку документации и другие атрибуты. Это может создать проблемы при отладке и использовании инструментов рефлексии.

### **Проблема потери метаданных**

```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        """Это wrapper функция"""
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def greet(name):
    """Приветствует пользователя по имени"""
    return f"Hello, {name}!"

print(greet.__name__)  # wrapper (не greet!)
print(greet.__doc__)   # Это wrapper функция (не оригинальная документация!)
```

**Что произошло:**
- `greet.__name__` показывает `"wrapper"` вместо `"greet"`
- `greet.__doc__` показывает документацию wrapper'а, а не оригинальной функции
- Теряется информация об оригинальной функции

### **Атрибуты функций**
Основные атрибуты функций в Python:

| Атрибут | Описание | Пример |
|---------|----------|---------|
| `__name__` | Имя функции | `"greet"` |
| `__doc__` | Строка документации | `"Приветствует пользователя"` |
| `__module__` | Модуль, где определена функция | `"__main__"` |
| `__qualname__` | Квалифицированное имя | `"MyClass.method"` |
| `__annotations__` | Аннотации типов | `{"name": str, "return": str}` |

**Пример:**
```python
def calculate_area(width: float, height: float) -> float:
    """
    Вычисляет площадь прямоугольника.
    
    Args:
        width: ширина
        height: высота
    
    Returns:
        Площадь прямоугольника
    """
    return width * height

print(calculate_area.__name__)        # calculate_area
print(calculate_area.__doc__)         # Вычисляет площадь...
print(calculate_area.__module__)      # __main__
print(calculate_area.__annotations__) # {'width': <class 'float'>, ...}
```

### **Ручное сохранение метаданных**
Можно вручную копировать атрибуты из оригинальной функции:

```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    
    # Вручную копируем метаданные
    wrapper.__name__ = func.__name__
    wrapper.__doc__ = func.__doc__
    wrapper.__module__ = func.__module__
    wrapper.__annotations__ = func.__annotations__
    
    return wrapper

@my_decorator
def greet(name: str) -> str:
    """Приветствует пользователя"""
    return f"Hello, {name}!"

print(greet.__name__)  # greet
print(greet.__doc__)   # Приветствует пользователя
```

**Проблема:** Это неудобно и легко забыть скопировать все необходимые атрибуты.


## `17.4` `@functools.wraps` - что такое и зачем?
`functools.wraps` — это декоратор для декораторов, который автоматически копирует метаданные из оригинальной функции в wrapper-функцию.

**Зачем нужен:**
- Сохраняет `__name__`, `__doc__`, `__module__` и другие атрибуты
- Упрощает написание декораторов
- Облегчает отладку
- Корректно работает с инструментами документации

### **Синтаксис**
```python
from functools import wraps

def my_decorator(func):
    @wraps(func)  # ← Сохраняет метаданные оригинальной функции
    def wrapper(*args, **kwargs):
        # Дополнительная логика
        return func(*args, **kwargs)
    return wrapper
```

### **Пример: Без `@wraps` vs С `@wraps`**
**Без `@wraps`:**

```python
def logger(func):
    def wrapper(*args, **kwargs):
        """Wrapper функция для логирования"""
        print(f"Вызов: {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

@logger
def add(a, b):
    """Складывает два числа"""
    return a + b

print(add.__name__)  # wrapper
print(add.__doc__)   # Wrapper функция для логирования
help(add)
# Help on function wrapper in module __main__:
# wrapper(*args, **kwargs)
#     Wrapper функция для логирования
```

**С `@wraps`:**

```python
from functools import wraps

def logger(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        """Wrapper функция для логирования"""
        print(f"Вызов: {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

@logger
def add(a, b):
    """Складывает два числа"""
    return a + b

print(add.__name__)  # add
print(add.__doc__)   # Складывает два числа
help(add)
# Help on function add in module __main__:
# add(a, b)
#     Складывает два числа
```

### **Практические примеры**
**Пример 1: Декоратор с `@wraps`**

```python
from functools import wraps
import time

def timer(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} выполнилась за {end - start:.4f}s")
        return result
    return wrapper

@timer
def calculate_fibonacci(n: int) -> int:
    """Вычисляет n-ое число Фибоначчи"""
    if n <= 1:
        return n
    return calculate_fibonacci(n - 1) + calculate_fibonacci(n - 2)

# Метаданные сохранены
print(calculate_fibonacci.__name__)  # calculate_fibonacci
print(calculate_fibonacci.__doc__)   # Вычисляет n-ое число Фибоначчи

calculate_fibonacci(10)
# calculate_fibonacci выполнилась за 0.0003s
```

**Пример 2: Декоратор для кэширования**

```python
from functools import wraps

def cache(func):
    cached_results = {}
    
    @wraps(func)
    def wrapper(*args):
        if args not in cached_results:
            cached_results[args] = func(*args)
            print(f"Вычислено: {func.__name__}{args}")
        else:
            print(f"Из кэша: {func.__name__}{args}")
        return cached_results[args]
    
    return wrapper

@cache
def expensive_computation(x, y):
    """Выполняет сложное вычисление"""
    return x ** y

print(expensive_computation.__name__)  # expensive_computation (не wrapper!)

print(expensive_computation(2, 10))  # Вычислено: expensive_computation(2, 10)
print(expensive_computation(2, 10))  # Из кэша: expensive_computation(2, 10)
print(expensive_computation(3, 5))   # Вычислено: expensive_computation(3, 5)
```

### **Какие атрибуты копирует `@wraps`**
`functools.wraps` копирует следующие атрибуты:
- `__module__` — имя модуля
- `__name__` — имя функции
- `__qualname__` — квалифицированное имя
- `__annotations__` — аннотации типов
- `__doc__` — строка документации
- `__dict__` — словарь атрибутов функции

**Вывод:** Всегда используйте `@functools.wraps` при написании декораторов!


## `17.5` Параметризованный декоратор
**Параметризованный декоратор** — это декоратор, который принимает аргументы. Это позволяет настраивать поведение декоратора.

### **Структура параметризованного декоратора**

```python
def decorator_with_params(param1, param2):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # Используем param1, param2
            return func(*args, **kwargs)
        return wrapper
    return decorator
```

**Три уровня функций:**
1. **Внешняя функция** — принимает параметры декоратора
2. **Средняя функция** — принимает декорируемую функцию
3. **Внутренняя функция (wrapper)** — выполняет саму логику

### **Пример 1: Декоратор с параметром количества повторов**

```python
from functools import wraps

def repeat(times):
    """Повторяет выполнение функции заданное количество раз"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for _ in range(times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(times=3)
def greet(name):
    print(f"Hello, {name}!")

greet("Alice")
# Вывод:
# Hello, Alice!
# Hello, Alice!
# Hello, Alice!

@repeat(times=5)
def show_number(n):
    print(n)

show_number(42)
# Вывод: 42 (5 раз)
```

### **Пример 2: Декоратор с проверкой прав доступа**

```python
from functools import wraps

def requires_permission(permission):
    """Проверяет наличие прав доступа"""
    def decorator(func):
        @wraps(func)
        def wrapper(user, *args, **kwargs):
            if permission not in user.get("permissions", []):
                raise PermissionError(f"Требуется право: {permission}")
            return func(user, *args, **kwargs)
        return wrapper
    return decorator

@requires_permission("admin")
def delete_user(user, user_id):
    print(f"Пользователь {user_id} удалён")

@requires_permission("read")
def view_data(user):
    print("Просмотр данных")

# Использование
admin_user = {"name": "Alice", "permissions": ["admin", "read", "write"]}
regular_user = {"name": "Bob", "permissions": ["read"]}

delete_user(admin_user, 123)  # ✓ Пользователь 123 удалён
delete_user(regular_user, 123)  # ✗ PermissionError: Требуется право: admin

view_data(regular_user)  # ✓ Просмотр данных
```

### **Пример 3: Декоратор для повторных попыток**

```python
from functools import wraps
import time
import random

def retry(max_attempts=3, delay=1):
    """Повторяет выполнение функции при ошибке"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            attempts = 0
            while attempts < max_attempts:
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    attempts += 1
                    if attempts >= max_attempts:
                        raise
                    print(f"Попытка {attempts} неудачна. Повтор через {delay}s...")
                    time.sleep(delay)
        return wrapper
    return decorator

@retry(max_attempts=5, delay=2)
def unstable_api_call():
    """Симуляция нестабильного API"""
    if random.random() < 0.7:  # 70% вероятность ошибки
        raise ConnectionError("API недоступен")
    return "Успех!"

result = unstable_api_call()
print(result)
# Попытка 1 неудачна. Повтор через 2s...
# Попытка 2 неудачна. Повтор через 2s...
# Успех!
```

### **Пример 4: Декоратор для валидации типов**

```python
from functools import wraps

def validate_types(**expected_types):
    """Проверяет типы аргументов функции"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # Проверяем kwargs
            for arg_name, arg_value in kwargs.items():
                if arg_name in expected_types:
                    expected_type = expected_types[arg_name]
                    if not isinstance(arg_value, expected_type):
                        raise TypeError(
                            f"Аргумент '{arg_name}' должен быть {expected_type.__name__}, "
                            f"получен {type(arg_value).__name__}"
                        )
            return func(*args, **kwargs)
        return wrapper
    return decorator

@validate_types(name=str, age=int, salary=float)
def create_user(name, age, salary):
    print(f"Создан пользователь: {name}, {age} лет, зарплата {salary}")

create_user(name="Alice", age=30, salary=50000.0)  # ✓ OK
create_user(name="Bob", age="25", salary=60000.0)  # ✗ TypeError
```

### **Пример 5: Декоратор для логирования с уровнем детализации**

```python
from functools import wraps
import logging

def log(level="INFO"):
    """Логирует вызов функции с заданным уровнем"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            logger = logging.getLogger(func.__module__)
            log_message = f"Вызов {func.__name__} с args={args}, kwargs={kwargs}"
            
            if level == "DEBUG":
                logger.debug(log_message)
            elif level == "INFO":
                logger.info(log_message)
            elif level == "WARNING":
                logger.warning(log_message)
            elif level == "ERROR":
                logger.error(log_message)
            
            result = func(*args, **kwargs)
            logger.info(f"{func.__name__} вернула: {result}")
            return result
        return wrapper
    return decorator

logging.basicConfig(level=logging.DEBUG)

@log(level="DEBUG")
def add(a, b):
    return a + b

@log(level="WARNING")
def divide(a, b):
    return a / b

add(5, 3)
divide(10, 2)
```

### **Универсальный шаблон**

```python
from functools import wraps

def my_decorator(param1=default1, param2=default2):
    """Описание декоратора"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # Логика ДО вызова функции
            # Можно использовать param1, param2
            
            result = func(*args, **kwargs)
            
            # Логика ПОСЛЕ вызова функции
            
            return result
        return wrapper
    return decorator

@my_decorator(param1=value1, param2=value2)
def my_function():
    pass
```

**Когда использовать параметризованные декораторы:**
- Когда нужна гибкая настройка поведения
- Для переиспользуемых декораторов с разными параметрами
- Когда один декоратор должен работать по-разному в разных случаях

----

# `18` (`*`) Итераторы
[Видосик про Итераторы](https://www.youtube.com/watch?v=Lnk-Xhje27Q)

## `18.1` Что такое итераторы? Зачем они нужны? В чем их профит?
**Что такое итератор?**

`Итератор` — это специальный объект в Python, который умеет выдавать элементы по одному, когда вы их запрашиваете. 

Представьте: у вас есть коробка с 1000 шариков. Есть два способа с ними работать:
- **Способ 1 (список):** Высыпать все 1000 шариков на стол сразу — они занимают много места
- **Способ 2 (итератор):** Брать по одному шарику из коробки, когда нужно — место почти не занимает

**Как это работает технически:**

Когда вы пишете цикл `for`, Python за кулисами делает примерно следующее:

```python
# Когда вы пишете:
for item in [1, 2, 3]:
    print(item)

# Python на самом деле делает что-то вроде:
items = [1, 2, 3]
iterator = iter(items)  # Создает итератор из списка

try:
    while True:
        item = next(iterator)  # Берет следующий элемент
        print(item)
except StopIteration:  # Когда элементы закончились
    pass  # Выходит из цикла
```

**Две главные функции для работы с итераторами:**
- `iter(объект)` — создает итератор из объекта
- `next(итератор)` — берет следующий элемент из итератора

**Пример 1: Ручная работа с итератором**
```python
# У нас есть список
numbers = [10, 20, 30]

# Создаем из него итератор
my_iterator = iter(numbers)

# Берем элементы по одному вручную
print(next(my_iterator))  # 10
print(next(my_iterator))  # 20
print(next(my_iterator))  # 30

# Если попытаться взять еще один — ошибка
# print(next(my_iterator))  # StopIteration — элементы кончились!
```

**Пример 2: Итератор со строкой**
```python
text = "привет"
text_iterator = iter(text)

print(next(text_iterator))  # 'п'
print(next(text_iterator))  # 'р'
print(next(text_iterator))  # 'и'
print(next(text_iterator))  # 'в'
print(next(text_iterator))  # 'е'
print(next(text_iterator))  # 'т'
```

**Зачем нужны итераторы:**

1. **Экономия памяти** — не нужно хранить все данные в памяти одновременно
   ```python
   # Список — все 1 миллион чисел в памяти
   big_list = list(range(1000000))  # Занимает ~8 МБ памяти
   
   # Итератор — хранит только "где мы сейчас находимся"
   big_iterator = iter(range(1000000))  # Занимает ~100 байт
   ```

2. **Работа с данными, которые не помещаются в память**
   ```python
   # Огромный файл на 10 ГБ
   with open('huge_file.txt') as f:
       for line in f:  # f — это итератор!
           print(line)  # Читает по одной строке, а не весь файл
   ```

3. **Ленивые вычисления** — элемент вычисляется только когда нужен
   ```python
   # Не вычисляет все квадраты сразу, а только по запросу
   squares = (x**2 for x in range(1000000))
   print(next(squares))  # 0 — вычислил только первый
   print(next(squares))  # 1 — вычислил только второй
   ```

**Профит (выгода):**
- **Память:** Обработка миллиарда чисел требует не гигабайты, а килобайты памяти
- **Скорость запуска:** Программа начинает работать сразу, не дожидаясь загрузки всех данных
- **Гибкость:** Можно работать с потоками данных (сеть, файлы, датчики) в реальном времени


## `18.2` Генераторы
**Что такое генератор?**
`Генератор` — это функция, которая умеет "останавливаться" и "продолжаться".

Обычная функция:
- Выполняется от начала до конца
- `return` возвращает результат и функция завершается

Функция-генератор:
- Может останавливаться на `yield` и возвращать значение
- При следующем вызове продолжает работу с места остановки
- `yield` значит "вернуть значение, но не забывать, где остановились"

**Как создать генератор:**

Просто напишите функцию и используйте `yield` вместо `return`.

**Пример 1: Простейший генератор**
```python
def my_first_generator():
    print("Начали работу")
    yield 1  # Остановка 1: вернуть 1
    print("Продолжили работу")
    yield 2  # Остановка 2: вернуть 2
    print("Почти закончили")
    yield 3  # Остановка 3: вернуть 3
    print("Всё, закончили")

# Создаем генератор (функция еще не выполнилась!)
gen = my_first_generator()

print(next(gen))  
# Напечатает: Начали работу
#             1

print(next(gen))
# Напечатает: Продолжили работу
#             2

print(next(gen))
# Напечатает: Почти закончили
#             3

# print(next(gen))
# Напечатает: Всё, закончили
# StopIteration — элементы закончились
```

**Обратите внимание:** Строки `print` выполняются только когда доходит до них очередь!

**Пример 2: Генератор счетчика**
```python
def count_up_to(max_number):
    """Генератор, который считает от 1 до max_number"""
    current = 1
    while current <= max_number:
        yield current  # Вернуть текущее число
        current += 1   # Увеличить счетчик

# Использование в цикле
for number in count_up_to(5):
    print(number)  # 1, 2, 3, 4, 5

# Или вручную
counter = count_up_to(3)
print(next(counter))  # 1
print(next(counter))  # 2
print(next(counter))  # 3
```

**Пример 3: Генератор четных чисел**
```python
def even_numbers(up_to):
    """Генерирует четные числа от 0 до up_to"""
    number = 0
    while number <= up_to:
        yield number
        number += 2

for num in even_numbers(10):
    print(num, end=' ')  # 0 2 4 6 8 10
```

**Генераторные выражения (короткая запись):**

Есть короткий способ создать генератор — похоже на создание списка, но с круглыми скобками:

```python
# Создание списка (все элементы сразу в памяти)
squares_list = [x**2 for x in range(10)]
print(squares_list)  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# Генераторное выражение (элементы создаются по запросу)
squares_gen = (x**2 for x in range(10))
print(squares_gen)  # <generator object> — не список!

# Берем элементы
print(next(squares_gen))  # 0
print(next(squares_gen))  # 1
print(next(squares_gen))  # 4

# Или в цикле
for square in (x**2 for x in range(5)):
    print(square, end=' ')  # 0 1 4 9 16
```

**Пример 4: Практическая задача — чтение большого файла**

```python
def read_numbers_from_file(filename):
    """Читает числа из файла по одному"""
    with open(filename, 'r') as file:
        for line in file:
            # Каждую строку превращаем в число и отдаем
            yield int(line.strip())

# Файл может быть огромным, но в памяти только одно число!
for number in read_numbers_from_file('numbers.txt'):
    if number > 100:
        print(f"Нашли большое число: {number}")
```

**Ключевые моменты:**

- Генератор — это функция с `yield`
- `yield` работает как "пауза" в функции
- Генератор помнит свое состояние между вызовами
- Генератор создается сразу, но код начинает выполняться только при первом `next()`


## `18.3` В чем разница генераторов от итераторов?  
**Главное правило:** `Генератор` — это всегда `итератор`, но `итератор` — не всегда `генератор`.

Это как сказать: "Любая собака — это животное, но не любое животное — это собака"

**Что такое итератор (в общем смысле):**

Итератор — это любой объект, который умеет:
1. Выдавать элементы по одному через `next()`
2. Сообщать когда элементы закончились (через ошибку `StopIteration`)

**Что такое генератор:**

Генератор — это **способ создать** итератор с помощью функции с `yield`. Это как конструктор для создания итератора.

**Итераторами являются:**
- Генераторы (функции с `yield`)
- Файлы
- `range()`
- Строки, списки, кортежи (после `iter()`)
- Много других встроенных объектов

**Сравнение на примере:**

```python
# ИТЕРАТОР ИЗ СПИСКА
my_list = [1, 2, 3]
list_iterator = iter(my_list)  # Превратили список в итератор

print(next(list_iterator))  # 1
print(next(list_iterator))  # 2

# ГЕНЕРАТОР (это тоже итератор!)
def my_generator():
    yield 1
    yield 2
    yield 3

gen = my_generator()  # Создали генератор

print(next(gen))  # 1
print(next(gen))  # 2

# Оба работают через next() — оба итераторы!
# Но создали мы их по-разному
```

**Основные различия:**

| **Аспект** | **Обычный итератор** | **Генератор** |
|------------|---------------------|---------------|
| **Как создать** | `iter()` от существующего объекта | Функция с `yield` |
| **Сложность** | Простой (берет из готовых данных) | Можем писать любую логику |
| **Код** | Короткий (`iter(список)`) | Пишем функцию |
| **Гибкость** | Ограниченная | Очень гибкая |
| **Когда использовать** | Готовые данные уже есть | Нужно генерировать данные "на лету" |

**Пример: Одна и та же задача разными способами**

Задача: получить числа от 1 до 5

```python
# СПОСОБ 1: Список + итератор
numbers_list = [1, 2, 3, 4, 5]
iterator1 = iter(numbers_list)

for num in iterator1:
    print(num, end=' ')  # 1 2 3 4 5

# СПОСОБ 2: Генератор
def generate_numbers():
    for i in range(1, 6):
        yield i

iterator2 = generate_numbers()

for num in iterator2:
    print(num, end=' ')  # 1 2 3 4 5

# СПОСОБ 3: Генераторное выражение
iterator3 = (i for i in range(1, 6))

for num in iterator3:
    print(num, end=' ')  # 1 2 3 4 5
```

Все три способа дают итератор, но третий (генератор) самый гибкий.

**Когда генератор лучше:**

```python
# Нужно генерировать бесконечную последовательность
def infinite_numbers():
    num = 0
    while True:  # Бесконечный цикл!
        yield num
        num += 1

# Список так сделать невозможно!
# infinite_list = [0, 1, 2, 3, ...]  # Нельзя!

gen = infinite_numbers()
print(next(gen))  # 0
print(next(gen))  # 1
print(next(gen))  # 2
# И так можно бесконечно
```

**Важное отличие — повторное использование:**

```python
# Список можно перебрать много раз
my_list = [1, 2, 3]
for num in my_list:
    print(num, end=' ')  # 1 2 3

for num in my_list:
    print(num, end=' ')  # 1 2 3 — снова работает!

# Генератор "одноразовый"
def my_gen():
    yield 1
    yield 2
    yield 3

gen = my_gen()

for num in gen:
    print(num, end=' ')  # 1 2 3

for num in gen:
    print(num, end=' ')  # Ничего! Генератор "израсходован"

# Нужно создать новый
gen = my_gen()  # Создаем заново
for num in gen:
    print(num, end=' ')  # 1 2 3 — теперь работает
```

**Простое объяснение:**
- **Итератор** — это категория объектов (как "транспорт")
- **Генератор** — это конкретный вид итератора (как "велосипед")
- Все генераторы — итераторы
- Но не все итераторы — генераторы


## `18.4` Когда использовать и кейсы
**Когда использовать итераторы и генераторы:**
### **1. Работа с большими объемами данных**

Если данных много и они не помещаются в память — используйте итераторы/генераторы.

**Кейс: Обработка большого файла**

```python
# ❌ ПЛОХО — весь файл в память (может быть 10 ГБ!)
def process_file_bad(filename):
    with open(filename, 'r', encoding='utf-8') as f:
        all_lines = f.readlines()  # Загрузили ВСЁ в память!
    
    for line in all_lines:
        # обрабатываем строку
        process_line(line)

# ✅ ХОРОШО — по одной строке
def process_file_good(filename):
    with open(filename, 'r', encoding='utf-8') as f:
        for line in f:  # Файл — это итератор!
            # обрабатываем строку
            process_line(line)  # В памяти только одна строка

# ✅ ЕЩЕ ЛУЧШЕ — свой генератор с обработкой
def read_and_clean_lines(filename):
    """Генератор: читает и очищает строки"""
    with open(filename, 'r', encoding='utf-8') as f:
        for line in f:
            cleaned = line.strip()  # Убираем пробелы
            if cleaned:  # Пропускаем пустые
                yield cleaned

# Использование
for line in read_and_clean_lines('big_data.txt'):
    print(line)  # В памяти всегда только одна строка
```

### **2. Цепочки обработки данных (pipeline)**

Когда нужно выполнить несколько операций последовательно.

**Кейс: Обработка чисел из файла**

```python
def read_numbers(filename):
    """Шаг 1: Читаем числа из файла"""
    with open(filename, 'r') as f:
        for line in f:
            yield int(line.strip())

def filter_positive(numbers):
    """Шаг 2: Оставляем только положительные"""
    for num in numbers:
        if num > 0:
            yield num

def square_numbers(numbers):
    """Шаг 3: Возводим в квадрат"""
    for num in numbers:
        yield num ** 2

def limit_results(numbers, max_count):
    """Шаг 4: Берем первые max_count результатов"""
    count = 0
    for num in numbers:
        if count >= max_count:
            break
        yield num
        count += 1

# Строим цепочку (ничего еще не вычислилось!)
step1 = read_numbers('numbers.txt')
step2 = filter_positive(step1)
step3 = square_numbers(step2)
step4 = limit_results(step3, 5)

# Только теперь начинаются вычисления!
for result in step4:
    print(result)

# Можно записать короче:
for result in limit_results(
    square_numbers(
        filter_positive(
            read_numbers('numbers.txt')
        )
    ), 5
):
    print(result)
```

**Преимущество:** Обрабатывается только 5 чисел, хотя в файле может быть миллион!

### **3. Бесконечные последовательности**

Когда нужен бесконечный источник данных.

**Кейс: Бесконечный счетчик**

```python
def counter(start=0, step=1):
    """Бесконечно считает с заданным шагом"""
    current = start
    while True:  # Бесконечный цикл!
        yield current
        current += step

# Берем столько, сколько нужно
c = counter(10, 5)
for _ in range(5):  # Возьмем только 5 значений
    print(next(c))  # 10, 15, 20, 25, 30
```

**Кейс: Генератор случайных данных**

```python
import random

def random_numbers():
    """Бесконечный генератор случайных чисел"""
    while True:
        yield random.randint(1, 100)

# Генерируем пока не найдем число > 95
gen = random_numbers()
for num in gen:
    print(num)
    if num > 95:
        break  # Выходим когда нужно
```

### **4. Ленивые вычисления**

Когда вычисления дорогие и нужны не все результаты.

**Кейс: Поиск простых чисел**

```python
def is_prime(n):
    """Проверка, является ли число простым (медленная операция)"""
    if n < 2:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

def prime_numbers():
    """Генератор простых чисел"""
    num = 2
    while True:
        if is_prime(num):  # Проверка только когда нужно!
            yield num
        num += 1

# Найдем первые 10 простых чисел
primes = prime_numbers()
for _ in range(10):
    print(next(primes), end=' ')  # 2 3 5 7 11 13 17 19 23 29

# Если бы мы делали список, пришлось бы проверить ВСЕ числа заранее!
```

### **5. Экономия памяти при преобразованиях**

**Кейс: Обработка логов**

```python
def parse_log_lines(filename):
    """Парсим строки лога"""
    with open(filename, 'r') as f:
        for line in f:
            # Пример строки: "2025-01-15 ERROR Something went wrong"
            parts = line.strip().split(' ', 2)
            if len(parts) == 3:
                date, level, message = parts
                yield {'date': date, 'level': level, 'message': message}

def filter_errors(log_entries):
    """Оставляем только ошибки"""
    for entry in log_entries:
        if entry['level'] == 'ERROR':
            yield entry

# Обрабатываем только ошибки, остальное не загружаем в память
logs = parse_log_lines('app.log')
errors = filter_errors(logs)

for error in errors:
    print(f"{error['date']}: {error['message']}")
```

### **Когда НЕ нужно использовать итераторы/генераторы:**

1. **Данные помещаются в память** — используйте обычный список
   ```python
   # Если данных мало — список проще
   small_data = [1, 2, 3, 4, 5]
   ```

2. **Нужен доступ по индексу**
   ```python
   # С генератором нельзя:
   # gen[5]  # Ошибка!
   
   # Нужен список:
   data = [1, 2, 3, 4, 5]
   print(data[2])  # 3 — работает
   ```

3. **Нужно узнать длину заранее**
   ```python
   # len(генератор) не работает!
   # Нужен список или кортеж
   ```

4. **Нужно проходить по данным много раз**
   ```python
   # Генератор "одноразовый"
   gen = (x for x in range(5))
   list(gen)  # [0, 1, 2, 3, 4]
   list(gen)  # [] — пустой! Израсходован
   
   # Список можно использовать многократно
   my_list = list(range(5))
   list(my_list)  # [0, 1, 2, 3, 4]
   list(my_list)  # [0, 1, 2, 3, 4] — всё ещё работает
   ```

**Правило большого пальца:**
- Данных мало (< 10000 элементов) → используйте список
- Данных много или они не все нужны → используйте генератор
- Нужна гибкость (доступ по индексу, длина, многократный проход) → список
- Нужна экономия памяти или бесконечность → генератор

----

# `19` (`*`) Type hints
[Большое видео про Type hints](https://www.youtube.com/watch?v=RwH2UzC2rIo)

## `19.1` Что такое и зачем нужны?
### **Что такое Type hints?**

**Type hints (аннотации типов)** — это синтаксис Python для указания ожидаемых типов переменных, параметров функций и возвращаемых значений. Это необязательные подсказки, которые не влияют на выполнение кода, но помогают в разработке.

**Основные характеристики:**
- Добавлены в Python 3.5 (PEP 484)
- Не обязательны — Python остаётся динамически типизированным
- Игнорируются интерпретатором Python
- Проверяются внешними инструментами (mypy, pyright, pyre)

**Синтаксис:**

```python
# Без type hints
def greet(name):
    return f"Hello, {name}!"

# С type hints
def greet(name: str) -> str:
    return f"Hello, {name}!"

# Переменные с аннотациями
age: int = 25
price: float = 99.99
items: list[int] = [1, 2, 3]
```

### **Зачем нужны type hints?**
**1. Улучшение читаемости кода**

Сразу видно, какие типы данных ожидаются:

```python
# Непонятно, что принимает и возвращает
def process(data, config):
    return data

# Понятно с первого взгляда
def process(data: dict, config: dict) -> list:
    return list(data.values())
```

**2. Раннее обнаружение ошибок**

Статические анализаторы находят ошибки до запуска кода:

```python
def add(a: int, b: int) -> int:
    return a + b

result = add(5, "10")  # mypy найдёт ошибку: str вместо int
```

**3. Улучшение автодополнения в IDE**

IDE знают типы и предлагают правильные методы:

```python
def get_user(user_id: int) -> dict:
    return {"name": "Alice", "age": 30}

user = get_user(123)
# IDE знает, что user — dict, и предложит .get(), .keys(), .items()
```

**4. Упрощение рефакторинга**

При изменении типов легко найти все места, где нужны правки:

```python
# Меняем возвращаемый тип с dict на list
def get_users(limit: int) -> list:  # было dict
    return []

# Анализатор покажет все места, где код ожидал dict
```

**5. Самодокументирование кода**

Не нужно читать весь код функции, чтобы понять интерфейс:

```python
def calculate_discount(
    price: float,
    discount_percent: float,
    min_price: float = 0.0
) -> float:
    """Вычисляет цену со скидкой"""
    discounted = price * (1 - discount_percent / 100)
    return max(discounted, min_price)
```

### **Практические примеры**
**Пример 1: Функции с type hints**

```python
def calculate_area(width: float, height: float) -> float:
    return width * height

def find_user(user_id: int) -> dict | None:
    """Возвращает пользователя или None"""
    if user_id in database:
        return database[user_id]
    return None
```

**Пример 2: Класс с type hints**

```python
class User:
    def __init__(self, name: str, age: int) -> None:
        self.name: str = name
        self.age: int = age
    
    def get_info(self) -> str:
        return f"{self.name}, {self.age} лет"
    
    def is_adult(self) -> bool:
        return self.age >= 18
```

**Пример 3: Коллекции с типами**

```python
# Списки, словари, множества
numbers: list[int] = [1, 2, 3, 4, 5]
scores: dict[str, int] = {"Alice": 100, "Bob": 95}
tags: set[str] = {"python", "typing"}
coordinates: tuple[float, float] = (12.5, 45.3)
```

### **Важно: Type hints не выполняются во время работы**

```python
def add(a: int, b: int) -> int:
    return a + b

# Python НЕ проверяет типы во время выполнения
result = add("Hello", "World")  # Код выполнится без ошибок!
print(result)  # HelloWorld

# Но mypy найдёт ошибку при статическом анализе
```

### **Когда использовать type hints**
**✅ Используйте:**
- В публичных API и библиотеках
- В больших проектах и командной разработке
- В сложной бизнес-логике
- При работе с внешними данными

**❌ Не обязательно:**
- В небольших скриптах
- В прототипах и экспериментах
- Когда типы очевидны из контекста


## `19.2` Что такое динамическая типизация?
### **Динамическая vs Статическая типизация**
**Динамическая типизация** — это подход, при котором тип переменной определяется во время выполнения программы, а не при компиляции. Python использует динамическую типизацию.

**Статическая типизация** — это подход, при котором типы переменных проверяются на этапе компиляции. Используется в языках как Java, C++, C#, Go.

### **Характеристики динамической типизации**
**1. Тип определяется во время выполнения**

```python
# Переменная может менять тип
x = 5           # x — int
x = "Hello"     # x теперь str
x = [1, 2, 3]   # x теперь list

# В статически типизированных языках это ошибка компиляции
```

**2. Не нужно объявлять типы**

```python
# Python
name = "Alice"
age = 30

# Java требует явное объявление:
# String name = "Alice";
# int age = 30;
```

**3. Проверка типов во время выполнения**

```python
def divide(a, b):
    return a / b

divide(10, 2)      # ✓ Работает
divide("10", "2")  # ✗ TypeError во время выполнения
```

### **Преимущества динамической типизации**
**1. Быстрое прототипирование**

Не тратим время на объявление типов:

```python
users = []
users.append({"name": "Alice", "age": 30})
users.append({"name": "Bob", "age": 25})

for user in users:
    print(user["name"])
```

**2. Duck Typing ("утиная типизация")**

*"Если это ходит как утка и крякает как утка, то это утка"*
Важно не ЧТО это за объект, а ЧТО он умеет делать:

```python
def print_all(items):
    for item in items:
        print(item)

# Работает с любым итерируемым объектом
print_all([1, 2, 3])      # список
print_all("Hello")        # строка
print_all(range(5))       # range
```

**3. Гибкость кода**

Одна функция работает с разными типами:

```python
def double(value):
    return value * 2

print(double(5))        # 10 (int)
print(double("Hi"))     # HiHi (str)
print(double([1, 2]))   # [1, 2, 1, 2] (list)
```

### **Недостатки динамической типизации**
**1. Ошибки обнаруживаются только во время выполнения**

```python
def calculate(a, b):
    return a + b

# Ошибка проявится только при запуске
result = calculate(5, "10")  # TypeError: unsupported operand type(s)
```

**2. Меньше помощи от IDE**

```python
def process(data):
    # IDE не знает методы data
    return data.method()  # Автодополнение не работает
```

**3. Сложнее рефакторинг**

```python
# Изменили возвращаемый тип
def get_users():
    return []  # было dict, стало list

# Нужно вручную найти все места использования
```

### **Сравнение с статической типизацией**

| Характеристика | Динамическая (Python) | Статическая (Java, C++) |
|----------------|----------------------|------------------------|
| **Проверка типов** | Во время выполнения | При компиляции |
| **Объявление типов** | Не требуется | Обязательно |
| **Скорость разработки** | Быстрая | Медленнее |
| **Гибкость** | Высокая | Ограниченная |
| **Обнаружение ошибок** | Во время работы | До запуска |
| **Рефакторинг** | Сложнее | Проще |

### **Type hints — лучшее из двух миров**
Type hints позволяют получить преимущества статической типизации, сохраняя гибкость динамической:

```python
# Динамическая типизация + статический анализ
def add(a: int, b: int) -> int:
    return a + b

# Python выполнит код в любом случае
result = add("Hello", "World")  # Работает во время выполнения

# Но mypy предупредит об ошибке до запуска
# error: Argument 1 to "add" has incompatible type "str"; expected "int"
```

**Подход Python:**
- Код выполняется как обычно (динамическая типизация)
- Статические анализаторы проверяют типы отдельно (опционально)
- Разработчик выбирает уровень строгости проверки типов

## `19.3` Модуль `typing`
Модуль **`typing`** предоставляет расширенные возможности для аннотации типов, которые выходят за рамки базовых типов Python.

**Зачем нужен:**
- Аннотация сложных структур данных
- Указание нескольких возможных типов
- Определение протоколов и callable-объектов
- Создание типизированных коллекций

### **Базовые типы из `typing`**
**1. `Optional` — значение или None**

Используется, когда функция может вернуть значение или `None`:

```python
from typing import Optional

def find_user(user_id: int) -> Optional[dict]:
    """Возвращает пользователя или None"""
    if user_id in users_db:
        return users_db[user_id]
    return None

# Optional[dict] === dict | None (в Python 3.10+)
```

**2. `Union` — один из нескольких типов**

Когда параметр может быть разных типов:

```python
from typing import Union

def process_id(user_id: Union[int, str]) -> str:
    """Принимает int или str"""
    return str(user_id)

# В Python 3.10+ можно использовать |
def process_id(user_id: int | str) -> str:
    return str(user_id)
```

**3. `Any` — любой тип**

Отключает проверку типов для конкретного значения:

```python
from typing import Any

def print_value(value: Any) -> None:
    """Принимает значение любого типа"""
    print(value)

# Используйте экономно — это отключает проверку типов!
```

### **Продвинутые типы**

**4. `Callable` — функции и методы**

Для аннотации функций как параметров:

```python
from typing import Callable

def execute(
    func: Callable[[int, int], int],
    a: int,
    b: int
) -> int:
    """Выполняет функцию, принимающую два int и возвращающую int"""
    return func(a, b)

def add(x: int, y: int) -> int:
    return x + y

def multiply(x: int, y: int) -> int:
    return x * y

result = execute(add, 5, 3)       # 8
result = execute(multiply, 5, 3)  # 15

# Callable[[arg_types], return_type]
```

**5. `Literal` — конкретные значения**

Ограничивает значения конкретным набором:

```python
from typing import Literal

def set_mode(mode: Literal["read", "write", "append"]) -> None:
    """Принимает только конкретные строки"""
    print(f"Режим: {mode}")

set_mode("read")    # ✓ OK
set_mode("write")   # ✓ OK
set_mode("delete")  # ✗ mypy ошибка

# Полезно для ограничения значений
Status = Literal["pending", "success", "error"]

def update_status(status: Status) -> None:
    print(status)
```

### **Коллекции и последовательности**

**6. `Sequence`, `Iterable`, `Mapping`**

Абстрактные типы для более гибких аннотаций:

```python
from typing import Sequence, Iterable, Mapping

def print_items(items: Sequence[int]) -> None:
    """Принимает любую последовательность: list, tuple, range"""
    for item in items:
        print(item)

print_items([1, 2, 3])        # list
print_items((1, 2, 3))        # tuple
print_items(range(1, 4))      # range

def sum_values(data: Mapping[str, int]) -> int:
    """Принимает любое отображение: dict, OrderedDict и т.д."""
    return sum(data.values())

def process_all(items: Iterable[str]) -> None:
    """Принимает любой итерируемый объект"""
    for item in items:
        print(item.upper())
```

### **Практические примеры**
**Пример 1: API клиент**

```python
from typing import Optional, Literal

HttpMethod = Literal["GET", "POST", "PUT", "DELETE"]

class APIClient:
    def request(
        self,
        method: HttpMethod,
        endpoint: str,
        data: Optional[dict] = None
    ) -> dict:
        """Выполняет HTTP запрос"""
        response = self._send(method, endpoint, data)
        return response.json()
    
    def get(self, endpoint: str) -> dict:
        return self.request("GET", endpoint)
    
    def post(self, endpoint: str, data: dict) -> dict:
        return self.request("POST", endpoint, data)
```

**Пример 2: Callback функции**

```python
from typing import Callable

def process_data(
    data: list[int],
    transformer: Callable[[int], int],
    filter_func: Callable[[int], bool]
) -> list[int]:
    """Применяет трансформацию и фильтрацию к данным"""
    transformed = [transformer(x) for x in data]
    return [x for x in transformed if filter_func(x)]

def double(x: int) -> int:
    return x * 2

def is_even(x: int) -> bool:
    return x % 2 == 0

numbers = [1, 2, 3, 4, 5]
result = process_data(numbers, double, is_even)
print(result)  # [2, 4, 6, 8, 10]
```

### **Таблица: Когда использовать какой тип**

| Ситуация | Тип | Пример |
|----------|-----|--------|
| Значение или None | `Optional[T]` или `T \| None` | `Optional[str]` |
| Несколько типов | `Union[T1, T2]` или `T1 \| T2` | `int \| str` |
| Любой тип | `Any` | `Any` |
| Функция как параметр | `Callable` | `Callable[[int], str]` |
| Конкретные значения | `Literal` | `Literal["read", "write"]` |
| Структура словаря | `TypedDict` | `class User(TypedDict): ...` |
| Duck typing | `Protocol` | `class Drawable(Protocol): ...` |
| Константы | `Final` | `Final[int] = 100` |

## `19.4` (`**`) Generics
[Видео про Generics](https://youtu.be/1vtYHS4V1ok?si=zdz5l8v72ejAKgpJ)

**Generics (обобщённые типы)** — это механизм создания функций и классов, которые работают с разными типами данных, сохраняя при этом информацию о конкретном типе.

**Зачем нужны:**
- Переиспользование кода для разных типов
- Сохранение информации о типах
- Безопасность типов без дублирования кода

### **Проблема без Generics**

```python
# Без generics — теряем информацию о типе
def get_first(items: list) -> object:
    return items[0]

numbers = [1, 2, 3]
first = get_first(numbers)  # first имеет тип object, не int!

# IDE не знает, что first — это int
# result = first + 5  # mypy не может проверить
```

### **TypeVar — переменная типа**
`TypeVar` создаёт переменную типа, которая может принимать любой тип:

```python
from typing import TypeVar

T = TypeVar('T')

def get_first(items: list[T]) -> T:
    """Возвращает первый элемент списка любого типа"""
    return items[0]

# mypy понимает типы!
numbers: list[int] = [1, 2, 3]
first_num: int = get_first(numbers)  # T = int

words: list[str] = ["hello", "world"]
first_word: str = get_first(words)   # T = str
```

**Как это работает:**
- `T` — это "заполнитель" для любого типа
- При вызове функции `T` автоматически заменяется на конкретный тип
- mypy отслеживает, что возвращаемый тип совпадает с типом элементов списка

### **Базовые примеры с TypeVar**
**Пример 1: Функция с одним типом**

```python
from typing import TypeVar

T = TypeVar('T')

def identity(value: T) -> T:
    """Возвращает то же значение, что получила"""
    return value

x: int = identity(5)           # T = int
y: str = identity("hello")     # T = str
z: list = identity([1, 2, 3])  # T = list
```

**Пример 2: Функция с двумя параметрами одного типа**

```python
from typing import TypeVar

T = TypeVar('T')

def swap(a: T, b: T) -> tuple[T, T]:
    """Меняет местами два значения одного типа"""
    return (b, a)

x, y = swap(1, 2)           # T = int, result: tuple[int, int]
a, b = swap("hi", "bye")    # T = str, result: tuple[str, str]

# mypy найдёт ошибку
# swap(1, "text")  # ✗ Разные типы!
```

### **Ограничения для TypeVar**
Можно ограничить `TypeVar` конкретными типами:

```python
from typing import TypeVar

# T может быть только int или float
T = TypeVar('T', int, float)

def add(a: T, b: T) -> T:
    return a + b

add(5, 3)      # ✓ OK, T = int
add(5.5, 2.3)  # ✓ OK, T = float
add("a", "b")  # ✗ Ошибка — str не разрешён
```

**Ограничение базовым классом:**

```python
from typing import TypeVar

# T должен быть числом (int, float или их подклассы)
T = TypeVar('T', bound=int | float)

def double(value: T) -> T:
    return value * 2

double(5)      # ✓ OK
double(3.14)   # ✓ OK
double("hi")   # ✗ Ошибка
```


### **Generic классы**
Создание классов, работающих с любыми типами:

```python
from typing import Generic, TypeVar

T = TypeVar('T')

class Stack(Generic[T]):
    """Стек для элементов любого типа"""
    def __init__(self) -> None:
        self._items: list[T] = []
    
    def push(self, item: T) -> None:
        self._items.append(item)
    
    def pop(self) -> T:
        return self._items.pop()
    
    def is_empty(self) -> bool:
        return len(self._items) == 0

# Стек целых чисел
int_stack: Stack[int] = Stack()
int_stack.push(1)
int_stack.push(2)
value: int = int_stack.pop()  # mypy знает, что value — int

# Стек строк
str_stack: Stack[str] = Stack()
str_stack.push("hello")
str_stack.push("world")
text: str = str_stack.pop()  # mypy знает, что text — str

# mypy найдёт ошибку
# int_stack.push("text")  # ✗ Нельзя добавить str в Stack[int]
```

### **Generic с несколькими параметрами**

```python
from typing import Generic, TypeVar

K = TypeVar('K')  # Key
V = TypeVar('V')  # Value

class Pair(Generic[K, V]):
    """Пара ключ-значение"""
    def __init__(self, key: K, value: V) -> None:
        self.key = key
        self.value = value
    
    def get_key(self) -> K:
        return self.key
    
    def get_value(self) -> V:
        return self.value

# Разные комбинации типов
pair1: Pair[str, int] = Pair("age", 30)
pair2: Pair[int, str] = Pair(1, "Alice")
pair3: Pair[str, list[int]] = Pair("numbers", [1, 2, 3])

key: str = pair1.get_key()    # mypy знает, что key — str
value: int = pair1.get_value()  # mypy знает, что value — int
```

### **Практический пример: Repository pattern**

```python
from typing import Generic, TypeVar, Optional

T = TypeVar('T')

class Repository(Generic[T]):
    """Обобщённый репозиторий для работы с данными"""
    def __init__(self) -> None:
        self._data: dict[int, T] = {}
        self._current_id: int = 0
    
    def add(self, item: T) -> int:
        """Добавляет элемент и возвращает его ID"""
        self._current_id += 1
        self._data[self._current_id] = item
        return self._current_id
    
    def get(self, item_id: int) -> Optional[T]:
        """Получает элемент по ID"""
        return self._data.get(item_id)
    
    def get_all(self) -> list[T]:
        """Возвращает все элементы"""
        return list(self._data.values())

# Используем для разных типов
class User:
    def __init__(self, name: str, age: int) -> None:
        self.name = name
        self.age = age

class Product:
    def __init__(self, title: str, price: float) -> None:
        self.title = title
        self.price = price

# Репозиторий пользователей
user_repo: Repository[User] = Repository()
user_id = user_repo.add(User("Alice", 30))
user = user_repo.get(user_id)  # mypy знает, что user — Optional[User]

# Репозиторий продуктов
product_repo: Repository[Product] = Repository()
product_id = product_repo.add(Product("Laptop", 1000.0))
product = product_repo.get(product_id)  # mypy знает, что product — Optional[Product]
```

### **Когда использовать Generics**

**✅ Используйте Generics когда:**
- Пишете контейнеры или коллекции (Stack, Queue, List)
- Создаёте функции обработки данных, работающие с любыми типами
- Реализуете паттерны (Repository, Factory, Builder)
- Нужна типобезопасность без дублирования кода

**❌ Не нужны Generics когда:**
- Функция всегда работает с конкретным типом
- Тип не важен для логики (используйте `Any`)
- Код простой и не будет переиспользоваться


## `19.5` (`**`) Ковариантность, контрвариантность и инвариантность
Эти понятия описывают, как связаны типы при наследовании и как они могут быть заменены друг другом.

**Простыми словами:**
- **Ковариантность** — можно заменить базовый тип на подтип
- **Контрвариантность** — можно заменить подтип на базовый тип
- **Инвариантность** — нельзя заменять типы вообще

### **Базовая иерархия классов**

```python
class Animal:
    def speak(self) -> str:
        return "Some sound"

class Dog(Animal):
    def speak(self) -> str:
        return "Woof!"

class Cat(Animal):
    def speak(self) -> str:
        return "Meow!"
```

`Dog` и `Cat` — это **подтипы** `Animal`


### **Ковариантность (Covariance)**
**Определение:** Можно использовать более специфичный тип вместо общего.

**Пример с возвращаемым значением:**

```python
from typing import Callable

# Функция возвращает Animal
def get_animal() -> Animal:
    return Animal()

# Функция возвращает Dog (подтип Animal)
def get_dog() -> Dog:
    return Dog()

# ✓ Ковариантность: Dog можно использовать вместо Animal
animal_getter: Callable[[], Animal] = get_dog  # OK!

# Почему это работает?
# Если ожидается Animal, то Dog тоже подходит (Dog IS-A Animal)
```

**Практический пример:**

```python
def process_animals(animals: list[Animal]) -> None:
    for animal in animals:
        print(animal.speak())

# ✗ Это НЕ работает из-за инвариантности list
dogs: list[Dog] = [Dog(), Dog()]
# process_animals(dogs)  # Ошибка mypy!

# ✓ Решение: используйте Sequence (ковариантный тип)
from typing import Sequence

def process_animals_safe(animals: Sequence[Animal]) -> None:
    for animal in animals:
        print(animal.speak())

dogs: list[Dog] = [Dog(), Dog()]
process_animals_safe(dogs)  # ✓ OK!
```

### **Контрвариантность (Contravariance)**
**Определение:** Можно использовать более общий тип вместо специфичного (звучит странно, но это про параметры функций).

**Пример с параметрами функции:**

```python
from typing import Callable

# Функция принимает Animal
def feed_animal(animal: Animal) -> None:
    print(f"Feeding: {animal.speak()}")

# Функция принимает Dog (более специфичный тип)
def feed_dog(dog: Dog) -> None:
    print(f"Feeding dog: {dog.speak()}")

# ✓ Контрвариантность: функция с Animal может использоваться для Dog
dog_feeder: Callable[[Dog], None] = feed_animal  # OK!

# Почему это работает?
# Если функция умеет работать с Animal, она умеет работать и с Dog
```

**Визуализация:**

```
Animal (базовый)
  ↓
Dog (подтип)

Ковариантность (возвращаемое значение):
  Animal ← Dog ✓ (Dog можно вместо Animal)

Контрвариантность (параметры):
  Animal → Dog ✓ (Animal можно вместо Dog)
```

### **Инвариантность (Invariance)**
**Определение:** Тип должен совпадать точно, замены не допускаются.

**Пример:**

```python
# list, dict, set — инвариантные типы

def add_animal(animals: list[Animal]) -> None:
    animals.append(Animal())

dogs: list[Dog] = [Dog(), Dog()]
# add_animal(dogs)  # ✗ Ошибка mypy!

# Почему это ошибка?
# Если бы это работало, мы бы добавили Animal в список Dog!
# dogs = [Dog(), Dog(), Animal()]  # Теперь в списке Dog есть просто Animal!
```

**Проблема с инвариантностью:**

```python
# Если бы list был ковариантным (это НЕ так!)
dogs: list[Dog] = [Dog()]
animals: list[Animal] = dogs  # Представим, что это OK

# Теперь можем добавить Cat в список Dog!
animals.append(Cat())  # Это был бы список Dog, но мы добавили Cat!

# dogs теперь содержит Cat! Это нарушает типобезопасность
```


### **TypeVar с вариантностью**

```python
from typing import TypeVar

# Инвариантный (по умолчанию)
T = TypeVar('T')

# Ковариантный — для возвращаемых значений
T_co = TypeVar('T_co', covariant=True)

# Контрвариантный — для параметров
T_contra = TypeVar('T_contra', contravariant=True)
```

**Пример с ковариантностью:**

```python
from typing import TypeVar, Generic

T_co = TypeVar('T_co', covariant=True)

class Box(Generic[T_co]):
    """Контейнер только для чтения (ковариантный)"""
    def __init__(self, item: T_co) -> None:
        self._item = item
    
    def get(self) -> T_co:
        return self._item

# ✓ Ковариантность работает
dog_box: Box[Dog] = Box(Dog())
animal_box: Box[Animal] = dog_box  # OK! Dog -> Animal
```

**Пример с контрвариантностью:**

```python
from typing import TypeVar, Generic

T_contra = TypeVar('T_contra', contravariant=True)

class Handler(Generic[T_contra]):
    """Обработчик (контрвариантный)"""
    def handle(self, item: T_contra) -> None:
        print(f"Handling: {item}")

# ✓ Контрвариантность работает
animal_handler: Handler[Animal] = Handler()
dog_handler: Handler[Dog] = animal_handler  # OK! Animal -> Dog
```

### **Практическая таблица**

| Вариантность | Когда использовать | Пример | Замена |
|--------------|-------------------|--------|--------|
| **Ковариантность** | Только чтение (возвращаемые значения) | `Sequence[T]`, `Iterable[T]` | `Dog` → `Animal` ✓ |
| **Контрвариантность** | Только запись (параметры функций) | Редко используется | `Animal` → `Dog` ✓ |
| **Инвариантность** | Чтение и запись | `list[T]`, `dict[K,V]` | Замена запрещена ✗ |


### **Практический совет**

**Для 99% случаев запомните:**
1. **Возвращаемые значения** — ковариантны (подтип вместо базового ✓)
2. **Параметры функций** — контрвариантны (базовый вместо подтипа ✓)
3. **Изменяемые коллекции** (`list`, `dict`) — инвариантны (точное совпадение)
4. **Неизменяемые коллекции** (`Sequence`, `Iterable`) — ковариантны

**Когда в сомнениях:**
- Используйте `Sequence[T]` вместо `list[T]` для параметров функций
- Используйте `Iterable[T]` для максимальной гибкости
- Не беспокойтесь о вариантности в простых случаях — mypy подскажет, если что-то не так!


## `19.6` Совместимость с другими версиями
`Type hints` эволюционировали с каждой версией Python, добавляя новые возможности и упрощая синтаксис. Важно понимать, какие фичи доступны в разных версиях.

### **История развития type hints**

| Версия | Год | Основные изменения |
|--------|-----|-------------------|
| **Python 3.5** | 2015 | Первое появление type hints (PEP 484), модуль `typing` |
| **Python 3.6** | 2016 | Аннотации переменных, `typing.NamedTuple` |
| **Python 3.7** | 2018 | `from __future__ import annotations`, улучшения `dataclass` |
| **Python 3.8** | 2019 | `Literal`, `Final`, `TypedDict`, `Protocol` |
| **Python 3.9** | 2020 | Встроенные дженерики (`list[int]` вместо `List[int]`) |
| **Python 3.10** | 2021 | Union types с `|` оператором (`int | str`) |
| **Python 3.11** | 2022 | `Self` тип, улучшения производительности |
| **Python 3.12** | 2023 | Синтаксис для дженериков, улучшенная поддержка типов |


### **Python 3.5-3.8: Старый синтаксис**
**Нужно импортировать типы из `typing`:**

```python
from typing import List, Dict, Set, Tuple, Optional, Union

# Коллекции
numbers: List[int] = [1, 2, 3]
scores: Dict[str, int] = {"Alice": 100}
tags: Set[str] = {"python"}
coords: Tuple[float, float] = (10.5, 20.3)

# Опциональные типы
def find_user(user_id: int) -> Optional[Dict]:
    pass

# Union типы
def process(value: Union[int, str]) -> str:
    return str(value)
```

### **Python 3.9+: Упрощённый синтаксис**
**Можно использовать встроенные типы напрямую:**

```python
# Не нужен импорт из typing!
numbers: list[int] = [1, 2, 3]
scores: dict[str, int] = {"Alice": 100}
tags: set[str] = {"python"}
coords: tuple[float, float] = (10.5, 20.3)

# Optional всё ещё нужен из typing
from typing import Optional
def find_user(user_id: int) -> Optional[dict]:
    pass

# Но Union можно заменить на |
def process(value: int | str) -> str:
    return str(value)
```

### **Python 3.10+: Оператор `|` для Union**
**Новый способ указания нескольких типов:**

```python
# Старый способ (работает везде)
from typing import Union, Optional
def process(value: Union[int, str, float]) -> Union[str, None]:
    pass

# Новый способ (Python 3.10+)
def process(value: int | str | float) -> str | None:
    pass

# Optional[T] теперь можно писать как T | None
def find_user(user_id: int) -> dict | None:
    pass
```

### **Обратная совместимость: `from __future__ import annotations`**
Если нужно использовать новый синтаксис в старых версиях Python:

```python
from __future__ import annotations

# Теперь работает в Python 3.7+
def get_items() -> list[int]:
    return [1, 2, 3]

def process(value: int | str) -> str:
    return str(value)
```

**Как это работает:**
- Аннотации становятся строками и не вычисляются во время импорта
- Позволяет использовать синтаксис из новых версий
- Анализаторы типов всё равно понимают аннотации

**Ограничения:**
- Не работает для `isinstance()` и `issubclass()` проверок
- Добавляет небольшой overhead при использовании рефлексии

### **Таблица совместимости**
| Фича | Python 3.5-3.8 | Python 3.9+ | Python 3.10+ |
|------|---------------|-------------|--------------|
| Базовые аннотации | ✅ | ✅ | ✅ |
| `typing.List[int]` | ✅ | ✅ (устарел) | ✅ (устарел) |
| `list[int]` | ❌ | ✅ | ✅ |
| `Union[int, str]` | ✅ | ✅ | ✅ (устарел) |
| `int \| str` | ❌ | ❌ | ✅ |
| `Optional[int]` | ✅ | ✅ | ✅ |
| `int \| None` | ❌ | ❌ | ✅ |
| `TypedDict` | ✅ (3.8+) | ✅ | ✅ |
| `Protocol` | ✅ (3.8+) | ✅ | ✅
| `Literal` | ✅ (3.8+) | ✅ | ✅ |
| `Final` | ✅ (3.8+) | ✅ | ✅ |
| `Self` | ❌ | ❌ | ✅ (3.11+) |


### **Рекомендации по использованию**
**Если вы пишете для Python 3.9+:**

```python
# ✅ Используйте встроенные типы
numbers: list[int] = [1, 2, 3]
user: dict[str, str] = {"name": "Alice"}

# ✅ Используйте | для Union в Python 3.10+
def process(value: int | str | None) -> str:
    return str(value) if value else ""

# ✅ Optional можно заменить на T | None
def find_item(item_id: int) -> dict | None:
    pass
```

**Если нужна поддержка Python 3.7-3.8:**
```python
from __future__ import annotations
from typing import Optional, Union

# Теперь работает новый синтаксис
def get_users() -> list[dict[str, int]]:
    return [{"age": 30}]

# Но для Union и Optional всё равно нужен typing
def process(value: Union[int, str]) -> Optional[str]:
    pass
```

**Если нужна поддержка Python 3.5-3.6:**
```python
from typing import List, Dict, Optional, Union

# Старый синтаксис
def get_users() -> List[Dict[str, int]]:
    return [{"age": 30}]

def process(value: Union[int, str]) -> Optional[str]:
    pass
```

### **Forward References (Отложенные аннотации)**
Проблема возникает, когда тип ещё не определён:

```python
# ❌ Ошибка: User ещё не определён
class User:
    def get_friend(self) -> User:
        pass

# ✅ Решение 1: Строковая аннотация
class User:
    def get_friend(self) -> "User":
        pass

# ✅ Решение 2: from __future__ import annotations
from __future__ import annotations

class User:
    def get_friend(self) -> User:
        pass
```

**Пример с циклическими зависимостями:**
```python
from __future__ import annotations
from typing import Optional

class TreeNode:
    def __init__(self, value: int) -> None:
        self.value: int = value
        self.left: Optional[TreeNode] = None
        self.right: Optional[TreeNode] = None
    
    def add_left(self, node: TreeNode) -> TreeNode:
        self.left = node
        return self
    
    def add_right(self, node: TreeNode) -> TreeNode:
        self.right = node
        return self
```

### **Проверка типов в runtime**
Type hints **не проверяются** Python во время выполнения, но есть инструменты для runtime-проверки:

**1. Использование `isinstance()` — не работает с типами из `typing`:**

```python
from typing import List

numbers: List[int] = [1, 2, 3]

# ❌ Не работает
isinstance(numbers, List[int])  # TypeError

# ✅ Работает только для базового типа
isinstance(numbers, list)  # True
```

**2. Библиотека `typeguard` для runtime-проверки:**

```python
from typeguard import typechecked

@typechecked
def add(a: int, b: int) -> int:
    return a + b

add(5, 3)      # ✓ OK
add(5, "3")    # ✗ TypeError во время выполнения
```

**3. Библиотека `pydantic` для валидации данных:**

```python
from pydantic import BaseModel

class User(BaseModel):
    name: str
    age: int
    email: str

# ✓ Валидация успешна
user = User(name="Alice", age=30, email="alice@mail.com")

# ✗ ValidationError — age должен быть int
user = User(name="Bob", age="25", email="bob@mail.com")
```

### **Статические анализаторы типов**
Для проверки типов используются внешние инструменты:

**1. mypy — самый популярный**

```bash
# Установка
pip install mypy

# Проверка файла
mypy script.py

# Проверка проекта
mypy .
```

**Пример использования:**

```python
# script.py
def greet(name: str) -> str:
    return f"Hello, {name}!"

result = greet(123)  # Ошибка типа
```

```bash
$ mypy script.py
script.py:4: error: Argument 1 to "greet" has incompatible type "int"; expected "str"
```

**2. pyright — от Microsoft**

```bash
# Установка
pip install pyright

# Проверка
pyright script.py
```

**3. pyre — от Facebook/Meta**

```bash
# Установка
pip install pyre-check

# Проверка
pyre check
```

**4. pytype — от Google**

```bash
# Установка
pip install pytype

# Проверка
pytype script.py
```

### **Настройка mypy**
Создайте файл `mypy.ini` или `pyproject.toml`:

**mypy.ini:**

```ini
[mypy]
python_version = 3.10
warn_return_any = True
warn_unused_configs = True
disallow_untyped_defs = True
disallow_any_generics = True
check_untyped_defs = True
no_implicit_optional = True
warn_redundant_casts = True
warn_unused_ignores = True
warn_no_return = True
strict = False

# Игнорировать определённые модули
[mypy-some_library.*]
ignore_missing_imports = True
```

**pyproject.toml:**

```toml
[tool.mypy]
python_version = "3.10"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
```

### **Игнорирование ошибок типов**
Иногда нужно отключить проверку для конкретной строки:

```python
# Игнорировать ошибку на этой строке
result = some_function()  # type: ignore

# Игнорировать конкретный тип ошибки
result = some_function()  # type: ignore[arg-type]

# Игнорировать весь файл
# mypy: ignore-errors
```

**Когда использовать `type: ignore`:**
- При работе с библиотеками без type hints
- Для legacy кода
- Когда mypy ошибается (редко)
- В тестах с mock-объектами

### **Миграция проекта на type hints**
**Шаг 1: Установите mypy**

```bash
pip install mypy
```

**Шаг 2: Запустите проверку**

```bash
mypy . --ignore-missing-imports
```

**Шаг 3: Добавляйте аннотации постепенно**

Начните с публичных API:

```python
# До
def calculate_discount(price, percent):
    return price * (1 - percent / 100)

# После
def calculate_discount(price: float, percent: float) -> float:
    return price * (1 - percent / 100)
```

**Шаг 4: Используйте `# type: ignore` временно**

Для legacy кода, который сложно типизировать:

```python
def legacy_function(data):  # type: ignore
    # Сложная логика без типов
    pass
```

**Шаг 5: Настройте строгость постепенно**

```ini
# mypy.ini — начните с мягких настроек
[mypy]
warn_return_any = True
warn_unused_configs = True

# Постепенно добавляйте строгость
disallow_untyped_defs = True
strict = True
```

### **Практические примеры совместимости**
**Пример 1: Универсальный код для разных версий**

```python
from __future__ import annotations
from typing import Optional, List, Dict, Union
import sys

# Проверка версии Python
if sys.version_info >= (3, 10):
    # Python 3.10+ — используем | оператор
    def process(value: int | str | None) -> str | None:
        return str(value) if value else None
else:
    # Старые версии — используем Union
    def process(value: Union[int, str, None]) -> Optional[str]:
        return str(value) if value else None
```

**Пример 2: Совместимость с TypedDict**

```python
from typing import TypedDict

# Python 3.8+
class User(TypedDict):
    name: str
    age: int

# Для Python 3.7 используйте альтернативный синтаксис
User = TypedDict('User', {
    'name': str,
    'age': int
})
```

**Пример 3: Совместимость с Protocol**

```python
from typing import Protocol

# Python 3.8+
class Drawable(Protocol):
    def draw(self) -> None: ...

# Для Python 3.7 используйте typing_extensions
try:
    from typing import Protocol
except ImportError:
    from typing_extensions import Protocol

class Drawable(Protocol):
    def draw(self) -> None: ...
```


### **Библиотека `typing_extensions`**
Для использования новых фич в старых версиях Python:

```bash
pip install typing_extensions
```

```python
from typing_extensions import (
    Literal,      # Доступен в 3.8+, но можно использовать в 3.7
    TypedDict,    # Доступен в 3.8+, но можно использовать в 3.7
    Protocol,     # Доступен в 3.8+, но можно использовать в 3.7
    Final,        # Доступен в 3.8+, но можно использовать в 3.7
    Self,         # Доступен в 3.11+, но можно использовать раньше
)

# Теперь работает в Python 3.7
Mode = Literal["read", "write", "append"]

def open_file(filename: str, mode: Mode) -> None:
    pass
```

### **Выводы и best practices**
**✅ Рекомендации:**
1. **Используйте type hints в новом коде** — это улучшает читаемость и помогает найти ошибки
2. **Начинайте с публичного API** — функции, классы, методы, которые используют другие разработчики
3. **Используйте современный синтаксис** — если проект на Python 3.9+, используйте `list[int]` вместо `List[int]`
4. **Проверяйте типы с mypy** — добавьте проверку в CI/CD pipeline
5. **Не переусердствуйте** — не нужно типизировать каждую переменную в скриптах
6. **Используйте `from __future__ import annotations`** — для совместимости и производительности

**❌ Чего избегать:**
1. Не используйте `Any` без необходимости — это отключает проверку типов
2. Не игнорируйте все ошибки mypy — используйте `type: ignore` точечно
3. Не используйте устаревший синтаксис в новых проектах — `List[int]` вместо `list[int]`
4. Не проверяйте типы во runtime без необходимости — это замедляет код

**Итоговая таблица: Какой синтаксис использовать**
| Версия Python | Рекомендуемый синтаксис |
|---------------|------------------------|
| **3.5-3.6** | `from typing import List, Dict`<br>`List[int]`, `Dict[str, int]` |
| **3.7-3.8** | `from __future__ import annotations`<br>`list[int]`, `dict[str, int]` |
| **3.9** | `list[int]`, `dict[str, int]`<br>`Union[int, str]` для множественных типов |
| **3.10+** | `list[int]`, `dict[str, int]`<br>`int \| str` для множественных типов |
| **3.11+** | Современный синтаксис + `Self` для методов классов |



















----



# `20` (`**`) Extra Python  
_P.S: only for flexing on the job interview_  

## `20.1` Модуль `itertools`  
## `20.2` Модуль `functools`  
## `20.3` Регулярные выражения. Модуль `re`  

----

# `21` (`*`) Cache & Hash
[Небольшое видео про Cache в Python](https://youtu.be/IR4dmy0uu4s?si=2v3nxyKQXPan3BY4)
[Как работают словари в Python | Хэш-таблицы](https://www.youtube.com/watch?v=6XS-wzpWs7E)

## `21.1` Что такое кэш?
**Что такое кэш?**

`Кэш` — это способ сохранить результаты работы программы, чтобы не делать одну и ту же работу дважды.

**Аналогия из жизни:**

Представьте, что вы решаете математическую задачу на листочке. Задача сложная, вы потратили 10 минут. Потом друг просит решить такую же задачу. Что вы сделаете?

- **Без кэша:** Решите задачу заново, потратите еще 10 минут
- **С кэшем:** Покажете уже готовое решение с листочка, потратите 5 секунд

Кэш в программировании работает точно так же — сохраняет результаты, чтобы не пересчитывать.

**Как работает кэш:**

1. Программа получает задачу
2. Проверяет: "А я уже решал такую задачу?"
3. Если **да** — берет готовый ответ из кэша (быстро!)
4. Если **нет** — решает задачу, сохраняет ответ в кэш (медленно, но только один раз)

**Пример 1: Медленная функция без кэша**

```python
import time

def slow_function(n):
    """Функция, которая долго работает"""
    print(f"Вычисляю для {n}...")
    time.sleep(2)  # Имитация долгой работы (2 секунды)
    return n * 2

# Вызываем несколько раз
print(slow_function(5))  # Вычисляю для 5... -> 10 (ждем 2 сек)
print(slow_function(5))  # Вычисляю для 5... -> 10 (опять ждем 2 сек!)
print(slow_function(5))  # Вычисляю для 5... -> 10 (и снова 2 сек!)

# Всего 6 секунд на одну и ту же задачу!
```

**Пример 2: Функция с ручным кэшем**

```python
import time

# Создаем "хранилище" для результатов
cache = {}

def slow_function_with_cache(n):
    """Функция с кэшем"""
    # Проверяем: есть ли уже результат?
    if n in cache:
        print(f"Беру из кэша для {n}!")
        return cache[n]  # Возвращаем сохраненный результат
    
    # Если нет — вычисляем
    print(f"Вычисляю для {n}...")
    time.sleep(2)
    result = n * 2
    
    # Сохраняем в кэш
    cache[n] = result
    return result

# Вызываем несколько раз
print(slow_function_with_cache(5))  # Вычисляю для 5... -> 10 (2 сек)
print(slow_function_with_cache(5))  # Беру из кэша для 5! -> 10 (мгновенно!)
print(slow_function_with_cache(5))  # Беру из кэша для 5! -> 10 (мгновенно!)

# Всего 2 секунды вместо 6!

print(cache)  # {5: 10} — результат сохранен
```

**Зачем нужен кэш:**

1. **Ускорение программы** — не делаем одну работу много раз
2. **Экономия ресурсов** — не нагружаем процессор/память лишними вычислениями
3. **Уменьшение нагрузки** — меньше запросов к базам данных, API, файлам

**Где используется кэш:**

- Веб-браузеры (сохраняют картинки с сайтов, чтобы не загружать их снова)
- Процессоры (сохраняют данные из памяти для быстрого доступа)
- Базы данных (сохраняют результаты частых запросов)
- Ваши программы (сохраняют результаты функций)

**Важно понимать:**

Кэш — это **компромисс**:
- ✅ Плюс: программа работает быстрее
- ❌ Минус: используется дополнительная память для хранения результатов


## `21.2` `lru_cache` и мемоизация
**Что такое мемоизация?**

**Мемоизация** — это умное слово для "запоминания результатов функции". Это техника кэширования специально для функций.

Правило мемоизации простое:
- Если функцию вызвали с теми же аргументами — вернуть сохраненный результат
- Если с новыми аргументами — вычислить и сохранить

**Что такое `lru_cache`?**

`lru_cache` — это готовый инструмент в Python для автоматической мемоизации. Это декоратор (специальная "обертка" для функций).

**LRU** означает **Least Recently Used** (наименее недавно использованный) — если кэш переполняется, удаляются самые старые результаты.

**Пример 1: Классическая задача — числа Фибоначчи**

Числа Фибоначчи: 0, 1, 1, 2, 3, 5, 8, 13, 21...
Каждое число = сумма двух предыдущих.

```python
# БЕЗ кэша (медленно!)
def fibonacci_slow(n):
    """Вычисление n-го числа Фибоначчи"""
    if n <= 1:
        return n
    return fibonacci_slow(n - 1) + fibonacci_slow(n - 2)

# Попробуем посчитать
import time

start = time.time()
print(fibonacci_slow(35))  # 9227465
end = time.time()
print(f"Время: {end - start:.2f} секунд")  # ~3-5 секунд!

# Почему медленно? Функция вызывается МИЛЛИОНЫ раз!
# fibonacci_slow(5) вызывает fibonacci_slow(4) и fibonacci_slow(3)
# fibonacci_slow(4) вызывает fibonacci_slow(3) и fibonacci_slow(2)
# fibonacci_slow(3) вычисляется много раз!
```

```python
# С lru_cache (быстро!)
from functools import lru_cache

@lru_cache(maxsize=None)  # maxsize=None — неограниченный размер кэша
def fibonacci_fast(n):
    """То же самое, но с кэшем"""
    if n <= 1:
        return n
    return fibonacci_fast(n - 1) + fibonacci_fast(n - 2)

start = time.time()
print(fibonacci_fast(35))  # 9227465
end = time.time()
print(f"Время: {end - start:.6f} секунд")  # ~0.000030 секунд!

# В 100000 раз быстрее! Каждое число вычисляется только один раз
```

**Как работает `@lru_cache`:**

```python
from functools import lru_cache

@lru_cache(maxsize=128)  # Хранить максимум 128 результатов
def expensive_function(x, y):
    """Дорогая функция (долго работает)"""
    print(f"Вычисляю для x={x}, y={y}")
    # Имитация сложных вычислений
    result = x ** y
    return result

# Первый вызов — вычисляется
print(expensive_function(2, 10))  # Вычисляю для x=2, y=10 -> 1024

# Второй вызов с теми же аргументами — из кэша!
print(expensive_function(2, 10))  # (ничего не печатает) -> 1024

# Третий вызов с другими аргументами — вычисляется
print(expensive_function(3, 5))   # Вычисляю для x=3, y=5 -> 243

# Четвертый — снова из кэша
print(expensive_function(2, 10))  # -> 1024 (мгновенно)
```

**Пример 2: Факториал**

```python
from functools import lru_cache

@lru_cache(maxsize=None)
def factorial(n):
    """Факториал числа n"""
    print(f"Вычисляю факториал {n}")
    if n <= 1:
        return 1
    return n * factorial(n - 1)

print(factorial(5))
# Вычисляю факториал 5
# Вычисляю факториал 4
# Вычисляю факториал 3
# Вычисляю факториал 2
# Вычисляю факториал 1
# -> 120

print(factorial(5))  # (ничего не печатает) -> 120 из кэша!

print(factorial(6))
# Вычисляю факториал 6 (только одно вычисление!)
# factorial(5) уже в кэше
# -> 720
```

**Параметры `lru_cache`:**

```python
from functools import lru_cache

# Кэш на 128 элементов (по умолчанию)
@lru_cache(maxsize=128)
def func1(x):
    return x * 2

# Неограниченный кэш
@lru_cache(maxsize=None)
def func2(x):
    return x * 2

# Без типизации (typed=False по умолчанию)
# func(1) и func(1.0) — одно и то же
@lru_cache(maxsize=128, typed=False)
def func3(x):
    return x * 2

# С типизацией (typed=True)
# func(1) и func(1.0) — разные вызовы
@lru_cache(maxsize=128, typed=True)
def func4(x):
    return x * 2
```

**Управление кэшем:**

```python
from functools import lru_cache

@lru_cache(maxsize=3)
def add(a, b):
    print(f"Вычисляю {a} + {b}")
    return a + b

add(1, 2)  # Вычисляю 1 + 2 -> 3
add(2, 3)  # Вычисляю 2 + 3 -> 5
add(1, 2)  # (из кэша) -> 3

# Посмотреть информацию о кэше
print(add.cache_info())
# CacheInfo(hits=1, misses=2, maxsize=3, currsize=2)
# hits — сколько раз взяли из кэша
# misses — сколько раз вычисляли
# currsize — текущий размер кэша

# Очистить кэш
add.cache_clear()
print(add.cache_info())
# CacheInfo(hits=0, misses=0, maxsize=3, currsize=0)

add(1, 2)  # Вычисляю 1 + 2 -> 3 (снова вычисляет)
```

**Когда использовать `lru_cache`:**

✅ **Используйте когда:**
- Функция вызывается много раз с одинаковыми аргументами
- Функция чистая (всегда возвращает одинаковый результат для одинаковых аргументов)
- Функция выполняется долго (сложные вычисления, обращения к базе данных)

❌ **НЕ используйте когда:**
- Функция возвращает разные результаты для одинаковых аргументов (использует случайность, время)
- Аргументы функции не могут быть хэшированы (списки, словари)
- Функция имеет побочные эффекты (изменяет глобальные переменные, файлы)

**Пример неправильного использования:**

```python
from functools import lru_cache
import random

# ❌ ПЛОХО — результат случайный!
@lru_cache
def get_random():
    return random.randint(1, 100)

print(get_random())  # 42
print(get_random())  # 42 (одно и то же!)
print(get_random())  # 42 (всегда одно и то же!)

# Кэш "заморозил" первое случайное число
```


## `21.3` Методы кэширования
Кроме `lru_cache`, существуют разные способы кэширования в зависимости от задачи.

### **1. Ручной кэш (словарь)**

Самый простой способ — использовать обычный словарь.

**Пример 1: Кэш для функции с одним аргументом**

```python
# Глобальный словарь для хранения результатов
cache = {}

def square(n):
    """Возведение в квадрат с кэшированием"""
    if n in cache:
        print(f"Из кэша: {n}")
        return cache[n]
    
    print(f"Вычисляю: {n}")
    result = n ** 2
    cache[n] = result
    return result

print(square(5))   # Вычисляю: 5 -> 25
print(square(5))   # Из кэша: 5 -> 25
print(square(10))  # Вычисляю: 10 -> 100
print(square(5))   # Из кэша: 5 -> 25
```

**Пример 2: Кэш для функции с несколькими аргументами**

```python
cache = {}

def multiply(a, b):
    """Умножение с кэшированием"""
    # Ключ — кортеж из аргументов
    key = (a, b)
    
    if key in cache:
        print(f"Из кэша: {a} * {b}")
        return cache[key]
    
    print(f"Вычисляю: {a} * {b}")
    result = a * b
    cache[key] = result
    return result

print(multiply(3, 4))   # Вычисляю: 3 * 4 -> 12
print(multiply(3, 4))   # Из кэша: 3 * 4 -> 12
print(multiply(5, 6))   # Вычисляю: 5 * 6 -> 30
```

### **2. Кэш внутри функции (замыкание)**

Можно хранить кэш прямо внутри функции, используя атрибуты функции.

```python
def cached_function(n):
    """Функция со встроенным кэшем"""
    # Проверяем, есть ли атрибут cache у функции
    if not hasattr(cached_function, 'cache'):
        cached_function.cache = {}  # Создаем кэш
    
    # Проверяем кэш
    if n in cached_function.cache:
        print(f"Из кэша: {n}")
        return cached_function.cache[n]
    
    # Вычисляем
    print(f"Вычисляю: {n}")
    result = n ** 3
    cached_function.cache[n] = result
    return result

print(cached_function(2))  # Вычисляю: 2 -> 8
print(cached_function(2))  # Из кэша: 2 -> 8
print(cached_function(3))  # Вычисляю: 3 -> 27

# Можем посмотреть кэш
print(cached_function.cache)  # {2: 8, 3: 27}
```

### **3. Свой декоратор для кэширования**

Можно написать собственный декоратор, который добавляет кэширование к любой функции.

```python
def simple_cache(func):
    """Декоратор для простого кэширования"""
    cache = {}
    
    def wrapper(*args):
        # Используем args (аргументы) как ключ
        if args in cache:
            print(f"Из кэша для {func.__name__}{args}")
            return cache[args]
        
        print(f"Вычисляю {func.__name__}{args}")
        result = func(*args)
        cache[args] = result
        return result
    
    return wrapper

# Применяем декоратор
@simple_cache
def add(a, b):
    return a + b

@simple_cache
def power(base, exp):
    return base ** exp

print(add(2, 3))      # Вычисляю add(2, 3) -> 5
print(add(2, 3))      # Из кэша для add(2, 3) -> 5
print(power(2, 10))   # Вычисляю power(2, 10) -> 1024
print(power(2, 10))   # Из кэша для power(2, 10) -> 1024
```

### **4. cache (новый в Python 3.9+)**

В Python 3.9 появился упрощенный вариант `lru_cache` — просто `cache`.

```python
from functools import cache  # Только Python 3.9+

@cache  # Эквивалентно @lru_cache(maxsize=None)
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

print(fibonacci(100))  # Очень быстро!
```

### **5. Кэш с ограничением по времени (TTL — Time To Live)**

Иногда нужно, чтобы кэш "протухал" через определенное время.

```python
import time

def cache_with_ttl(ttl_seconds):
    """Декоратор с кэшем, который живет ttl_seconds"""
    def decorator(func):
        cache = {}
        
        def wrapper(*args):
            current_time = time.time()
            
            # Проверяем кэш
            if args in cache:
                result, timestamp = cache[args]
                # Если кэш свежий — используем
                if current_time - timestamp < ttl_seconds:
                    print(f"Из кэша (возраст: {current_time - timestamp:.1f}с)")
                    return result
                else:
                    print("Кэш устарел, пересчитываю")
            
            # Вычисляем и сохраняем с временной меткой
            print("Вычисляю")
            result = func(*args)
            cache[args] = (result, current_time)
            return result
        
        return wrapper
    return decorator

@cache_with_ttl(ttl_seconds=3)  # Кэш живет 3 секунды
def get_data(n):
    return n * 2

print(get_data(5))    # Вычисляю -> 10
time.sleep(1)
print(get_data(5))    # Из кэша (возраст: 1.0с) -> 10
time.sleep(3)
print(get_data(5))    # Кэш устарел, пересчитываю -> 10
```

### **6. Кэш на уровне класса**

Если у вас есть класс, можно кэшировать методы.

```python
from functools import lru_cache

class Calculator:
    @lru_cache(maxsize=128)
    def factorial(self, n):
        """Факториал с кэшем"""
        print(f"Вычисляю факториал {n}")
        if n <= 1:
            return 1
        return n * self.factorial(n - 1)

calc = Calculator()
print(calc.factorial(5))   # Вычисления
print(calc.factorial(5))   # Из кэша
print(calc.factorial(6))   # Только одно новое вычисление
```

### **Сравнение методов:**

| Метод | Простота | Гибкость | Когда использовать |
|-------|----------|----------|-------------------|
| Ручной словарь | Легко | Максимальная | Простые случаи, обучение |
| `lru_cache` | Очень легко | Средняя | Большинство случаев |
| `cache` | Очень легко | Низкая | Неограниченный кэш |
| Свой декоратор | Сложнее | Максимальная | Особые требования |
| Кэш с TTL | Средне | Высокая | Данные устаревают |


## `21.4` Что такое хэш?
**Что такое хэш?**

`Хэш (hash)` — это число, которое получается из любых данных по специальной формуле. Это как "отпечаток пальца" для данных.

**Аналогия:**

Представьте библиотеку с миллионом книг. Как быстро найти нужную книгу?

- **Плохой способ:** Смотреть все книги по порядку (медленно!)
- **Хороший способ:** У каждой книги есть номер-код. По этому коду вы сразу знаете, на какой полке искать

Хэш — это и есть такой "номер-код" для любых данных.

**Как работает хэш в Python:**

Python использует функцию `hash()`, которая превращает данные в число.

**Пример 1: Хэши разных типов данных**

```python
# Хэш от числа
print(hash(42))          # 42 (для маленьких чисел часто равен самому числу)
print(hash(1000000))     # 1000000

# Хэш от строки
print(hash("привет"))    # Большое число, например: -2834723987324
print(hash("hello"))     # Другое большое число

# Хэш от кортежа
print(hash((1, 2, 3)))   # Какое-то число

# Важно: одинаковые данные всегда дают одинаковый хэш!
print(hash("test"))      # Например: 394857234
print(hash("test"))      # 394857234 (то же самое!)
```

**Пример 2: Хэш для быстрого поиска**

```python
# Представим, что мы ищем число в списке
numbers = [10, 20, 30, 40, 50, 100, 200, 300]

# Нужно найти 200 — придется проверить много элементов
if 200 in numbers:  # Python проверяет: 10? нет. 20? нет. 30? нет...
    print("Нашли!")

# Теперь с множеством (использует хэши!)
numbers_set = {10, 20, 30, 40, 50, 100, 200, 300}

# Поиск мгновенный! Python вычисляет hash(200) и сразу находит
if 200 in numbers_set:  # Мгновенно!
    print("Нашли!")
```

**Важные свойства хэша:**

1. **Детерминированность** — одинаковые данные всегда дают одинаковый хэш
   ```python
   print(hash("apple"))  # Например: 5873461234
   print(hash("apple"))  # 5873461234 (всегда одинаково!)
   ```

2. **Быстрота вычисления** — хэш считается очень быстро
   ```python
   # Даже для длинной строки хэш считается мгновенно
   long_text = "a" * 1000000  # Миллион символов
   print(hash(long_text))     # Мгновенно!
   ```

3. **Распределенность** — разные данные обычно дают разные хэши
   ```python
   print(hash("cat"))   # 8472634234
   print(hash("dog"))   # 1928475632 (совсем другое число!)
   ```

4. **Необратимость** — по хэшу нельзя восстановить исходные данные
   ```python
   h = hash("password123")
   # По числу h невозможно узнать, что было "password123"
   ```

**Пример 3: Что можно хэшировать, а что нельзя**

```python
# ✅ Можно хэшировать (неизменяемые типы):
print(hash(42))                  # int
print(hash(3.14))                # float
print(hash("text"))              # str
print(hash((1, 2, 3)))           # tuple
print(hash(True))                # bool

# ❌ Нельзя хэшировать (изменяемые типы):
try:
    print(hash([1, 2, 3]))       # list — ошибка!
except TypeError as e:
    print(f"Ошибка: {e}")        # unhashable type: 'list'

try:
    print(hash({"a": 1}))        # dict — ошибка!
except TypeError as e:
    print(f"Ошибка: {e}")        # unhashable type: 'dict'

try:
    print(hash({1, 2, 3}))       # set — ошибка!
except TypeError as e:
    print(f"Ошибка: {e}")        # unhashable type: 'set'
```

**Почему нельзя хэшировать изменяемые типы?**

```python
# Представим, что мы могли бы хэшировать список
my_list = [1, 2, 3]
h1 = hash(my_list)  # Предположим, получили хэш

my_list.append(4)   # Изменили список
h2 = hash(my_list)  # Хэш изменился?

# Если h1 != h2 — проблема! 
# Если использовали h1 как ключ в словаре, как теперь найти этот элемент?
```

**Где используются хэши в Python:**

### **1. Словари (dict)**

Словари используют хэши ключей для быстрого доступа.

```python
# Словарь
phonebook = {
    "Алиса": "123-45-67",
    "Боб": "765-43-21",
    "Вася": "111-22-33"
}

# Когда вы пишете:
print(phonebook["Боб"])

# Python делает:
# 1. Вычисляет hash("Боб")
# 2. По этому хэшу мгновенно находит значение "765-43-21"
# Не нужно проверять "Алиса"? нет, "Боб"? да!
```

### **2. Множества (set)**

Множества используют хэши для проверки уникальности.

```python
# Множество
numbers = {1, 2, 3, 4, 5}

# Добавление элемента
numbers.add(3)  # Python: hash(3) уже есть? Да — не добавляем

# Проверка вхождения
if 3 in numbers:  # hash(3) есть в множестве? Мгновенная проверка!
    print("Есть!")
```

### **3. Кэширование**

```python
from functools import lru_cache

@lru_cache
def slow_function(a, b):
    return a + b

# Python использует hash((a, b)) как ключ в кэше
slow_function(1, 2)  # Вычисляет, сохраняет с ключом hash((1, 2))
slow_function(1, 2)  # hash((1, 2)) уже есть? Да — берем из кэша!
```

**Пример 4: Коллизии хэшей**

Иногда разные объекты могут иметь одинаковый хэш (это редко, но бывает).

```python
# Коллизия — это когда hash(x) == hash(y), но x != y

# У некоторых чисел могут совпадать хэши
# (Python обрабатывает это правильно)

# Пример: создадим искусственную коллизию
class BadHash:
    def __init__(self, value):
        self.value = value
    
    def __hash__(self):
        return 42  # Всегда возвращаем 42!
    
    def __eq__(self, other):
        return self.value == other.value

# Все объекты имеют одинаковый хэш
obj1 = BadHash(1)
obj2 = BadHash(2)
obj3 = BadHash(3)

print(hash(obj1))  # 42
print(hash(obj2))  # 42
print(hash(obj3))  # 42

# Но множество всё равно работает правильно!
s = {obj1, obj2, obj3}
print(len(s))  # 3 — все элементы разные, несмотря на одинаковые хэши
```

**Итого про хэш:**

- Хэш — это "отпечаток пальца" для данных
- Используется для быстрого поиска (словари, множества, кэш)
- Одинаковые данные = одинаковый хэш
- По хэшу нельзя восстановить данные
- Изменяемые типы (списки, словари) нельзя хэшировать


## `21.5` Разница кэша и хэша  
Многие путают кэш и хэш, потому что оба слова похожи. Но это **совершенно разные вещи**!

**Простое объяснение:**

- **Хэш** — это "номер" для данных (как номер паспорта для человека)
- **Кэш** — это "сохраненный результат" работы (как шпаргалка с готовыми ответами)

**Аналогия из жизни:**

Представьте библиотеку:

- **Хэш** — это номер на корешке книги, по которому вы быстро находите нужную полку
- **Кэш** — это список "недавно прочитанных книг", который лежит на вашем столе для быстрого доступа

### **Сравнительная таблица:**

| **Аспект** | **Хэш** | **Кэш** |
|-----------|---------|---------|
| **Что это?** | Число-"отпечаток" данных | Сохраненный результат вычисления |
| **Для чего?** | Быстрый поиск и сравнение | Избежать повторных вычислений |
| **Функция** | `hash(данные)` → число | Сохранить результат функции |
| **Пример** | `hash("apple")` → `5873461234` | `fibonacci(10)` → сохранить результат `55` |
| **Где используется** | Словари, множества, ключи | Ускорение функций, веб-кэш |
| **Изменяется?** | Нет (всегда одинаковый для данных) | Да (можно очистить, обновить) |
| **Память** | Почти не занимает | Может занимать много памяти |

### **Как они связаны?**
Хэш часто используется **внутри** кэша, но это разные концепции:

```python
# Внутри lru_cache:
# 
# def lru_cache_внутренности(func):
#     cache = {}  # Словарь для кэша
#     
#     def wrapper(*args):
#         key = hash(args)  # ХЭШ аргументов как ключ
#         
#         if key in cache:  # Проверка КЭШа
#             return cache[key]  # Возврат из КЭШа
#         
#         result = func(*args)
#         cache[key] = result  # Сохранение в КЭШ
#         return result
#     
#     return wrapper
```

### **Итоговое сравнение в терминах задач:**

**Хэш отвечает на вопрос:** "Как быстро найти/сравнить данные?"
```python
# Быстрый поиск
if "key" in my_dict:  # hash("key") → поиск
    pass
```

**Кэш отвечает на вопрос:** "Как не делать одну работу дважды?"
```python
# Избежать повторных вычислений
@lru_cache
def work(x):
    return x * 2
```

### **Запоминалка:**

- **Хэш** = **H**ow to find? (Как найти?) → номер для поиска
- **Кэш** = **C**ache results (Кэшировать результаты) → сохранять ответы

**Главное:** 
- Хэш помогает **найти** данные быстро
- Кэш помогает **не пересчитывать** данные заново

Они могут работать вместе, но это разные инструменты для разных целей!

----

# `22` (`**`) Типы данных 4
_P.S: only for flexing on the job interview_  

## `22.1` `Decimal` что такое и для чего нужен?
`Decimal` — это класс из модуля `decimal` для работы с **десятичными числами с фиксированной точностью**. В отличие от обычных `float`, которые используют двоичное представление, `Decimal` хранит числа в десятичном виде, что устраняет проблемы с точностью.

**Проблема с float:**
```python
print(0.1 + 0.2)  # 0.30000000000000004 (неточность!)
print(0.1 + 0.1 + 0.1 == 0.3)  # False
```

**Для чего нужен Decimal:**
- 💰 **Финансовые расчеты** — точная работа с деньгами
- 📊 **Научные вычисления** — когда важна точность
- 🧮 **Бухгалтерия и налоги** — никаких ошибок округления
- ⚖️ **Юридические расчеты** — где точность критична

**Основные возможности:**
- Точные десятичные вычисления
- Контроль точности (количество знаков после запятой)
- Контроль округления
- Работа с очень большими и малыми числами

**Примеры:**

```python
from decimal import Decimal, getcontext

# Проблема с float
print(0.1 + 0.2)  # 0.30000000000000004
print(0.1 + 0.2 == 0.3)  # False

# Решение с Decimal
a = Decimal('0.1')
b = Decimal('0.2')
print(a + b)  # 0.3
print(a + b == Decimal('0.3'))  # True

# ВАЖНО: создавайте Decimal из СТРОКИ, не из float!
wrong = Decimal(0.1)  # ❌ сохранит неточность float
correct = Decimal('0.1')  # ✅ точное значение

print(wrong)    # 0.1000000000000000055511151231257827021181583404541015625
print(correct)  # 0.1

# Арифметические операции
price = Decimal('19.99')
quantity = Decimal('3')
tax_rate = Decimal('0.13')

subtotal = price * quantity
tax = subtotal * tax_rate
total = subtotal + tax

print(f"Подытог: {subtotal}")  # 59.97
print(f"Налог: {tax}")  # 7.7961
print(f"Итого: {total}")  # 67.7661

# Округление
print(f"Итого (округл.): {total.quantize(Decimal('0.01'))}")  # 67.77
```

```python
from decimal import Decimal, getcontext, ROUND_HALF_UP

# Настройка точности
getcontext().prec = 6  # 6 значащих цифр

a = Decimal('1.123456789')
b = Decimal('2.987654321')
print(a + b)  # 4.11111 (округлено до 6 цифр)

# Различные режимы округления
amount = Decimal('10.555')

print(amount.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP))  # 10.56

# Практический пример: расчет скидки
original_price = Decimal('999.99')
discount_percent = Decimal('15.5')

discount = original_price * (discount_percent / 100)
final_price = original_price - discount

print(f"Цена: {original_price}")
print(f"Скидка {discount_percent}%: -{discount.quantize(Decimal('0.01'))}")
print(f"Итого: {final_price.quantize(Decimal('0.01'))}")
# Цена: 999.99
# Скидка 15.5%: -155.00
# Итого: 844.99
```

## `22.2` `namedtuple` что такое и для чего нужен?
`namedtuple` — это класс из модуля `collections`, который создает **именованные кортежи**. Это легковесная альтернатива классам для хранения данных.

**Отличия от обычного кортежа:**
- Обычный кортеж: доступ по индексу `point[0]`, `point[1]`
- namedtuple: доступ по имени `point.x`, `point.y`

**Преимущества:**
- ✅ Читаемость — понятные имена вместо индексов
- ✅ Неизменяемость — как у обычных кортежей
- ✅ Легковесность — меньше памяти, чем у классов
- ✅ Совместимость — можно использовать как обычный кортеж
- ✅ Удобство — автоматически создаются `__repr__`, `__eq__` и др.

**Для чего нужен:**
- 📍 Представление координат, точек
- 📊 Хранение структурированных данных
- 🗂️ Возврат нескольких значений из функции
- 📋 Альтернатива словарям для фиксированных структур

**Примеры:**

```python
from collections import namedtuple

# Создание namedtuple
Point = namedtuple('Point', ['x', 'y'])

# Можно также через строку
# Point = namedtuple('Point', 'x y')

# Создание экземпляров
p1 = Point(10, 20)
p2 = Point(x=30, y=40)

# Доступ по имени (как у класса)
print(p1.x)  # 10
print(p1.y)  # 20

# Доступ по индексу (как у кортежа)
print(p1[0])  # 10
print(p1[1])  # 20

# Распаковка
x, y = p1
print(f"x={x}, y={y}")  # x=10, y=20

# Неизменяемость
# p1.x = 15  # AttributeError: can't set attribute

# Красивый вывод
print(p1)  # Point(x=10, y=20)

# Методы namedtuple
print(p1._fields)  # ('x', 'y') - названия полей
print(p1._asdict())  # {'x': 10, 'y': 20} - как словарь

# Создание нового с заменой значений
p3 = p1._replace(x=50)
print(p3)  # Point(x=50, y=20)
```

```python
from collections import namedtuple

# Практический пример: данные пользователя
User = namedtuple('User', ['id', 'name', 'email', 'age'])

user1 = User(1, 'Иван', 'ivan@example.com', 30)
user2 = User(2, 'Мария', 'maria@example.com', 25)

print(user1.name)   # Иван
print(user1.email)  # ivan@example.com

# Использование в функциях
def get_user_info():
    return User(3, 'Петр', 'petr@example.com', 35)

user = get_user_info()
print(f"{user.name}, {user.age} лет")  # Петр, 35 лет

# Работа со списком пользователей
users = [
    User(1, 'Анна', 'anna@example.com', 28),
    User(2, 'Олег', 'oleg@example.com', 32),
    User(3, 'Елена', 'elena@example.com', 24)
]

# Фильтрация
adults = [u for u in users if u.age >= 30]
for user in adults:
    print(f"{user.name}: {user.age} лет")
# Олег: 32 лет

# Сортировка по имени
sorted_users = sorted(users, key=lambda u: u.name)
for user in sorted_users:
    print(user.name)
# Анна
# Елена
# Олег
```

## `22.3` `defaultdict` что такое и для чего нужен?
`defaultdict` — это подкласс обычного словаря из модуля `collections`, который **автоматически создает значения** для несуществующих ключей.

**Отличие от обычного словаря:**
```python
# Обычный словарь
d = {}
# d['key'] += 1  # KeyError!

# defaultdict
from collections import defaultdict
d = defaultdict(int)
d['key'] += 1  # OK! Создастся 0, потом прибавится 1
```

**Для чего нужен:**
- 📊 **Подсчет элементов** — не нужно проверять наличие ключа
- 📋 **Группировка данных** — автоматическое создание списков/множеств
- 🗂️ **Вложенные структуры** — упрощение работы с графами, деревьями
- ⚡ **Упрощение кода** — меньше проверок `if key in dict`

**Типы по умолчанию:**
- `defaultdict(int)` — значение по умолчанию 0
- `defaultdict(list)` — пустой список []
- `defaultdict(set)` — пустое множество set()
- `defaultdict(str)` — пустая строка ""
- `defaultdict(dict)` — пустой словарь {}

**Примеры:**

```python
from collections import defaultdict

# Подсчет элементов
text = "hello world"
char_count = defaultdict(int)

for char in text:
    char_count[char] += 1  # Не нужно проверять наличие ключа!

print(dict(char_count))
# {'h': 1, 'e': 1, 'l': 3, 'o': 2, ' ': 1, 'w': 1, 'r': 1, 'd': 1}

# Сравнение с обычным словарем
# Обычный способ (много кода)
normal_dict = {}
for char in text:
    if char in normal_dict:
        normal_dict[char] += 1
    else:
        normal_dict[char] = 1

# С defaultdict (короче и понятнее!)
dd = defaultdict(int)
for char in text:
    dd[char] += 1

# Подсчет слов
words = ['apple', 'banana', 'apple', 'cherry', 'banana', 'apple']
word_count = defaultdict(int)

for word in words:
    word_count[word] += 1

print(dict(word_count))
# {'apple': 3, 'banana': 2, 'cherry': 1}
```

```python
from collections import defaultdict

# Группировка данных
students = [
    ('Иван', 'Математика'),
    ('Мария', 'Физика'),
    ('Иван', 'Физика'),
    ('Петр', 'Математика'),
    ('Мария', 'Химия'),
    ('Иван', 'Химия')
]

# Группируем предметы по студентам
student_subjects = defaultdict(list)

for student, subject in students:
    student_subjects[student].append(subject)

print(dict(student_subjects))
# {'Иван': ['Математика', 'Физика', 'Химия'],
#  'Мария': ['Физика', 'Химия'],
#  'Петр': ['Математика']}

# Группировка по первой букве
words = ['apple', 'apricot', 'banana', 'blueberry', 'cherry', 'coconut']
grouped = defaultdict(list)

for word in words:
    first_letter = word[0]
    grouped[first_letter].append(word)

print(dict(grouped))
# {'a': ['apple', 'apricot'],
#  'b': ['banana', 'blueberry'],
#  'c': ['cherry', 'coconut']}
```

## `22.4` `OrderedDict` что такое и для чего нужен?
`OrderedDict` — это словарь из модуля `collections`, который **сохраняет порядок добавления элементов**.

**Историческая справка:**
- До Python 3.6: обычный `dict` НЕ гарантировал порядок
- Python 3.6+: обычный `dict` сохраняет порядок (но это деталь реализации)
- Python 3.7+: порядок в `dict` — часть спецификации языка

**Зачем нужен сейчас:**
- 📜 **Совместимость** с старым кодом
- 🔄 **Специальные методы** — `move_to_end()`, `popitem(last=True/False)`
- 📊 **Явное указание** — порядок важен (для читаемости кода)
- 🎯 **Сравнение** — `OrderedDict` учитывает порядок при сравнении

**Примеры:**

```python
from collections import OrderedDict

# Создание OrderedDict
od = OrderedDict()
od['a'] = 1
od['b'] = 2
od['c'] = 3
od['d'] = 4

print(od)  # OrderedDict([('a', 1), ('b', 2), ('c', 3), ('d', 4)])

# Порядок сохраняется
for key, value in od.items():
    print(f"{key}: {value}")
# a: 1
# b: 2
# c: 3
# d: 4

# Специальный метод move_to_end()
od.move_to_end('b')  # Переместить 'b' в конец
print(od)  # OrderedDict([('a', 1), ('c', 3), ('d', 4), ('b', 2)])

od.move_to_end('c', last=False)  # Переместить 'c' в начало
print(od)  # OrderedDict([('c', 3), ('a', 1), ('d', 4), ('b', 2)])

# popitem() с параметром last
last_item = od.popitem(last=True)  # Удалить последний
print(f"Удален последний: {last_item}")  # ('b', 2)

first_item = od.popitem(last=False)  # Удалить первый
print(f"Удален первый: {first_item}")  # ('c', 3)

print(od)  # OrderedDict([('a', 1), ('d', 4)])
```

```python
from collections import OrderedDict

# Практический пример: простой кеш с ограничением размера
# (хранит только последние N элементов)

def create_cache(max_size):
    """Создает словарь-кеш с ограничением размера"""
    cache = OrderedDict()
    
    def get(key):
        """Получить значение из кеша"""
        if key not in cache:
            return None
        # Перемещаем в конец (отмечаем как недавно использованный)
        cache.move_to_end(key)
        return cache[key]
    
    def put(key, value):
        """Добавить значение в кеш"""
        if key in cache:
            # Если ключ уже есть, обновляем и перемещаем в конец
            cache.move_to_end(key)
        cache[key] = value
        
        # Если превышен размер, удаляем самый старый (первый)
        if len(cache) > max_size:
            cache.popitem(last=False)
    
    def show():
        """Показать содержимое кеша"""
        return dict(cache)
    
    return {'get': get, 'put': put, 'show': show}

# Создаем кеш на 3 элемента
cache = create_cache(3)

# Добавляем элементы
cache['put']('a', 1)
cache['put']('b', 2)
cache['put']('c', 3)
print(cache['show']())  # {'a': 1, 'b': 2, 'c': 3}

# Используем 'a' (он переместится в конец)
print(cache['get']('a'))  # 1
print(cache['show']())  # {'b': 2, 'c': 3, 'a': 1}

# Добавляем 'd' - 'b' удалится (самый старый)
cache['put']('d', 4)
print(cache['show']())  # {'c': 3, 'a': 1, 'd': 4}

# Добавляем 'e' - 'c' удалится
cache['put']('e', 5)
print(cache['show']())  # {'a': 1, 'd': 4, 'e': 5}
```

## `22.5` `ChainMap` что такое и для чего нужен?
`ChainMap` — это класс из модуля `collections`, который **объединяет несколько словарей** в одно представление. При поиске ключа просматривает словари по порядку.

**Как работает:**
- Не создает новый словарь
- Хранит ссылки на существующие словари
- Поиск идет слева направо (первый найденный ключ)
- Изменения влияют на первый словарь

**Для чего нужен:**
- ⚙️ **Конфигурации** — объединение настроек (дефолтные + пользовательские)
- 🔍 **Приоритет поиска** — локальные → глобальные переменные
- 💾 **Экономия памяти** — не дублирует данные
- 🔗 **Контексты** — вложенные области видимости

**Примеры:**

```python
from collections import ChainMap

# Объединение словарей
defaults = {'theme': 'light', 'language': 'en', 'font_size': 12}
user_settings = {'theme': 'dark', 'font_size': 14}

# ChainMap ищет сначала в user_settings, потом в defaults
config = ChainMap(user_settings, defaults)

print(config['theme'])      # 'dark' (из user_settings)
print(config['language'])   # 'en' (из defaults)
print(config['font_size'])  # 14 (из user_settings)

# Все ключи
print(dict(config))
# {'theme': 'dark', 'font_size': 14, 'language': 'en'}

# Изменение значения (изменяется первый словарь)
config['theme'] = 'blue'
print(user_settings)  # {'theme': 'blue', 'font_size': 14}

# Добавление нового ключа
config['new_setting'] = 'value'
print(user_settings)  # {'theme': 'blue', 'font_size': 14, 'new_setting': 'value'}

# Доступ к исходным словарям
print(config.maps)  # [{'theme': 'blue', ...}, {'theme': 'light', ...}]
```

```python
from collections import ChainMap

# Практический пример: система конфигурации
system_defaults = {
    'max_users': 100,
    'timeout': 30,
    'debug': False,
    'port': 8080
}

app_config = {
    'timeout': 60,
    'debug': True
}

user_config = {
    'timeout': 90
}

# Приоритет: user > app > system
config = ChainMap(user_config, app_config, system_defaults)

print(f"Timeout: {config['timeout']}")      # 90 (user)
print(f"Debug: {config['debug']}")          # True (app)
print(f"Max users: {config['max_users']}")  # 100 (system)
print(f"Port: {config['port']}")            # 8080 (system)

# Добавление нового контекста
emergency_config = {'max_users': 10, 'emergency_mode': True}
config = config.new_child(emergency_config)

print(f"Max users: {config['max_users']}")  # 10 (emergency)
print(f"Emergency: {config['emergency_mode']}")  # True

# Удаление контекста
config = config.parents  # убираем emergency_config
print(f"Max users: {config['max_users']}")  # 100 (обратно к system)
```

## `22.6` `deque` что такое и для чего нужен?
`deque` (double-ended queue, "дек") — это **двусторонняя очередь** из модуля `collections`. Позволяет эффективно добавлять и удалять элементы **с обоих концов**.

**Отличие от списка:**
- Список: быстрое добавление/удаление только в конце
- `deque`: быстрое добавление/удаление **с обоих концов** (O(1))

**Основные методы:**
- `append(x)` — добавить справа
- `appendleft(x)` — добавить слева
- `pop()` — удалить справа
- `popleft()` — удалить слева
- `rotate(n)` — сдвинуть элементы на n позиций

**Для чего нужен:**
- 📋 **Очереди** — FIFO (First In, First Out)
- 📚 **Стеки** — LIFO (Last In, First Out)
- ⏮️ **История действий** — ограниченная история (maxlen)
- 🔄 **Циклические буферы**
- 🎮 **Игры** — хранение последних действий

**Примеры:**

```python
from collections import deque

# Создание deque
dq = deque([1, 2, 3, 4, 5])
print(dq)  # deque([1, 2, 3, 4, 5])

# Добавление с обоих концов
dq.append(6)        # справа
dq.appendleft(0)    # слева
print(dq)  # deque([0, 1, 2, 3, 4, 5, 6])

# Удаление с обоих концов
dq.pop()        # удалить справа, вернет 6
dq.popleft()    # удалить слева, вернет 0
print(dq)  # deque([1, 2, 3, 4, 5])

# Rotation (поворот)
dq.rotate(2)  # сдвинуть вправо на 2
print(dq)  # deque([4, 5, 1, 2, 3])

dq.rotate(-2)  # сдвинуть влево на 2
print(dq)  # deque([1, 2, 3, 4, 5])

# Ограниченная длина (maxlen)
limited_dq = deque(maxlen=3)
limited_dq.append(1)
limited_dq.append(2)
limited_dq.append(3)
print(limited_dq)  # deque([1, 2, 3], maxlen=3)

limited_dq.append(4)  # Добавится 4, удалится 1
print(limited_dq)  # deque([2, 3, 4], maxlen=3)
```

```python
from collections import deque

# Практический пример: история браузера (ограниченная)
class BrowserHistory:
    def __init__(self, max_history=10):
        self.history = deque(maxlen=max_history)
        self.current = -1
    
    def visit(self, url):
        # Удаляем всё после текущей позиции
        while len(self.history) > self.current + 1:
            self.history.pop()
        
        self.history.append(url)
        self.current = len(self.history) - 1
    
    def back(self):
        if self.current > 0:
            self.current -= 1
            return self.history[self.current]
        return None
    
    def forward(self):
        if self.current < len(self.history) - 1:
            self.current += 1
            return self.history[self.current]
        return None
    
    def current_page(self):
        if 0 <= self.current < len(self.history):
            return self.history[self.current]
        return None

# Используем
browser = BrowserHistory(max_history=5)
browser.visit("google.com")
browser.visit("github.com")
browser.visit("stackoverflow.com")

print(browser.current_page())  # stackoverflow.com
print(browser.back())           # github.com
print(browser.back())           # google.com
print(browser.forward())        # github.com
```

## `22.7` Можно ещё поизучать модуль `collections`  
Модуль `collections` содержит дополнительные структуры данных, которые расширяют стандартные типы Python.

**Основные классы:**
- `Counter` — подсчет элементов
- `defaultdict` — словарь со значениями по умолчанию
- `OrderedDict` — словарь с сохранением порядка
- `ChainMap` — объединение словарей
- `deque` — двусторонняя очередь
- `namedtuple` — именованные кортежи
- `UserDict`, `UserList`, `UserString` — базовые классы для создания своих типов

**Counter — подсчет элементов:**

```python
from collections import Counter

# Подсчет элементов
words = ['apple', 'banana', 'apple', 'cherry', 'banana', 'apple']
counter = Counter(words)
print(counter)  # Counter({'apple': 3, 'banana': 2, 'cherry': 1})

# Самые частые элементы
print(counter.most_common(2))  # [('apple', 3), ('banana', 2)]

# Подсчет символов
text = "hello world"
char_counter = Counter(text)
print(char_counter)  # Counter({'l': 3, 'o': 2, ...})

# Арифметика с Counter
c1 = Counter(a=3, b=1)
c2 = Counter(a=1, b=2)
print(c1 + c2)  # Counter({'a': 4, 'b': 3})
print(c1 - c2)  # Counter({'a': 2}) (отрицательные удаляются)
```

**Практический пример — анализ текста:**

```python
from collections import Counter, defaultdict, deque

text = """
Python is a high-level programming language.
Python is easy to learn.
Python is widely used.
"""

# Подсчет слов
words = text.lower().split()
word_count = Counter(words)
print("Топ-5 слов:")
for word, count in word_count.most_common(5):
    print(f"  {word}: {count}")

# Группировка слов по длине
words_by_length = defaultdict(list)
for word in set(words):
    words_by_length[len(word)].append(word)

print("\nСлова по длине:")
for length in sorted(words_by_length.keys()):
    print(f"  {length}: {words_by_length[length]}")

# Последние 3 действия (история)
actions = deque(maxlen=3)
actions.append("открыт файл")
actions.append("изменена строка 5")
actions.append("сохранен файл")
actions.append("запущен код")

print("\nПоследние действия:")
for action in actions:
    print(f"  - {action}")
```

**Итоговая шпаргалка:**

| Класс | Для чего | Когда использовать |
|-------|----------|-------------------|
| `Decimal` | Точные вычисления | Деньги, финансы, точные расчеты |
| `namedtuple` | Именованные кортежи | Структуры данных, координаты |
| `defaultdict` | Словарь с дефолтом | Подсчет, группировка |
| `OrderedDict` | Словарь с порядком | Когда порядок важен, LRU cache |
| `ChainMap` | Объединение словарей | Конфигурации, приоритеты |
| `deque` | Двусторонняя очередь | Очереди, стеки, история |
| `Counter` | Подсчет элементов | Частотный анализ |














----

# `23` Принципы ООП
## `23.1` Парадигмы программирования. Что такое объект в Python?
**Что такое парадигма программирования?**

Парадигма программирования — это **стиль** или **подход** к написанию программ. Это как разные способы решения одной задачи.

**Аналогия:**

Представьте, что вам нужно добраться из точки А в точку Б:
- Можно пойти пешком (одна парадигма)
- Можно поехать на машине (другая парадигма)
- Можно полететь на самолете (третья парадигма)

Цель одна, но способы разные!

### **Основные парадигмы программирования:**

### **1. Процедурное программирование**

Программа — это последовательность команд (процедур), выполняемых одна за другой.

**Пример:**
```python
# Процедурный стиль — функции и данные отдельно

# Данные
balance = 1000

# Функции для работы с данными
def deposit(amount):
    global balance
    balance += amount
    print(f"Пополнение: +{amount}. Баланс: {balance}")

def withdraw(amount):
    global balance
    if balance >= amount:
        balance -= amount
        print(f"Снятие: -{amount}. Баланс: {balance}")
    else:
        print("Недостаточно средств")

# Использование
deposit(500)    # Пополнение: +500. Баланс: 1500
withdraw(200)   # Снятие: -200. Баланс: 1300
```

**Характеристики:**
- Программа = набор функций
- Данные хранятся отдельно от функций
- Функции изменяют данные

### **2. Объектно-ориентированное программирование (ООП)**

Программа — это набор объектов, которые взаимодействуют друг с другом. Данные и функции объединены вместе.

**Пример:**
```python
# ООП стиль — данные и функции вместе

class BankAccount:
    def __init__(self):
        self.balance = 1000
    
    def deposit(self, amount):
        self.balance += amount
        print(f"Пополнение: +{amount}. Баланс: {self.balance}")
    
    def withdraw(self, amount):
        if self.balance >= amount:
            self.balance -= amount
            print(f"Снятие: -{amount}. Баланс: {self.balance}")
        else:
            print("Недостаточно средств")

# Создаем объект
account = BankAccount()

# Используем методы объекта
account.deposit(500)    # Пополнение: +500. Баланс: 1500
account.withdraw(200)   # Снятие: -200. Баланс: 1300
```

**Характеристики:**
- Программа = набор объектов
- Данные и функции объединены в объекты
- Объекты взаимодействуют друг с другом

### **3. Функциональное программирование**

Программа — это набор функций, которые не изменяют данные, а создают новые.

**Пример:**
```python
# Функциональный стиль — функции не изменяют данные

def deposit(balance, amount):
    """Возвращает новый баланс"""
    return balance + amount

def withdraw(balance, amount):
    """Возвращает новый баланс или None"""
    if balance >= amount:
        return balance - amount
    else:
        return None

# Использование
balance = 1000
balance = deposit(balance, 500)     # balance = 1500
balance = withdraw(balance, 200)    # balance = 1300

print(f"Баланс: {balance}")
```

**Характеристики:**
- Функции не изменяют данные, а возвращают новые
- Избегание изменяемого состояния
- Функции как данные

### **Что такое объект в Python?**

**Объект** — это "коробка", в которой хранятся:
1. **Данные** (свойства, характеристики)
2. **Функции** (действия, которые можно совершить)

**Важно:** В Python **всё является объектом**!

**Примеры объектов:**

```python
# Число — это объект!
number = 42
print(type(number))  # <class 'int'>

# У числа есть методы (функции)
print(number.bit_length())  # 6 (количество бит)

# Строка — это объект!
text = "привет"
print(type(text))  # <class 'str'>

# У строки есть методы
print(text.upper())      # ПРИВЕТ
print(text.capitalize()) # Привет

# Список — это объект!
numbers = [1, 2, 3]
print(type(numbers))  # <class 'list'>

# У списка есть методы
numbers.append(4)  # Добавить элемент
numbers.reverse()  # Перевернуть список
print(numbers)     # [4, 3, 2, 1]
```

**Объект = данные + методы**

```python
# Строка "hello"
text = "hello"

# Данные объекта
print(text)        # "hello" — сами данные
print(len(text))   # 5 — длина (данные)

# Методы объекта (функции, привязанные к объекту)
print(text.upper())       # "HELLO"
print(text.replace('l', 'L'))  # "heLLo"
print(text.count('l'))    # 2
```

**Пример: создадим свой простой объект**

```python
# Словарь как простой объект
person = {
    'name': 'Алиса',
    'age': 25,
    'city': 'Москва'
}

# У "объекта" есть данные
print(person['name'])  # Алиса
print(person['age'])   # 25

# Но это еще не полноценный объект ООП
# Функции хранятся отдельно
def introduce(person_dict):
    print(f"Меня зовут {person_dict['name']}, мне {person_dict['age']} лет")

introduce(person)  # Меня зовут Алиса, мне 25 лет
```

В ООП мы объединим данные и функции вместе (об этом в следующих разделах).


## `23.2` Преимущества ООП и недостатки
### **Преимущества ООП:**

**1. Организация кода**

Всё связанное находится в одном месте.

```python
# БЕЗ ООП — всё разбросано
user_name = "Анна"
user_age = 25
user_email = "anna@example.com"

def send_email_to_user(email, message):
    print(f"Отправка на {email}: {message}")

def is_adult(age):
    return age >= 18

# С ООП — всё вместе
class User:
    def __init__(self, name, age, email):
        self.name = name
        self.age = age
        self.email = email
    
    def send_email(self, message):
        print(f"Отправка на {self.email}: {message}")
    
    def is_adult(self):
        return self.age >= 18

user = User("Анна", 25, "anna@example.com")
user.send_email("Привет!")  # Всё логически связано
```

**2. Повторное использование кода (наследование)**

Можно создавать новые классы на основе существующих.

```python
# Базовый функционал
class Animal:
    def __init__(self, name):
        self.name = name
    
    def speak(self):
        pass

# Расширяем функционал
class Dog(Animal):
    def speak(self):
        return f"{self.name} говорит: Гав!"

class Cat(Animal):
    def speak(self):
        return f"{self.name} говорит: Мяу!"

dog = Dog("Бобик")
cat = Cat("Мурка")

print(dog.speak())  # Бобик говорит: Гав!
print(cat.speak())  # Мурка говорит: Мяу!
```

**3. Модульность**

Код разделен на независимые части (объекты).

```python
# Каждый объект — независимая единица
account1 = BankAccount()
account2 = BankAccount()

# Изменение одного не влияет на другой
account1.deposit(100)
account2.deposit(500)

print(account1.balance)  # 1100
print(account2.balance)  # 1500
```

**4. Скрытие сложности (инкапсуляция)**

Пользователь работает с простым интерфейсом, не зная внутренней реализации.

```python
class CoffeeMachine:
    def make_coffee(self, coffee_type):
        self._grind_beans()    # Внутренние детали
        self._heat_water()     # скрыты от пользователя
        self._brew(coffee_type)
        return "☕ Ваш кофе готов!"
    
    def _grind_beans(self):
        # Сложная логика помола
        pass
    
    def _heat_water(self):
        # Сложная логика нагрева
        pass
    
    def _brew(self, coffee_type):
        # Сложная логика заваривания
        pass

# Пользователь не знает, как работает машина внутри
machine = CoffeeMachine()
coffee = machine.make_coffee("эспрессо")  # Просто!
```

**5. Легкость поддержки**

Изменения в одном месте не ломают весь код.

```python
# Изменили класс User
class User:
    def __init__(self, name, age, email):
        self.name = name
        self.age = age
        self.email = email
    
    # Добавили новый метод — старый код продолжает работать
    def get_full_info(self):
        return f"{self.name}, {self.age} лет, {self.email}"
```

**6. Моделирование реального мира**

Объекты похожи на объекты реального мира.

```python
# Реальный мир: машины, двери, двигатели
class Car:
    def __init__(self, brand):
        self.brand = brand
        self.engine = Engine()
        self.doors = [Door(), Door(), Door(), Door()]
    
    def start(self):
        self.engine.start()
        print(f"{self.brand} завелась")

class Engine:
    def start(self):
        print("Двигатель запущен")

class Door:
    def open(self):
        print("Дверь открыта")

# Код похож на реальную машину
car = Car("Toyota")
car.start()
car.doors[0].open()
```

### **Недостатки ООП:**

**1. Избыточность для простых задач**

```python
# Для простой задачи ООП — overkill

# ПРОСТАЯ ЗАДАЧА: сложить два числа

# Процедурный стиль (просто и понятно)
def add(a, b):
    return a + b

print(add(2, 3))  # 5

# ООП стиль (слишком сложно для такой задачи)
class Calculator:
    def add(self, a, b):
        return a + b

calc = Calculator()
print(calc.add(2, 3))  # 5 — зачем столько кода?
```

**2. Сложность для начинающих**

ООП требует понимания абстрактных концепций.

```python
# Новичку сложно понять это с первого раза
class AbstractFactory:
    def create_product(self):
        pass

class ConcreteFactory(AbstractFactory):
    def create_product(self):
        return ConcreteProduct()

# Процедурный код проще для понимания
def create_product():
    return {"type": "product"}
```

**3. Медленнее выполнение**

Вызовы методов объектов медленнее обычных функций.

```python
# Функция (быстрее)
def square(x):
    return x * x

# Метод объекта (медленнее из-за дополнительных операций)
class Math:
    def square(self, x):
        return x * x

# Разница незначительна, но есть
```

**4. Больше памяти**

Объекты хранят больше информации.

```python
# Простые переменные (меньше памяти)
x = 10
y = 20

# Объект (больше памяти — хранит данные + методы + служебную информацию)
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

p = Point(10, 20)
```

**5. Может привести к переусложнению**

Программисты иногда создают слишком сложную архитектуру.

```python
# Простая задача: хранить имя и возраст

# ПЛОХО — переусложнение
class Person:
    def __init__(self, name, age):
        self._personal_info = PersonalInfo(name, age)
    
    def get_name(self):
        return self._personal_info.get_name()

class PersonalInfo:
    def __init__(self, name, age):
        self._name = Name(name)
        self._age = Age(age)
    
    def get_name(self):
        return self._name.get_value()

class Name:
    def __init__(self, value):
        self._value = value
    
    def get_value(self):
        return self._value

# ХОРОШО — просто
person = {"name": "Анна", "age": 25}
print(person["name"])
```

### **Когда использовать ООП:**

✅ **Используйте ООП:**
- Большие проекты с множеством связанных данных
- Когда нужна модульность и переиспользование кода
- При моделировании сложных систем (игры, веб-приложения, GUI)
- Когда работают несколько программистов

❌ **НЕ используйте ООП:**
- Простые скрипты и утилиты
- Математические вычисления
- Обработка данных (лучше функциональный подход)
- Быстрые прототипы


## `23.3` Что такое класс и объект?
[Введение ООП в Python](https://youtu.be/gFRa6qVN980?si=QH97AeHOY3hP1mat)

**Класс** — это **чертёж** или **шаблон** для создания объектов.

**Объект** — это **конкретный экземпляр** класса.

**Аналогия:**

- **Класс** = чертёж дома (бумажный план)
- **Объект** = настоящий построенный дом

По одному чертежу можно построить много одинаковых домов, но каждый дом будет отдельным объектом.

### **Пример 1: Класс и объекты**

```python
# Класс — чертёж для собаки
class Dog:
    def __init__(self, name, age):
        self.name = name  # Данные
        self.age = age
    
    def bark(self):  # Поведение
        print(f"{self.name} говорит: Гав-гав!")

# Создаем объекты (конкретные собаки) по чертежу
dog1 = Dog("Бобик", 3)
dog2 = Dog("Шарик", 5)
dog3 = Dog("Рекс", 2)

# У каждого объекта свои данные
print(dog1.name)  # Бобик
print(dog2.name)  # Шарик
print(dog3.name)  # Рекс

# Но поведение одинаковое
dog1.bark()  # Бобик говорит: Гав-гав!
dog2.bark()  # Шарик говорит: Гав-гав!
```

### **Структура класса:**

```python
class ClassName:  # Имя класса с большой буквы
    """Описание класса"""
    
    def __init__(self, параметры):  # Конструктор (инициализатор)
        self.свойство1 = значение1
        self.свойство2 = значение2
    
    def метод1(self):  # Методы (функции класса)
        # код метода
        pass
    
    def метод2(self, параметр):
        # код метода
        pass
```

### **Пример 2: Класс "Книга"**

```python
class Book:
    """Класс для представления книги"""
    
    def __init__(self, title, author, pages):
        """Конструктор — вызывается при создании объекта"""
        self.title = title      # Название
        self.author = author    # Автор
        self.pages = pages      # Страницы
        self.current_page = 0   # Текущая страница
    
    def read(self, pages_count):
        """Прочитать несколько страниц"""
        self.current_page += pages_count
        if self.current_page > self.pages:
            self.current_page = self.pages
        print(f"Прочитано до страницы {self.current_page}")
    
    def info(self):
        """Информация о книге"""
        return f"'{self.title}' - {self.author}, {self.pages} стр."

# Создаем объекты (книги)
book1 = Book("Война и мир", "Толстой", 1200)
book2 = Book("Гарри Поттер", "Роулинг", 300)

# У каждой книги свои данные
print(book1.info())  # 'Война и мир' - Толстой, 1200 стр.
print(book2.info())  # 'Гарри Поттер' - Роулинг, 300 стр.

# Читаем книги независимо
book1.read(50)   # Прочитано до страницы 50
book2.read(100)  # Прочитано до страницы 100
book1.read(30)   # Прочитано до страницы 80

print(book1.current_page)  # 80
print(book2.current_page)  # 100
```

### **Что такое `self`?**

`self` — это ссылка на **сам объект**. Через `self` методы получают доступ к данным объекта.

```python
class Counter:
    def __init__(self):
        self.count = 0  # self.count — это "мой счетчик"
    
    def increment(self):
        self.count += 1  # Увеличиваю МОЙ счетчик
        print(f"Счетчик: {self.count}")

# Создаем два независимых счетчика
counter1 = Counter()
counter2 = Counter()

counter1.increment()  # Счетчик: 1
counter1.increment()  # Счетчик: 2

counter2.increment()  # Счетчик: 1

# У каждого объекта свой self.count
print(counter1.count)  # 2
print(counter2.count)  # 1
```

**Почему `self`?**

```python
# Когда вы пишете:
dog1.bark()

# Python преобразует это в:
Dog.bark(dog1)  # Передает dog1 как self

# Поэтому первый параметр всегда self
```

### **Пример 3: Класс "Банковский счёт"**

```python
class BankAccount:
    def __init__(self, owner, balance=0):
        self.owner = owner
        self.balance = balance
    
    def deposit(self, amount):
        """Пополнить счёт"""
        self.balance += amount
        print(f"{self.owner}: +{amount}. Баланс: {self.balance}")
    
    def withdraw(self, amount):
        """Снять деньги"""
        if self.balance >= amount:
            self.balance -= amount
            print(f"{self.owner}: -{amount}. Баланс: {self.balance}")
        else:
            print(f"{self.owner}: Недостаточно средств!")
    
    def get_balance(self):
        """Узнать баланс"""
        return self.balance

# Создаем счета для разных людей
account_anna = BankAccount("Анна", 1000)
account_boris = BankAccount("Борис", 500)

# Каждый работает со своим счётом
account_anna.deposit(200)   # Анна: +200. Баланс: 1200
account_boris.withdraw(100) # Борис: -100. Баланс: 400

print(account_anna.get_balance())  # 1200
print(account_boris.get_balance()) # 400
```

### **Разница класс vs объект:**

```python
# Класс — это тип/шаблон
print(type(Dog))  # <class 'type'>

# Объект — это экземпляр класса
dog = Dog("Бобик", 3)
print(type(dog))  # <class '__main__.Dog'>

# Класс существует в единственном числе
# Объектов может быть сколько угодно
dog1 = Dog("Бобик", 3)
dog2 = Dog("Шарик", 5)
dog3 = Dog("Рекс", 2)
# ... можно создать тысячи собак по одному классу
```

**Запоминалка:**
- **Класс** = форма для печенья
- **Объект** = конкретное печенье, сделанное по этой форме


## `23.4` 4 принципа ООП
Существует **4 основных принципа ООП**, которые делают код лучше:

1. **Абстракция**
2. **Инкапсуляция**
3. **Наследование**
4. **Полиморфизм**

### **1. Абстракция**

**Абстракция** — это **выделение важного и скрытие несущественного**.

Мы показываем пользователю только то, что ему нужно, и скрываем сложные детали.

**Аналогия из жизни:**

Когда вы водите машину:
- Вы используете: руль, педали, коробку передач (простой интерфейс)
- Вы НЕ думаете о: работе двигателя, системе впрыска топлива, электронике (сложные детали)

**Суть абстракции:** Пользователь видит только **что** делает объект, но не **как** он это делает.

### **2. Инкапсуляция**

**Инкапсуляция** — это **объединение данных и методов в одном месте** + **защита данных от прямого доступа**.

Данные объекта должны изменяться только через методы этого объекта.

**Аналогия из жизни:**

Банковский счёт:
- ❌ НЕЛЬЗЯ: прийти в банк и самому дописать нули на счету
- ✅ МОЖНО: попросить банк пополнить счёт через официальную процедуру

**Суть инкапсуляции:** Данные защищены, изменить их можно только через методы, которые проверяют корректность.

### **3. Наследование**

**Наследование** — это создание нового класса на основе существующего.

Новый класс (потомок) получает все свойства и методы родительского класса, и может добавлять свои.

**Аналогия из жизни:**

Дети наследуют черты родителей:
- Ребёнок получает: цвет глаз, группу крови, форму носа от родителей
- Но также имеет свои уникальные черты

**Суть наследования:** Не нужно писать один и тот же код снова — берём готовый класс и расширяем его.

### **4. Полиморфизм**

**Полиморфизм** — это способность использовать объекты разных классов через **единый интерфейс**.

Слово "полиморфизм" означает "много форм". Один и тот же метод может работать по-разному в разных классах.

**Аналогия из жизни:**

Кнопка "Play":
- На магнитофоне — проигрывает кассету
- На DVD-плеере — проигрывает диск
- На телефоне — проигрывает музыку

Одна кнопка, но делает разные вещи в зависимости от устройства!

**Суть полиморфизма:** Пишем код один раз, а он работает с разными типами объектов. Не нужно знать точный тип объекта — главное, чтобы у него был нужный метод.

---

### **Итоги: Четыре принципа ООП**

#### **1. Абстракция** — "Скрыть сложность"
- Показываем простой интерфейс
- Скрываем сложную реализацию
- Пример: пульт от телевизора (нажимаем кнопку, не думаем о схемах)

#### **2. Инкапсуляция** — "Защитить данные"
- Данные и методы вместе
- Данные изменяются только через методы
- Пример: банковский счёт (нельзя просто дописать нули)

#### **3. Наследование** — "Переиспользовать код"
- Создаём новые классы на основе старых
- Потомок получает всё от родителя
- Пример: Dog и Cat наследуют от Animal

#### **4. Полиморфизм** — "Много форм одного действия"
- Один метод работает по-разному в разных классах
- Пишем код один раз для всех типов
- Пример: метод `speak()` у разных животных

---

**Как они работают вместе:**

```python
# Абстракция — простой интерфейс
class Animal:  
    def speak(self):
        pass

# Инкапсуляция — данные внутри класса
class Dog(Animal):  # Наследование
    def __init__(self, name):
        self._name = name  # Защищенные данные
    
    def speak(self):  # Полиморфизм
        return f"{self._name} говорит: Гав!"

class Cat(Animal):  # Наследование
    def __init__(self, name):
        self._name = name
    
    def speak(self):  # Полиморфизм
        return f"{self._name} говорит: Мяу!"

# Используем все принципы вместе
animals = [Dog("Бобик"), Cat("Мурка")]

for animal in animals:  # Полиморфизм
    print(animal.speak())  # Абстракция — не знаем детали реализации

# Бобик говорит: Гав!
# Мурка говорит: Мяу!
```

**Зачем нужны эти принципы?**

✅ Код легче читать  
✅ Код легче изменять  
✅ Меньше ошибок  
✅ Можно переиспользовать код  
✅ Легче работать в команде

----

# `24` Атрибуты и методы
## `24.1` Какие кейсы есть вообще, и какие соглашения на использовании в Python (camelCase, snake_case, etc)
**Кейс (case)** — это стиль написания имен переменных, функций, классов и других идентификаторов в коде.

**Основные стили написания:**

| Стиль | Описание | Пример | Использование в Python |
|-------|----------|--------|----------------------|
| **snake_case** | Слова через нижнее подчеркивание | `my_variable`, `calculate_sum` | ✅ Переменные, функции, методы |
| **UPPER_CASE** | Все буквы заглавные | `MAX_SIZE`, `API_KEY` | ✅ Константы |
| **camelCase** | Первое слово с маленькой буквы | `myVariable`, `calculateSum` | ❌ Не используется в Python |
| **PascalCase** | Каждое слово с заглавной буквы | `MyClass`, `UserProfile` | ✅ Классы |
| **_leading_underscore** | Начинается с подчеркивания | `_internal_var` | ✅ "Приватные" атрибуты (соглашение) |
| **__double_leading** | Два подчеркивания в начале | `__private_var` | ✅ Name mangling (избегание конфликтов) |
| **__dunder__** | Два подчеркивания с обеих сторон | `__init__`, `__str__` | ✅ Магические методы |

**Официальный стиль Python (PEP 8):**

```python
# ✅ ПРАВИЛЬНО (snake_case для переменных и функций)
user_name = "Иван"
total_price = 100
max_attempts = 5

def calculate_discount(price, percent):
    return price * (percent / 100)

def get_user_data():
    pass

# ✅ ПРАВИЛЬНО (UPPER_CASE для констант)
MAX_SIZE = 100
API_KEY = "secret_key"
DEFAULT_TIMEOUT = 30
PI = 3.14159

# ✅ ПРАВИЛЬНО (PascalCase для классов)
class UserProfile:
    pass

class ShoppingCart:
    pass

class DatabaseConnection:
    pass

# ❌ НЕПРАВИЛЬНО (camelCase не используется в Python)
userName = "Иван"  # плохо
totalPrice = 100   # плохо

def calculateDiscount(price, percent):  # плохо
    pass

# ❌ НЕПРАВИЛЬНО (смешивание стилей)
User_Name = "Иван"  # плохо
CALCULATE_discount = lambda x: x * 2  # плохо
```

**Специальные соглашения:**

```python
# Одно подчеркивание в начале — "внутреннее" использование
_internal_variable = 10
_helper_function = lambda x: x * 2

# Два подчеркивания в начале — name mangling (изменение имени)
__private_attribute = "секрет"

# Два подчеркивания с обеих сторон — магические методы
__init__, __str__, __repr__, __add__

# Одно подчеркивание — временная переменная (игнорируется)
for _ in range(5):
    print("Hello")

# Разделение тысяч (Python 3.6+)
million = 1_000_000
big_number = 123_456_789
```

**Примеры хорошего стиля:**

```python
# Модуль: lowercase с подчеркиваниями
# my_module.py, user_service.py

# Константы: UPPER_CASE
DATABASE_URL = "postgresql://localhost/mydb"
MAX_CONNECTIONS = 100
DEFAULT_PAGE_SIZE = 20

# Функции: snake_case
def calculate_total_price(items, tax_rate):
    subtotal = sum(item['price'] for item in items)
    tax = subtotal * tax_rate
    return subtotal + tax

def validate_email_address(email):
    return '@' in email and '.' in email

# Классы: PascalCase
class ShoppingCart:
    pass

class PaymentProcessor:
    pass

# Переменные: snake_case
user_age = 25
is_active = True
item_count = 0
shopping_cart_items = []

# "Приватные" переменные: _leading_underscore
_cache = {}
_internal_counter = 0

def _private_helper_function():
    pass
```

## `24.2` Функция `dir()` — для получения списка атрибутов и методов объекта
`dir()` — встроенная функция, которая возвращает список всех атрибутов и методов объекта (включая встроенные).

**Для чего нужна:**
- 🔍 **Исследование объекта** — узнать, что можно делать с объектом
- 📚 **Обучение** — посмотреть доступные методы
- 🐛 **Отладка** — проверить наличие атрибутов
- 📝 **Документация** — найти нужный метод

**Примеры:**

```python
# dir() для встроенных типов

# Строка
text = "hello"
print(dir(text))
# ['__add__', '__class__', ..., 'capitalize', 'upper', 'lower', 'split', ...]

# Можно увидеть все методы строк
print([method for method in dir(text) if not method.startswith('_')])
# ['capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', ...]

# Список
my_list = [1, 2, 3]
print([method for method in dir(my_list) if not method.startswith('_')])
# ['append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', ...]

# Словарь
my_dict = {'a': 1}
print([method for method in dir(my_dict) if not method.startswith('_')])
# ['clear', 'copy', 'fromkeys', 'get', 'items', 'keys', 'pop', ...]

# Число
number = 42
print([method for method in dir(number) if not method.startswith('_')])
# ['bit_count', 'bit_length', 'conjugate', 'denominator', 'from_bytes', ...]
```

```python
# dir() для пользовательских объектов

# Создадим простой "класс" через функцию (пока без настоящих классов)
def create_user(name, age):
    """Создает структуру данных пользователя"""
    user = type('User', (), {})()  # создаем пустой объект
    user.name = name
    user.age = age
    user.is_active = True
    return user

user = create_user("Иван", 30)

# Смотрим атрибуты
print(dir(user))
# [..., 'age', 'is_active', 'name', ...]

# Только пользовательские атрибуты (без встроенных)
user_attrs = [attr for attr in dir(user) if not attr.startswith('_')]
print(user_attrs)  # ['age', 'is_active', 'name']

# Практическое использование
print("Атрибуты пользователя:")
for attr in user_attrs:
    value = getattr(user, attr)
    print(f"  {attr}: {value}")
# Атрибуты пользователя:
#   age: 30
#   is_active: True
#   name: Иван
```

## `24.3` Создание классов и объектов в Python
**Класс** — это шаблон (чертеж) для создания объектов. Определяет, какие атрибуты и методы будут у объектов.

**Объект (экземпляр)** — конкретная реализация класса. Создается на основе класса.

**Синтаксис создания класса:**
```python
class ИмяКласса:
    # тело класса
    pass
```

**Создание объекта:**
```python
объект = ИмяКласса()
```

**Примеры:**

```python
# Простейший класс (пустой)
class Dog:
    pass

# Создание объектов (экземпляров класса)
dog1 = Dog()
dog2 = Dog()
dog3 = Dog()

print(dog1)  # <__main__.Dog object at 0x...>
print(dog2)  # <__main__.Dog object at 0x...>
print(dog3)  # <__main__.Dog object at 0x...>

# Это разные объекты
print(dog1 == dog2)  # False
print(type(dog1))    # <class '__main__.Dog'>

# Можно добавлять атрибуты после создания
dog1.name = "Шарик"
dog1.age = 3
dog1.breed = "Овчарка"

print(dog1.name)  # Шарик
print(dog1.age)   # 3

# У dog2 нет этих атрибутов
# print(dog2.name)  # AttributeError
```

```python
# Класс с начальными атрибутами (без __init__)
class Cat:
    # Атрибуты класса (общие для всех объектов)
    species = "Felis catus"
    legs = 4

# Создаем объекты
cat1 = Cat()
cat2 = Cat()

# Все коты имеют эти атрибуты
print(cat1.species)  # Felis catus
print(cat2.species)  # Felis catus
print(cat1.legs)     # 4

# Можно добавить индивидуальные атрибуты
cat1.name = "Мурзик"
cat1.color = "рыжий"

cat2.name = "Барсик"
cat2.color = "серый"

print(f"{cat1.name} ({cat1.color})")  # Мурзик (рыжий)
print(f"{cat2.name} ({cat2.color})")  # Барсик (серый)

# Множество объектов одного класса
cats = []
names = ["Мурзик", "Барсик", "Пушок", "Снежок"]

for name in names:
    cat = Cat()
    cat.name = name
    cats.append(cat)

print("Все коты:")
for cat in cats:
    print(f"  - {cat.name}")
```


## `24.4` Атрибуты класса и объекта
**Атрибут класса** — переменная, определенная внутри класса. Общая для всех объектов этого класса.

**Атрибут объекта** — переменная, привязанная к конкретному объекту. У каждого объекта свои значения.

**Отличия:**
- Атрибут класса: один на все объекты, изменяется через класс
- Атрибут объекта: уникален для каждого объекта

**Примеры:**

```python
# Атрибуты класса
class Car:
    # Атрибуты класса (общие для всех машин)
    wheels = 4
    vehicle_type = "car"
    total_cars = 0  # счетчик созданных машин

# Доступ к атрибутам класса через имя класса
print(Car.wheels)        # 4
print(Car.vehicle_type)  # car
print(Car.total_cars)    # 0

# Создаем объекты
car1 = Car()
car2 = Car()

# Доступ к атрибутам класса через объект
print(car1.wheels)  # 4
print(car2.wheels)  # 4

# Изменение атрибута класса влияет на все объекты
Car.wheels = 6
print(car1.wheels)  # 6
print(car2.wheels)  # 6

# Атрибуты объекта (индивидуальные)
car1.brand = "Toyota"
car1.model = "Camry"
car1.year = 2020

car2.brand = "BMW"
car2.model = "X5"
car2.year = 2021

print(f"{car1.brand} {car1.model} ({car1.year})")  # Toyota Camry (2020)
print(f"{car2.brand} {car2.model} ({car2.year})")  # BMW X5 (2021)

# У car2 нет атрибута color
# print(car2.color)  # AttributeError
```

```python
# Практический пример: библиотека книг
class Book:
    # Атрибуты класса
    total_books = 0
    library_name = "Городская библиотека"
    
    # Можно использовать атрибуты класса в вычислениях
    def register_book(book):
        Book.total_books += 1

# Создаем книги и регистрируем их
book1 = Book()
book1.title = "Война и мир"
book1.author = "Л.Н. Толстой"
book1.pages = 1225
Book.register_book(book1)

book2 = Book()
book2.title = "Преступление и наказание"
book2.author = "Ф.М. Достоевский"
book2.pages = 671
Book.register_book(book2)

book3 = Book()
book3.title = "Мастер и Маргарита"
book3.author = "М.А. Булгаков"
book3.pages = 480
Book.register_book(book3)

# Статистика
print(f"Библиотека: {Book.library_name}")
print(f"Всего книг: {Book.total_books}")
print("\nКниги в библиотеке:")
for book in [book1, book2, book3]:
    print(f"  • {book.title} - {book.author} ({book.pages} стр.)")

# Библиотека: Городская библиотека
# Всего книг: 3
# 
# Книги в библиотеке:
#   • Война и мир - Л.Н. Толстой (1225 стр.)
#   • Преступление и наказание - Ф.М. Достоевский (671 стр.)
#   • Мастер и Маргарита - М.А. Булгаков (480 стр.)
```

## `24.5` Атрибут `__dict__` — словарь атрибутов объекта
`__dict__` — специальный атрибут, который содержит словарь всех атрибутов объекта (или класса).

**Ключ** — имя атрибута (строка)
**Значение** — значение атрибута

**Для чего нужен:**
- 🔍 Просмотр всех атрибутов объекта
- 🗂️ Динамическая работа с атрибутами
- 📋 Сериализация объектов
- 🐛 Отладка

**Примеры:**

```python
class Person:
    species = "Homo sapiens"  # атрибут класса

# Создаем объект
person = Person()
person.name = "Иван"
person.age = 30
person.city = "Москва"

# __dict__ содержит только атрибуты объекта (не класса!)
print(person.__dict__)
# {'name': 'Иван', 'age': 30, 'city': 'Москва'}

# __dict__ класса содержит атрибуты класса
print(Person.__dict__)
# {..., 'species': 'Homo sapiens', ...}

# Можно работать с __dict__ как с обычным словарем
print(person.__dict__['name'])  # Иван
print(person.__dict__.keys())   # dict_keys(['name', 'age', 'city'])

# Добавление атрибута через __dict__
person.__dict__['job'] = 'Программист'
print(person.job)  # Программист

# Удаление атрибута через __dict__
del person.__dict__['city']
# print(person.city)  # AttributeError
```

```python
# Практическое использование __dict__

class Product:
    category = "товар"

# Создаем товары
product1 = Product()
product1.name = "Ноутбук"
product1.price = 50000
product1.stock = 5

product2 = Product()
product2.name = "Мышь"
product2.price = 500
product2.stock = 50

# Красивый вывод всех атрибутов
def print_object_info(obj):
    print(f"Атрибуты объекта {type(obj).__name__}:")
    for key, value in obj.__dict__.items():
        print(f"  {key}: {value}")

print_object_info(product1)
# Атрибуты объекта Product:
#   name: Ноутбук
#   price: 50000
#   stock: 5

print_object_info(product2)
# Атрибуты объекта Product:
#   name: Мышь
#   price: 500
#   stock: 50

# Копирование атрибутов одного объекта в другой
product3 = Product()
product3.__dict__ = product1.__dict__.copy()
print(product3.name)   # Ноутбук
print(product3.price)  # 50000

# Сохранение в JSON (сериализация)
import json

data = product1.__dict__
json_str = json.dumps(data, ensure_ascii=False)
print(json_str)
# {"name": "Ноутбук", "price": 50000, "stock": 5}

# Загрузка из JSON
loaded_data = json.loads(json_str)
product4 = Product()
product4.__dict__ = loaded_data
print(product4.name)  # Ноутбук
```

## `24.6` Встроенные функции для работы с атрибутами:
Python предоставляет четыре встроенные функции для динамической работы с атрибутами:

- `getattr(obj, name, default)` — получить атрибут
- `setattr(obj, name, value)` — установить атрибут
- `hasattr(obj, name)` — проверить наличие атрибута
- `delattr(obj, name)` — удалить атрибут

**Зачем нужны:**
- 🔄 Динамическая работа с атрибутами (имя атрибута в переменной)
- 🛡️ Безопасный доступ (с проверкой наличия)
- 🎯 Условная логика (разные атрибуты в зависимости от условий)

### `getattr()` — получить атрибут

```python
class User:
    role = "user"

user = User()
user.name = "Иван"
user.age = 30

# Обычный доступ
print(user.name)  # Иван

# Через getattr()
print(getattr(user, 'name'))  # Иван
print(getattr(user, 'age'))   # 30

# Значение по умолчанию, если атрибута нет
print(getattr(user, 'email', 'не указан'))  # не указан
# Без default было бы AttributeError

# Динамический доступ
attr_name = 'name'
print(getattr(user, attr_name))  # Иван

# Практический пример: получение настроек
settings = User()
settings.theme = 'dark'
settings.language = 'ru'

# Получаем настройку с дефолтом
theme = getattr(settings, 'theme', 'light')
font_size = getattr(settings, 'font_size', 12)  # нет такого атрибута
print(f"Тема: {theme}, Размер шрифта: {font_size}")
# Тема: dark, Размер шрифта: 12
```

### `setattr()` — установить атрибут

```python
class Car:
    pass

car = Car()

# Обычная установка
car.brand = "Toyota"

# Через setattr()
setattr(car, 'model', 'Camry')
setattr(car, 'year', 2020)

print(car.model)  # Camry
print(car.year)   # 2020

# Динамическая установка
attrs = {
    'color': 'белый',
    'price': 2000000,
    'mileage': 50000
}

for key, value in attrs.items():
    setattr(car, key, value)

print(f"{car.brand} {car.model}, {car.color}, {car.price} руб")
# Toyota Camry, белый, 2000000 руб

# Практический пример: массовая установка атрибутов
def set_attributes(obj, **kwargs):
    """Устанавливает множество атрибутов за раз"""
    for key, value in kwargs.items():
        setattr(obj, key, value)

product = Car()  # используем Car как универсальный класс
set_attributes(product,
               name='Ноутбук',
               price=50000,
               brand='Lenovo',
               stock=10)

print(product.name)   # Ноутбук
print(product.stock)  # 10
```

### `hasattr()` — проверить наличие атрибута

```python
class Student:
    university = "МГУ"

student = Student()
student.name = "Мария"
student.age = 20

# Проверка наличия атрибута
print(hasattr(student, 'name'))    # True
print(hasattr(student, 'age'))     # True
print(hasattr(student, 'email'))   # False

# Условная логика
if hasattr(student, 'email'):
    print(f"Email: {student.email}")
else:
    print("Email не указан")
# Email не указан

# Безопасное получение
if hasattr(student, 'name'):
    name = student.name
    print(f"Студент: {name}")

# Практический пример: валидация данных
def validate_user(user):
    """Проверяет наличие обязательных полей"""
    required_fields = ['name', 'age', 'email']
    missing = []
    
    for field in required_fields:
        if not hasattr(user, field):
            missing.append(field)
    
    if missing:
        return False, f"Отсутствуют поля: {', '.join(missing)}"
    return True, "OK"

user1 = Student()
user1.name = "Иван"
user1.age = 25

valid, message = validate_user(user1)
print(f"Валиден: {valid}, {message}")
# Валиден: False, Отсутствуют поля: email
```

### `delattr()` — удалить атрибут

```python
class Account:
    pass

account = Account()
account.username = "ivan123"
account.email = "ivan@example.com"
account.password = "secret"

print(hasattr(account, 'password'))  # True

# Обычное удаление
del account.password

# Через delattr()
account.temp_token = "abc123"
delattr(account, 'temp_token')

# print(account.temp_token)  # AttributeError

# Условное удаление
if hasattr(account, 'email'):
    delattr(account, 'email')
    print("Email удален")

# Практический пример: очистка временных данных
def cleanup_temp_attrs(obj):
    """Удаляет все временные атрибуты (начинаются с temp_)"""
    attrs_to_delete = []
    
    for attr in dir(obj):
        if attr.startswith('temp_'):
            attrs_to_delete.append(attr)
    
    for attr in attrs_to_delete:
        delattr(obj, attr)
    
    return len(attrs_to_delete)

data = Account()
data.name = "Данные"
data.temp_cache = [1, 2, 3]
data.temp_buffer = "buffer"
data.value = 100

deleted = cleanup_temp_attrs(data)
print(f"Удалено {deleted} временных атрибутов")
# Удалено 2 временных атрибутов

print(hasattr(data, 'temp_cache'))   # False
print(hasattr(data, 'value'))        # True
```

## `24.7` Что такое метод и как его создавать?
**Метод** — это функция, определенная внутри класса. Методы описывают действия, которые может выполнять объект.

**Отличие от обычной функции:**
- Функция — независима, вызывается сама по себе
- Метод — привязан к классу/объекту, вызывается через точку

**Синтаксис:**
```python
class ИмяКласса:
    def имя_метода(self):
        # тело метода
        pass
```

**Параметр `self`** — ссылка на объект, который вызывает метод (о нем подробнее позже).

**Примеры:**

```python
# Простой класс с методами
class Calculator:
    def add(self, a, b):
        return a + b
    
    def subtract(self, a, b):
        return a - b
    
    def multiply(self, a, b):
        return a * b
    
    def divide(self, a, b):
        if b == 0:
            return "Ошибка: деление на ноль"
        return a / b

# Создаем объект
calc = Calculator()

# Вызываем методы
print(calc.add(5, 3))       # 8
print(calc.subtract(10, 4)) # 6
print(calc.multiply(7, 6))  # 42
print(calc.divide(20, 4))   # 5.0
print(calc.divide(10, 0))   # Ошибка: деление на ноль
```

```python
# Методы, работающие с атрибутами объекта
class BankAccount:
    def create_account(self, owner, initial_balance=0):
        """Создает счет"""
        self.owner = owner
        self.balance = initial_balance
        self.transactions = []
    
    def deposit(self, amount):
        """Пополнение счета"""
        if amount > 0:
            self.balance += amount
            self.transactions.append(f"+{amount}")
            return f"Пополнено на {amount}. Баланс: {self.balance}"
        return "Сумма должна быть положительной"
    
    def withdraw(self, amount):
        """Снятие со счета"""
        if amount > self.balance:
            return "Недостаточно средств"
        if amount > 0:
            self.balance -= amount
            self.transactions.append(f"-{amount}")
            return f"Снято {amount}. Баланс: {self.balance}"
        return "Сумма должна быть положительной"
    
    def get_balance(self):
        """Получить баланс"""
        return self.balance
    
    def get_history(self):
        """Получить историю транзакций"""
        return self.transactions

# Используем
account = BankAccount()
account.create_account("Иван Иванов", 1000)

print(account.deposit(500))      # Пополнено на 500. Баланс: 1500
print(account.withdraw(300))     # Снято 300. Баланс: 1200
print(account.withdraw(2000))    # Недостаточно средств
print(f"Баланс: {account.get_balance()}")  # Баланс: 1200
print(f"История: {account.get_history()}")  # История: ['+500', '-300']
```

**Шпаргалка:**

**Стили написания:**
```python
my_variable = 1        # snake_case - переменные, функции
MAX_SIZE = 100         # UPPER_CASE - константы
MyClass                # PascalCase - классы
_internal = 10         # _leading - "приватные"
```

**Работа с атрибутами:**
```python
dir(obj)                          # список атрибутов
obj.__dict__                      # словарь атрибутов
getattr(obj, 'name', default)     # получить атрибут
setattr(obj, 'name', value)       # установить атрибут
hasattr(obj, 'name')              # проверить наличие
delattr(obj, 'name')              # удалить атрибут
```

**Класс и методы:**
```python
class MyClass:
    class_attr = "общий"          # атрибут класса
    
    def my_method(self):          # метод
        self.obj_attr = "личный"  # атрибут объекта
        return "результат"

obj = MyClass()                   # создание объекта
obj.my_method()                   # вызов метода
```

----

# `25` Методы экземпляра класса
## `25.1` Метод `__init__` — конструктор класса
**Теория:**
`__init__` — это специальный метод (конструктор), который автоматически вызывается при создании нового объекта класса. Он нужен для инициализации — задания начальных значений атрибутам объекта. Без `__init__` каждый объект создавался бы "пустым", и пришлось бы вручную добавлять атрибуты после создания.

**Примеры:**

```python
# Пример 1: Простой класс с __init__
class Dog:
    def __init__(self, name, age):
        self.name = name  # Сохраняем имя собаки
        self.age = age    # Сохраняем возраст

# Создаём объекты
dog1 = Dog("Бобик", 3)  # __init__ вызывается автоматически
dog2 = Dog("Рекс", 5)

print(dog1.name)  # Бобик
print(dog2.age)   # 5
```

```python
# Пример 2: __init__ с параметрами по умолчанию
class Book:
    def __init__(self, title, pages=100):
        self.title = title
        self.pages = pages
        self.is_read = False  # Можно задавать значения без параметров

book1 = Book("Война и мир", 1300)
book2 = Book("Рассказ")  # pages будет 100 по умолчанию

print(book2.pages)    # 100
print(book1.is_read)  # False
```

## `25.2` Параметр `self` — что это и зачем нужен
**Теория:**
`self` — это ссылка на конкретный экземпляр класса (объект). Когда вы вызываете метод на объекте, Python автоматически передаёт этот объект первым параметром. `self` позволяет методам обращаться к атрибутам и другим методам именно этого объекта.

**Важно:** имя `self` — это соглашение, технически можно использовать любое имя, но все программисты используют именно `self`.

**Примеры:**

```python
# Пример 1: self даёт доступ к атрибутам объекта
class Counter:
    def __init__(self, start):
        self.value = start  # self.value — атрибут конкретного объекта
    
    def increment(self):
        self.value += 1  # Обращаемся к атрибуту через self

counter1 = Counter(0)
counter2 = Counter(100)

counter1.increment()  # Python автоматически передаёт counter1 как self
counter2.increment()

print(counter1.value)  # 1
print(counter2.value)  # 101 — каждый объект независим!
```

```python
# Пример 2: self для вызова других методов
class Calculator:
    def __init__(self, value):
        self.value = value
    
    def add(self, number):
        self.value += number
    
    def double(self):
        self.add(self.value)  # Вызываем другой метод через self
    
calc = Calculator(5)
calc.double()  # Внутри вызовется self.add(5)
print(calc.value)  # 10
```

**Почему self обязателен:**
Без `self` Python не поймёт, к какому конкретно объекту относятся атрибуты — к `dog1` или `dog2`, к `counter1` или `counter2`. `self` — это способ сказать: "работай с ЭТИМ конкретным объектом".

----

# `26` (`*`) Доступ к атрибутам
## `26.1` Сокрытие данных (инкапсуляция) в Python
**Теория:**
`Инкапсуляция` — это один из принципов ООП, который означает "упаковку" данных и методов внутри класса, а также ограничение прямого доступа к внутренним данным объекта. Идея в том, что внутреннее устройство объекта должно быть скрыто, а взаимодействие с ним происходит через публичные методы.

**Зачем это нужно:**
- **Защита данных** — предотвращение случайного изменения важных атрибутов
- **Контроль** — возможность проверять значения перед записью
- **Гибкость** — можно менять внутреннюю реализацию без изменения внешнего интерфейса
- **Логика** — можно добавить вычисления при получении/установке значений

**Важно:** В Python нет настоящего сокрытия данных, как в Java или C++. Все атрибуты технически доступны. Python следует философии "мы все взрослые люди" — доверие программисту вместо жёстких ограничений.

**Примеры:**

```python
# Пример 1: Проблема без инкапсуляции
class BankAccount:
    def __init__(self, balance):
        self.balance = balance

account = BankAccount(1000)
account.balance = -5000  # Можем установить отрицательный баланс — это плохо!
print(account.balance)  # -5000
```

```python
# Пример 2: Решение с методами (базовая инкапсуляция)
class BankAccount:
    def __init__(self, balance):
        self._balance = balance  # _ указывает: "это внутренний атрибут"
    
    def get_balance(self):
        return self._balance
    
    def deposit(self, amount):
        if amount > 0:
            self._balance += amount
        else:
            print("Сумма должна быть положительной")
    
    def withdraw(self, amount):
        if 0 < amount <= self._balance:
            self._balance -= amount
        else:
            print("Недостаточно средств или неверная сумма")

account = BankAccount(1000)
account.deposit(500)
print(account.get_balance())  # 1500
account.withdraw(2000)  # Недостаточно средств или неверная сумма
# Технически всё ещё можно: account._balance = -5000, но это нарушает соглашение
```


## `26.2` Соглашения между разработчиками по именованию и доступу
**Теория:**
В Python используются соглашения об именовании для обозначения уровня доступа к атрибутам и методам. Это не строгие правила, а договорённость между программистами.

**Три уровня доступа:**

1. **Публичные атрибуты** (`name`) — обычные атрибуты, доступны везде
2. **Защищённые атрибуты** (`_name`) — один символ подчёркивания в начале
3. **Приватные атрибуты** (`__name`) — два символа подчёркивания в начале

**Примеры:**

```python
# Пример 1: Разные уровни доступа
class Person:
    def __init__(self, name, age, passport):
        self.name = name           # Публичный — можно свободно использовать
        self._age = age            # Защищённый — используй осторожно
        self.__passport = passport # Приватный — не трогай снаружи!
    
    def get_info(self):
        return f"{self.name}, {self._age} лет"
    
    def _internal_check(self):
        # Защищённый метод для внутреннего использования
        return self.__passport is not None

person = Person("Иван", 30, "1234567890")

# Публичный доступ — нормально
print(person.name)  # Иван

# Защищённый — работает, но намекает "будь осторожен"
print(person._age)  # 30

# Приватный — вызовет ошибку
print(person.__passport)  # AttributeError!
```

```python
# Пример 2: Name mangling — механизм приватности
class Secret:
    def __init__(self):
        self.__hidden = "секрет"
    
    def reveal(self):
        return self.__hidden

obj = Secret()
# print(obj.__hidden)  # AttributeError

# Но на самом деле атрибут доступен через name mangling:
print(obj._Secret__hidden)  # секрет
# Python переименовал __hidden в _Secret__hidden
```

**Соглашения:**
- `_name` — "Это внутренний атрибут, используй, только если знаешь что делаешь"
- `__name` — "Это точно не для внешнего использования" (name mangling для избежания конфликтов в наследовании)
- `name_` — для избежания конфликтов с ключевыми словами (например, `class_`)
- `__name__` — специальные методы Python (dunder methods)


## `26.3` Геттеры, сеттеры, делитеры — что это и зачем нужны
**Теория:**
Геттеры, сеттеры и делитеры — это специальные методы для управления доступом к атрибутам объекта:

- **Геттер (getter)** — метод для **получения** значения атрибута
- **Сеттер (setter)** — метод для **установки** значения атрибута с валидацией
- **Делитер (deleter)** — метод для **удаления** атрибута

Этот паттерн пришёл из языков вроде Java и C++, где прямой доступ к полям класса считается плохой практикой

**Зачем нужны:**
- Валидация данных при установке
- Вычисления при получении (динамические атрибуты)
- Преобразование и нормализация данных
- Логирование обращений к атрибутам
- Защита от некорректных значений
- Побочные эффекты (например, обновление связанных данных)

**Примеры:**

```python
# Пример 1: Классические геттеры и сеттеры (старый стиль)
class Temperature:
    def __init__(self, celsius):
        self._celsius = celsius
    
    def get_celsius(self):  # Геттер
        return self._celsius
    
    def set_celsius(self, value):  # Сеттер
        if value < -273.15:
            raise ValueError("Температура не может быть ниже абсолютного нуля")
        self._celsius = value
    
    def del_celsius(self):  # Делитер
        print("Удаление температуры")
        del self._celsius

temp = Temperature(25)
print(temp.get_celsius())  # 25
temp.set_celsius(30)
print(temp.get_celsius())  # 30
# temp.set_celsius(-300)  # ValueError!
```

```python
# Пример 2: Геттер с вычислениями
class Rectangle:
    def __init__(self, width, height):
        self._width = width
        self._height = height
    
    def get_area(self):  # Геттер для вычисляемого свойства
        return self._width * self._height
    
    def set_width(self, value):
        if value <= 0:
            raise ValueError("Ширина должна быть положительной")
        self._width = value

rect = Rectangle(5, 10)
print(rect.get_area())  # 50
rect.set_width(8)
print(rect.get_area())  # 80 (автоматически пересчиталось)
```

```python
# Пример 3: Преобразование данных
class Person:
    def __init__(self, name, email):
        self._name = name
        self._email = email
    
    def get_name(self):
        """Возвращаем имя с заглавной буквы"""
        return self._name.title()
    
    def set_name(self, value):
        """Сохраняем имя, убрав лишние пробелы"""
        if not value.strip():
            raise ValueError("Имя не может быть пустым")
        self._name = value.strip()
    
    def get_email(self):
        """Возвращаем email в нижнем регистре"""
        return self._email.lower()

person = Person("  иВаН  ", "Ivan@EXAMPLE.COM")
print(person.get_name())   # Иван
print(person.get_email())  # ivan@example.com
```

```python
# Пример 4: Побочные эффекты — логирование изменений
class BankAccount:
    def __init__(self, balance):
        self._balance = balance
        self._transaction_count = 0
    
    def get_balance(self):
        return self._balance
    
    def set_balance(self, amount):
        if amount < 0:
            raise ValueError("Баланс не может быть отрицательным")
        
        old_balance = self._balance
        self._balance = amount
        self._transaction_count += 1
        print(f"Транзакция #{self._transaction_count}: {old_balance} → {amount}")

account = BankAccount(1000)
account.set_balance(1500)  # Транзакция #1: 1000 → 1500
account.set_balance(1200)  # Транзакция #2: 1500 → 1200
```

**Проблема старого стиля:**
Код выглядит громоздко: `temp.get_celsius()` и `temp.set_celsius(30)` вместо простого `temp.celsius` и `temp.celsius = 30`. Приходится писать много дополнительного кода, и синтаксис становится менее естественным для Python

**Решение — `property`:**
Python предлагает более элегантное решение через `property`, который позволяет использовать синтаксис обычных атрибутов с контролем доступа под капотом. Современный Python почти не использует явные `get_`/`set_` методы — вместо этого применяется декоратор `@property`


## `26.4` Свойство (`property`) — атрибут с управляемым доступом
**Теория:**
`property` — это встроенный класс Python, который превращает методы в атрибуты. Снаружи это выглядит как обычный атрибут (`obj.name`), но при обращении к нему вызываются специальные методы (геттер, сеттер, делитер). Это делает код чище и естественнее — вместо `obj.get_celsius()` пишем просто `obj.celsius`.

**Как это работает:**
Когда вы создаёте `property`, вы связываете имя атрибута с методами:
- При **чтении** атрибута (`print(obj.celsius)`) вызывается геттер
- При **записи** атрибута (`obj.celsius = 30`) вызывается сеттер
- При **удалении** атрибута (`del obj.celsius`) вызывается делитер

**Синтаксис:**
```python
attribute = property(fget=getter, fset=setter, fdel=deleter, doc=docstring)
```
- `fget` — функция-геттер (для чтения)
- `fset` — функция-сеттер (для записи)
- `fdel` — функция-делитер (для удаления)
- `doc` — строка документации (опционально)

Все параметры опциональны — можно создать property только с геттером (read-only).

**Примеры:**

```python
# Пример 1: property с геттером и сеттером
class Temperature:
    def __init__(self, celsius):
        self._celsius = celsius
    
    def get_celsius(self):
        print("Получение температуры")
        return self._celsius
    
    def set_celsius(self, value):
        print("Установка температуры")
        if value < -273.15:
            raise ValueError("Температура не может быть ниже абсолютного нуля")
        self._celsius = value
    
    def del_celsius(self):
        print("Удаление температуры")
        del self._celsius
    
    # Создаём property, связывая его с методами
    celsius = property(get_celsius, set_celsius, del_celsius, "Температура в градусах Цельсия")

temp = Temperature(25)

# Работаем как с обычным атрибутом, но вызываются методы
print(temp.celsius)  # Получение температуры → 25
temp.celsius = 30    # Установка температуры
print(temp.celsius)  # Получение температуры → 30
del temp.celsius     # Удаление температуры

# Можем прочитать документацию
print(Temperature.celsius.__doc__)  # Температура в градусах Цельсия
```

```python
# Пример 2: property только с геттером (read-only атрибут)
class Circle:
    def __init__(self, radius):
        self._radius = radius
    
    def get_area(self):
        return 3.14159 * self._radius ** 2
    
    def get_circumference(self):
        return 2 * 3.14159 * self._radius
    
    # Read-only свойства — только геттер
    area = property(get_area)
    circumference = property(get_circumference)

circle = Circle(5)
print(circle.area)          # 78.53975
print(circle.circumference) # 31.4159

# Нельзя изменить — нет сеттера
try:
    circle.area = 100
except AttributeError as e:
    print(f"Ошибка: {e}")  # can't set attribute
```

```python
# Пример 3: Вычисляемые свойства с преобразованием единиц
class Distance:
    def __init__(self, meters):
        self._meters = meters
    
    def get_meters(self):
        return self._meters
    
    def set_meters(self, value):
        if value < 0:
            raise ValueError("Расстояние не может быть отрицательным")
        self._meters = value
    
    def get_kilometers(self):
        """Автоматическое преобразование в километры"""
        return self._meters / 1000
    
    def set_kilometers(self, value):
        """Устанавливаем через километры, сохраняем в метрах"""
        if value < 0:
            raise ValueError("Расстояние не может быть отрицательным")
        self._meters = value * 1000
    
    def get_miles(self):
        """Автоматическое преобразование в мили"""
        return self._meters / 1609.34
    
    def set_miles(self, value):
        """Устанавливаем через мили, сохраняем в метрах"""
        if value < 0:
            raise ValueError("Расстояние не может быть отрицательным")
        self._meters = value * 1609.34
    
    # Создаём свойства для разных единиц измерения
    meters = property(get_meters, set_meters)
    kilometers = property(get_kilometers, set_kilometers)
    miles = property(get_miles, set_miles)

distance = Distance(5000)  # 5000 метров

print(distance.meters)      # 5000
print(distance.kilometers)  # 5.0
print(distance.miles)       # 3.106855

# Устанавливаем в километрах
distance.kilometers = 10
print(distance.meters)      # 10000.0

# Устанавливаем в милях
distance.miles = 1
print(distance.meters)      # 1609.34
print(distance.kilometers)  # 1.60934
```

```python
# Пример 4: Свойство с делитером и сложной логикой
class User:
    def __init__(self, username, password):
        self._username = username
        self._password = password
        self._is_active = True
    
    def get_password(self):
        """Возвращаем замаскированный пароль"""
        return "*" * len(self._password)
    
    def set_password(self, value):
        """Проверяем сложность пароля"""
        if len(value) < 8:
            raise ValueError("Пароль должен быть минимум 8 символов")
        if not any(c.isdigit() for c in value):
            raise ValueError("Пароль должен содержать цифры")
        if not any(c.isupper() for c in value):
            raise ValueError("Пароль должен содержать заглавные буквы")
        self._password = value
        print("Пароль успешно изменён")
    
    def del_password(self):
        """При удалении пароля деактивируем пользователя"""
        print("Пароль удалён, пользователь деактивирован")
        self._password = None
        self._is_active = False
    
    password = property(get_password, set_password, del_password, "Пароль пользователя")

user = User("ivan", "Secret123")

print(user.password)  # ********* (замаскирован)

user.password = "NewPass456"  # Пароль успешно изменён
print(user.password)          # **********

try:
    user.password = "weak"  # ValueError: Пароль должен быть минимум 8 символов
except ValueError as e:
    print(f"Ошибка: {e}")

del user.password  # Пароль удалён, пользователь деактивирован
print(user._is_active)  # False
```

```python
# Пример 5: Сравнение старого и нового стиля
class Rectangle:
    def __init__(self, width, height):
        self._width = width
        self._height = height
    
    # Геттеры
    def get_width(self):
        return self._width
    
    def get_height(self):
        return self._height
    
    def get_area(self):
        return self._width * self._height
    
    # Сеттеры
    def set_width(self, value):
        if value <= 0:
            raise ValueError("Ширина должна быть положительной")
        self._width = value
    
    def set_height(self, value):
        if value <= 0:
            raise ValueError("Высота должна быть положительной")
        self._height = value
    
    # Превращаем в свойства
    width = property(get_width, set_width)
    height = property(get_height, set_height)
    area = property(get_area)  # read-only

rect = Rectangle(5, 10)

# Старый стиль (если бы не было property):
# rect.set_width(8)
# print(rect.get_area())

# Новый стиль с property:
rect.width = 8       # Естественный синтаксис!
print(rect.area)     # 80
print(rect.height)   # 10

# Валидация работает
try:
    rect.width = -5
except ValueError as e:
    print(f"Ошибка: {e}")  # Ширина должна быть положительной
```

**Преимущества property:**
1. **Естественный синтаксис** — `obj.celsius = 30` вместо `obj.set_celsius(30)`
2. **Обратная совместимость** — можно добавить валидацию к существующему атрибуту без изменения кода, который его использует
3. **Вычисляемые атрибуты** — значение рассчитывается динамически, но выглядит как обычный атрибут
4. **Read-only атрибуты** — легко создать атрибут, который можно только читать
5. **Единообразие** — все атрибуты используют одинаковый синтаксис

**Недостатки старого синтаксиса property:**
Хотя `property()` лучше явных геттеров/сеттеров, код всё ещё выглядит громоздко — приходится писать отдельные функции и связывать их. Есть более элегантное решение — декоратор `@property`, о котором в следующем разделе!


## `26.5` Декоратор `@property` — как работает и зачем
[Видео про @property](https://youtu.be/HkbQ_NaH0Lc?si=ufzyV1HdKl6a48Ov)

**Теория:**
`@property` — это декоратор, который делает то же самое, что и `property()`, но синтаксис гораздо красивее и понятнее. Это современный и рекомендуемый способ создания свойств в Python.

**Как работает:**
1. `@property` над методом делает его геттером
2. `@имя_свойства.setter` создаёт сеттер для этого свойства
3. `@имя_свойства.deleter` создаёт делитер для этого свойства

Все три декоратора работают с одним и тем же именем свойства, связывая соответствующие методы.

**Важно:** Имя метода под декоратором должно совпадать с именем свойства. Сначала определяется геттер с `@property`, затем можно добавить сеттер и делитер.

**Примеры:**

```python
# Пример 1: Базовое использование @property
class Person:
    def __init__(self, name, age):
        self._name = name
        self._age = age
    
    @property
    def name(self):
        """Геттер для имени"""
        return self._name.title()  # Возвращаем с большой буквы
    
    @property
    def age(self):
        """Геттер для возраста"""
        return self._age
    
    @age.setter
    def age(self, value):
        """Сеттер для возраста с валидацией"""
        if not isinstance(value, int):
            raise TypeError("Возраст должен быть целым числом")
        if value < 0 or value > 150:
            raise ValueError("Некорректный возраст")
        self._age = value
    
    @age.deleter
    def age(self):
        """Делитер для возраста"""
        print("Удаление возраста")
        del self._age

person = Person("иван", 30)
print(person.name)  # Иван (автоматически с большой буквы)
print(person.age)   # 30

person.age = 35     # Сработает валидация
print(person.age)   # 35

# person.age = -5   # ValueError: Некорректный возраст
# person.age = "30" # TypeError: Возраст должен быть целым числом

del person.age      # Удаление возраста
```

```python
# Пример 2: Вычисляемые свойства
class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    @property
    def area(self):
        """Площадь вычисляется динамически"""
        return self.width * self.height
    
    @property
    def perimeter(self):
        """Периметр вычисляется динамически"""
        return 2 * (self.width + self.height)

rect = Rectangle(5, 10)
print(rect.area)      # 50
print(rect.perimeter) # 30

rect.width = 8
print(rect.area)      # 80 (автоматически пересчиталось!)
# rect.area = 100     # AttributeError: can't set attribute
```

```python
# Пример 3: Преобразование единиц измерения
class Temperature:
    def __init__(self, celsius):
        self._celsius = celsius
    
    @property
    def celsius(self):
        return self._celsius
    
    @celsius.setter
    def celsius(self, value):
        if value < -273.15:
            raise ValueError("Температура не может быть ниже абсолютного нуля")
        self._celsius = value
    
    @property
    def fahrenheit(self):
        """Автоматическое преобразование в Фаренгейты"""
        return self._celsius * 9/5 + 32
    
    @fahrenheit.setter
    def fahrenheit(self, value):
        """Устанавливаем через Фаренгейты, сохраняем в Цельсиях"""
        self._celsius = (value - 32) * 5/9

temp = Temperature(0)
print(temp.celsius)     # 0
print(temp.fahrenheit)  # 32.0

temp.fahrenheit = 212   # Устанавливаем 212°F
print(temp.celsius)     # 100.0 (автоматически конвертировалось!)
```

```python
# Пример 4: Ленивая инициализация с кэшированием
class DataLoader:
    def __init__(self, filename):
        self.filename = filename
        self._data = None  # Данные ещё не загружены
    
    @property
    def data(self):
        """Загружаем данные только при первом обращении"""
        if self._data is None:
            print(f"Загрузка данных из {self.filename}...")
            # Симуляция загрузки данных
            self._data = f"Содержимое файла {self.filename}"
        return self._data
    
    @data.setter
    def data(self, value):
        """Обновляем кэш"""
        print("Обновление кэшированных данных")
        self._data = value
    
    @data.deleter
    def data(self):
        """Очищаем кэш"""
        print("Очистка кэша")
        self._data = None

loader = DataLoader("data.txt")
print("Объект создан, но данные не загружены")

# Первое обращение — данные загружаются
print(loader.data)  # Загрузка данных из data.txt... → Содержимое файла data.txt

# Второе обращение — используется кэш
print(loader.data)  # Содержимое файла data.txt (без загрузки)

# Очищаем кэш
del loader.data  # Очистка кэша

# Снова загружается при обращении
print(loader.data)  # Загрузка данных из data.txt... → Содержимое файла data.txt
```

```python
# Пример 5: Сложная валидация и связанные свойства
class BankAccount:
    def __init__(self, owner, balance):
        self._owner = owner
        self._balance = balance
        self._transaction_history = []
    
    @property
    def owner(self):
        return self._owner
    
    @owner.setter
    def owner(self, value):
        if not value or not value.strip():
            raise ValueError("Владелец не может быть пустым")
        old_owner = self._owner
        self._owner = value.strip()
        print(f"Владелец счёта изменён: {old_owner} → {self._owner}")
    
    @property
    def balance(self):
        return self._balance
    
    @balance.setter
    def balance(self, value):
        if value < 0:
            raise ValueError("Баланс не может быть отрицательным")
        
        change = value - self._balance
        self._balance = value
        
        # Записываем в историю транзакций
        self._transaction_history.append({
            'new_balance': value,
            'change': change
        })
        print(f"Баланс изменён: {change:+.2f} (новый баланс: {value:.2f})")
    
    @property
    def transaction_history(self):
        """Read-only свойство — нельзя изменить историю напрямую"""
        return self._transaction_history.copy()

account = BankAccount("Иван Иванов", 1000)

print(account.balance)  # 1000

account.balance = 1500  # Баланс изменён: +500.00 (новый баланс: 1500.00)
account.balance = 1200  # Баланс изменён: -300.00 (новый баланс: 1200.00)

print(account.transaction_history)
# [{'new_balance': 1500, 'change': 500}, {'new_balance': 1200, 'change': -300}]

account.owner = "Пётр Петров"  # Владелец счёта изменён: Иван Иванов → Пётр Петров
```

```python
# Пример 6: Сравнение старого синтаксиса property() с @property
class Circle:
    def __init__(self, radius):
        self._radius = radius
    
    # Старый способ с property()
    def get_radius(self):
        return self._radius
    
    def set_radius(self, value):
        if value <= 0:
            raise ValueError("Радиус должен быть положительным")
        self._radius = value
    
    radius_old = property(get_radius, set_radius)
    
    # Новый способ с @property (гораздо чище!)
    @property
    def diameter(self):
        return self._radius * 2
    
    @diameter.setter
    def diameter(self, value):
        if value <= 0:
            raise ValueError("Диаметр должен быть положительным")
        self._radius = value / 2
    
    @property
    def area(self):
        return 3.14159 * self._radius ** 2

circle = Circle(5)

# Оба способа работают одинаково
print(circle.radius_old)  # 5
print(circle.diameter)    # 10
print(circle.area)        # 78.53975

circle.diameter = 20
print(circle.radius_old)  # 10.0
print(circle.area)        # 314.159
```

**Преимущества @property:**
- **Чистый синтаксис** — код выглядит как обычные атрибуты: `obj.value` вместо `obj.get_value()`
- **Читабельность** — все методы для одного свойства находятся рядом
- **Обратная совместимость** — можно добавить валидацию к существующим атрибутам без изменения внешнего API
- **Ленивые вычисления** — значение вычисляется только при обращении
- **Pythonic** — это стандартный и рекомендуемый способ создания свойств в Python

**Когда использовать @property:**
- Нужна валидация при установке значения
- Атрибут должен быть вычисляемым (например, площадь из ширины и высоты)
- Нужно преобразование данных при чтении/записи
- Требуется ленивая инициализация
- Хотите сделать атрибут read-only (только геттер без сеттера)
- Нужно логирование обращений к атрибуту


## `26.6` Декораторы `@classmethod` и `@staticmethod` — что такое `cls` и различия
**Теория:**
Обычные методы работают с экземплярами класса через `self`. Но иногда нужны методы, которые:
- Работают с самим классом, а не с конкретным объектом — `@classmethod`
- Вообще не зависят от класса или объекта — `@staticmethod`

### `@classmethod`
- Первый параметр — `cls` (сам класс, а не объект)
- Может обращаться к атрибутам класса и создавать экземпляры
- Используется для фабричных методов (альтернативных конструкторов)

### `@staticmethod`
- Не получает ни `self`, ни `cls`
- Просто функция внутри класса для логической группировки
- Не может менять состояние класса или объекта

**Примеры:**

```python
# Пример 1: Различия между методами
class MyClass:
    class_variable = "Я переменная класса"
    
    def instance_method(self):
        """Обычный метод — работает с объектом"""
        return f"Вызван из объекта: {self}"
    
    @classmethod
    def class_method(cls):
        """Метод класса — работает с классом"""
        return f"Вызван из класса: {cls.__name__}, переменная: {cls.class_variable}"
    
    @staticmethod
    def static_method():
        """Статический метод — не работает ни с чем"""
        return "Просто функция в классе"

obj = MyClass()

print(obj.instance_method())      # Вызван из объекта: <__main__.MyClass object at ...>
print(obj.class_method())         # Вызван из класса: MyClass, переменная: Я переменная класса
print(MyClass.class_method())     # То же самое — можно вызывать через класс
print(MyClass.static_method())    # Просто функция в классе
```

```python
# Пример 2: @classmethod для альтернативных конструкторов
class Date:
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day
    
    @classmethod
    def from_string(cls, date_string):
        """Создание объекта из строки"""
        year, month, day = map(int, date_string.split('-'))
        return cls(year, month, day)  # cls — это Date (или подкласс)
    
    @classmethod
    def today(cls):
        """Создание объекта с сегодняшней датой"""
        import datetime
        today = datetime.date.today()
        return cls(today.year, today.month, today.day)
    
    def __str__(self):
        return f"{self.year}-{self.month:02d}-{self.day:02d}"

# Разные способы создания объекта
date1 = Date(2025, 10, 9)              # Обычный конструктор
date2 = Date.from_string("2025-10-09") # Через classmethod
date3 = Date.today()                   # Через classmethod

print(date1)  # 2025-10-09
print(date2)  # 2025-10-09
print(date3)  # 2025-10-09
```

```python
# Пример 3: @staticmethod для вспомогательных функций
class StringUtils:
    @staticmethod
    def is_palindrome(text):
        """Проверка, является ли строка палиндромом"""
        cleaned = text.replace(" ", "").lower()
        return cleaned == cleaned[::-1]
    
    @staticmethod
    def count_words(text):
        """Подсчёт слов в строке"""
        return len(text.split())
    
    @staticmethod
    def reverse_words(text):
        """Переворот слов в строке"""
        return ' '.join(text.split()[::-1])

# Можно вызывать без создания объекта
print(StringUtils.is_palindrome("А роза упала на лапу Азора"))  # True
print(StringUtils.count_words("Привет мир"))                    # 2
print(StringUtils.reverse_words("Привет мир"))                  # мир Привет

# Или через объект (но смысла нет)
utils = StringUtils()
print(utils.is_palindrome("level"))  # True
```

```python
# Пример 4: Наследование и @classmethod
class Animal:
    species_count = 0
    
    def __init__(self, name):
        self.name = name
        Animal.species_count += 1
    
    @classmethod
    def get_count(cls):
        return f"Всего {cls.__name__}: {cls.species_count}"
    
    @classmethod
    def create_many(cls, names):
        """Создаёт несколько экземпляров"""
        return [cls(name) for name in names]

class Dog(Animal):
    pass

class Cat(Animal):
    pass

# classmethod работает с правильным классом
dogs = Dog.create_many(["Бобик", "Рекс"])
cats = Cat.create_many(["Мурка"])

print(Dog.get_count())  # Всего Dog: 3
print(Cat.get_count())  # Всего Cat: 3
# species_count общий для всех, но cls.__name__ разный
```

**Когда что использовать:**
- **Обычный метод** — когда нужен доступ к атрибутам объекта
- **@classmethod** — для альтернативных конструкторов, работы с атрибутами класса
- **@staticmethod** — для утилитарных функций, логически связанных с классом


## `26.7` (`**`) Продвинутое: `@singledispatchmethod` — перегрузка методов по типу аргумента
[Видео про @singledispatchmethod](https://www.youtube.com/watch?v=iXORLumN1Lo)

**Теория:**
`@singledispatchmethod` — это декоратор из модуля `functools`, который позволяет создавать методы с разным поведением в зависимости от типа первого аргумента (после `self`). Это называется **перегрузка методов** или **single dispatch**.

**Зачем нужно:**
В Python нет встроенной перегрузки методов, как в Java или C++. Обычно приходится писать множество `if isinstance(...)` проверок. `@singledispatchmethod` делает код чище и понятнее.

**Как работает:**
1. Базовый метод с `@singledispatchmethod` определяет общее поведение
2. Специализированные версии регистрируются через `@метод.register`
3. Python автоматически выбирает нужную версию по типу аргумента

**Примеры:**

```python
# Пример 1: Базовое использование
from functools import singledispatchmethod

class DataProcessor:
    @singledispatchmethod
    def process(self, data):
        """Базовая версия — для неизвестных типов"""
        raise NotImplementedError(f"Не знаю как обработать {type(data)}")
    
    @process.register
    def _(self, data: str):
        """Специальная версия для строк"""
        return f"Обработка строки: {data.upper()}"
    
    @process.register
    def _(self, data: int):
        """Специальная версия для чисел"""
        return f"Обработка числа: {data * 2}"
    
    @process.register
    def _(self, data: list):
        """Специальная версия для списков"""
        return f"Обработка списка из {len(data)} элементов: {sum(data)}"

processor = DataProcessor()

print(processor.process("hello"))      # Обработка строки: HELLO
print(processor.process(42))           # Обработка числа: 84
print(processor.process([1, 2, 3]))    # Обработка списка из 3 элементов: 6
# processor.process(3.14)              # NotImplementedError
```

```python
# Пример 2: Форматирование разных типов данных
from functools import singledispatchmethod
from datetime import datetime

class Formatter:
    @singledispatchmethod
    def format(self, value):
        """По умолчанию — просто str()"""
        return str(value)
    
    @format.register
    def _(self, value: int):
        """Форматирование целых чисел"""
        return f"{value:,}".replace(",", " ")  # 1000000 → 1 000 000
    
    @format.register
    def _(self, value: float):
        """Форматирование дробных чисел"""
        return f"{value:.2f}"  # 3.14159 → 3.14
    
    @format.register
    def _(self, value: bool):
        """Форматирование булевых значений"""
        return "✓" if value else "✗"
    
    @format.register
    def _(self, value: datetime):
        """Форматирование дат"""
        return value.strftime("%d.%m.%Y %H:%M")
    
    @format.register(list)
    @format.register(tuple)
    def _(self, value):
        """Форматирование последовательностей (можно регистрировать несколько типов)"""
        formatted = [self.format(item) for item in value]
        return f"[{', '.join(formatted)}]"

formatter = Formatter()

print(formatter.format(1000000))                    # 1 000 000
print(formatter.format(3.14159))                    # 3.14
print(formatter.format(True))                       # ✓
print(formatter.format(datetime(2025, 10, 9, 14, 30)))  # 09.10.2025 14:30
print(formatter.format([1, 2.5, True]))             # [1, 2.50, ✓]
print(formatter.format((100, 200)))                 # [100, 200]
```

```python
# Пример 3: Сохранение в разные форматы
from functools import singledispatchmethod
import json

class DataSaver:
    def __init__(self, filename):
        self.filename = filename
    
    @singledispatchmethod
    def save(self, data):
        """Базовый метод — ошибка"""
        raise TypeError(f"Не могу сохранить тип {type(data)}")
    
    @save.register
    def _(self, data: dict):
        """Сохранение словаря в JSON"""
        with open(self.filename, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        print(f"Словарь сохранён в JSON: {self.filename}")
    
    @save.register
    def _(self, data: str):
        """Сохранение строки в текстовый файл"""
        with open(self.filename, 'w', encoding='utf-8') as f:
            f.write(data)
        print(f"Строка сохранена в TXT: {self.filename}")
    
    @save.register
    def _(self, data: list):
        """Сохранение списка построчно"""
        with open(self.filename, 'w', encoding='utf-8') as f:
            for item in data:
                f.write(f"{item}\n")
        print(f"Список сохранён построчно: {self.filename}")

# Использование
saver = DataSaver("output.txt")
saver.save({"name": "Иван", "age": 30})  # Словарь сохранён в JSON: output.txt
saver.save("Привет, мир!")               # Строка сохранена в TXT: output.txt
saver.save([1, 2, 3, 4, 5])              # Список сохранён построчно: output.txt
```

**Важные моменты:**
- Dispatch происходит только по **первому** аргументу после `self`
- Типы проверяются через `isinstance()`, работает наследование
- Можно регистрировать один метод для нескольких типов
- Имя метода в `@метод.register` можно опустить (использовать `_`)

**Альтернатива без singledispatchmethod:**
```python
# Без singledispatchmethod пришлось бы писать так:
def process(self, data):
    if isinstance(data, str):
        return f"Обработка строки: {data.upper()}"
    elif isinstance(data, int):
        return f"Обработка числа: {data * 2}"
    elif isinstance(data, list):
        return f"Обработка списка: {sum(data)}"
    else:
        raise NotImplementedError(f"Не знаю как обработать {type(data)}")
# Менее читабельно и сложнее поддерживать
```

----

# `27` (`*`) Магические методы
[Магические методы в ООП, можно смотреть другие методы на этом канале](https://youtu.be/Aabdr3yxEhQ?si=rTjDFcfXIEmy5zPS)

Что такое магические методы и зачем нужны?

**Магические методы (magic methods)** или **дандер-методы (dunder methods, от "double underscore")** — это специальные методы в Python, имена которых начинаются и заканчиваются двумя подчеркиваниями: `__method__`.

**Особенности:**
- 🎩 Вызываются автоматически при определенных операциях
- 🔧 Позволяют настроить поведение объектов
- 🐍 Делают объекты "питоничными" — работают как встроенные типы
- ⚙️ Перегружают операторы и встроенные функции

**Зачем нужны:**
- Определяют, как создаются и удаляются объекты
- Настраивают строковое представление объектов
- Позволяют использовать операторы (`+`, `-`, `==`, `<` и т.д.)
- Делают объекты итерируемыми, вызываемыми, контекстными менеджерами
- Позволяют обращаться к объектам как к контейнерам (`obj[key]`)

**Категории магических методов:**
1. **Инициализация и удаление**: `__init__`, `__new__`, `__del__`
2. **Представление**: `__str__`, `__repr__`
3. **Сравнение**: `__eq__`, `__lt__`, `__gt__` и др.
4. **Арифметика**: `__add__`, `__sub__`, `__mul__` и др.
5. **Контейнеры**: `__len__`, `__getitem__`, `__setitem__`
6. **Вызов**: `__call__`
7. **Контекстные менеджеры**: `__enter__`, `__exit__`

## `27.1` `__init__`, `__new__`, `super()`, `__del__`
### `__init__` — инициализация объекта

**Теория:**

`__init__` (инициализатор) — автоматически вызывается после создания объекта. Используется для установки начальных значений атрибутов.

**Важно:**
- `__init__` НЕ создает объект (это делает `__new__`)
- `__init__` инициализирует уже созданный объект
- Первый параметр всегда `self` — ссылка на сам объект
- Не должен ничего возвращать (или `return None`)

**Синтаксис:**
```python
class MyClass:
    def __init__(self, параметры):
        self.атрибут = значение
```

**Примеры:**

```python
# Пример 1: Базовое использование __init__
class Person:
    def __init__(self, name, age):
        # Устанавливаем атрибуты объекта
        self.name = name
        self.age = age
        print(f"Создан человек: {name}")

# При создании объекта автоматически вызывается __init__
person1 = Person("Иван", 30)  # Создан человек: Иван
person2 = Person("Мария", 25)  # Создан человек: Мария

print(person1.name)  # Иван
print(person1.age)   # 30
print(person2.name)  # Мария

# Каждый объект имеет свои атрибуты
person1.age = 31
print(person1.age)  # 31
print(person2.age)  # 25 (не изменился)
```

```python
# Пример 2: __init__ с параметрами по умолчанию
class BankAccount:
    def __init__(self, owner, balance=0, currency="RUB"):
        self.owner = owner
        self.balance = balance
        self.currency = currency
        self.transactions = []  # пустой список транзакций
        print(f"Открыт счёт для {owner}")
    
    def deposit(self, amount):
        self.balance += amount
        self.transactions.append(f"+{amount}")
    
    def get_info(self):
        return f"{self.owner}: {self.balance} {self.currency}"

# Создание с разными параметрами
account1 = BankAccount("Иван")  # balance=0, currency="RUB"
account2 = BankAccount("Мария", 5000)  # currency="RUB"
account3 = BankAccount("John", 1000, "USD")

print(account1.get_info())  # Иван: 0 RUB
print(account2.get_info())  # Мария: 5000 RUB
print(account3.get_info())  # John: 1000 USD

account1.deposit(3000)
print(account1.get_info())  # Иван: 3000 RUB
print(account1.transactions)  # ['+3000']
```

```python
# Пример 3: __init__ с валидацией данных
class Product:
    def __init__(self, name, price, quantity=1):
        # Валидация данных при создании
        if not isinstance(name, str) or not name.strip():
            raise ValueError("Название должно быть непустой строкой")
        
        if not isinstance(price, (int, float)) or price < 0:
            raise ValueError("Цена должна быть неотрицательным числом")
        
        if not isinstance(quantity, int) or quantity < 0:
            raise ValueError("Количество должно быть неотрицательным целым числом")
        
        self.name = name.strip()
        self.price = price
        self.quantity = quantity
        self.total = price * quantity
    
    def __str__(self):
        return f"{self.name}: {self.price} руб x {self.quantity} = {self.total} руб"

# Правильное создание
product1 = Product("Ноутбук", 50000, 2)
print(product1)  # Ноутбук: 50000 руб x 2 = 100000 руб

product2 = Product("Мышь", 500)  # quantity=1 по умолчанию
print(product2)  # Мышь: 500 руб x 1 = 500 руб

# Неправильное создание вызовет ошибку
try:
    product3 = Product("", 100)  # пустое название
except ValueError as e:
    print(f"Ошибка: {e}")  # Ошибка: Название должно быть непустой строкой

try:
    product4 = Product("Товар", -100)  # отрицательная цена
except ValueError as e:
    print(f"Ошибка: {e}")  # Ошибка: Цена должна быть неотрицательным числом
```


### `__new__` — создание объекта

**Теория:**

`__new__` — статический метод, который создает и возвращает новый объект. Вызывается ДО `__init__`.

**Отличие от `__init__`:**
- `__new__` создает объект и возвращает его
- `__init__` инициализирует уже созданный объект

**Порядок вызова:**
1. `__new__` создает объект
2. Если `__new__` вернул объект нашего класса, вызывается `__init__`

**Когда использовать `__new__`:**
- Создание неизменяемых объектов (наследники `int`, `str`, `tuple`)
- Паттерн Singleton (один экземпляр класса)
- Управление процессом создания объекта

**Примеры:**

```python
# Пример 1: Базовое использование __new__
class MyClass:
    def __new__(cls, *args, **kwargs):
        print(f"1. __new__ вызван для {cls}")
        # Создаем экземпляр через object.__new__
        instance = super().__new__(cls)
        print(f"2. __new__ создал объект: {instance}")
        return instance
    
    def __init__(self, value):
        print(f"3. __init__ вызван для {self}")
        self.value = value
        print(f"4. __init__ установил value={value}")

# При создании объекта
obj = MyClass(42)
# Вывод:
# 1. __new__ вызван для <class '__main__.MyClass'>
# 2. __new__ создал объект: <__main__.MyClass object at 0x...>
# 3. __init__ вызван для <__main__.MyClass object at 0x...>
# 4. __init__ установил value=42

print(obj.value)  # 42
```

```python
# Пример 2: Singleton (только один экземпляр класса)
class Database:
    _instance = None  # Хранит единственный экземпляр
    
    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            print("Создается новый экземпляр Database")
            cls._instance = super().__new__(cls)
        else:
            print("Возвращается существующий экземпляр")
        return cls._instance
    
    def __init__(self, host, port):
        # __init__ вызывается каждый раз!
        # Нужна проверка, чтобы не перезаписать данные
        if not hasattr(self, 'initialized'):
            self.host = host
            self.port = port
            self.initialized = True
            print(f"Инициализация: {host}:{port}")

# Создаем "разные" объекты
db1 = Database("localhost", 5432)
# Создается новый экземпляр Database
# Инициализация: localhost:5432

db2 = Database("example.com", 3306)
# Возвращается существующий экземпляр

# Это один и тот же объект!
print(db1 is db2)  # True
print(db1.host)    # localhost (не изменился!)
print(db2.host)    # localhost
print(id(db1) == id(db2))  # True (одинаковый адрес в памяти)
```

```python
# Пример 3: Кастомизация создания неизменяемых объектов
class PositiveInt(int):
    """Целое число, которое всегда положительное"""
    
    def __new__(cls, value):
        # Для неизменяемых типов модификация происходит в __new__
        if value < 0:
            value = -value  # делаем положительным
        # Создаем объект int с нужным значением
        return super().__new__(cls, value)
    
    def __init__(self, value):
        # __init__ для int ничего не делает, но можно добавить логику
        print(f"Создано PositiveInt: {self}")

# Используем
num1 = PositiveInt(10)   # Создано PositiveInt: 10
print(num1)  # 10

num2 = PositiveInt(-5)   # Создано PositiveInt: 5
print(num2)  # 5 (стало положительным!)

# Это настоящие int, работают все операции
print(num1 + num2)  # 15
print(num2 * 3)     # 15
print(type(num2))   # <class '__main__.PositiveInt'>
```


### `super()` — доступ к родительскому классу

**Теория:**

`super()` — встроенная функция для обращения к методам родительского (базового) класса.

**Зачем нужен:**
- Вызвать `__init__` родительского класса
- Получить доступ к методам родителя
- Работает с множественным наследованием (MRO)

**Синтаксис:**
```python
super().__init__(параметры)  # вызов __init__ родителя
super().метод(параметры)      # вызов метода родителя
```

**Примеры:**

```python
# Пример 1: Базовое использование super()
class Animal:
    def __init__(self, name, age):
        self.name = name
        self.age = age
        print(f"Создано животное: {name}")
    
    def make_sound(self):
        return "Какой-то звук"
    
    def info(self):
        return f"{self.name}, {self.age} лет"

class Dog(Animal):
    def __init__(self, name, age, breed):
        # Вызываем __init__ родителя
        super().__init__(name, age)
        self.breed = breed
        print(f"Создана собака породы: {breed}")
    
    def make_sound(self):
        # Переопределяем метод родителя
        return "Гав-гав!"
    
    def info(self):
        # Используем метод родителя и дополняем
        base_info = super().info()
        return f"{base_info}, порода: {self.breed}"

# Создание объекта
dog = Dog("Шарик", 3, "Овчарка")
# Создано животное: Шарик
# Создана собака породы: Овчарка

print(dog.info())        # Шарик, 3 лет, порода: Овчарка
print(dog.make_sound())  # Гав-гав!
print(dog.name)          # Шарик (из родительского класса)
```

```python
# Пример 2: Цепочка наследования
class Vehicle:
    def __init__(self, brand, model):
        self.brand = brand
        self.model = model
        print(f"Vehicle: {brand} {model}")
    
    def start(self):
        return "Транспорт запущен"

class Car(Vehicle):
    def __init__(self, brand, model, doors):
        super().__init__(brand, model)
        self.doors = doors
        print(f"Car: {doors} дверей")
    
    def start(self):
        base_start = super().start()
        return f"{base_start} - Автомобиль готов"

class ElectricCar(Car):
    def __init__(self, brand, model, doors, battery_capacity):
        super().__init__(brand, model, doors)
        self.battery_capacity = battery_capacity
        print(f"ElectricCar: батарея {battery_capacity} кВт⋅ч")
    
    def start(self):
        base_start = super().start()
        return f"{base_start} - Заряд батареи: {self.battery_capacity} кВт⋅ч"

# Создание объекта (вызываются __init__ всех родителей)
tesla = ElectricCar("Tesla", "Model 3", 4, 75)
# Vehicle: Tesla Model 3
# Car: 4 дверей
# ElectricCar: батарея 75 кВт⋅ч

print(tesla.start())
# Транспорт запущен - Автомобиль готов - Заряд батареи: 75 кВт⋅ч

print(f"{tesla.brand} {tesla.model}, {tesla.doors} дверей")
# Tesla Model 3, 4 дверей
```

```python
# Пример 3: Расширение функционала родительского класса
class Employee:
    company = "TechCorp"
    
    def __init__(self, name, position, salary):
        self.name = name
        self.position = position
        self.salary = salary
    
    def get_info(self):
        return f"{self.name} - {self.position}"
    
    def annual_salary(self):
        return self.salary * 12

class Manager(Employee):
    def __init__(self, name, position, salary, team_size):
        # Используем родительский __init__
        super().__init__(name, position, salary)
        self.team_size = team_size
        self.bonus_percent = 20
    
    def get_info(self):
        # Расширяем родительский метод
        base_info = super().get_info()
        return f"{base_info} (команда: {self.team_size} чел.)"
    
    def annual_salary(self):
        # Используем родительский метод и добавляем бонус
        base_salary = super().annual_salary()
        bonus = base_salary * (self.bonus_percent / 100)
        return base_salary + bonus

# Обычный сотрудник
employee = Employee("Иван", "Разработчик", 100000)
print(employee.get_info())      # Иван - Разработчик
print(employee.annual_salary())  # 1200000

# Менеджер
manager = Manager("Мария", "Менеджер", 150000, 5)
print(manager.get_info())       # Мария - Менеджер (команда: 5 чел.)
print(manager.annual_salary())  # 2160000 (1800000 + 20% бонус)

# Оба имеют доступ к атрибуту класса
print(employee.company)  # TechCorp
print(manager.company)   # TechCorp
```


### `__del__` — деструктор объекта

**Теория:**

`__del__` (деструктор) — вызывается автоматически при удалении объекта сборщиком мусора.

**Важно:**
- Не гарантируется момент вызова (работает сборщик мусора)
- Редко используется в Python (в отличие от C++)
- Нельзя полагаться на `__del__` для критических операций
- Лучше использовать контекстные менеджеры (`with`)

**Когда может быть полезен:**
- Закрытие файлов, соединений
- Освобождение ресурсов
- Логирование удаления объектов

**Примеры:**

```python
# Пример 1: Базовое использование __del__
class TempFile:
    def __init__(self, filename):
        self.filename = filename
        print(f"Создан временный файл: {filename}")
    
    def __del__(self):
        print(f"Удаляется временный файл: {self.filename}")

# Создание и удаление объекта
temp = TempFile("temp.txt")
# Создан временный файл: temp.txt

print("Работа с файлом...")

del temp  # Явное удаление
# Удаляется временный файл: temp.txt

# Автоматическое удаление при выходе из области видимости
def create_temp():
    temp = TempFile("another_temp.txt")
    print("Функция завершена")
    # temp удалится автоматически

create_temp()
# Создан временный файл: another_temp.txt
# Функция завершена
# Удаляется временный файл: another_temp.txt
```

```python
# Пример 2: Управление ресурсами (НЕ рекомендуемый способ!)
class Connection:
    active_connections = 0
    
    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.connected = True
        Connection.active_connections += 1
        print(f"Подключение к {host}:{port} открыто")
        print(f"Активных подключений: {Connection.active_connections}")
    
    def close(self):
        if self.connected:
            self.connected = False
            Connection.active_connections -= 1
            print(f"Подключение к {self.host}:{self.port} закрыто")
    
    def __del__(self):
        # Страховка на случай, если забыли вызвать close()
        if self.connected:
            print(f"⚠️ Внимание: подключение не было закрыто явно!")
            self.close()

# Правильное использование
conn1 = Connection("localhost", 8080)
# Подключение к localhost:8080 открыто
# Активных подключений: 1

conn1.close()  # Явно закрываем
# Подключение к localhost:8080 закрыто

del conn1  # __del__ ничего не делает (уже закрыто)

# Неправильное использование (забыли close)
conn2 = Connection("example.com", 3306)
# Подключение к example.com:3306 открыто
# Активных подключений: 1

del conn2  # __del__ срабатывает как страховка
# ⚠️ Внимание: подключение не было закрыто явно!
# Подключение к example.com:3306 закрыто
```

```python
# Пример 3: Отладка и логирование
class User:
    total_users = 0
    deleted_users = 0
    
    def __init__(self, username, email):
        self.username = username
        self.email = email
        self.created_at = __import__('datetime').datetime.now()
        User.total_users += 1
        print(f"✅ Создан пользователь: {username}")
    
    def __del__(self):
        User.deleted_users += 1
        lifetime = __import__('datetime').datetime.now() - self.created_at
        print(f"🗑️ Удален пользователь: {self.username}")
        print(f"   Время жизни объекта: {lifetime.total_seconds():.2f} сек")
        print(f"   Всего создано: {User.total_users}, удалено: {User.deleted_users}")

# Создание пользователей
user1 = User("ivan", "ivan@example.com")
user2 = User("maria", "maria@example.com")
user3 = User("petr", "petr@example.com")

# ✅ Создан пользователь: ivan
# ✅ Создан пользователь: maria
# ✅ Создан пользователь: petr

import time
time.sleep(0.5)  # небольшая задержка

# Удаление пользователей
del user1
# 🗑️ Удален пользователь: ivan
#    Время жизни объекта: 0.50 сек
#    Всего создано: 3, удалено: 1

del user2, user3
# 🗑️ Удален пользователь: maria
#    Время жизни объекта: 0.50 сек
#    Всего создано: 3, удалено: 2
# 🗑️ Удален пользователь: petr
#    Время жизни объекта: 0.50 сек
#    Всего создано: 3, удалено: 3

print(f"\nСтатистика: создано {User.total_users}, удалено {User.deleted_users}")
```

## `27.2` `__str__`, `__repr__`
`__str__` и `__repr__` — методы для строкового представления объектов.

**`__str__`** — "читаемое" представление для пользователей
- Вызывается функцией `str()` и `print()`
- Должен быть понятным человеку
- Может быть неполным

**`__repr__`** — "официальное" представление для разработчиков
- Вызывается функцией `repr()` и в интерактивной консоли
- Должен быть однозначным
- Идеально: можно воссоздать объект через `eval(repr(obj))`
- Если `__str__` не определен, используется `__repr__`

**Правило:**
- `__repr__` для разработчиков (отладка)
- `__str__` для пользователей (вывод)

**Примеры:**

```python
# Пример 1: Базовое использование __str__ и __repr__
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __str__(self):
        # Красивое представление для пользователя
        return f"Точка ({self.x}, {self.y})"
    
    def __repr__(self):
        # Техническое представление для разработчика
        return f"Point(x={self.x}, y={self.y})"

point = Point(10, 20)

# print() использует __str__
print(point)  # Точка (10, 20)

# str() тоже использует __str__
s = str(point)
print(s)  # Точка (10, 20)

# repr() использует __repr__
r = repr(point)
print(r)  # Point(x=10, y=20)

# В интерактивной консоли используется __repr__
point  # Point(x=10, 20)

# Разница в списке
points = [Point(1, 2), Point(3, 4)]
print(points)  # [Point(x=1, y=2), Point(x=3, y=4)] - используется __repr__!
```

```python
# Пример 2: Подробное представление объекта
class Book:
    def __init__(self, title, author, year, pages):
        self.title = title
        self.author = author
        self.year = year
        self.pages = pages
    
    def __str__(self):
        # Краткое представление для обычного пользователя
        return f'"{self.title}" - {self.author}'
    
    def __repr__(self):
        # Полное представление с всеми параметрами
        return (f"Book(title={self.title!r}, author={self.author!r}, "
                f"year={self.year}, pages={self.pages})")

book1 = Book("Война и мир", "Л.Н. Толстой", 1869, 1225)
book2 = Book("1984", "Джордж Оруэлл", 1949, 328)

# Для пользователя (краткая информация)
print(book1)  # "Война и мир" - Л.Н. Толстой
print(book2)  # "1984" - Джордж Оруэлл

# Для разработчика (полная информация)
print(repr(book1))
# Book(title='Война и мир', author='Л.Н. Толстой', year=1869, pages=1225)

# В списке
library = [book1, book2]
print(library)
# [Book(title='Война и мир', author='Л.Н. Толстой', year=1869, pages=1225),
#  Book(title='1984', author='Джордж Оруэлл', year=1949, pages=328)]

# Форматирование
print(f"Книга: {book1}")  # использует __str__
print(f"Отладка: {book1!r}")  # использует __repr__
# Книга: "Война и мир" - Л.Н. Толстой
# Отладка: Book(title='Война и мир', author='Л.Н. Толстой', year=1869, pages=1225)
```

```python
# Пример 3: Воссоздание объекта из repr
class Money:
    def __init__(self, amount, currency="RUB"):
        self.amount = amount
        self.currency = currency
    
    def __str__(self):
        # Красивое представление с символом валюты
        symbols = {"RUB": "₽", "USD": "$", "EUR": "€"}
        symbol = symbols.get(self.currency, self.currency)
        return f"{self.amount} {symbol}"
    
    def __repr__(self):
        # Можно воссоздать объект через eval()
        return f"Money({self.amount}, {self.currency!r})"
    
    def __add__(self, other):
        if self.currency != other.currency:
            raise ValueError("Нельзя складывать разные валюты")
        return Money(self.amount + other.amount, self.currency)

money1 = Money(1000, "RUB")
money2 = Money(500, "RUB")
money3 = Money(100, "USD")

# Пользовательское представление
print(money1)  # 1000 ₽
print(money2)  # 500 ₽
print(money3)  # 100 $

# Техническое представление
print(repr(money1))  # Money(1000, 'RUB')
print(repr(money3))  # Money(100, 'USD')

# Воссоздание объекта из repr
money_str = repr(money1)
recreated = eval(money_str)  # Money(1000, 'RUB')
print(recreated)  # 1000 ₽
print(type(recreated))  # <class '__main__.Money'>

# Операции
total = money1 + money2
print(f"Итого: {total}")  # Итого: 1500 ₽
print(f"Отладка: {total!r}")  # Отладка: Money(1500, 'RUB')

# Только __str__ без __repr__
class SimpleProduct:
    def __init__(self, name, price):
        self.name = name
        self.price = price
    
    def __str__(self):
        return f"{self.name}: {self.price} руб"
    # __repr__ не определен - будет использован стандартный

product = SimpleProduct("Ноутбук", 50000)
print(product)  # Ноутбук: 50000 руб (использует __str__)
print(repr(product))  # <__main__.SimpleProduct object at 0x...> (стандартный)
```

## `27.3` Сравнение объектов
Магические методы сравнения позволяют использовать операторы сравнения (`==`, `!=`, `<`, `>`, `<=`, `>=`) с пользовательскими объектами.

**Список методов:**
- `**Список методов:**
- `__eq__(self, other)` — равно (`==`)
- `__ne__(self, other)` — не равно (`!=`)
- `__lt__(self, other)` — меньше (`<`)
- `__gt__(self, other)` — больше (`>`)
- `__le__(self, other)` — меньше или равно (`<=`)
- `__ge__(self, other)` — больше или равно (`>=`)

**Важно:**
- Если определен только `__eq__`, остальные операторы не будут работать
- `__ne__` по умолчанию возвращает `not __eq__`
- Для полной поддержки сортировки нужны `__lt__`, `__le__`, `__gt__`, `__ge__`
- Можно использовать декоратор `@functools.total_ordering` (определить `__eq__` и один из операторов порядка)


### `__eq__` — равенство

**Теория:**

`__eq__` определяет, когда два объекта считаются равными. Используется оператором `==`.

**По умолчанию:**
- Без `__eq__`: сравниваются адреса в памяти (`id`)
- С `__eq__`: сравниваются по вашей логике

**Примеры:**

```python
# Пример 1: Сравнение по значениям атрибутов
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def __eq__(self, other):
        # Проверяем, что other тоже Person
        if not isinstance(other, Person):
            return False
        # Сравниваем по имени и возрасту
        return self.name == other.name and self.age == other.age
    
    def __str__(self):
        return f"{self.name} ({self.age})"

# Без __eq__: разные объекты всегда не равны
person1 = Person("Иван", 30)
person2 = Person("Иван", 30)
person3 = Person("Мария", 25)

print(person1 == person2)  # True (одинаковые данные)
print(person1 == person3)  # False (разные данные)
print(person1 is person2)  # False (разные объекты в памяти)

# Сравнение с другим типом
print(person1 == "Иван")  # False
print(person1 == 30)      # False

# Использование в списках и множествах
people = [person1, person2, person3]
print(person1 in people)  # True
print(Person("Мария", 25) in people)  # True (благодаря __eq__)
```

```python
# Пример 2: Сравнение по одному ключевому атрибуту
class Product:
    def __init__(self, id, name, price):
        self.id = id
        self.name = name
        self.price = price
    
    def __eq__(self, other):
        # Товары равны, если у них одинаковый ID
        if not isinstance(other, Product):
            return NotImplemented  # позволяет other попробовать свой __eq__
        return self.id == other.id
    
    def __str__(self):
        return f"Product({self.id}: {self.name}, {self.price}₽)"

product1 = Product(1, "Ноутбук", 50000)
product2 = Product(1, "Ноутбук обновленный", 45000)  # тот же ID!
product3 = Product(2, "Мышь", 500)

print(product1 == product2)  # True (одинаковый ID)
print(product1 == product3)  # False (разные ID)

# Цена и название могут отличаться
print(f"{product1.price} == {product2.price}?")  # 50000 == 45000?
print(f"Но товары равны: {product1 == product2}")  # Но товары равны: True
```

```python
# Пример 3: Сравнение сложных объектов
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __eq__(self, other):
        if not isinstance(other, Vector):
            return NotImplemented
        # Векторы равны, если координаты совпадают
        return self.x == other.x and self.y == other.y
    
    def __str__(self):
        return f"Vector({self.x}, {self.y})"
    
    def __repr__(self):
        return f"Vector({self.x}, {self.y})"

v1 = Vector(3, 4)
v2 = Vector(3, 4)
v3 = Vector(4, 3)

print(v1 == v2)  # True
print(v1 == v3)  # False

# Работа с коллекциями
vectors = [Vector(1, 2), Vector(3, 4), Vector(5, 6)]
print(Vector(3, 4) in vectors)  # True

# Удаление дубликатов (работает благодаря __eq__)
all_vectors = [Vector(1, 1), Vector(2, 2), Vector(1, 1), Vector(3, 3)]
unique_vectors = []
for v in all_vectors:
    if v not in unique_vectors:
        unique_vectors.append(v)
print(unique_vectors)  # [Vector(1, 1), Vector(2, 2), Vector(3, 3)]
```


### `__ne__` — неравенство

**Теория:**

`__ne__` определяет оператор `!=` (не равно).

**По умолчанию:**
- Если определен `__eq__`, то `__ne__` автоматически работает как `not __eq__`
- Можно переопределить для специфической логики

**Обычно НЕ нужно определять** `__ne__`, если есть `__eq__`.

**Примеры:**

```python
# Пример 1: Автоматический __ne__ (обычный случай)
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __eq__(self, other):
        if not isinstance(other, Point):
            return False
        return self.x == other.x and self.y == other.y
    
    # __ne__ не определяем - работает автоматически!
    
    def __str__(self):
        return f"({self.x}, {self.y})"

p1 = Point(1, 2)
p2 = Point(1, 2)
p3 = Point(3, 4)

print(p1 == p2)  # True
print(p1 != p2)  # False (автоматически: not (p1 == p2))
print(p1 != p3)  # True
```

```python
# Пример 2: Явное определение __ne__ (редкий случай)
class CaseInsensitiveString:
    def __init__(self, text):
        self.text = text
    
    def __eq__(self, other):
        if isinstance(other, str):
            return self.text.lower() == other.lower()
        if isinstance(other, CaseInsensitiveString):
            return self.text.lower() == other.text.lower()
        return False
    
    def __ne__(self, other):
        # Явно определяем для ясности
        return not self.__eq__(other)
    
    def __str__(self):
        return self.text

s1 = CaseInsensitiveString("Hello")
s2 = CaseInsensitiveString("HELLO")
s3 = CaseInsensitiveString("World")

print(s1 == s2)  # True (регистр не важен)
print(s1 != s2)  # False
print(s1 == "hello")  # True
print(s1 != "world")  # True
```

```python
# Пример 3: Специальная логика __ne__
class Range:
    def __init__(self, start, end):
        self.start = start
        self.end = end
    
    def __eq__(self, other):
        # Диапазоны равны, если границы совпадают
        if not isinstance(other, Range):
            return False
        return self.start == other.start and self.end == other.end
    
    def __ne__(self, other):
        # Можно добавить дополнительную логику
        result = not self.__eq__(other)
        print(f"Сравнение {self} != {other}: {result}")
        return result
    
    def __str__(self):
        return f"[{self.start}, {self.end}]"

r1 = Range(1, 10)
r2 = Range(1, 10)
r3 = Range(5, 15)

print(r1 != r2)  # Сравнение [1, 10] != [1, 10]: False
print(r1 != r3)  # Сравнение [1, 10] != [5, 15]: True
```


### `__lt__` — меньше

**Теория:**

`__lt__` (less than) определяет оператор `<` (меньше).

**Используется для:**
- Сравнения объектов
- Сортировки (`sorted()`, `.sort()`)
- Работы с приоритетными очередями

**Примеры:**

```python
# Пример 1: Сравнение по числовому атрибуту
class Student:
    def __init__(self, name, grade):
        self.name = name
        self.grade = grade  # оценка
    
    def __lt__(self, other):
        # Студент "меньше", если оценка ниже
        if not isinstance(other, Student):
            return NotImplemented
        return self.grade < other.grade
    
    def __eq__(self, other):
        if not isinstance(other, Student):
            return False
        return self.grade == other.grade
    
    def __str__(self):
        return f"{self.name}: {self.grade}"

s1 = Student("Иван", 4)
s2 = Student("Мария", 5)
s3 = Student("Петр", 3)

print(s1 < s2)  # True (4 < 5)
print(s2 < s3)  # False (5 < 3)
print(s3 < s1)  # True (3 < 4)

# Сортировка работает!
students = [s1, s2, s3]
sorted_students = sorted(students)
print("Отсортированные студенты:")
for student in sorted_students:
    print(f"  {student}")
# Отсортированные студенты:
#   Петр: 3
#   Иван: 4
#   Мария: 5
```

```python
# Пример 2: Сложное сравнение (по нескольким критериям)
class Task:
    def __init__(self, title, priority, deadline):
        self.title = title
        self.priority = priority  # 1 - высокий, 5 - низкий
        self.deadline = deadline  # дата
    
    def __lt__(self, other):
        if not isinstance(other, Task):
            return NotImplemented
        # Сначала сравниваем по приоритету
        if self.priority != other.priority:
            return self.priority < other.priority
        # Если приоритеты равны, сравниваем по дедлайну
        return self.deadline < other.deadline
    
    def __str__(self):
        return f"{self.title} (приоритет {self.priority}, до {self.deadline})"

from datetime import date

task1 = Task("Отчет", 2, date(2025, 10, 15))
task2 = Task("Презентация", 1, date(2025, 10, 20))
task3 = Task("Email", 2, date(2025, 10, 10))

print(task2 < task1)  # True (приоритет 1 < 2)
print(task3 < task1)  # True (приоритет равен, но дедлайн раньше)

# Сортировка по приоритету и дедлайну
tasks = [task1, task2, task3]
sorted_tasks = sorted(tasks)
print("\nЗадачи по приоритету:")
for task in sorted_tasks:
    print(f"  {task}")
# Задачи по приоритету:
#   Презентация (приоритет 1, до 2025-10-20)
#   Email (приоритет 2, до 2025-10-10)
#   Отчет (приоритет 2, до 2025-10-15)
```

```python
# Пример 3: Сравнение версий
class Version:
    def __init__(self, version_string):
        # "1.2.3" -> [1, 2, 3]
        self.parts = [int(x) for x in version_string.split('.')]
    
    def __lt__(self, other):
        if not isinstance(other, Version):
            return NotImplemented
        # Сравниваем части версии по порядку
        return self.parts < other.parts
    
    def __eq__(self, other):
        if not isinstance(other, Version):
            return False
        return self.parts == other.parts
    
    def __str__(self):
        return '.'.join(map(str, self.parts))

v1 = Version("1.2.3")
v2 = Version("1.2.10")
v3 = Version("2.0.0")
v4 = Version("1.2.3")

print(v1 < v2)  # True (1.2.3 < 1.2.10)
print(v2 < v3)  # True (1.2.10 < 2.0.0)
print(v1 < v4)  # False (равны)
print(v1 == v4)  # True

# Сортировка версий
versions = [Version("2.1.0"), Version("1.9.5"), Version("2.0.1"), Version("1.10.0")]
sorted_versions = sorted(versions)
print("\nВерсии по возрастанию:")
for v in sorted_versions:
    print(f"  {v}")
# Версии по возрастанию:
#   1.9.5
#   1.10.0
#   2.0.1
#   2.1.0
```


### `__gt__` — больше

**Теория:**

`__gt__` (greater than) определяет оператор `>` (больше).

**Обычно не нужно определять**, если есть `__lt__` — Python автоматически использует `other < self`.

**Примеры:**

```python
# Пример 1: Автоматическое поведение
class Price:
    def __init__(self, amount):
        self.amount = amount
    
    def __lt__(self, other):
        if not isinstance(other, Price):
            return NotImplemented
        return self.amount < other.amount
    
    def __eq__(self, other):
        if not isinstance(other, Price):
            return False
        return self.amount == other.amount
    
    # __gt__ не определяем - работает автоматически!
    
    def __str__(self):
        return f"{self.amount}₽"

p1 = Price(100)
p2 = Price(200)
p3 = Price(50)

print(p2 > p1)  # True (200 > 100)
print(p1 > p3)  # True (100 > 50)
print(p3 > p2)  # False

# Работает и сортировка в обратном порядке
prices = [p1, p2, p3]
sorted_desc = sorted(prices, reverse=True)
for price in sorted_desc:
    print(price)
# 200₽
# 100₽
# 50₽
```

```python
# Пример 2: Явное определение __gt__ для оптимизации
class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.area = width * height
    
    def __lt__(self, other):
        if not isinstance(other, Rectangle):
            return NotImplemented
        return self.area < other.area
    
    def __gt__(self, other):
        # Явно определяем для читаемости кода
        if not isinstance(other, Rectangle):
            return NotImplemented
        return self.area > other.area
    
    def __eq__(self, other):
        if not isinstance(other, Rectangle):
            return False
        return self.area == other.area
    
    def __str__(self):
        return f"{self.width}x{self.height} (S={self.area})"

r1 = Rectangle(5, 10)   # площадь 50
r2 = Rectangle(8, 8)    # площадь 64
r3 = Rectangle(3, 15)   # площадь 45

print(r2 > r1)  # True (64 > 50)
print(r1 > r3)  # True (50 > 45)
print(r3 > r2)  # False (45 > 64)

# Найти самый большой
rectangles = [r1, r2, r3]
largest = max(rectangles)
print(f"Самый большой: {largest}")  # Самый большой: 8x8 (S=64)
```

```python
# Пример 3: Сравнение с учетом дополнительной логики
class Score:
    def __init__(self, points, time_spent):
        self.points = points
        self.time_spent = time_spent  # в секундах
    
    def __lt__(self, other):
        if not isinstance(other, Score):
            return NotImplemented
        # Меньше очков = хуже
        if self.points != other.points:
            return self.points < other.points
        # При равных очках - больше времени = хуже
        return self.time_spent > other.time_spent
    
    def __gt__(self, other):
        if not isinstance(other, Score):
            return NotImplemented
        # Больше очков = лучше
        if self.points != other.points:
            return self.points > other.points
        # При равных очках - меньше времени = лучше
        return self.time_spent < other.time_spent
    
    def __eq__(self, other):
        if not isinstance(other, Score):
            return False
        return self.points == other.points and self.time_spent == other.time_spent
    
    def __str__(self):
        return f"{self.points} очков за {self.time_spent}с"

score1 = Score(100, 30)  # 100 очков за 30 сек
score2 = Score(100, 25)  # 100 очков за 25 сек (лучше!)
score3 = Score(95, 20)   # 95 очков за 20 сек

print(score2 > score1)  # True (одинаковые очки, но быстрее)
print(score1 > score3)  # True (больше очков)
print(score3 > score2)  # False (меньше очков)

# Топ игроков
scores = [score1, score2, score3]
leaderboard = sorted(scores, reverse=True)
print("\nТаблица лидеров:")
for i, score in enumerate(leaderboard, 1):
    print(f"  {i}. {score}")
# Таблица лидеров:
#   1. 100 очков за 25с
#   2. 100 очков за 30с
#   3. 95 очков за 20с
```


### `__le__` — меньше или равно

**Теория:**

`__le__` (less or equal) определяет оператор `<=` (меньше или равно).

**Автоматическое поведение:**
- Если определены `__lt__` и `__eq__`, то `<=` работает как `< or ==`
- Можно определить явно для специфической логики

**Примеры:**

```python
# Пример 1: Автоматическое __le__
class Age:
    def __init__(self, years):
        self.years = years
    
    def __lt__(self, other):
        if not isinstance(other, Age):
            return NotImplemented
        return self.years < other.years
    
    def __eq__(self, other):
        if not isinstance(other, Age):
            return False
        return self.years == other.years
    
    # __le__ работает автоматически!
    
    def __str__(self):
        return f"{self.years} лет"

age1 = Age(18)
age2 = Age(21)
age3 = Age(18)

print(age1 <= age2)  # True (18 <= 21)
print(age1 <= age3)  # True (18 <= 18, равны)
print(age2 <= age1)  # False (21 <= 18)

# Фильтрация
ages = [Age(15), Age(18), Age(25), Age(30)]
adults = [age for age in ages if age >= Age(18)]
print("Совершеннолетние:")
for age in adults:
    print(f"  {age}")
# Совершеннолетние:
#   18 лет
#   25 лет
#   30 лет
```

```python
# Пример 2: Явное определение __le__
class DateRange:
    def __init__(self, start, end):
        self.start = start
        self.end = end
        self.duration = (end - start).days
    
    def __lt__(self, other):
        if not isinstance(other, DateRange):
            return NotImplemented
        return self.duration < other.duration
    
    def __le__(self, other):
        if not isinstance(other, DateRange):
            return NotImplemented
        return self.duration <= other.duration
    
    def __eq__(self, other):
        if not isinstance(other, DateRange):
            return False
        return self.duration == other.duration
    
    def __str__(self):
        return f"{self.start} - {self.end} ({self.duration} дней)"

from datetime import date

range1 = DateRange(date(2025, 1, 1), date(2025, 1, 10))   # 9 дней
range2 = DateRange(date(2025, 2, 1), date(2025, 2, 10))   # 9 дней
range3 = DateRange(date(2025, 3, 1), date(2025, 3, 20))   # 19 дней

print(range1 <= range2)  # True (9 <= 9)
print(range1 <= range3)  # True (9 <= 19)
print(range3 <= range1)  # False (19 <= 9)

print(f"{range1} <= {range2}: {range1 <= range2}")
# 2025-01-01 - 2025-01-10 (9 дней) <= 2025-02-01 - 2025-02-10 (9 дней): True
```

```python
# Пример 3: Проверка вхождения в диапазон
class NumberRange:
    def __init__(self, min_val, max_val):
        self.min = min_val
        self.max = max_val
    
    def __contains__(self, value):
        # Для оператора 'in'
        return self.min <= value <= self.max
    
    def __le__(self, other):
        # Диапазон <= другому, если полностью в него входит
        if not isinstance(other, NumberRange):
            return NotImplemented
        return self.min >= other.min and self.max <= other.max
    
    def __str__(self):
        return f"[{self.min}, {self.max}]"

range1 = NumberRange(5, 10)
range2 = NumberRange(1, 15)   # шире
range3 = NumberRange(7, 9)    # уже

print(range3 <= range1)  # True ([7,9] входит в [5,10])
print(range1 <= range2)  # True ([5,10] входит в [1,15])
print(range2 <= range1)  # False ([1,15] не входит в [5,10])

print(7 in range1)   # True
print(15 in range1)  # False
```


### `__ge__` — больше или равно

**Теория:**

`__ge__` (greater or equal) определяет оператор `>=` (больше или равно).

**Автоматическое поведение:**
- Если определены `__gt__` и `__eq__`, работает автоматически
- Или автоматически через `not (self < other)`

**Примеры:**

```python
# Пример 1: Автоматическое __ge__
class Temperature:
    def __init__(self, celsius):
        self.celsius = celsius
    
    def __lt__(self, other):
        if not isinstance(other, Temperature):
            return NotImplemented
        return self.celsius < other.celsius
    
    def __eq__(self, other):
        if not isinstance(other, Temperature):
            return False
        return self.celsius == other.celsius
    
    # __ge__ работает автоматически
    
    def __str__(self):
        return f"{self.celsius}°C"

temp1 = Temperature(20)
temp2 = Temperature(15)
temp3 = Temperature(20)

print(temp1 >= temp2)  # True (20 >= 15)
print(temp1 >= temp3)  # True (20 >= 20)
print(temp2 >= temp1)  # False (15 >= 20)

# Проверка комфортной температуры
comfortable_temp = Temperature(18)
current_temp = Temperature(22)

if current_temp >= comfortable_temp:
    print(f"Температура комфортная: {current_temp}")
else:
    print(f"Температура низкая: {current_temp}")
# Температура комфортная: 22°C
```

```python
# Пример 2: Использование @functools.total_ordering
from functools import total_ordering

@total_ordering  # Автоматически создает все операторы сравнения
class FileSize:
    def __init__(self, bytes):
        self.bytes = bytes
    
    def __eq__(self, other):
        if not isinstance(other, FileSize):
            return False
        return self.bytes == other.bytes
    
    def __lt__(self, other):
        # Определяем только __eq__ и __lt__
        # Остальные операторы создаются автоматически!
        if not isinstance(other, FileSize):
            return NotImplemented
        return self.bytes < other.bytes
    
    def __str__(self):
        if self.bytes < 1024:
            return f"{self.bytes} B"
        elif self.bytes < 1024 ** 2:
            return f"{self.bytes / 1024:.1f} KB"
        else:
            return f"{self.bytes / (1024 ** 2):.1f} MB"

file1 = FileSize(1024)        # 1 KB
file2 = FileSize(1024 * 500)  # 500 KB
file3 = FileSize(1024 * 1024) # 1 MB

# Все операторы работают благодаря @total_ordering!
print(file1 < file2)   # True
print(file2 > file1)   # True
print(file3 >= file2)  # True
print(file1 <= file3)  # True

# Сортировка
files = [file3, file1, file2]
sorted_files = sorted(files)
print("\nФайлы по размеру:")
for f in sorted_files:
    print(f"  {f}")
# Файлы по размеру:
#   1.0 KB
#   500.0 KB
#   1.0 MB
```

```python
# Пример 3: Сравнение с валидацией
class Money:
    def __init__(self, amount, currency="RUB"):
        self.amount = amount
        self.currency = currency
    
    def _check_currency(self, other):
        if not isinstance(other, Money):
            raise TypeError(f"Нельзя сравнивать Money с {type(other)}")
        if self.currency != other.currency:
            raise ValueError(f"Нельзя сравнивать {self.currency} с {other.currency}")
    
    def __lt__(self, other):
        self._check_currency(other)
        return self.amount < other.amount
    
    def __le__(self, other):
        self._check_currency(other)
        return self.amount <= other.amount
    
    def __gt__(self, other):
        self._check_currency(other)
        return self.amount > other.amount
    
    def __ge__(self, other):
        self._check_currency(other)
        return self.amount >= other.amount
    
    def __eq__(self, other):
        if not isinstance(other, Money):
            return False
        return self.amount == other.amount and self.currency == other.currency
    
    def __str__(self):
        symbols = {"RUB": "₽", "USD": "$", "EUR": "€"}
        symbol = symbols.get(self.currency, self.currency)
        return f"{self.amount} {symbol}"

money1 = Money(1000, "RUB")
money2 = Money(1500, "RUB")
money3 = Money(100, "USD")

print(money2 >= money1)  # True (1500 >= 1000)
print(money1 >= money2)  # False (1000 >= 1500)

# Ошибка при сравнении разных валют
try:
    print(money1 >= money3)
except ValueError as e:
    print(f"Ошибка: {e}")
    # Ошибка: Нельзя сравнивать RUB с USD

# Проверка минимального баланса
min_balance = Money(500, "RUB")
user_balance = Money(750, "RUB")

if user_balance >= min_balance:
    print(f"✅ Баланс достаточен: {user_balance}")
else:
    print(f"❌ Недостаточно средств. Минимум: {min_balance}")
# ✅ Баланс доста
точен: 750 ₽
```


**Итоговая шпаргалка по магическим методам:**

### Инициализация и удаление:
```python
class MyClass:
    def __new__(cls, *args):
        # Создает объект (вызывается первым)
        return super().__new__(cls)
    
    def __init__(self, value):
        # Инициализирует объект (вызывается вторым)
        self.value = value
    
    def __del__(self):
        # Вызывается при удалении (редко используется)
        pass
```

### Представление:
```python
class MyClass:
    def __str__(self):
        # Для пользователей (print, str)
        return "Читаемое представление"
    
    def __repr__(self):
        # Для разработчиков (repr, консоль)
        return "MyClass(value)"
```

### Сравнение:
```python
class MyClass:
    def __eq__(self, other):   # ==
        return self.value == other.value
    
    def __ne__(self, other):   # != (обычно не нужен)
        return not self.__eq__(other)
    
    def __lt__(self, other):   # 
        return self.value < other.value
    
    def __le__(self, other):   # <=
        return self.value <= other.value
    
    def __gt__(self, other):   # >
        return self.value > other.value
    
    def __ge__(self, other):   # >=
        return self.value >= other.value
```

### Упрощение с @total_ordering:
```python
from functools import total_ordering

@total_ordering
class MyClass:
    def __eq__(self, other):
        return self.value == other.value
    
    def __lt__(self, other):
        return self.value < other.value
    
    # Остальные операторы создаются автоматически!
```

### Важные правила:

**Для `__new__` и `__init__`:**
- `__new__` создает объект, `__init__` инициализирует
- `__new__` возвращает объект, `__init__` возвращает `None`
- `__init__` вызывается, только если `__new__` вернул объект нашего класса

**Для `super()`:**
- Вызывает методы родительского класса
- Обязателен при наследовании с `__init__`
- Работает с множественным наследованием (MRO)

**Для `__str__` и `__repr__`:**
- `__str__` — для пользователей (красиво)
- `__repr__` — для разработчиков (точно)
- Если нет `__str__`, используется `__repr__`
- `__repr__` должен быть однозначным

**Для операторов сравнения:**
- Достаточно определить `__eq__` и `__lt__`
- Остальные работают автоматически
- Или используйте `@total_ordering`
- Всегда проверяйте `isinstance(other, МойКласс)`
- Возвращайте `NotImplemented` для несовместимых типов

**Порядок вызова при создании:**
```python
1. __new__(cls)      # создание
2. __init__(self)    # инициализация
3. ... работа с объектом ...
4. __del__(self)     # удаление (когда GC удалит)
```

**Операторы и их методы:**
```python
a == b  →  a.__eq__(b)
a != b  →  a.__ne__(b)
a < b   →  a.__lt__(b)
a <= b  →  a.__le__(b)
a > b   →  a.__gt__(b)
a >= b  →  a.__ge__(b)
str(a)  →  a.__str__()
repr(a) →  a.__repr__()
```

**Практические советы:**

✅ **Делайте:**
- Определяйте `__init__` для установки начальных значений
- Определяйте `__str__` и `__repr__` для удобной отладки
- Используйте `@total_ordering` для полного сравнения
- Проверяйте типы в операторах сравнения
- Используйте `super().__init__()` при наследовании

❌ **Не делайте:**
- Не полагайтесь на `__del__` для важных операций
- Не забывайте вызывать `super().__init__()`
- Не определяйте все 6 операторов сравнения вручную
- Не возвращайте значения из `__init__`
- Не используйте `==` для сравнения на идентичность (используйте `is`)

**Когда использовать:**
- `__init__` — почти всегда (инициализация атрибутов)
- `__str__`, `__repr__` — для удобной отладки и вывода
- `__eq__` — когда нужно сравнивать объекты по значению
- `__lt__`, `__le__`, etc. — когда нужна сортировка
- `__new__` — для Singleton, неизменяемых типов
- `__del__` — редко (лучше использовать контекстные менеджеры)

**Типичные ошибки:**

```python
# ❌ НЕПРАВИЛЬНО
class Bad:
    def __init__(self, value):
        return value  # __init__ не должен ничего возвращать!
    
    def __eq__(self, other):
        return self.value == other.value  # нет проверки типа!
    
    def __lt__(self, other):
        return self.value < other  # сравнение с любым типом!

# ✅ ПРАВИЛЬНО
class Good:
    def __init__(self, value):
        self.value = value
        # Не возвращаем ничего (или return None)
    
    def __eq__(self, other):
        if not isinstance(other, Good):
            return False
        return self.value == other.value
    
    def __lt__(self, other):
        if not isinstance(other, Good):
            return NotImplemented
        return self.value < other.value
```

**Полный пример класса с магическими методами:**

```python
from functools import total_ordering

@total_ordering
class Product:
    """Товар в интернет-магазине"""
    
    def __init__(self, name, price, quantity=1):
        if price < 0:
            raise ValueError("Цена не может быть отрицательной")
        if quantity < 0:
            raise ValueError("Количество не может быть отрицательным")
        
        self.name = name
        self.price = price
        self.quantity = quantity
    
    def __str__(self):
        # Для пользователей
        return f"{self.name}: {self.price}₽ x {self.quantity}"
    
    def __repr__(self):
        # Для разработчиков
        return f"Product({self.name!r}, {self.price}, {self.quantity})"
    
    def __eq__(self, other):
        if not isinstance(other, Product):
            return False
        return (self.name == other.name and 
                self.price == other.price)
    
    def __lt__(self, other):
        if not isinstance(other, Product):
            return NotImplemented
        # Сравниваем по цене
        return self.price < other.price
    
    def total(self):
        """Общая стоимость"""
        return self.price * self.quantity

# Использование
p1 = Product("Ноутбук", 50000, 2)
p2 = Product("Мышь", 500, 5)
p3 = Product("Клавиатура", 1500, 3)

# Вывод
print(p1)        # Ноутбук: 50000₽ x 2
print(repr(p2))  # Product('Мышь', 500, 5)

# Сравнение
print(p1 > p2)   # True (50000 > 500)
print(p2 < p3)   # True (500 < 1500)

# Сортировка
products = [p1, p2, p3]
sorted_products = sorted(products)
print("\nТовары по цене:")
for p in sorted_products:
    print(f"  {p} = {p.total()}₽")
# Товары по цене:
#   Мышь: 500₽ x 5 = 2500₽
#   Клавиатура: 1500₽ x 3 = 4500₽
#   Ноутбук: 50000₽ x 2 = 100000₽
```

Это основные магические методы для инициализации, представления и сравнения объектов. Есть еще множество других магических методов для арифметических операций (`__add__`, `__sub__`), работы с контейнерами (`__getitem__`, `__setitem__`), вызова объектов (`__call__`) и т.д., но это уже более продвинутые темы.

## `27.4` Вызываемые объекты
### `__call__` — делаем объект вызываемым
`__call__` — магический метод, который позволяет вызывать объект как функцию.

**Что это значит:**
```python
obj = MyClass()
obj()  # вызов объекта как функции → вызывается obj.__call__()
```

**Зачем нужен:**
- 🎯 Создание **функциональных объектов** с состоянием
- 🏭 **Фабрики и генераторы** с настройками
- 📊 **Декораторы на основе классов**
- 🔧 **Callable objects** — объекты, которые ведут себя как функции
- 💾 **Кеширование и мемоизация**
- 🎮 **Стратегии и команды** (паттерны проектирования)

**Отличие от обычного метода:**
```python
obj.method()  # вызов метода
obj()         # вызов объекта (через __call__)
```

**Проверка вызываемости:**
```python
callable(obj)  # True, если есть __call__
```

**Примеры:**

```python
# Пример 1: Счетчик вызовов с состоянием
class Counter:
    """Вызываемый объект, который считает количество вызовов"""
    
    def __init__(self, start=0):
        self.count = start
        print(f"Счетчик создан, начальное значение: {start}")
    
    def __call__(self, increment=1):
        """Увеличивает счетчик при вызове"""
        self.count += increment
        print(f"Счетчик вызван, текущее значение: {self.count}")
        return self.count
    
    def reset(self):
        """Сброс счетчика"""
        self.count = 0
        print("Счетчик сброшен")

# Создаем счетчик
counter = Counter(10)
# Счетчик создан, начальное значение: 10

# Вызываем объект как функцию!
counter()        # Счетчик вызван, текущее значение: 11
counter()        # Счетчик вызван, текущее значение: 12
counter(5)       # Счетчик вызван, текущее значение: 17

# Получаем значение
result = counter()
print(f"Результат: {result}")  # Результат: 18

# Обычный метод тоже работает
counter.reset()  # Счетчик сброшен

# Проверка на вызываемость
print(callable(counter))  # True
print(callable(123))      # False

# Можно создать несколько независимых счетчиков
counter1 = Counter(0)
counter2 = Counter(100)

counter1()  # 1
counter1()  # 2
counter2()  # 101
counter2()  # 102

print(f"counter1: {counter1.count}, counter2: {counter2.count}")
# counter1: 2, counter2: 102
```

```python
# Пример 2: Генератор приветствий с настройками
class Greeter:
    """Генератор приветствий с настраиваемым стилем"""
    
    def __init__(self, greeting="Привет", punctuation="!"):
        self.greeting = greeting
        self.punctuation = punctuation
        self.greet_count = 0
    
    def __call__(self, name):
        """Генерирует приветствие при вызове"""
        self.greet_count += 1
        message = f"{self.greeting}, {name}{self.punctuation}"
        return message
    
    def __str__(self):
        return f"Greeter('{self.greeting}', использовано {self.greet_count} раз)"

# Создаем разные приветствия
hello = Greeter("Привет")
good_morning = Greeter("Доброе утро", ".")
hey = Greeter("Эй")

# Используем как функции
print(hello("Иван"))         # Привет, Иван!
print(hello("Мария"))        # Привет, Мария!
print(good_morning("Петр"))  # Доброе утро, Петр.
print(hey("Друг"))           # Эй, Друг!

# Статистика использования
print(hello)         # Greeter('Привет', использовано 2 раз)
print(good_morning)  # Greeter('Доброе утро', использовано 1 раз)

# Практическое применение: генерация сообщений
class MessageFormatter:
    def __init__(self, template):
        self.template = template
    
    def __call__(self, **kwargs):
        return self.template.format(**kwargs)

# Создаем форматтеры
email_subject = MessageFormatter("Заказ #{order_id}: {status}")
notification = MessageFormatter("⚠️ {user}, у вас {count} непрочитанных сообщений")

# Используем
print(email_subject(order_id=12345, status="Доставлен"))
# Заказ #12345: Доставлен

print(notification(user="Иван", count=5))
# ⚠️ Иван, у вас 5 непрочитанных сообщений
```

```python
# Пример 3: Валидатор с настраиваемыми правилами
class Validator:
    """Вызываемый валидатор с кастомными правилами"""
    
    def __init__(self, min_length=0, max_length=100, required=True):
        self.min_length = min_length
        self.max_length = max_length
        self.required = required
        self.validation_count = 0
    
    def __call__(self, value):
        """Валидирует значение при вызове"""
        self.validation_count += 1
        errors = []
        
        # Проверка на обязательность
        if self.required and not value:
            errors.append("Поле обязательно для заполнения")
            return False, errors
        
        # Проверка длины
        if value and len(value) < self.min_length:
            errors.append(f"Минимальная длина: {self.min_length} символов")
        
        if value and len(value) > self.max_length:
            errors.append(f"Максимальная длина: {self.max_length} символов")
        
        # Результат
        is_valid = len(errors) == 0
        return is_valid, errors if errors else ["OK"]
    
    def __str__(self):
        return (f"Validator(min={self.min_length}, max={self.max_length}, "
                f"required={self.required}, проверок: {self.validation_count})")

# Создаем валидаторы для разных полей
username_validator = Validator(min_length=3, max_length=20, required=True)
bio_validator = Validator(min_length=0, max_length=500, required=False)
password_validator = Validator(min_length=8, max_length=50, required=True)

# Используем валидаторы (вызываем как функции)
# Username
valid, messages = username_validator("john")
print(f"Username 'john': {valid}, {messages}")
# Username 'john': True, ['OK']

valid, messages = username_validator("jo")
print(f"Username 'jo': {valid}, {messages}")
# Username 'jo': False, ['Минимальная длина: 3 символов']

# Password
valid, messages = password_validator("pass")
print(f"Password 'pass': {valid}, {messages}")
# Password 'pass': False, ['Минимальная длина: 8 символов']

valid, messages = password_validator("secure_password_123")
print(f"Password 'secure_password_123': {valid}, {messages}")
# Password 'secure_password_123': True, ['OK']

# Bio (необязательное поле)
valid, messages = bio_validator("")
print(f"Bio '': {valid}, {messages}")
# Bio '': True, ['OK']

# Статистика
print(f"\n{username_validator}")
# Validator(min=3, max=20, required=True, проверок: 2)

# Практическое применение: валидация формы
def validate_form(data, validators):
    """Валидирует данные формы"""
    results = {}
    for field, validator in validators.items():
        value = data.get(field, "")
        is_valid, messages = validator(value)
        results[field] = {
            'valid': is_valid,
            'messages': messages,
            'value': value
        }
    return results

# Валидаторы для формы регистрации
form_validators = {
    'username': Validator(min_length=3, max_length=20, required=True),
    'email': Validator(min_length=5, max_length=100, required=True),
    'password': Validator(min_length=8, max_length=50, required=True),
    'bio': Validator(min_length=0, max_length=500, required=False)
}

# Данные формы
form_data = {
    'username': 'john_doe',
    'email': 'john@example.com',
    'password': 'secure123',
    'bio': 'Python разработчик'
}

# Валидация
validation_results = validate_form(form_data, form_validators)

print("\nРезультаты валидации формы:")
for field, result in validation_results.items():
    status = "✅" if result['valid'] else "❌"
    print(f"{status} {field}: {result['messages'][0]}")

# Результаты валидации формы:
# ✅ username: OK
# ✅ email: OK
# ✅ password: OK
# ✅ bio: OK
```

---

**Шпаргалка по `__call__`:**

**Базовая структура:**
```python
class MyCallable:
    def __init__(self, param):
        self.param = param
    
    def __call__(self, *args, **kwargs):
        # Логика при вызове
        return result

obj = MyCallable(10)
result = obj(5)  # вызов __call__
```

**Проверка вызываемости:**
```python
callable(obj)  # True, если определен __call__
callable(123)  # False
callable(print)  # True (функции вызываемы)
```

**Когда использовать:**
- ✅ Объект нужно вызывать как функцию
- ✅ Функция с состоянием (сохранение данных между вызовами)
- ✅ Фабрики и генераторы с настройками
- ✅ Декораторы на основе классов
- ✅ Callback-функции с дополнительной логикой

**Преимущества перед обычной функцией:**
- 💾 Сохранение состояния между вызовами
- 🎛️ Настраиваемые параметры через `__init__`
- 📊 Дополнительные методы и атрибуты
- 🔍 Легче отлаживать и тестировать

**Практические применения:**

```python
# 1. Декоратор на основе класса
class CountCalls:
    def __init__(self, func):
        self.func = func
        self.count = 0
    
    def __call__(self, *args, **kwargs):
        self.count += 1
        print(f"Вызов #{self.count}")
        return self.func(*args, **kwargs)

@CountCalls
def hello(name):
    print(f"Привет, {name}!")

hello("Иван")   # Вызов #1, Привет, Иван!
hello("Мария")  # Вызов #2, Привет, Мария!

# 2. Фильтр с настройками
class Filter:
    def __init__(self, min_value, max_value):
        self.min = min_value
        self.max = max_value
    
    def __call__(self, value):
        return self.min <= value <= self.max

age_filter = Filter(18, 65)
print(age_filter(25))  # True
print(age_filter(70))  # False

# 3. Генератор ID
class IDGenerator:
    def __init__(self, prefix="ID"):
        self.prefix = prefix
        self.counter = 0
    
    def __call__(self):
        self.counter += 1
        return f"{self.prefix}_{self.counter:05d}"

user_id = IDGenerator("USER")
order_id = IDGenerator("ORDER")

print(user_id())   # USER_00001
print(user_id())   # USER_00002
print(order_id())  # ORDER_00001
```

**Важные советы:**

✅ **Делайте:**
- Используйте `__call__`, когда объект логически "делает что-то"
- Сохраняйте состояние в атрибутах объекта
- Документируйте параметры `__call__` в docstring
- Делайте понятные имена классов (глаголы: Validator, Counter, Generator)

❌ **Не делайте:**
- Не злоупотребляйте: простые функции часто лучше
- Не делайте слишком сложную логику в `__call__`
- Не забывайте про `__init__` для начальной настройки
- Не используйте для простых случаев без состояния

**Сравнение подходов:**

```python
# ❌ Функция + глобальное состояние (плохо)
counter = 0

def count():
    global counter
    counter += 1
    return counter

# ✅ Вызываемый объект (хорошо)
class Counter:
    def __init__(self):
        self.count = 0
    
    def __call__(self):
        self.count += 1
        return self.count

# Можно создать несколько независимых счетчиков
counter1 = Counter()
counter2 = Counter()
```

Вызываемые объекты (`__call__`) — мощный инструмент для создания функциональных объектов с состоянием. Они объединяют гибкость объектов (атрибуты, методы) с простотой использования функций.

## `27.5` Работа с атрибутами (`**`)
[Работа с атрибутами видео](https://youtu.be/CAx-NLFc-Z4?si=CEOVVPMhHs4uwHkH)

Магические методы для работы с атрибутами позволяют контролировать доступ к атрибутам объекта: чтение, запись и удаление.

**Четыре основных метода:**

| Метод | Когда вызывается | Операция |
|-------|------------------|----------|
| `__getattribute__` | При **любом** доступе к атрибуту | `obj.attr` |
| `__getattr__` | Только если атрибут **не найден** | `obj.nonexistent` |
| `__setattr__` | При установке атрибута | `obj.attr = value` |
| `__delattr__` | При удалении атрибута | `del obj.attr` |

**Порядок вызова при чтении атрибута:**
1. `__getattribute__` вызывается всегда
2. Если `__getattribute__` вызвал `AttributeError` → вызывается `__getattr__`
3. Если `__getattr__` не определен → `AttributeError` попадает к пользователю

**Зачем нужны:**
- 🔍 **Динамические атрибуты** — вычисляемые на лету
- 🛡️ **Валидация** — проверка значений перед установкой
- 📝 **Логирование** — отслеживание доступа к атрибутам
- 🔒 **Защита** — запрет изменения "приватных" атрибутов
- 🎭 **Прокси-объекты** — делегирование другим объектам
- 💾 **Ленивая загрузка** — создание атрибутов по требованию


### `__getattribute__` — перехват доступа ко всем атрибутам

**Теория:**

`__getattribute__` вызывается при **каждом** обращении к атрибуту, даже если атрибут существует.

**Важно:**
- ⚠️ Вызывается для ВСЕХ атрибутов (включая методы)
- ⚠️ Легко создать бесконечную рекурсию!
- ⚠️ Используйте `super().__getattribute__()` для доступа к реальным атрибутам
- ⚠️ Это низкоуровневый метод, используйте осторожно

**Бесконечная рекурсия (ОШИБКА):**
```python
def __getattribute__(self, name):
    return self.name  # ❌ Снова вызовет __getattribute__!
```

**Правильный способ:**
```python
def __getattribute__(self, name):
    return super().__getattribute__(name)  # ✅
```

**Примеры:**

```python
# Пример 1: Логирование доступа к атрибутам
class LoggedAccess:
    """Класс, который логирует все обращения к атрибутам"""
    
    def __init__(self, name, value):
        # При инициализации тоже вызывается __setattr__!
        # Используем super() чтобы избежать нашей логики
        super().__setattr__('name', name)
        super().__setattr__('value', value)
        super().__setattr__('access_log', [])
    
    def __getattribute__(self, attr):
        # Получаем access_log через super, чтобы избежать рекурсии
        if attr != 'access_log':
            access_log = super().__getattribute__('access_log')
            access_log.append(f"Чтение: {attr}")
        
        # Возвращаем реальное значение атрибута
        return super().__getattribute__(attr)
    
    def show_log(self):
        """Показать лог доступа"""
        print("История доступа:")
        for entry in self.access_log:
            print(f"  {entry}")

# Создаем объект
obj = LoggedAccess("test", 42)

# Обращаемся к атрибутам
print(obj.name)   # test
print(obj.value)  # 42
x = obj.name      # еще одно обращение

# Смотрим лог
obj.show_log()
# История доступа:
#   Чтение: name
#   Чтение: value
#   Чтение: name
#   Чтение: show_log
#   Чтение: access_log
```

```python
# Пример 2: Защита "приватных" атрибутов
class ProtectedAttributes:
    """Запрещает доступ к атрибутам, начинающимся с underscore"""
    
    def __init__(self):
        super().__setattr__('_secret', "Секретные данные")
        super().__setattr__('public', "Публичные данные")
    
    def __getattribute__(self, name):
        # Разрешаем доступ к методам класса
        if name.startswith('_') and not name.startswith('__'):
            raise AttributeError(f"Доступ к приватному атрибуту '{name}' запрещен")
        return super().__getattribute__(name)
    
    def get_secret(self):
        """Легальный способ получить приватные данные"""
        # Внутри методов можем использовать super()
        return super().__getattribute__('_secret')

obj = ProtectedAttributes()

# Доступ к публичному атрибуту - OK
print(obj.public)  # Публичные данные

# Доступ к приватному атрибуту - ошибка
try:
    print(obj._secret)
except AttributeError as e:
    print(f"Ошибка: {e}")
    # Ошибка: Доступ к приватному атрибуту '_secret' запрещен

# Через метод - OK
print(obj.get_secret())  # Секретные данные
```

```python
# Пример 3: Автоматическое преобразование имен атрибутов
class CaseInsensitiveAttrs:
    """Атрибуты нечувствительны к регистру"""
    
    def __init__(self):
        # Храним атрибуты в нижнем регистре
        super().__setattr__('_data', {})
    
    def __getattribute__(self, name):
        # Специальные атрибуты обрабатываем обычным способом
        if name.startswith('_'):
            return super().__getattribute__(name)
        
        # Получаем словарь данных
        data = super().__getattribute__('_data')
        
        # Ищем в нижнем регистре
        key = name.lower()
        if key in data:
            return data[key]
        
        raise AttributeError(f"Атрибут '{name}' не найден")
    
    def __setattr__(self, name, value):
        if name.startswith('_'):
            super().__setattr__(name, value)
        else:
            data = super().__getattribute__('_data')
            data[name.lower()] = value

obj = CaseInsensitiveAttrs()

# Устанавливаем атрибут
obj.UserName = "Иван"

# Можем получить в любом регистре!
print(obj.username)   # Иван
print(obj.USERNAME)   # Иван
print(obj.UserName)   # Иван
```


### `__getattr__` — обработка несуществующих атрибутов

**Теория:**

`__getattr__` вызывается только когда атрибут **не найден** обычным способом.

**Отличие от `__getattribute__`:**
- `__getattribute__` — вызывается всегда
- `__getattr__` — только для отсутствующих атрибутов (fallback)

**Когда использовать:**
- ✅ Динамические атрибуты
- ✅ Значения по умолчанию
- ✅ Прокси к другим объектам
- ✅ Ленивая загрузка данных

**Примеры:**

```python
# Пример 1: Динамические атрибуты со значениями по умолчанию
class Config:
    """Конфигурация с значениями по умолчанию"""
    
    def __init__(self):
        self.database = "localhost"
        self.port = 5432
    
    def __getattr__(self, name):
        # Вызывается только для несуществующих атрибутов
        print(f"Атрибут '{name}' не найден, возвращаем значение по умолчанию")
        
        # Возвращаем разные дефолты в зависимости от имени
        if name.startswith('max_'):
            return 100
        elif name.startswith('enable_'):
            return True
        elif name.startswith('timeout_'):
            return 30
        else:
            raise AttributeError(f"Атрибут '{name}' не найден")

config = Config()

# Существующие атрибуты - обычное поведение
print(config.database)  # localhost
print(config.port)      # 5432

# Несуществующие атрибуты - вызывается __getattr__
print(config.max_connections)  # 100
# Атрибут 'max_connections' не найден, возвращаем значение по умолчанию

print(config.enable_logging)   # True
# Атрибут 'enable_logging' не найден, возвращаем значение по умолчанию

print(config.timeout_seconds)  # 30
# Атрибут 'timeout_seconds' не найден, возвращаем значение по умолчанию

# Неизвестный атрибут - ошибка
try:
    print(config.unknown)
except AttributeError as e:
    print(f"Ошибка: {e}")
    # Ошибка: Атрибут 'unknown' не найден
```

```python
# Пример 2: Прокси к вложенному объекту
class User:
    def __init__(self, name, age):
        self.name = name
        self.age = age

class UserProxy:
    """Прокси, который делегирует вызовы к реальному объекту User"""
    
    def __init__(self, user):
        # Сохраняем реальный объект
        self._user = user
        self.access_count = 0
    
    def __getattr__(self, name):
        # Вызывается для атрибутов, которых нет в прокси
        self.access_count += 1
        print(f"Доступ к атрибуту '{name}' через прокси")
        
        # Делегируем к реальному объекту
        return getattr(self._user, name)

# Создаем реального пользователя
real_user = User("Иван", 30)

# Создаем прокси
proxy = UserProxy(real_user)

# Обращаемся через прокси
print(proxy.name)  # Доступ к атрибуту 'name' через прокси -> Иван
print(proxy.age)   # Доступ к атрибуту 'age' через прокси -> 30

# Счетчик доступов работает
print(f"Количество обращений: {proxy.access_count}")  # 2
```

```python
# Пример 3: Ленивая загрузка атрибутов
class LazyData:
    """Загружает данные только при первом обращении"""
    
    def __init__(self):
        self._cache = {}
        print("Объект создан, данные еще не загружены")
    
    def __getattr__(self, name):
        # Проверяем кеш
        if name in self._cache:
            print(f"Возвращаем '{name}' из кеша")
            return self._cache[name]
        
        # "Загружаем" данные (имитация)
        print(f"Загружаем данные для '{name}'...")
        
        if name == 'users':
            data = ['Иван', 'Мария', 'Петр']
        elif name == 'posts':
            data = ['Пост 1', 'Пост 2', 'Пост 3']
        elif name == 'comments':
            data = ['Комментарий 1', 'Комментарий 2']
        else:
            raise AttributeError(f"Неизвестный атрибут: {name}")
        
        # Кешируем для следующих обращений
        self._cache[name] = data
        return data

# Создаем объект
data = LazyData()
# Объект создан, данные еще не загружены

# Первое обращение - загрузка
print(data.users)
# Загружаем данные для 'users'...
# ['Иван', 'Мария', 'Петр']

# Второе обращение - из кеша
print(data.users)
# Возвращаем 'users' из кеша
# ['Иван', 'Мария', 'Петр']

# Другие атрибуты загружаются по требованию
print(data.posts)
# Загружаем данные для 'posts'...
# ['Пост 1', 'Пост 2', 'Пост 3']

print(data.comments)
# Загружаем данные для 'comments'...
# ['Комментарий 1', 'Комментарий 2']
```


### `__setattr__` — перехват установки атрибутов

**Теория:**

`__setattr__` вызывается при **любой** попытке установить значение атрибута.

**Важно:**
- ⚠️ Вызывается даже в `__init__`!
- ⚠️ Используйте `super().__setattr__()` или `self.__dict__[name] = value`
- ⚠️ Легко создать бесконечную рекурсию

**Бесконечная рекурсия (ОШИБКА):**
```python
def __setattr__(self, name, value):
    self.name = value  # ❌ Снова вызовет __setattr__!
```

**Правильные способы:**
```python
def __setattr__(self, name, value):
    super().__setattr__(name, value)  # ✅ Способ 1
    # или
    self.__dict__[name] = value       # ✅ Способ 2
```

**Примеры:**

```python
# Пример 1: Валидация значений при установке
class Person:
    """Класс с валидацией атрибутов"""
    
    def __init__(self, name, age):
        # __setattr__ будет вызван для каждого присваивания!
        self.name = name
        self.age = age
    
    def __setattr__(self, name, value):
        # Валидация для имени
        if name == 'name':
            if not isinstance(value, str):
                raise TypeError("Имя должно быть строкой")
            if len(value) < 2:
                raise ValueError("Имя слишком короткое")
            if not value.strip():
                raise ValueError("Имя не может быть пустым")
        
        # Валидация для возраста
        elif name == 'age':
            if not isinstance(value, int):
                raise TypeError("Возраст должен быть целым числом")
            if value < 0 or value > 150:
                raise ValueError("Недопустимый возраст")
        
        # Устанавливаем атрибут через super
        super().__setattr__(name, value)
    
    def __str__(self):
        return f"Person(name={self.name}, age={self.age})"

# Правильное создание
person = Person("Иван", 30)
print(person)  # Person(name=Иван, age=30)

# Правильное изменение
person.age = 31
print(person)  # Person(name=Иван, age=31)

# Неправильное имя
try:
    person.name = "А"
except ValueError as e:
    print(f"Ошибка: {e}")  # Ошибка: Имя слишком короткое

# Неправильный возраст
try:
    person.age = -5
except ValueError as e:
    print(f"Ошибка: {e}")  # Ошибка: Недопустимый возраст

try:
    person.age = "тридцать"
except TypeError as e:
    print(f"Ошибка: {e}")  # Ошибка: Возраст должен быть целым числом
```

```python
# Пример 2: Только чтение (read-only) атрибуты
class ReadOnly:
    """Класс с атрибутами только для чтения"""
    
    def __init__(self, value):
        # В __init__ разрешаем установку
        super().__setattr__('_initialized', False)
        super().__setattr__('value', value)
        super().__setattr__('created_at', __import__('datetime').datetime.now())
        super().__setattr__('_initialized', True)
    
    def __setattr__(self, name, value):
        # После инициализации запрещаем изменения
        if super().__getattribute__('_initialized'):
            raise AttributeError(f"Атрибут '{name}' только для чтения")
        super().__setattr__(name, value)
    
    def __delattr__(self, name):
        raise AttributeError(f"Нельзя удалить атрибут '{name}'")

# Создаем объект
obj = ReadOnly(42)
print(obj.value)      # 42
print(obj.created_at) # 2025-10-13 ...

# Попытка изменить - ошибка
try:
    obj.value = 100
except AttributeError as e:
    print(f"Ошибка: {e}")
    # Ошибка: Атрибут 'value' только для чтения

# Попытка добавить новый атрибут - ошибка
try:
    obj.new_attr = "test"
except AttributeError as e:
    print(f"Ошибка: {e}")
    # Ошибка: Атрибут 'new_attr' только для чтения
```

```python
# Пример 3: Отслеживание изменений (History/Audit)
class TrackedObject:
    """Объект, который отслеживает все изменения атрибутов"""
    
    def __init__(self, name):
        # Используем __dict__ напрямую, чтобы избежать истории для служебных атрибутов
        self.__dict__['_history'] = []
        self.__dict__['_name'] = name
        self.value = 0
    
    def __setattr__(self, name, value):
        # Записываем в историю
        import datetime
        old_value = getattr(self, name, '<не установлено>')
        
        timestamp = datetime.datetime.now().strftime('%H:%M:%S')
        self.__dict__['_history'].append({
            'timestamp': timestamp,
            'attribute': name,
            'old_value': old_value,
            'new_value': value
        })
        
        # Устанавливаем значение
        self.__dict__[name] = value
    
    def show_history(self):
        """Показать историю изменений"""
        print(f"\nИстория изменений '{self.__dict__['_name']}':")
        for change in self.__dict__['_history']:
            print(f"  [{change['timestamp']}] {change['attribute']}: "
                  f"{change['old_value']} → {change['new_value']}")

# Создаем объект
obj = TrackedObject("test_object")

# Изменяем атрибуты
obj.value = 10
obj.value = 20
obj.value = 30
obj.status = "active"
obj.status = "inactive"

# Смотрим историю
obj.show_history()
# История изменений 'test_object':
#   [15:30:45] value: <не установлено> → 0
#   [15:30:45] value: 0 → 10
#   [15:30:45] value: 10 → 20
#   [15:30:45] value: 20 → 30
#   [15:30:45] status: <не установлено> → active
#   [15:30:45] status: active → inactive
```


### `__delattr__` — перехват удаления атрибутов

**Теория:**

`__delattr__` вызывается при попытке удалить атрибут оператором `del`.

**Синтаксис:**
```python
del obj.attribute  # вызывает obj.__delattr__('attribute')
```

**Зачем нужен:**
- 🔒 Запрет удаления важных атрибутов
- 📝 Логирование удалений
- 🧹 Очистка связанных ресурсов
- ✅ Валидация при удалении

**Примеры:**

```python
# Пример 1: Защита от удаления критичных атрибутов
class ProtectedObject:
    """Объект с защищенными атрибутами"""
    
    PROTECTED = {'id', 'created_at', 'type'}  # Защищенные атрибуты
    
    def __init__(self, id, type):
        self.id = id
        self.type = type
        self.created_at = __import__('datetime').datetime.now()
        self.data = "некоторые данные"
        self.temp = "временные данные"
    
    def __delattr__(self, name):
        # Проверяем, защищен ли атрибут
        if name in self.PROTECTED:
            raise AttributeError(f"Нельзя удалить защищенный атрибут '{name}'")
        
        # Логируем удаление
        print(f"Удаляется атрибут: {name}")
        
        # Выполняем удаление
        super().__delattr__(name)
    
    def __str__(self):
        attrs = ', '.join(f"{k}={v}" for k, v in self.__dict__.items())
        return f"ProtectedObject({attrs})"

# Создаем объект
obj = ProtectedObject(123, "user")
print(obj)

# Удаляем обычный атрибут - OK
del obj.temp
print("После удаления temp:")
print(obj)

# Удаляем данные - OK
del obj.data
# Удаляется атрибут: data

# Попытка удалить защищенный атрибут - ошибка
try:
    del obj.id
except AttributeError as e:
    print(f"Ошибка: {e}")
    # Ошибка: Нельзя удалить защищенный атрибут 'id'

try:
    del obj.type
except AttributeError as e:
    print(f"Ошибка: {e}")
    # Ошибка: Нельзя удалить защищенный атрибут 'type'
```

```python
# Пример 2: Логирование и очистка ресурсов
class ManagedResource:
    """Ресурс с управлением жизненным циклом"""
    
    def __init__(self, name):
        self.name = name
        self._resources = {}
        print(f"Создан ресурс: {name}")
    
    def __setattr__(self, name, value):
        if name.startswith('resource_'):
            print(f"  → Выделен ресурс: {name} = {value}")
            # Сохраняем в отдельный словарь
            if '_resources' not in self.__dict__:
                self.__dict__['_resources'] = {}
            self.__dict__['_resources'][name] = value
        
        super().__setattr__(name, value)
    
    def __delattr__(self, name):
        if name.startswith('resource_'):
            print(f"  ← Освобождается ресурс: {name}")
            # Выполняем очистку
            if hasattr(self, '_resources') and name in self._resources:
                del self._resources[name]
                print(f"     Ресурс {name} очищен из реестра")
        
        super().__delattr__(name)
    
    def cleanup_all(self):
        """Очистить все ресурсы"""
        print(f"\nОчистка всех ресурсов объекта '{self.name}':")
        resources_to_delete = list(self._resources.keys())
        for resource_name in resources_to_delete:
            delattr(self, resource_name)

# Используем
obj = ManagedResource("database_connection")

# Выделяем ресурсы
obj.resource_connection = "DB Connection #1"
obj.resource_file = "File Handle #1"
obj.resource_memory = "Memory Block #1"
obj.normal_attr = "обычный атрибут"

print("\nУдаление одного ресурса:")
del obj.resource_file

print("\nОчистка всех ресурсов:")
obj.cleanup_all()

# Создан ресурс: database_connection
#   → Выделен ресурс: resource_connection = DB Connection #1
#   → Выделен ресурс: resource_file = File Handle #1
#   → Выделен ресурс: resource_memory = Memory Block #1
# 
# Удаление одного ресурса:
#   ← Освобождается ресурс: resource_file
#      Ресурс resource_file очищен из реестра
# 
# Очистка всех ресурсов объекта 'database_connection':
#   ← Освобождается ресурс: resource_connection
#      Ресурс resource_connection очищен из реестра
#   ← Освобождается ресурс: resource_memory
#      Ресурс resource_memory очищен из реестра
```

```python
# Пример 3: Каскадное удаление связанных атрибутов
class LinkedAttributes:
    """Объект со связанными атрибутами"""
    
    # Определяем связи между атрибутами
    DEPENDENCIES = {
        'user': ['user_id', 'user_email', 'user_settings'],
        'order': ['order_id', 'order_date', 'order_total'],
    }
    
    def __init__(self):
        # Пользовательские данные
        self.user = "Иван"
        self.user_id = 123
        self.user_email = "ivan@example.com"
        self.user_settings = {'theme': 'dark'}
        
        # Данные заказа
        self.order = "Заказ #456"
        self.order_id = 456
        self.order_date = "2025-10-13"
        self.order_total = 1500
    
    def __delattr__(self, name):
        # Проверяем, есть ли зависимые атрибуты
        if name in self.DEPENDENCIES:
            dependent_attrs = self.DEPENDENCIES[name]
            print(f"Удаление '{name}' и связанных атрибутов: {dependent_attrs}")
            
            # Удаляем зависимые атрибуты
            for dep_attr in dependent_attrs:
                if hasattr(self, dep_attr):
                    print(f"  → Удаляем связанный атрибут: {dep_attr}")
                    # Используем super, чтобы избежать повторного вызова этой логики
                    super().__delattr__(dep_attr)
        
        # Удаляем основной атрибут
        super().__delattr__(name)
        print(f"✓ Атрибут '{name}' удален")
    
    def show_attributes(self):
        print("\nТекущие атрибуты:")
        for key, value in self.__dict__.items():
            print(f"  {key}: {value}")

obj = LinkedAttributes()
obj.show_attributes()

print("\n" + "="*50)
print("Удаляем 'user' (должны удалиться все связанные):")
print("="*50)
del obj.user

obj.show_attributes()

# Текущие атрибуты:
#   user: Иван
#   user_id: 123
#   user_email: ivan@example.com
#   user_settings: {'theme': 'dark'}
#   order: Заказ #456
#   order_id: 456
#   order_date: 2025-10-13
#   order_total: 1500
# 
# ==================================================
# Удаляем 'user' (должны удалиться все связанные):
# ==================================================
# Удаление 'user' и связанных атрибутов: ['user_id', 'user_email', 'user_settings']
#   → Удаляем связанный атрибут: user_id
#   → Удаляем связанный атрибут: user_email
#   → Удаляем связанный атрибут: user_settings
# ✓ Атрибут 'user' удален
# 
# Текущие атрибуты:
#   order: Заказ #456
#   order_id: 456
#   order_date: 2025-10-13
#   order_total: 1500
```

---

**Итоговая шпаргалка по работе с атрибутами:**

### Когда что вызывается:

```python
obj.attr          # __getattribute__ → (если не найдено) __getattr__
obj.attr = value  # __setattr__
del obj.attr      # __delattr
__
```

### Безопасный доступ к атрибутам внутри магических методов:

```python
class Safe:
    def __getattribute__(self, name):
        # ✅ ПРАВИЛЬНО: используем super()
        return super().__getattribute__(name)
    
    def __setattr__(self, name, value):
        # ✅ ПРАВИЛЬНО: два способа
        super().__setattr__(name, value)  # Способ 1
        # или
        self.__dict__[name] = value       # Способ 2
    
    def __delattr__(self, name):
        # ✅ ПРАВИЛЬНО: используем super()
        super().__delattr__(name)

class Unsafe:
    def __getattribute__(self, name):
        # ❌ ОШИБКА: бесконечная рекурсия!
        return self.name
    
    def __setattr__(self, name, value):
        # ❌ ОШИБКА: бесконечная рекурсия!
        self.name = value
```

### Сравнение методов:

| Метод | Когда вызывается | Частота использования | Сложность |
|-------|------------------|----------------------|-----------|
| `__getattr__` | Атрибут не найден | ⭐⭐⭐ Часто | 🟢 Легко |
| `__setattr__` | Установка атрибута | ⭐⭐ Средне | 🟡 Средне |
| `__delattr__` | Удаление атрибута | ⭐ Редко | 🟡 Средне |
| `__getattribute__` | Любой доступ | ⚠️ Очень редко | 🔴 Сложно |

### Типичные паттерны использования:

**1. Динамические атрибуты (`__getattr__`):**
```python
class DynamicAttrs:
    def __getattr__(self, name):
        if name.startswith('get_'):
            # Динамическая генерация getter'ов
            attr_name = name[4:]  # убираем 'get_'
            return lambda: getattr(self, attr_name, None)
        raise AttributeError(f"'{name}' not found")

obj = DynamicAttrs()
obj.value = 42
getter = obj.get_value  # динамически создается getter
print(getter())  # 42
```

**2. Валидация (`__setattr__`):**
```python
class Validated:
    def __setattr__(self, name, value):
        if name == 'age' and (value < 0 or value > 150):
            raise ValueError("Invalid age")
        if name == 'email' and '@' not in str(value):
            raise ValueError("Invalid email")
        super().__setattr__(name, value)
```

**3. Прокси-объект (`__getattr__`):**
```python
class Proxy:
    def __init__(self, obj):
        self._obj = obj
    
    def __getattr__(self, name):
        # Делегируем к внутреннему объекту
        return getattr(self._obj, name)
```

**4. Защита атрибутов (`__delattr__`):**
```python
class Protected:
    PROTECTED = {'id', 'created_at'}
    
    def __delattr__(self, name):
        if name in self.PROTECTED:
            raise AttributeError(f"Cannot delete '{name}'")
        super().__delattr__(name)
```

### Практический комплексный пример:

```python
class SmartObject:
    """Умный объект с валидацией, логированием и защитой"""
    
    PROTECTED = {'id', 'created_at'}
    VALIDATORS = {
        'age': lambda v: 0 <= v <= 150,
        'email': lambda v: '@' in str(v),
        'name': lambda v: len(str(v)) >= 2
    }
    
    def __init__(self, id):
        # Инициализация без валидации
        self.__dict__['_log'] = []
        self.__dict__['id'] = id
        self.__dict__['created_at'] = __import__('datetime').datetime.now()
    
    def __getattr__(self, name):
        # Для несуществующих атрибутов возвращаем None
        self._log.append(f"GET (missing): {name}")
        return None
    
    def __setattr__(self, name, value):
        # Валидация
        if name in self.VALIDATORS:
            if not self.VALIDATORS[name](value):
                raise ValueError(f"Invalid value for '{name}': {value}")
        
        # Логирование
        old_value = getattr(self, name, '<not set>')
        self.__dict__['_log'].append(
            f"SET: {name} = {value} (was: {old_value})"
        )
        
        # Установка
        self.__dict__[name] = value
    
    def __delattr__(self, name):
        # Защита
        if name in self.PROTECTED:
            raise AttributeError(f"Cannot delete protected '{name}'")
        
        # Логирование
        self.__dict__['_log'].append(f"DELETE: {name}")
        
        # Удаление
        super().__delattr__(name)
    
    def show_log(self):
        print("\n📋 История операций:")
        for entry in self._log:
            print(f"  {entry}")

# Использование
obj = SmartObject(123)

# Установка валидных значений
obj.name = "Иван"
obj.age = 30
obj.email = "ivan@example.com"

# Попытка установить невалидное значение
try:
    obj.age = 200
except ValueError as e:
    print(f"❌ {e}")

# Доступ к несуществующему атрибуту
print(f"phone: {obj.phone}")  # None

# Удаление обычного атрибута
del obj.email

# Попытка удалить защищенный атрибут
try:
    del obj.id
except AttributeError as e:
    print(f"❌ {e}")

# Просмотр истории
obj.show_log()

# Вывод:
# ❌ Invalid value for 'age': 200
# phone: None
# ❌ Cannot delete protected 'id'
# 
# 📋 История операций:
#   SET: name = Иван (was: <not set>)
#   SET: age = 30 (was: <not set>)
#   SET: email = ivan@example.com (was: <not set>)
#   GET (missing): phone
#   DELETE: email
```

### Важные советы:

**✅ Делайте:**
- Используйте `__getattr__` для несуществующих атрибутов (проще и безопаснее)
- Используйте `super().__setattr__()` или `self.__dict__[name]` в `__setattr__`
- Документируйте поведение ваших магических методов
- Добавляйте валидацию в `__setattr__`
- Логируйте операции для отладки

**❌ Не делайте:**
- Не используйте `__getattribute__` без крайней необходимости
- Не создавайте рекурсию в магических методах
- Не забывайте про `super()` при доступе к реальным атрибутам
- Не делайте слишком сложную логику в этих методах
- Не используйте `self.attr` внутри `__setattr__` и `__getattribute__`

**⚠️ Распространенные ошибки:**

```python
# ❌ ОШИБКА 1: Рекурсия в __getattribute__
class Bad1:
    def __getattribute__(self, name):
        return self.name  # Рекурсия!

# ❌ ОШИБКА 2: Рекурсия в __setattr__
class Bad2:
    def __setattr__(self, name, value):
        self.name = value  # Рекурсия!

# ❌ ОШИБКА 3: Забыли про __init__
class Bad3:
    def __init__(self):
        self.value = 10  # Вызовет __setattr__!
    
    def __setattr__(self, name, value):
        if value < 0:
            raise ValueError("Negative!")
        self.name = value  # Рекурсия + некорректная проверка!

# ✅ ПРАВИЛЬНО:
class Good:
    def __init__(self):
        super().__setattr__('value', 10)
    
    def __setattr__(self, name, value):
        if name == 'value' and value < 0:
            raise ValueError("Negative!")
        super().__setattr__(name, value)
```

### Производительность:

```python
# Магические методы добавляют накладные расходы!

class Normal:
    def __init__(self):
        self.value = 10

class WithSetattr:
    def __setattr__(self, name, value):
        super().__setattr__(name, value)
    
    def __init__(self):
        self.value = 10

# Normal быстрее, чем WithSetattr
# Используйте магические методы только когда нужно!
```

### Альтернативы магическим методам:

Для простых случаев рассмотрите альтернативы:

```python
# Вместо __setattr__ для валидации:
# 1. Property
class WithProperty:
    @property
    def age(self):
        return self._age
    
    @age.setter
    def age(self, value):
        if not 0 <= value <= 150:
            raise ValueError("Invalid age")
        self._age = value

# 2. Dataclass с валидацией
from dataclasses import dataclass

@dataclass
class WithDataclass:
    age: int
    
    def __post_init__(self):
        if not 0 <= self.age <= 150:
            raise ValueError("Invalid age")

# 3. Pydantic (внешняя библиотека)
from pydantic import BaseModel, validator

class WithPydantic(BaseModel):
    age: int
    
    @validator('age')
    def validate_age(cls, v):
        if not 0 <= v <= 150:
            raise ValueError("Invalid age")
        return v
```

### Когда использовать каждый метод:

**`__getattr__`** — используйте часто:
- ✅ Динамические атрибуты
- ✅ Значения по умолчанию
- ✅ Прокси-объекты
- ✅ Ленивая загрузка

**`__setattr__`** — используйте умеренно:
- ✅ Валидация всех атрибутов
- ✅ Логирование изменений
- ✅ Вычисляемые атрибуты
- ⚠️ Осторожно с `__init__`

**`__delattr__`** — используйте редко:
- ✅ Защита критичных атрибутов
- ✅ Очистка ресурсов
- ✅ Каскадное удаление

**`__getattribute__`** — используйте очень редко:
- ⚠️ Только для низкоуровневых операций
- ⚠️ Перехват доступа ко всем атрибутам
- ⚠️ Высокий риск ошибок

### Финальный совет:

Магические методы работы с атрибутами — мощный инструмент, но:
- 🎯 Используйте их только когда действительно нужно
- 📖 Документируйте нестандартное поведение
- 🧪 Тщательно тестируйте
- 🔍 Рассмотрите более простые альтернативы (property, dataclass)
- ⚡ Помните о производительности

Для большинства случаев достаточно `__getattr__` и `__setattr__`. `__getattribute__` нужен очень редко, и его использование требует особой осторожности.

## `27.6` Хэширование
**Хеширование** — процесс преобразования объекта в целое число (hash), которое используется для быстрого поиска и сравнения объектов.

**Магические методы:**
- `__hash__()` — возвращает хеш объекта (целое число)
- `__eq__()` — определяет равенство объектов

**Зачем нужно хеширование:**
- 📦 Использование объектов как **ключей словаря**
- 🔍 Добавление объектов в **множества** (`set`)
- ⚡ **Быстрый поиск** — O(1) вместо O(n)
- 🎯 **Уникальность** — идентификация объектов

**Важные правила:**

1. **Связь с `__eq__`:**
   - Если `a == b`, то `hash(a) == hash(b)` (обязательно!)
   - Если `hash(a) == hash(b)`, то `a == b` (не обязательно, но желательно)

2. **Неизменяемость:**
   - Хешируемые объекты должны быть **неизменяемыми**
   - Изменяемые объекты (list, dict, set) не хешируются по умолчанию

3. **Стабильность:**
   - Хеш объекта не должен меняться во время жизни объекта

**По умолчанию:**
```python
# Встроенные неизменяемые типы - хешируемые
hash(42)           # OK
hash("text")       # OK
hash((1, 2, 3))    # OK

# Изменяемые типы - не хешируемые
hash([1, 2, 3])    # TypeError
hash({1: 2})       # TypeError
```

**Использование:**
```python
# Объект как ключ словаря
my_dict = {obj: "value"}

# Объект в множестве
my_set = {obj1, obj2, obj3}

# Проверка хешируемости
hash(obj)  # Если не вызывает ошибку, объект хешируемый
```

**Примеры:**

```python
# Пример 1: Базовое хеширование на основе атрибутов
class Point:
    """Точка на плоскости (неизменяемая)"""
    
    def __init__(self, x, y):
        self._x = x
        self._y = y
    
    @property
    def x(self):
        return self._x
    
    @property
    def y(self):
        return self._y
    
    def __eq__(self, other):
        """Равенство: координаты совпадают"""
        if not isinstance(other, Point):
            return False
        return self.x == other.x and self.y == other.y
    
    def __hash__(self):
        """Хеш на основе координат"""
        # Используем tuple для хеширования нескольких значений
        return hash((self.x, self.y))
    
    def __repr__(self):
        return f"Point({self.x}, {self.y})"

# Создаем точки
p1 = Point(10, 20)
p2 = Point(10, 20)  # такие же координаты
p3 = Point(30, 40)

# Проверка равенства и хеша
print(p1 == p2)  # True
print(hash(p1))  # например: 3713081631934410656
print(hash(p2))  # такой же хеш!
print(hash(p3))  # другой хеш

# Использование как ключи словаря
points_data = {
    p1: "Начало",
    p3: "Конец"
}
print(points_data[p2])  # "Начало" (p2 == p1, найдено!)

# Использование в множестве
points_set = {p1, p2, p3}  # p1 и p2 считаются одинаковыми
print(len(points_set))  # 2 (не 3!)
print(points_set)  # {Point(10, 20), Point(30, 40)}

# Быстрый поиск
print(Point(10, 20) in points_set)  # True (очень быстро!)
print(Point(100, 200) in points_set)  # False
```

```python
# Пример 2: Хеширование составного ключа
class Student:
    """Студент с уникальным ID и именем"""
    
    def __init__(self, student_id, name, year):
        self.student_id = student_id  # уникальный ID
        self.name = name
        self.year = year
    
    def __eq__(self, other):
        """Равенство только по ID (ID уникален)"""
        if not isinstance(other, Student):
            return False
        return self.student_id == other.student_id
    
    def __hash__(self):
        """Хеш только по ID (неизменяемому идентификатору)"""
        # Хешируем только неизменяемую часть!
        return hash(self.student_id)
    
    def __repr__(self):
        return f"Student({self.student_id}, '{self.name}')"

# Создаем студентов
s1 = Student(101, "Иван", 2023)
s2 = Student(101, "Иван Иванов", 2024)  # тот же ID!
s3 = Student(102, "Мария", 2023)

# Равенство по ID
print(s1 == s2)  # True (одинаковый ID)
print(hash(s1) == hash(s2))  # True (одинаковый хеш)

# Словарь с оценками студентов
grades = {
    s1: [5, 4, 5],
    s3: [4, 5, 4]
}

# Можем найти по любому объекту с тем же ID
print(grades[s2])  # [5, 4, 5] (найдено через s1!)

# Множество студентов (без дубликатов)
students = {s1, s2, s3}
print(len(students))  # 2 (s1 и s2 считаются одинаковыми)
print(students)  # {Student(101, 'Иван'), Student(102, 'Мария')}

# Проверка наличия
print(Student(101, "Любое имя", 9999) in students)  # True (по ID!)
```

```python
# Пример 3: Запрет хеширования изменяемых объектов
class MutablePoint:
    """Изменяемая точка (НЕ хешируемая)"""
    
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __eq__(self, other):
        if not isinstance(other, MutablePoint):
            return False
        return self.x == other.x and self.y == other.y
    
    def __hash__(self):
        """Запрещаем хеширование изменяемого объекта"""
        raise TypeError(f"unhashable type: '{type(self).__name__}'")
    
    def __repr__(self):
        return f"MutablePoint({self.x}, {self.y})"

# Создаем изменяемую точку
mp = MutablePoint(10, 20)

# Можно изменять
mp.x = 30
print(mp)  # MutablePoint(30, 20)

# Нельзя использовать как ключ словаря
try:
    d = {mp: "value"}
except TypeError as e:
    print(f"Ошибка: {e}")
    # Ошибка: unhashable type: 'MutablePoint'

# Нельзя добавить в множество
try:
    s = {mp}
except TypeError as e:
    print(f"Ошибка: {e}")

# Решение: сделать неизменяемым или не использовать в set/dict
```

**Шпаргалка по хешированию:**

### Базовая реализация:

```python
class MyClass:
    def __init__(self, id, name):
        self.id = id      # неизменяемый идентификатор
        self.name = name  # может меняться
    
    def __eq__(self, other):
        if not isinstance(other, MyClass):
            return False
        return self.id == other.id
    
    def __hash__(self):
        # Хешируем только неизменяемые атрибуты!
        return hash(self.id)
```

### Хеширование нескольких атрибутов:

```python
class Person:
    def __init__(self, name, birth_date):
        self.name = name
        self.birth_date = birth_date
    
    def __hash__(self):
        # Хешируем tuple из атрибутов
        return hash((self.name, self.birth_date))
    
    def __eq__(self, other):
        if not isinstance(other, Person):
            return False
        return (self.name == other.name and 
                self.birth_date == other.birth_date)
```

### Запрет хеширования:

```python
class Mutable:
    # Явно запрещаем хеширование
    __hash__ = None
    
    def __eq__(self, other):
        # Определяем равенство, но не хеш
        return self.value == other.value
```

### Проверка хешируемости:

```python
from collections.abc import Hashable

obj = MyClass(1, "test")
print(isinstance(obj, Hashable))  # True, если хешируемый

# Или через hash()
try:
    hash(obj)
    print("Хешируемый")
except TypeError:
    print("Не хешируемый")
```

### Важные правила:

**✅ Делайте:**
- Хешируйте только неизменяемые атрибуты
- Обязательно определяйте `__eq__` вместе с `__hash__`
- Используйте `hash(tuple(...))` для нескольких атрибутов
- Делайте объекты неизменяемыми, если нужно хеширование

**❌ Не делайте:**
- Не хешируйте изменяемые атрибуты
- Не меняйте хеш объекта во время жизни
- Не определяйте `__hash__` без `__eq__`
- Не используйте случайные значения в `__hash__`

### Примеры правильного и неправильного:

```python
# ❌ НЕПРАВИЛЬНО: хеш изменяемого атрибута
class Bad:
    def __init__(self, value):
        self.value = value  # может меняться!
    
    def __hash__(self):
        return hash(self.value)  # Плохо!
    
    def __eq__(self, other):
        return self.value == other.value

# ✅ ПРАВИЛЬНО: хеш неизменяемого ID
class Good:
    def __init__(self, id, value):
        self.id = id        # не меняется
        self.value = value  # может меняться
    
    def __hash__(self):
        return hash(self.id)  # Хорошо!
    
    def __eq__(self, other):
        return self.id == other.id
```

### Встроенные типы:

```python
# Неизменяемые - хешируемые
hash(42)              # int
hash(3.14)            # float
hash("text")          # str
hash((1, 2))          # tuple
hash(True)            # bool
hash(None)            # NoneType

# Изменяемые - НЕ хешируемые
hash([1, 2])          # list - TypeError
hash({1, 2})          # set - TypeError
hash({"a": 1})        # dict - TypeError
```

### Практическое применение:

```python
# Кеширование результатов
cache = {}

def expensive_function(point):
    """Дорогая функция с кешированием"""
    if point in cache:
        print("Возврат из кеша")
        return cache[point]
    
    # Вычисление
    result = point.x ** 2 + point.y ** 2
    cache[point] = result
    return result

p1 = Point(3, 4)
print(expensive_function(p1))  # Вычисление
print(expensive_function(p1))  # Возврат из кеша

# Уникальные элементы
points = [Point(1, 1), Point(2, 2), Point(1, 1), Point(3, 3)]
unique_points = set(points)  # Автоматически убирает дубликаты
print(len(unique_points))  # 3 (не 4!)
```

Хеширование — ключевая возможность для использования пользовательских объектов в словарях и множествах. Главное правило: **если объект хешируемый, он должен быть неизменяемым** (или хешировать только неизменяемую часть).

## `27.7` (`**`) Ultra flex
### Унарные операторы

**Унарные операторы** — операторы, которые применяются к одному операнду.

**Магические методы для унарных операторов:**

| Оператор | Метод | Описание | Пример |
|----------|-------|----------|--------|
| `-obj` | `__neg__` | Унарный минус (отрицание) | `-5` |
| `+obj` | `__pos__` | Унарный плюс | `+5` |
| `~obj` | `__invert__` | Побитовая инверсия | `~5` |
| `abs(obj)` | `__abs__` | Абсолютное значение | `abs(-5)` |

**Зачем нужны:**
- 🔢 Математические операции с пользовательскими типами
- 🎯 Естественный синтаксис для объектов
- 🔄 Инверсия состояния или значения

**Примеры:**

```python
# Пример 1: Векторы с унарными операторами
class Vector:
    """Математический вектор с унарными операциями"""
    
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __neg__(self):
        """Унарный минус: меняет направление вектора"""
        return Vector(-self.x, -self.y)
    
    def __pos__(self):
        """Унарный плюс: возвращает копию"""
        return Vector(self.x, self.y)
    
    def __abs__(self):
        """Абсолютное значение: длина вектора"""
        return (self.x ** 2 + self.y ** 2) ** 0.5
    
    def __invert__(self):
        """Инверсия: меняет компоненты местами"""
        return Vector(self.y, self.x)
    
    def __repr__(self):
        return f"Vector({self.x}, {self.y})"

# Создаем вектор
v = Vector(3, 4)
print(v)  # Vector(3, 4)

# Унарный минус - противоположный вектор
neg_v = -v
print(neg_v)  # Vector(-3, -4)

# Унарный плюс - копия
pos_v = +v
print(pos_v)  # Vector(3, 4)

# Абсолютное значение - длина вектора
length = abs(v)
print(f"Длина вектора: {length}")  # 5.0

# Инверсия - меняем компоненты
inv_v = ~v
print(inv_v)  # Vector(4, 3)

# Цепочка операций
result = -~v  # сначала ~, потом -
print(result)  # Vector(-4, -3)
```

```python
# Пример 2: Температура с преобразованиями
class Temperature:
    """Температура с унарными операторами"""
    
    def __init__(self, celsius):
        self.celsius = celsius
    
    def __neg__(self):
        """Отрицательная температура"""
        return Temperature(-self.celsius)
    
    def __pos__(self):
        """Положительная (абсолютная) температура"""
        return Temperature(abs(self.celsius))
    
    def __abs__(self):
        """Абсолютное значение температуры"""
        return abs(self.celsius)
    
    def __invert__(self):
        """Инверсия: конвертация Цельсий ↔ Фаренгейт (упрощенно)"""
        # Если положительная - в Фаренгейт, если отрицательная - обратно
        if self.celsius >= 0:
            fahrenheit = self.celsius * 9/5 + 32
            return Temperature(fahrenheit)
        else:
            # Обратное преобразование
            celsius = (abs(self.celsius) - 32) * 5/9
            return Temperature(-celsius)
    
    def __repr__(self):
        return f"{self.celsius}°C"

temp = Temperature(25)
print(temp)  # 25°C

# Отрицание
cold = -temp
print(cold)  # -25°C

# Абсолютное значение
print(abs(cold))  # 25

# Конвертация
fahrenheit = ~temp
print(fahrenheit)  # 77.0°C (это 77°F в нашей системе)
```

```python
# Пример 3: Логическое состояние
class State:
    """Состояние с возможностью инверсии"""
    
    def __init__(self, value):
        self.value = value
    
    def __invert__(self):
        """Инверсия состояния (не/да, вкл/выкл)"""
        return State(not self.value)
    
    def __bool__(self):
        """Приведение к bool"""
        return self.value
    
    def __repr__(self):
        return f"State({'ON' if self.value else 'OFF'})"

# Создаем состояние
state = State(True)
print(state)  # State(ON)

# Инверсия состояния
off_state = ~state
print(off_state)  # State(OFF)

# Двойная инверсия
back_on = ~~state
print(back_on)  # State(ON)

# Использование в условиях
if state:
    print("Включено")  # Включено

if not ~state:
    print("После инверсии выключено")
```


### Арифметические операции

**Арифметические магические методы** позволяют использовать стандартные математические операторы с пользовательскими объектами.

**Основные операторы:**

| Оператор | Метод | Обратный метод | Метод на месте | Описание |
|----------|-------|----------------|----------------|----------|
| `+` | `__add__` | `__radd__` | `__iadd__` | Сложение |
| `-` | `__sub__` | `__rsub__` | `__isub__` | Вычитание |
| `*` | `__mul__` | `__rmul__` | `__imul__` | Умножение |
| `/` | `__truediv__` | `__rtruediv__` | `__itruediv__` | Деление |
| `//` | `__floordiv__` | `__rfloordiv__` | `__ifloordiv__` | Целочисленное деление |
| `%` | `__mod__` | `__rmod__` | `__imod__` | Остаток |
| `**` | `__pow__` | `__rpow__` | `__ipow__` | Возведение в степень |

**Обратные методы (`__radd__`, `__rsub__` и т.д.):**
- Вызываются, когда левый операнд не поддерживает операцию
- Пример: `5 + obj` → вызовет `obj.__radd__(5)`

**Методы на месте (`__iadd__`, `__isub__` и т.д.):**
- Для операторов `+=`, `-=`, `*=` и т.д.
- Изменяют объект на месте (если это нужно)

**Примеры:**

```python
# Пример 1: Комплексные числа (упрощенная версия)
class Complex:
    """Комплексное число a + bi"""
    
    def __init__(self, real, imag):
        self.real = real
        self.imag = imag
    
    def __add__(self, other):
        """Сложение комплексных чисел"""
        if isinstance(other, Complex):
            return Complex(self.real + other.real, self.imag + other.imag)
        # Сложение с обычным числом
        return Complex(self.real + other, self.imag)
    
    def __radd__(self, other):
        """Обратное сложение: 5 + complex"""
        return self.__add__(other)
    
    def __sub__(self, other):
        """Вычитание"""
        if isinstance(other, Complex):
            return Complex(self.real - other.real, self.imag - other.imag)
        return Complex(self.real - other, self.imag)
    
    def __mul__(self, other):
        """Умножение: (a+bi)(c+di) = (ac-bd) + (ad+bc)i"""
        if isinstance(other, Complex):
            real = self.real * other.real - self.imag * other.imag
            imag = self.real * other.imag + self.imag * other.real
            return Complex(real, imag)
        # Умножение на скаляр
        return Complex(self.real * other, self.imag * other)
    
    def __rmul__(self, other):
        """Обратное умножение: 5 * complex"""
        return self.__mul__(other)
    
    def __truediv__(self, other):
        """Деление"""
        if isinstance(other, (int, float)):
            return Complex(self.real / other, self.imag / other)
        raise NotImplementedError("Деление комплексных чисел")
    
    def __abs__(self):
        """Модуль комплексного числа"""
        return (self.real ** 2 + self.imag ** 2) ** 0.5
    
    def __repr__(self):
        sign = '+' if self.imag >= 0 else ''
        return f"{self.real}{sign}{self.imag}i"

# Создаем комплексные числа
c1 = Complex(3, 4)   # 3+4i
c2 = Complex(1, -2)  # 1-2i

print(f"c1 = {c1}")  # 3+4i
print(f"c2 = {c2}")  # 1-2i

# Сложение
c3 = c1 + c2
print(f"{c1} + {c2} = {c3}")  # 3+4i + 1-2i = 4+2i

# Вычитание
c4 = c1 - c2
print(f"{c1} - {c2} = {c4}")  # 3+4i - 1-2i = 2+6i

# Умножение
c5 = c1 * c2
print(f"{c1} * {c2} = {c5}")  # 3+4i * 1-2i = 11+(-2)i

# Умножение на скаляр
c6 = c1 * 2
print(f"{c1} * 2 = {c6}")  # 6+8i

# Обратное умножение
c7 = 3 * c1
print(f"3 * {c1} = {c7}")  # 9+12i

# Деление на скаляр
c8 = c1 / 2
print(f"{c1} / 2 = {c8}")  # 1.5+2.0i

# Модуль
print(f"|{c1}| = {abs(c1)}")  # |3+4i| = 5.0
```

```python
# Пример 2: Денежные суммы
class Money:
    """Денежная сумма с валютой"""
    
    def __init__(self, amount, currency="RUB"):
        self.amount = amount
        self.currency = currency
    
    def __add__(self, other):
        """Сложение денег"""
        if isinstance(other, Money):
            if self.currency != other.currency:
                raise ValueError(f"Нельзя складывать {self.currency} и {other.currency}")
            return Money(self.amount + other.amount, self.currency)
        # Добавление числа
        return Money(self.amount + other, self.currency)
    
    def __radd__(self, other):
        """Обратное сложение: 100 + money"""
        return self.__add__(other)
    
    def __sub__(self, other):
        """Вычитание"""
        if isinstance(other, Money):
            if self.currency != other.currency:
                raise ValueError(f"Нельзя вычитать {other.currency} из {self.currency}")
            return Money(self.amount - other.amount, self.currency)
        return Money(self.amount - other, self.currency)
    
    def __mul__(self, other):
        """Умножение на число (например, налог, скидка)"""
        if isinstance(other, (int, float)):
            return Money(self.amount * other, self.currency)
        raise TypeError("Можно умножать только на число")
    
    def __rmul__(self, other):
        """Обратное умножение: 2 * money"""
        return self.__mul__(other)
    
    def __truediv__(self, other):
        """Деление на число"""
        if isinstance(other, (int, float)):
            return Money(self.amount / other, self.currency)
        raise TypeError("Можно делить только на число")
    
    def __iadd__(self, other):
        """Оператор += (на месте)"""
        if isinstance(other, Money):
            if self.currency != other.currency:
                raise ValueError(f"Нельзя складывать {self.currency} и {other.currency}")
            self.amount += other.amount
        else:
            self.amount += other
        return self
    
    def __repr__(self):
        return f"{self.amount} {self.currency}"

# Использование
price = Money(1000, "RUB")
tax = Money(200, "RUB")

# Сложение
total = price + tax
print(f"Итого: {total}")  # Итого: 1200 RUB

# Вычитание
discount = Money(150, "RUB")
final = total - discount
print(f"Со скидкой: {final}")  # Со скидкой: 1050 RUB

# Умножение (налог 13%)
tax_amount = price * 0.13
print(f"Налог 13%: {tax_amount}")  # Налог 13%: 130.0 RUB

# Обратное умножение
double = 2 * price
print(f"Удвоенная цена: {double}")  # Удвоенная цена: 2000 RUB

# Деление пополам
half = price / 2
print(f"Половина: {half}")  # Половина: 500.0 RUB

# Оператор на месте +=
budget = Money(5000, "RUB")
print(f"Бюджет до: {budget}")
budget += price
print(f"Бюджет после: {budget}")  # Бюджет после: 6000 RUB

# Сложение с числом
result = price + 500
print(f"С доплатой: {result}")  # С доплатой: 1500 RUB

# Ошибка при смешивании валют
try:
    dollars = Money(100, "USD")
    mixed = price + dollars
except ValueError as e:
    print(f"Ошибка: {e}")  # Ошибка: Нельзя складывать RUB и USD
```

```python
# Пример 3: Дроби (рациональные числа)
from math import gcd

class Fraction:
    """Математическая дробь a/b"""
    
    def __init__(self, numerator, denominator=1):
        if denominator == 0:
            raise ValueError("Знаменатель не может быть нулем")
        
        # Сокращаем дробь
        common = gcd(abs(numerator), abs(denominator))
        self.numerator = numerator // common
        self.denominator = denominator // common
        
        # Знак всегда в числителе
        if self.denominator < 0:
            self.numerator = -self.numerator
            self.denominator = -self.denominator
    
    def __add__(self, other):
        """Сложение дробей: a/b + c/d = (ad + bc) / bd"""
        if isinstance(other, Fraction):
            num = self.numerator * other.denominator + other.numerator * self.denominator
            den = self.denominator * other.denominator
            return Fraction(num, den)
        # Сложение с целым числом
        return Fraction(self.numerator + other * self.denominator, self.denominator)
    
    def __radd__(self, other):
        return self.__add__(other)
    
    def __sub__(self, other):
        """Вычитание"""
        if isinstance(other, Fraction):
            num = self.numerator * other.denominator - other.numerator * self.denominator
            den = self.denominator * other.denominator
            return Fraction(num, den)
        return Fraction(self.numerator - other * self.denominator, self.denominator)
    
    def __mul__(self, other):
        """Умножение: (a/b) * (c/d) = ac / bd"""
        if isinstance(other, Fraction):
            return Fraction(self.numerator * other.numerator, 
                          self.denominator * other.denominator)
        return Fraction(self.numerator * other, self.denominator)
    
    def __rmul__(self, other):
        return self.__mul__(other)
    
    def __truediv__(self, other):
        """Деление: (a/b) / (c/d) = (a/b) * (d/c)"""
        if isinstance(other, Fraction):
            return Fraction(self.numerator * other.denominator,
                          self.denominator * other.numerator)
        return Fraction(self.numerator, self.denominator * other)
    
    def __float__(self):
        """Преобразование в float"""
        return self.numerator / self.denominator
    
    def __repr__(self):
        if self.denominator == 1:
            return str(self.numerator)
        return f"{self.numerator}/{self.denominator}"

# Создаем дроби
f1 = Fraction(1, 2)   # 1/2
f2 = Fraction(1, 3)   # 1/3
f3 = Fraction(2, 4)   # 2/4 = 1/2 (автоматически сокращается)

print(f"f1 = {f1}")  # 1/2
print(f"f2 = {f2}")  # 1/3
print(f"f3 = {f3}")  # 1/2 (сокращено!)

# Сложение
result = f1 + f2
print(f"{f1} + {f2} = {result}")  # 1/2 + 1/3 = 5/6

# Вычитание
result = f1 - f2
print(f"{f1} - {f2} = {result}")  # 1/2 - 1/3 = 1/6

# Умножение
result = f1 * f2
print(f"{f1} * {f2} = {result}")  # 1/2 * 1/3 = 1/6

# Деление
result = f1 / f2
print(f"{f1} / {f2} = {result}")  # 1/2 / 1/3 = 3/2

# Операции с целыми числами
result = f1 + 1
print(f"{f1} + 1 = {result}")  # 1/2 + 1 = 3/2

result = 2 * f1
print(f"2 * {f1} = {result}")  # 2 * 1/2 = 1

# Преобразование в float
print(f"{f1} = {float(f1)}")  # 1/2 = 0.5
print(f"{result} = {float(result)}")  # 5/6 = 0.8333...
```


### Преобразование типов

**Магические методы преобразования** позволяют конвертировать объекты в стандартные типы Python.

**Основные методы:**

| Метод | Функция | Результат | Описание |
|-------|---------|-----------|----------|
| `__int__` | `int(obj)` | `int` | Целое число |
| `__float__` | `float(obj)` | `float` | Число с плавающей точкой |
| `__bool__` | `bool(obj)` | `bool` | Булево значение |
| `__str__` | `str(obj)` | `str` | Строка (для пользователей) |
| `__bytes__` | `bytes(obj)` | `bytes` | Байтовая строка |
| `__complex__` | `complex(obj)` | `complex` | Комплексное число |

**Зачем нужны:**
- 🔄 Естественная конвертация объектов
- 🎯 Использование в арифметических выражениях
- ✅ Проверка в условиях (`if obj:`)
- 📊 Интеграция с встроенными функциями

**Примеры:**

```python
# Пример 1: Температура с преобразованиями
class Temperature:
    """Температура с автоматическими преобразованиями"""
    
    def __init__(self, celsius):
        self.celsius = celsius
    
    def __int__(self):
        """Преобразование в целое число (округление)"""
        return int(self.celsius)
    
    def __float__(self):
        """Преобразование в float"""
        return float(self.celsius)
    
    def __bool__(self):
        """True если температура выше нуля"""
        return self.celsius > 0
    
    def __str__(self):
        """Строковое представление"""
        return f"{self.celsius}°C"
    
    def __repr__(self):
        return f"Temperature({self.celsius})"

# Создаем температуры
temp1 = Temperature(25.7)
temp2 = Temperature(-5.3)
temp3 = Temperature(0)

# Преобразование в int
print(f"int({temp1}) = {int(temp1)}")  # int(25.7°C) = 25
print(f"int({temp2}) = {int(temp2)}")  # int(-5.3°C) = -5

# Преобразование в float
print(f"float({temp1}) = {float(temp1)}")  # float(25.7°C) = 25.7

# Использование в арифметике
result = int(temp1) + 10
print(f"Температура + 10 = {result}")  # 35

# Преобразование в bool (проверка условий)
if temp1:
    print(f"{temp1} - положительная температура")  # выполнится
else:
    print(f"{temp1} - отрицательная температура")

if temp2:
    print(f"{temp2} - положительная")
else:
    print(f"{temp2} - отрицательная")  # выполнится

# Использование в списках
temps = [temp1, temp2, temp3]
positive_temps = [t for t in temps if t]  # только положительные
print(f"Положительные: {positive_temps}")  # [Temperature(25.7)]

# Сортировка (использует __float__ или __int__)
sorted_temps = sorted(temps, key=float)
print(f"Отсортированные: {sorted_temps}")
# [Temperature(-5.3), Temperature(0), Temperature(25.7)]
```

```python
# Пример 2: Счетчик с преобразованиями
class Counter:
    """Счетчик со встроенными преобразованиями"""
    
    def __init__(self, start=0):
        self.count = start
    
    def increment(self):
        self.count += 1
    
    def __int__(self):
        """Текущее значение как int"""
        return self.count
    
    def __float__(self):
        """Текущее значение как float"""
        return float(self.count)
    
    def __bool__(self):
        """True если счетчик > 0"""
        return self.count > 0
    
    def __str__(self):
        return f"Counter: {self.count}"
    
    def __add__(self, other):
        """Сложение со счетчиком или числом"""
        if isinstance(other, Counter):
            return Counter(self.count + other.count)
        return Counter(self.count + other)
    
    def __radd__(self, other):
        """Обратное сложение"""
        return self.__add__(other)

# Создаем счетчики
c1 = Counter(5)
c2 = Counter(3)
c3 = Counter(0)

# Преобразование в число
print(f"int(c1) = {int(c1)}")  # 5
print(f"float(c1) = {float(c1)}")  # 5.0

# Использование в арифметике
total = int(c1) + int(c2)
print(f"Сумма счетчиков: {total}")  # 8

# Сложение счетчиков
c4 = c1 + c2
print(f"c1 + c2 = {c4}")  # Counter: 8

# Сложение с числом
c5 = c1 + 10
print(f"c1 + 10 = {c5}")  # Counter: 15

# Обратное сложение
c6 = 20 + c1
print(f"20 + c1 = {c6}")  # Counter: 25

# Проверка в условиях
if c1:
    print(f"{c1} - не пустой")  # выполнится

if not c3:
    print(f"{c3} - пустой")  # выполнится

# Использование с sum()
counters = [Counter(5), Counter(10), Counter(15)]
total_sum = sum(counters, Counter(0))  # нужен start=Counter(0)
print(f"Сумма всех: {total_sum}")  # Counter: 30
```

```python
# Пример 3: Рейтинг с преобразованиями
class Rating:
    """Рейтинг из 5 звезд"""
    
    def __init__(self, stars):
        if not 0 <= stars <= 5:
            raise ValueError("Рейтинг должен быть от 0 до 5")
        self.stars = stars
    
    def __int__(self):
        """Целая часть рейтинга"""
        return int(self.stars)
    
    def __float__(self):
        """Точный рейтинг"""
        return float(self.stars)
    
    def __bool__(self):
        """True если есть хотя бы 1 звезда"""
        return self.stars >= 1
    
    def __str__(self):
        """Визуальное представление звездами"""
        full_stars = int(self.stars)
        has_half = (self.stars - full_stars) >= 0.5
        empty_stars = 5 - full_stars - (1 if has_half else 0)
        
        result = "★" * full_stars
        if has_half:
            result += "½"
        result += "☆" * empty_stars
        
        return f"{result} ({self.stars}/5)"
    
    def __repr__(self):
        return f"Rating({self.stars})"
    
    def __add__(self, other):
        """Сложение рейтингов (среднее)"""
        if isinstance(other, Rating):
            avg = (self.stars + other.stars) / 2
            return Rating(avg)
        raise TypeError("Можно складывать только с Rating")

# Создаем рейтинги
r1 = Rating(4.5)
r2 = Rating(3.0)
r3 = Rating(5.0)
r4 = Rating(0.5)

# Визуализация
print(r1)  # ★★★★½ (4.5/5)
print(r2)  # ★★★☆☆ (3.0/5)
print(r3)  # ★★★★★ (5.0/5)
print(r4)  # ½☆☆☆☆ (0.5/5)

# Преобразование в число
print(f"int({r1}) = {int(r1)}")  # 4
print(f"float({r1}) = {float(r1)}")  # 4.5

# Использование в условиях
if r1:
    print(f"{r1} - положительный рейтинг")  # выполнится

if not Rating(0):
    print("Нулевой рейтинг = False")  # выполнится

# Среднее двух рейтингов
avg = r1 + r2
print(f"Средний рейтинг: {avg}")  # ★★★★☆ (3.75/5)

# Подсчет среднего рейтинга товара
ratings = [Rating(5), Rating(4), Rating(5), Rating(3), Rating(4)]
average_rating = sum(map(float, ratings)) / len(ratings)
final_rating = Rating(average_rating)
print(f"Средний рейтинг товара: {final_rating}")  # ★★★★☆ (4.2/5)

# Фильтрация хороших рейтингов (>= 4 звезды)
good_ratings = [r for r in ratings if float(r) >= 4.0]
print(f"Хороших рейтингов: {len(good_ratings)} из {len(ratings)}")  # 4 из 5
```


**Итоговая шпаргалка:**

### Унарные операторы:
```python
-obj   →   __neg__(self)     # унарный минус
+obj   →   __pos__(self)     # унарный плюс
~obj   →   __invert__(self)  # побитовая инверсия
abs(obj) → __abs__(self)     # абсолютное значение
```

### Арифметические операторы:
```python
obj + other  →  __add__(self, other)
other + obj  →  __radd__(self, other)   # обратное сложение
obj += other →  __iadd__(self, other)   # сложение на месте

obj - other  →  __sub__(self, other)
obj * other  →  __mul__(self, other)
obj / other  →  __truediv__(self, other)
obj // other →  __floordiv__(self, other)
obj % other  →  __mod__(self, other)
obj ** other →  __pow__(self, other)
```

### Преобразования типов:
```python
int(obj)     →  __int__(self)
float(obj)   →  __float__(self)
bool(obj)    →  __bool__(self)
str(obj)     →  __str__(self)
bytes(obj)   →  __bytes__(self)
complex(obj) →  __complex__(self)
```

### Когда что использовать:

**Унарные операторы:**
- `__neg__` — для математических объектов (векторы, матрицы)
- `__pos__` — редко нужен, обычно возвращает копию
- `__abs__` — для объектов с понятием "величины" (длина, модуль)
- `__invert__` — для битовых операций или логической инверсии

**Арифметические операторы:**
- Определяйте для математических типов (числа, векторы, матрицы)
- Используйте `__radd__` для коммутативности: `5 + obj` = `obj + 5`
- `__iadd__` для оптимизации изменяемых объектов
- Возвращайте `NotImplemented` для несовместимых типов

**Преобразования:**
- `__int__`, `__float__` — для числовых объектов
- `__bool__` — почти всегда нужен (для `if obj:`)
- `__str__` — всегда определяйте (для `print()`)

### Важные правила:

**✅ Делайте:**
```python
class Good:
    def __add__(self, other):
        if isinstance(other, Good):
            return Good(self.value + other.value)
        elif isinstance(other, (int, float)):
            return Good(self.value + other)
        return NotImplemented  # для других типов
    
    def __radd__(self, other):
        return self.__add__(other)  # переиспользуем логику
```

**❌ Не делайте:**
```python
class Bad:
    def __add__(self, other):
        # Плохо: изменяет self
        self.value += other.value
        return self
    
    def __radd__(self, other):
        # Плохо: разная логика
        return other + self.value  # может вызвать рекурсию!
```

### Полный пример класса с всеми операциями:

```python
class Quantity:
    """Физическая величина с единицами измерения"""
    
    def __init__(self, value, unit=""):
        self.value = value
        self.unit = unit
    
    # Унарные операторы
    def __neg__(self):
        return Quantity(-self.value, self.unit)
    
    def __pos__(self):
        return Quantity(+self.value, self.unit)
    
    def __abs__(self):
        return Quantity(abs(self.value), self.unit)
    
    # Арифметические операторы
    def __add__(self, other):
        if isinstance(other, Quantity):
            if self.unit != other.unit:
                raise ValueError(f"Нельзя складывать {self.unit} и {other.unit}")
            return Quantity(self.value + other.value, self.unit)
        return Quantity(self.value + other, self.unit)
    
    def __radd__(self, other):
        return self.__add__(other)
    
    def __sub__(self, other):
        if isinstance(other, Quantity):
            if self.unit != other.unit:
                raise ValueError(f"Нельзя вычитать {other.unit} из {self.unit}")
            return Quantity(self.value - other.value, self.unit)
        return Quantity(self.value - other, self.unit)
    
    def __mul__(self, other):
        if isinstance(other, Quantity):
            # Умножение величин (например, м * м = м²)
            new_unit = f"{self.unit}·{other.unit}" if self.unit and other.unit else ""
            return Quantity(self.value * other.value, new_unit)
        return Quantity(self.value * other, self.unit)
    
    def __rmul__(self, other):
        return self.__mul__(other)
    
    def __truediv__(self, other):
        if isinstance(other, Quantity):
            # Деление величин
            new_unit = f"{self.unit}/{other.unit}" if other.unit else self.unit
            return Quantity(self.value / other.value, new_unit)
        return Quantity(self.value / other, self.unit)
    
    # Преобразования типов
    def __int__(self):
        return int(self.value)
    
    def __float__(self):
        return float(self.value)
    
    def __bool__(self):
        return self.value != 0
    
    def __str__(self):
        return f"{self.value} {self.unit}".strip()
    
    def __repr__(self):
        return f"Quantity({self.value}, '{self.unit}')"
    
    # Сравнение
    def __eq__(self, other):
        if isinstance(other, Quantity):
            return self.value == other.value and self.unit == other.unit
        return self.value == other
    
    def __lt__(self, other):
        if isinstance(other, Quantity):
            if self.unit != other.unit:
                raise ValueError(f"Нельзя сравнивать {self.unit} и {other.unit}")
            return self.value < other.value
        return self.value < other

# Использование всех возможностей
distance1 = Quantity(100, "м")
distance2 = Quantity(50, "м")
time = Quantity(10, "с")

print("=== Унарные операторы ===")
print(f"-{distance1} = {-distance1}")  # -100 м
print(f"abs({-distance1}) = {abs(-distance1)}")  # 100 м

print("\n=== Арифметика ===")
total_distance = distance1 + distance2
print(f"{distance1} + {distance2} = {total_distance}")  # 150 м

difference = distance1 - distance2
print(f"{distance1} - {distance2} = {difference}")  # 50 м

speed = distance1 / time
print(f"{distance1} / {time} = {speed}")  # 10.0 м/с

area = distance1 * distance2
print(f"{distance1} * {distance2} = {area}")  # 5000 м·м

doubled = 2 * distance1
print(f"2 * {distance1} = {doubled}")  # 200 м

print("\n=== Преобразования ===")
print(f"int({distance1}) = {int(distance1)}")  # 100
print(f"float({speed}) = {float(speed)}")  # 10.0

print("\n=== Условия ===")
if distance1:
    print(f"{distance1} - ненулевое")  # выполнится

if not Quantity(0, "м"):
    print("Нулевое расстояние = False")  # выполнится

print("\n=== Сравнение ===")
print(f"{distance1} > {distance2}: {distance1 > distance2}")  # True
print(f"{distance1} == {Quantity(100, 'м')}: {distance1 == Quantity(100, 'м')}")  # True

# Ошибка при несовместимых единицах
try:
    result = distance1 + time
except ValueError as e:
    print(f"\nОшибка: {e}")  # Ошибка: Нельзя складывать м и с
```

### Практические советы:

**1. Проверка типов:**
```python
def __add__(self, other):
    if isinstance(other, MyClass):
        # Логика для MyClass
        pass
    elif isinstance(other, (int, float)):
        # Логика для чисел
        pass
    else:
        return NotImplemented  # Важно!
```

**2. Обратные операторы:**
```python
def __radd__(self, other):
    # Обычно просто переиспользуем __add__
    return self.__add__(other)
```

**3. Операторы на месте (in-place):**
```python
def __iadd__(self, other):
    # Для изменяемых объектов
    self.value += other
    return self  # Обязательно вернуть self!

# Для неизменяемых - создаем новый
def __iadd__(self, other):
    return self.__add__(other)  # новый объект
```

**4. Возврат NotImplemented:**
```python
def __add__(self, other):
    if isinstance(other, MyClass):
        return MyClass(self.value + other.value)
    return NotImplemented  # Позволяет other попробовать __radd__
```

**5. Булево значение:**
```python
def __bool__(self):
    # Осмысленная логика для вашего класса
    # Не просто True/False
    return self.value != 0  # для числовых
    return len(self.items) > 0  # для контейнеров
    return self.is_valid()  # для состояния
```

### Распространенные паттерны:

**Числовые типы:**
```python
class Number:
    def __add__(self, other):
        return Number(self.value + self._to_value(other))
    
    def __radd__(self, other):
        return self.__add__(other)
    
    def _to_value(self, other):
        """Вспомогательный метод для извлечения значения"""
        if isinstance(other, Number):
            return other.value
        return other
```

**Контейнеры:**
```python
class Container:
    def __len__(self):
        return len(self.items)
    
    def __bool__(self):
        return len(self.items) > 0
    
    def __add__(self, other):
        # Объединение контейнеров
        return Container(self.items + other.items)
```

**Неизменяемые объекты:**
```python
class Immutable:
    def __add__(self, other):
        # Всегда возвращаем новый объект
        return Immutable(self.value + other.value)
    
    def __iadd__(self, other):
        # Для неизменяемых __iadd__ = __add__
        return self.__add__(other)
```

### Когда НЕ нужно определять:

❌ **Не определяйте операторы если:**
- Операция не имеет смысла для вашего класса
- Поведение будет неочевидным для пользователя
- Можно сделать обычным методом понятнее

```python
# ❌ Плохо: непонятное использование оператора
class User:
    def __add__(self, other):
        # Что значит "сложить пользователей"?
        return User(self.name + other.name)  # Странно!

# ✅ Хорошо: явный метод
class User:
    def merge_with(self, other):
        # Понятно, что делает
        return User(self.name + " и " + other.name)
```

Магические методы делают ваши классы "питоничными" и удобными в использовании, но используйте их разумно — только когда операция действительно имеет смысл для вашего типа данных.

























----

# `28` (`*`) Протоколы
**Протокол** в Python — это набор методов, которые должен иметь объект, чтобы поддерживать определённое поведение. Это не формальный интерфейс (как в Java), а просто соглашение: "если у объекта есть метод `__iter__`, то он итерируемый".

Python работает по принципу **утиной типизации**: "Если что-то выглядит как утка и крякает как утка, то это утка". Если у объекта есть нужные методы — Python будет с ним работать.

## `28.1` Итерируемые объекты и итераторы
**Итерируемый объект (Iterable)** — это объект, по которому можно проходить в цикле `for`. Чтобы объект был итерируемым, у него должен быть метод `__iter__()`, который возвращает итератор.

**Итератор (Iterator)** — это объект, который возвращает элементы по одному. У него должны быть методы:
- `__iter__()` — возвращает сам себя
- `__next__()` — возвращает следующий элемент или выбрасывает `StopIteration`

### Пример 1: Простой итератор — счётчик

```python
class Counter:
    """Итератор, который считает от start до end"""
    
    def __init__(self, start, end):
        self.current = start
        self.end = end
    
    def __iter__(self):
        # Возвращаем сам себя, потому что это итератор
        return self
    
    def __next__(self):
        if self.current > self.end:
            raise StopIteration  # Сигнал, что элементы закончились
        
        value = self.current
        self.current += 1
        return value


# Использование
counter = Counter(1, 5)

for num in counter:
    print(num)  # 1, 2, 3, 4, 5

# Можно использовать вручную
counter2 = Counter(10, 12)
print(next(counter2))  # 10
print(next(counter2))  # 11
print(next(counter2))  # 12
# print(next(counter2))  # StopIteration!
```

### Пример 2: Итерируемый класс — библиотека книг

```python
class Library:
    """Итерируемая коллекция книг"""
    
    def __init__(self):
        self.books = []
    
    def add_book(self, book):
        self.books.append(book)
    
    def __iter__(self):
        # Возвращаем итератор для списка книг
        return iter(self.books)


# Использование
library = Library()
library.add_book("Война и мир")
library.add_book("Преступление и наказание")
library.add_book("Мастер и Маргарита")

for book in library:
    print(book)
# Война и мир
# Преступление и наказание
# Мастер и Маргарита
```

### Пример 3: Бесконечный итератор

```python
class InfiniteCounter:
    """Бесконечный счётчик"""
    
    def __init__(self, start=0):
        self.current = start
    
    def __iter__(self):
        return self
    
    def __next__(self):
        value = self.current
        self.current += 1
        return value


# Использование
counter = InfiniteCounter(100)

# Берём только первые 5 элементов
for i, num in enumerate(counter):
    if i >= 5:
        break
    print(num)  # 100, 101, 102, 103, 104
```

## `28.2` Протокол контекстных менеджеров
**Контекстный менеджер** — это объект, который управляет ресурсами (файлами, соединениями, блокировками) и гарантирует их корректное освобождение даже при ошибках. Используется с конструкцией `with`.

Протокол контекстного менеджера требует два метода:
- `__enter__()` — вызывается при входе в блок `with`
- `__exit__(exc_type, exc_value, traceback)` — вызывается при выходе (даже при ошибке)

### Пример 1: Менеджер для работы с файлом (простая версия)

```python
class FileManager:
    """Контекстный менеджер для работы с файлами"""
    
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode
        self.file = None
    
    def __enter__(self):
        print(f"Открываем файл {self.filename}")
        self.file = open(self.filename, self.mode)
        return self.file  # Это значение попадёт в переменную после as
    
    def __exit__(self, exc_type, exc_value, traceback):
        print(f"Закрываем файл {self.filename}")
        if self.file:
            self.file.close()
        
        # Если вернуть True, исключение будет подавлено
        # Если False или None, исключение продолжит распространяться
        return False


# Использование
with FileManager('test.txt', 'w') as f:
    f.write('Привет, мир!')
    # Файл автоматически закроется даже при ошибке

# Вывод:
# Открываем файл test.txt
# Закрываем файл test.txt
```

### Пример 2: Таймер выполнения кода

```python
import time

class Timer:
    """Контекстный менеджер для измерения времени выполнения"""
    
    def __enter__(self):
        self.start = time.time()
        print("Запускаем таймер...")
        return self
    
    def __exit__(self, exc_type, exc_value, traceback):
        self.end = time.time()
        self.elapsed = self.end - self.start
        print(f"Время выполнения: {self.elapsed:.4f} секунд")
        return False


# Использование
with Timer():
    # Какой-то долгий код
    total = sum(range(1_000_000))
    time.sleep(0.5)

# Вывод:
# Запускаем таймер...
# Время выполнения: 0.5234 секунд
```

### Пример 3: Менеджер для временного изменения атрибута

```python
class TemporaryAttribute:
    """Временно меняет атрибут объекта, потом восстанавливает"""
    
    def __init__(self, obj, attr_name, temp_value):
        self.obj = obj
        self.attr_name = attr_name
        self.temp_value = temp_value
        self.original_value = None
    
    def __enter__(self):
        # Сохраняем оригинальное значение
        self.original_value = getattr(self.obj, self.attr_name)
        # Устанавливаем временное
        setattr(self.obj, self.attr_name, self.temp_value)
        print(f"Временно изменили {self.attr_name} на {self.temp_value}")
        return self
    
    def __exit__(self, exc_type, exc_value, traceback):
        # Восстанавливаем оригинальное значение
        setattr(self.obj, self.attr_name, self.original_value)
        print(f"Восстановили {self.attr_name} обратно в {self.original_value}")
        return False


# Использование
class Robot:
    def __init__(self):
        self.speed = 10

robot = Robot()
print(f"Скорость: {robot.speed}")  # 10

with TemporaryAttribute(robot, 'speed', 100):
    print(f"Скорость внутри блока: {robot.speed}")  # 100

print(f"Скорость после блока: {robot.speed}")  # 10

# Вывод:
# Скорость: 10
# Временно изменили speed на 100
# Скорость внутри блока: 100
# Восстановили speed обратно в 10
# Скорость после блока: 10
```

## `28.3` (`**`) Дескрипторы
[Протокол Дескриптора](https://www.youtube.com/watch?v=5WNZf1NRZUw)

**Дескриптор** — это объект, который управляет доступом к атрибуту другого объекта. Это мощный механизм, на котором построены `property`, методы классов и статические методы.

Протокол дескриптора включает методы:
- `__get__(self, instance, owner)` — получение значения
- `__set__(self, instance, value)` — установка значения
- `__delete__(self, instance)` — удаление атрибута

### Пример 1: Валидатор положительных чисел

```python
class PositiveNumber:
    """Дескриптор, который проверяет, что значение положительное"""
    
    def __init__(self, name):
        self.name = name
    
    def __get__(self, instance, owner):
        # instance — это объект, у которого запрашивают атрибут
        # owner — это класс
        if instance is None:
            return self
        return instance.__dict__.get(self.name, 0)
    
    def __set__(self, instance, value):
        if value < 0:
            raise ValueError(f"{self.name} должно быть положительным числом!")
        instance.__dict__[self.name] = value
    
    def __delete__(self, instance):
        del instance.__dict__[self.name]


class BankAccount:
    """Банковский счёт с проверкой баланса"""
    
    balance = PositiveNumber('balance')  # Дескриптор
    
    def __init__(self, balance):
        self.balance = balance


# Использование
account = BankAccount(1000)
print(account.balance)  # 1000

account.balance = 500  # OK
print(account.balance)  # 500

try:
    account.balance = -100  # Ошибка!
except ValueError as e:
    print(e)  # balance должно быть положительным числом!
```

### Пример 2: Дескриптор для валидации email

```python
import re

class EmailDescriptor:
    """Дескриптор для проверки email"""
    
    def __init__(self, name):
        self.name = name
    
    def __get__(self, instance, owner):
        if instance is None:
            return self
        return instance.__dict__.get(self.name)
    
    def __set__(self, instance, value):
        # Простая проверка email
        if not re.match(r'^[\w\.-]+@[\w\.-]+\.\w+$', value):
            raise ValueError(f"Некорректный email: {value}")
        instance.__dict__[self.name] = value


class User:
    email = EmailDescriptor('email')
    
    def __init__(self, name, email):
        self.name = name
        self.email = email  # Проверка произойдёт здесь


# Использование
user = User("Иван", "ivan@example.com")
print(user.email)  # ivan@example.com

try:
    user2 = User("Пётр", "invalid-email")  # Ошибка!
except ValueError as e:
    print(e)  # Некорректный email: invalid-email
```

### Пример 3: Дескриптор с кэшированием (ленивое вычисление)

```python
class LazyProperty:
    """Дескриптор, который вычисляет значение только один раз"""
    
    def __init__(self, function):
        self.function = function
        self.name = function.__name__
    
    def __get__(self, instance, owner):
        if instance is None:
            return self
        
        # Проверяем, было ли уже вычислено значение
        if self.name not in instance.__dict__:
            # Вычисляем и сохраняем
            value = self.function(instance)
            instance.__dict__[self.name] = value
            print(f"Вычисляем {self.name}...")
        else:
            print(f"Используем кэшированное значение {self.name}")
        
        return instance.__dict__[self.name]


class DataProcessor:
    def __init__(self, data):
        self.data = data
    
    @LazyProperty
    def processed_data(self):
        # Тяжёлая операция
        print("Выполняем сложную обработку данных...")
        return [x * 2 for x in self.data]


# Использование
processor = DataProcessor([1, 2, 3, 4, 5])

print("Первый доступ:")
print(processor.processed_data)
# Вычисляем processed_data...
# Выполняем сложную обработку данных...
# [2, 4, 6, 8, 10]

print("\nВторой доступ:")
print(processor.processed_data)
# Используем кэшированное значение processed_data
# [2, 4, 6, 8, 10]
```

## `28.4` (`**`) Протокол последовательностей
**Протокол последовательности** позволяет объекту вести себя как список: поддерживать индексацию, срезы, `len()`, проверку вхождения через `in`.

Нужные методы:
- `__len__()` — возвращает длину
- `__getitem__(key)` — получение элемента по индексу или срезу

#### Пример: Кастомная последовательность — Fibonacci

```python
class FibonacciSequence:
    """Последовательность чисел Фибоначчи с индексацией"""
    
    def __init__(self, max_length):
        self.max_length = max_length
        self._cache = [0, 1]  # Кэш для оптимизации
    
    def __len__(self):
        return self.max_length
    
    def __getitem__(self, index):
        # Поддержка отрицательных индексов
        if isinstance(index, int):
            if index < 0:
                index = self.max_length + index
            
            if index < 0 or index >= self.max_length:
                raise IndexError("Индекс за пределами последовательности")
            
            # Вычисляем числа Фибоначчи до нужного индекса
            while len(self._cache) <= index:
                next_fib = self._cache[-1] + self._cache[-2]
                self._cache.append(next_fib)
            
            return self._cache[index]
        
        # Поддержка срезов
        elif isinstance(index, slice):
            return [self[i] for i in range(*index.indices(self.max_length))]
        
        raise TypeError("Индекс должен быть числом или срезом")
    
    def __contains__(self, value):
        """Поддержка оператора in"""
        return value in [self[i] for i in range(self.max_length)]


# Использование
fib = FibonacciSequence(10)

print(len(fib))          # 10
print(fib[0])            # 0
print(fib[5])            # 5
print(fib[-1])           # 34 (последний элемент)
print(fib[2:6])          # [1, 2, 3, 5]
print(8 in fib)          # True
print(100 in fib)        # False

# Можно итерировать
for num in fib:
    print(num, end=' ')  # 0 1 1 2 3 5 8 13 21 34
```

#### Пример: Playlist — музыкальный плейлист

```python
class Playlist:
    """Плейлист с поддержкой индексации и срезов"""
    
    def __init__(self, name):
        self.name = name
        self.songs = []
    
    def add_song(self, song):
        self.songs.append(song)
    
    def __len__(self):
        return len(self.songs)
    
    def __getitem__(self, index):
        return self.songs[index]
    
    def __setitem__(self, index, value):
        """Позволяет изменять песни по индексу"""
        self.songs[index] = value
    
    def __delitem__(self, index):
        """Позволяет удалять песни по индексу"""
        del self.songs[index]
    
    def __contains__(self, song):
        return song in self.songs
    
    def __repr__(self):
        return f"Playlist('{self.name}', {len(self)} песен)"


# Использование
playlist = Playlist("Моя музыка")
playlist.add_song("Song A")
playlist.add_song("Song B")
playlist.add_song("Song C")
playlist.add_song("Song D")

print(len(playlist))              # 4
print(playlist[0])                # Song A
print(playlist[-1])               # Song D
print(playlist[1:3])              # ['Song B', 'Song C']

playlist[1] = "New Song B"        # Замена
print(playlist[1])                # New Song B

del playlist[0]                   # Удаление
print(len(playlist))              # 3

print("Song C" in playlist)       # True
```

## Резюме

- **Итераторы** (`__iter__`, `__next__`) — позволяют перебирать элементы объекта
- **Контекстные менеджеры** (`__enter__`, `__exit__`) — управляют ресурсами безопасно
- **Дескрипторы** (`__get__`, `__set__`, `__delete__`) — контролируют доступ к атрибутам
- **Протокол последовательности** (`__len__`, `__getitem__`) — делает объект похожим на список
- Протоколы — это способ сделать свои классы более "питоничными" и интегрированными с языком






















----

# `29` (`*`) Наследование и Полиморфизм
## `29.1` Наследование
[Наследование](https://youtu.be/7WVYqjdMa6U?si=jas4MgS63tp7JNSM)

**Наследование** — это механизм, который позволяет создавать новый класс на основе существующего. Новый класс (дочерний, наследник) получает все атрибуты и методы родительского класса и может добавлять свои или изменять унаследованные.

### Зачем нужно наследование?

1. **Переиспользование кода** — не нужно дублировать одинаковую логику
2. **Иерархия классов** — создание логической структуры от общего к частному
3. **Расширяемость** — легко добавлять новую функциональность
4. **Полиморфизм** — разные классы могут использоваться единообразно

### Базовый синтаксис

```python
class ParentClass:
    # Родительский класс
    pass

class ChildClass(ParentClass):
    # Дочерний класс наследует ParentClass
    pass
```

### Пример 1: Простое наследование — животные

```python
class Animal:
    """Базовый класс для всех животных"""
    
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def make_sound(self):
        return "Какой-то звук"
    
    def info(self):
        return f"{self.name}, возраст: {self.age} лет"


class Dog(Animal):
    """Собака — наследник Animal"""
    
    def __init__(self, name, age, breed):
        super().__init__(name, age)  # Вызываем конструктор родителя
        self.breed = breed  # Добавляем новый атрибут
    
    def make_sound(self):
        # Переопределяем метод родителя
        return "Гав-гав!"
    
    def fetch(self):
        # Добавляем новый метод
        return f"{self.name} принёс палку!"


class Cat(Animal):
    """Кошка — наследник Animal"""
    
    def make_sound(self):
        return "Мяу!"
    
    def scratch(self):
        return f"{self.name} царапает мебель"


# Использование
dog = Dog("Бобик", 3, "Лабрадор")
cat = Cat("Мурка", 2)

print(dog.info())          # Бобик, возраст: 3 лет (метод из Animal)
print(dog.make_sound())    # Гав-гав! (переопределённый метод)
print(dog.fetch())         # Бобик принёс палку! (новый метод)

print(cat.info())          # Мурка, возраст: 2 лет
print(cat.make_sound())    # Мяу!
print(cat.scratch())       # Мурка царапает мебель
```

### Пример 2: Наследование в реальном проекте — пользователи

```python
class User:
    """Базовый класс пользователя"""
    
    def __init__(self, username, email):
        self.username = username
        self.email = email
        self.is_active = True
    
    def deactivate(self):
        self.is_active = False
        print(f"Пользователь {self.username} деактивирован")
    
    def __repr__(self):
        return f"User('{self.username}', '{self.email}')"


class Admin(User):
    """Администратор с расширенными правами"""
    
    def __init__(self, username, email, access_level):
        super().__init__(username, email)
        self.access_level = access_level
    
    def ban_user(self, user):
        if self.access_level >= 3:
            user.deactivate()
            print(f"Админ {self.username} забанил {user.username}")
        else:
            print("Недостаточно прав")
    
    def __repr__(self):
        return f"Admin('{self.username}', level={self.access_level})"


class Moderator(User):
    """Модератор с ограниченными правами"""
    
    def __init__(self, username, email, sections):
        super().__init__(username, email)
        self.sections = sections  # Разделы, которые модерирует
    
    def delete_message(self, message_id, section):
        if section in self.sections:
            print(f"Модератор {self.username} удалил сообщение {message_id}")
        else:
            print(f"Нет прав для модерации раздела {section}")


# Использование
regular_user = User("john_doe", "john@example.com")
admin = Admin("super_admin", "admin@example.com", access_level=5)
moderator = Moderator("mod_alice", "alice@example.com", sections=["forum", "chat"])

print(regular_user)  # User('john_doe', 'john@example.com')
print(admin)         # Admin('super_admin', level=5)

admin.ban_user(regular_user)
# Админ super_admin забанил john_doe
# Пользователь john_doe деактивирован

moderator.delete_message(123, "forum")  # OK
moderator.delete_message(456, "blog")   # Нет прав
```

### Пример 3: Множественное наследование

Python поддерживает множественное наследование — класс может наследоваться от нескольких родителей.

```python
class Flyable:
    """Миксин для летающих объектов"""
    
    def fly(self):
        return f"{self.name} летит!"


class Swimmable:
    """Миксин для плавающих объектов"""
    
    def swim(self):
        return f"{self.name} плывёт!"


class Duck(Animal, Flyable, Swimmable):
    """Утка может и летать, и плавать"""
    
    def __init__(self, name, age):
        super().__init__(name, age)
    
    def make_sound(self):
        return "Кря-кря!"


# Использование
duck = Duck("Дональд", 1)
print(duck.make_sound())  # Кря-кря!
print(duck.fly())         # Дональд летит!
print(duck.swim())        # Дональд плывёт!
print(duck.info())        # Дональд, возраст: 1 лет
```

### super() и MRO (Method Resolution Order)
[Method Resolution Order](https://youtu.be/9YPooWY6x9o?si=nidscOFBEq88o9tZ)

`super()` используется для вызова методов родительского класса. Python определяет порядок поиска методов через **MRO** (Method Resolution Order).

```python
class A:
    def method(self):
        print("Метод A")


class B(A):
    def method(self):
        print("Метод B")
        super().method()  # Вызов метода родителя


class C(A):
    def method(self):
        print("Метод C")
        super().method()


class D(B, C):
    def method(self):
        print("Метод D")
        super().method()


# Использование
obj = D()
obj.method()
# Вывод:
# Метод D
# Метод B
# Метод C
# Метод A

# Посмотреть MRO можно так:
print(D.__mro__)
# (<class 'D'>, <class 'B'>, <class 'C'>, <class 'A'>, <class 'object'>)
```

## `29.2` Полиморфизм
[Полиморфизм](https://youtu.be/aEOSBkzNImw?si=Wv7jFcPwqtRNF_zZ)

**Полиморфизм** (от греч. "много форм") — это способность объектов разных классов обрабатываться единообразно, если они имеют одинаковый интерфейс (методы с одинаковыми именами).

### Виды полиморфизма в Python:

1. **Полиморфизм через наследование** — разные классы переопределяют методы родителя
2. **Утиная типизация** — "если выглядит как утка и крякает как утка, то это утка"
3. **Перегрузка операторов** — изменение поведения операторов (+, -, ==, и т.д.)

### Пример 1: Полиморфизм через наследование

```python
class Shape:
    """Базовый класс для геометрических фигур"""
    
    def area(self):
        raise NotImplementedError("Метод должен быть переопределён")
    
    def perimeter(self):
        raise NotImplementedError("Метод должен быть переопределён")


class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height
    
    def perimeter(self):
        return 2 * (self.width + self.height)


class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return 3.14159 * self.radius ** 2
    
    def perimeter(self):
        return 2 * 3.14159 * self.radius


class Triangle(Shape):
    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c
    
    def area(self):
        # Формула Герона
        s = (self.a + self.b + self.c) / 2
        return (s * (s - self.a) * (s - self.b) * (s - self.c)) ** 0.5
    
    def perimeter(self):
        return self.a + self.b + self.c


# Полиморфизм в действии
def print_shape_info(shape):
    """Функция работает с любой фигурой"""
    print(f"Площадь: {shape.area():.2f}")
    print(f"Периметр: {shape.perimeter():.2f}")
    print()


# Использование
shapes = [
    Rectangle(5, 3),
    Circle(4),
    Triangle(3, 4, 5)
]

for shape in shapes:
    print_shape_info(shape)
# Площадь: 15.00
# Периметр: 16.00
#
# Площадь: 50.27
# Периметр: 25.13
#
# Площадь: 6.00
# Периметр: 12.00
```

### Пример 2: Утиная типизация

В Python не обязательно использовать наследование для полиморфизма. Достаточно, чтобы у объектов были нужные методы.

```python
class EmailNotification:
    """Уведомление по email"""
    
    def send(self, message):
        print(f"📧 Email: {message}")


class SMSNotification:
    """Уведомление по SMS"""
    
    def send(self, message):
        print(f"📱 SMS: {message}")


class PushNotification:
    """Push-уведомление"""
    
    def send(self, message):
        print(f"🔔 Push: {message}")


class TelegramNotification:
    """Уведомление в Telegram"""
    
    def send(self, message):
        print(f"✈️ Telegram: {message}")


# Функция работает с любым объектом, у которого есть метод send()
def notify_user(notification_service, message):
    notification_service.send(message)


# Использование — все работает без общего родителя!
notifications = [
    EmailNotification(),
    SMSNotification(),
    PushNotification(),
    TelegramNotification()
]

for notifier in notifications:
    notify_user(notifier, "У вас новое сообщение!")

# 📧 Email: У вас новое сообщение!
# 📱 SMS: У вас новое сообщение!
# 🔔 Push: У вас новое сообщение!
# ✈️ Telegram: У вас новое сообщение!
```

### Пример 3: Перегрузка операторов

Полиморфизм можно применить к операторам, переопределив специальные методы.

```python
class Vector:
    """Математический вектор"""
    
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __add__(self, other):
        """Перегрузка оператора +"""
        return Vector(self.x + other.x, self.y + other.y)
    
    def __sub__(self, other):
        """Перегрузка оператора -"""
        return Vector(self.x - other.x, self.y - other.y)
    
    def __mul__(self, scalar):
        """Перегрузка оператора * (умножение на число)"""
        return Vector(self.x * scalar, self.y * scalar)
    
    def __eq__(self, other):
        """Перегрузка оператора =="""
        return self.x == other.x and self.y == other.y
    
    def __repr__(self):
        return f"Vector({self.x}, {self.y})"


# Использование
v1 = Vector(3, 4)
v2 = Vector(1, 2)

print(v1 + v2)    # Vector(4, 6)
print(v1 - v2)    # Vector(2, 2)
print(v1 * 3)     # Vector(9, 12)
print(v1 == v2)   # False
print(v1 == Vector(3, 4))  # True
```

### Пример 4: Полиморфизм в системе оплаты

```python
class PaymentMethod:
    """Базовый класс для способов оплаты"""
    
    def pay(self, amount):
        raise NotImplementedError


class CreditCard(PaymentMethod):
    def __init__(self, card_number):
        self.card_number = card_number[-4:]  # Последние 4 цифры
    
    def pay(self, amount):
        print(f"💳 Оплата {amount}₽ картой **** {self.card_number}")
        return True


class PayPal(PaymentMethod):
    def __init__(self, email):
        self.email = email
    
    def pay(self, amount):
        print(f"🅿️ Оплата {amount}₽ через PayPal ({self.email})")
        return True


class Cryptocurrency(PaymentMethod):
    def __init__(self, wallet_address):
        self.wallet = wallet_address[:10] + "..."
    
    def pay(self, amount):
        print(f"₿ Оплата {amount}₽ криптовалютой (кошелёк: {self.wallet})")
        return True


class ShoppingCart:
    """Корзина покупок"""
    
    def __init__(self):
        self.items = []
    
    def add_item(self, name, price):
        self.items.append({"name": name, "price": price})
    
    def total(self):
        return sum(item["price"] for item in self.items)
    
    def checkout(self, payment_method):
        """Оформление заказа с любым способом оплаты"""
        total = self.total()
        print(f"\nИтого к оплате: {total}₽")
        
        if payment_method.pay(total):
            print("✅ Оплата прошла успешно!\n")
            self.items.clear()
        else:
            print("❌ Ошибка оплаты\n")


# Использование
cart = ShoppingCart()
cart.add_item("Ноутбук", 50000)
cart.add_item("Мышка", 1500)

# Можно использовать любой способ оплаты
cart.checkout(CreditCard("1234567812345678"))
# Итого к оплате: 51500₽
# 💳 Оплата 51500₽ картой **** 5678
# ✅ Оплата прошла успешно!

cart.add_item("Книга", 500)
cart.checkout(PayPal("user@example.com"))
# Итого к оплате: 500₽
# 🅿️ Оплата 500₽ через PayPal (user@example.com)
# ✅ Оплата прошла успешно!

cart.add_item("Наушники", 3000)
cart.checkout(Cryptocurrency("1A2B3C4D5E6F7G8H9I0J"))
# Итого к оплате: 3000₽
# ₿ Оплата 3000₽ криптовалютой (кошелёк: 1A2B3C4D5E...)
# ✅ Оплата прошла успешно!
```

## `29.3` Абстрактные классы и протоколы
[ABC & Protocol (на русском)](https://youtu.be/gYohffh1NaU?si=WzBf7_S5XhRb6-67)
[ABC & Protocol](https://youtu.be/dryNwWvSd4M?si=qeqoM5g0edk9tFoo)

### Абстрактные классы (ABC)

**Абстрактный класс** — это класс, который нельзя создать напрямую. Он служит шаблоном для других классов и определяет обязательные методы, которые должны быть реализованы в наследниках.

```python
from abc import ABC, abstractmethod

class AbstractClass(ABC):
    @abstractmethod
    def required_method(self):
        pass
```

### Пример 1: Абстрактный класс для БД

```python
from abc import ABC, abstractmethod

class Database(ABC):
    """Абстрактный класс для работы с базами данных"""
    
    @abstractmethod
    def connect(self):
        """Подключение к БД"""
        pass
    
    @abstractmethod
    def disconnect(self):
        """Отключение от БД"""
        pass
    
    @abstractmethod
    def execute(self, query):
        """Выполнение запроса"""
        pass
    
    def log(self, message):
        """Конкретный метод, доступный всем наследникам"""
        print(f"[LOG] {message}")


class PostgreSQL(Database):
    def connect(self):
        self.log("Подключение к PostgreSQL")
        self.connection = "PostgreSQL connection"
    
    def disconnect(self):
        self.log("Отключение от PostgreSQL")
        self.connection = None
    
    def execute(self, query):
        self.log(f"Выполнение SQL: {query}")
        return f"Результат для PostgreSQL: {query}"


class MongoDB(Database):
    def connect(self):
        self.log("Подключение к MongoDB")
        self.connection = "MongoDB connection"
    
    def disconnect(self):
        self.log("Отключение от MongoDB")
        self.connection = None
    
    def execute(self, query):
        self.log(f"Выполнение запроса: {query}")
        return f"Результат для MongoDB: {query}"


# Использование
def work_with_database(db: Database):
    """Функция работает с любой БД"""
    db.connect()
    result = db.execute("SELECT * FROM users")
    print(result)
    db.disconnect()
    print()


postgres = PostgreSQL()
mongo = MongoDB()

work_with_database(postgres)
# [LOG] Подключение к PostgreSQL
# [LOG] Выполнение SQL: SELECT * FROM users
# Результат для PostgreSQL: SELECT * FROM users
# [LOG] Отключение от PostgreSQL

work_with_database(mongo)
# [LOG] Подключение к MongoDB
# [LOG] Выполнение запроса: SELECT * FROM users
# Результат для MongoDB: SELECT * FROM users
# [LOG] Отключение от MongoDB

# Попытка создать экземпляр абстрактного класса вызовет ошибку
try:
    db = Database()
except TypeError as e:
    print(f"Ошибка: {e}")
# Ошибка: Can't instantiate abstract class Database with abstract methods connect, disconnect, execute
```

### Пример 2: Абстрактный класс для экспорта данных

```python
from abc import ABC, abstractmethod
import json
import csv

class DataExporter(ABC):
    """Абстрактный класс для экспорта данных"""
    
    def __init__(self, data):
        self.data = data
    
    @abstractmethod
    def export(self, filename):
        """Экспорт данных в файл"""
        pass
    
    def validate_data(self):
        """Общая валидация для всех экспортёров"""
        if not self.data:
            raise ValueError("Данные пусты!")
        return True


class JSONExporter(DataExporter):
    def export(self, filename):
        self.validate_data()
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(self.data, f, ensure_ascii=False, indent=2)
        print(f"✅ Данные экспортированы в {filename} (JSON)")


class CSVExporter(DataExporter):
    def export(self, filename):
        self.validate_data()
        with open(filename, 'w', encoding='utf-8', newline='') as f:
            if isinstance(self.data, list) and self.data:
                writer = csv.DictWriter(f, fieldnames=self.data[0].keys())
                writer.writeheader()
                writer.writerows(self.data)
        print(f"✅ Данные экспортированы в {filename} (CSV)")


class XMLExporter(DataExporter):
    def export(self, filename):
        self.validate_data()
        # Упрощённая реализация XML
        xml_content = "<data>\n"
        for item in self.data:
            xml_content += "  <item>\n"
            for key, value in item.items():
                xml_content += f"    <{key}>{value}</{key}>\n"
            xml_content += "  </item>\n"
        xml_content += "</data>"
        
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(xml_content)
        print(f"✅ Данные экспортированы в {filename} (XML)")


# Использование
data = [
    {"name": "Иван", "age": 25, "city": "Москва"},
    {"name": "Мария", "age": 30, "city": "Санкт-Петербург"}
]

exporters = [
    JSONExporter(data),
    CSVExporter(data),
    XMLExporter(data)
]

for i, exporter in enumerate(exporters, 1):
    exporter.export(f"output_{i}.txt")

# ✅ Данные экспортированы в output_1.txt (JSON)
# ✅ Данные экспортированы в output_2.txt (CSV)
# ✅ Данные экспортированы в output_3.txt (XML)
```

### Протоколы (Protocol) — структурная типизация

**Протоколы** (появились в Python 3.8) — это способ определить интерфейс без явного наследования. Класс удовлетворяет протоколу, если у него есть нужные методы.

```python
from typing import Protocol

class Drawable(Protocol):
    """Протокол для объектов, которые можно рисовать"""
    
    def draw(self) -> None:
        ...


# Классы НЕ наследуют Drawable, но соответствуют протоколу
class Circle:
    def draw(self):
        print("Рисуем круг ⭕")


class Square:
    def draw(self):
        print("Рисуем квадрат ⬜")


class Text:
    def draw(self):
        print("Рисуем текст 📝")


def render(obj: Drawable):
    """Функция работает с любым объектом, соответствующим протоколу"""
    obj.draw()


# Использование
shapes = [Circle(), Square(), Text()]

for shape in shapes:
    render(shape)

# Рисуем круг ⭕
# Рисуем квадрат ⬜
# Рисуем текст 📝
```

### Пример 3: Протокол для логирования

```python
from typing import Protocol

class Logger(Protocol):
    """Протокол для логгеров"""
    
    def log(self, message: str) -> None:
        ...


class ConsoleLogger:
    def log(self, message: str):
        print(f"[CONSOLE] {message}")


class FileLogger:
    def __init__(self, filename):
        self.filename = filename
    
    def log(self, message: str):
        with open(self.filename, 'a', encoding='utf-8') as f:
            f.write(f"{message}\n")
        print(f"[FILE] Записано в {self.filename}")


class DatabaseLogger:
    def log(self, message: str):
        # Имитация записи в БД
        print(f"[DB] Сохранено в БД: {message}")


class Application:
    """Приложение может работать с любым логгером"""
    
    def __init__(self, logger: Logger):
        self.logger = logger
    
    def run(self):
        self.logger.log("Приложение запущено")
        self.logger.log("Выполнение задачи...")
        self.logger.log("Приложение завершено")


# Использование
print("=== Console Logger ===")
app1 = Application(ConsoleLogger())
app1.run()

print("\n=== File Logger ===")
app2 = Application(FileLogger("app.log"))
app2.run()

print("\n=== Database Logger ===")
app3 = Application(DatabaseLogger())
app3.run()
```

## `29.4` (`**`) Generics
[Generics](https://youtu.be/hVulW66JboQ?si=dZMUg-qfSWPxoNBQ)

**Generics (обобщённые типы)** позволяют создавать классы и функции, которые работают с разными типами данных, сохраняя при этом типобезопасность.

```python
from typing import TypeVar, Generic, List

T = TypeVar('T')  # Объявляем переменную типа
```

### Пример 1: Обобщённый стек

```python
from typing import TypeVar, Generic, List

T = TypeVar('T')

class Stack(Generic[T]):
    """Обобщённый стек для любого типа данных"""
    
    def __init__(self):
        self._items: List[T] = []
    
    def push(self, item: T) -> None:
        """Добавить элемент в стек"""
        self._items.append(item)
    
    def pop(self) -> T:
        """Извлечь элемент из стека"""
        if self.is_empty():
            raise IndexError("Стек пуст")
        return self._items.pop()
    
    def peek(self) -> T:
        """Посмотреть верхний элемент без извлечения"""
        if self.is_empty():
            raise IndexError("Стек пуст")
        return self._items[-1]
    
    def is_empty(self) -> bool:
        return len(self._items) == 0
    
    def size(self) -> int:
        return len(self._items)
    
    def __repr__(self):
        return f"Stack({self._items})"


# Использование с разными типами
int_stack = Stack[int]()
int_stack.push(1)
int_stack.push(2)
int_stack.push(3)
print(int_stack)          # Stack([1, 2, 3])
print(int_stack.pop())    # 3

str_stack = Stack[str]()
str_stack.push("Hello")
str_stack.push("World")
print(str_stack)          # Stack(['Hello', 'World'])
print(str_stack.peek())   # World
```

### Пример 2: Обобщённая пара (Pair)

```python
from typing import TypeVar, Generic

T = TypeVar('T')
U = TypeVar('U')

class Pair(Generic[T, U]):
    """Пара значений разных типов"""
    
    def __init__(self, first: T, second: U):
        self.first = first
        self.second = second
    
    def get_first(self) -> T:
        return self.first
    
    def get_second(self) -> U:
        return self.second
    
    def swap(self) -> 'Pair[U, T]':
        """Меняет местами элементы пары"""
        return Pair(self.second, self.first)
    
    def __repr__(self):
        return f"Pair({self.first}, {self.second})"


# Использование
pair1 = Pair[str, int]("возраст", 25)
print(pair1)                    # Pair(возраст, 25)
print(pair1.get_first())        # возраст
print(pair1.get_second())       # 25

pair2 = Pair[int, str](404, "Not Found")
print(pair2)                    # Pair(404, Not Found)

swapped = pair2.swap()
print(swapped)                  # Pair(Not Found, 404)
```

### Пример 3: Обобщённый репозиторий

```python
from typing import TypeVar, Generic, List, Optional, Protocol

class Identifiable(Protocol):
    """Протокол для объектов с ID"""
    id: int


T = TypeVar('T', bound=Identifiable)

class Repository(Generic[T]):
    """Обобщённый репозиторий для хранения объектов"""
    
    def __init__(self):
        self._storage: List[T] = []
        self._next_id = 1
    
    def add(self, item: T) -> T:
        """Добавить объект"""
        item.id = self._next_id
        self._next_id += 1
        self._storage.append(item)
        return item
    
    def get_by_id(self, item_id: int) -> Optional[T]:
        """Получить объект по ID"""
        for item in self._storage:
            if item.id == item_id:
                return item
        return None
    
    def get_all(self) -> List[T]:
        """Получить все объекты"""
        return self._storage.copy()
    
    def delete(self, item_id: int) -> bool:
        """Удалить объект по ID"""
        for i, item in enumerate(self._storage):
            if item.id == item_id:
                del self._storage[i]
                return True
        return False
    
    def update(self, item: T) -> bool:
        """Обновить объект"""
        for i, stored_item in enumerate(self._storage):
            if stored_item.id == item.id:
                self._storage[i] = item
                return True
        return False
    
    def count(self) -> int:
        """Количество объектов"""
        return len(self._storage)


# Модели данных
class User:
    def __init__(self, name: str, email: str):
        self.id = 0  # Будет установлен репозиторием
        self.name = name
        self.email = email
    
    def __repr__(self):
        return f"User(id={self.id}, name='{self.name}', email='{self.email}')"


class Product:
    def __init__(self, title: str, price: float):
        self.id = 0
        self.title = title
        self.price = price
    
    def __repr__(self):
        return f"Product(id={self.id}, title='{self.title}', price={self.price})"


# Использование
user_repo = Repository[User]()
product_repo = Repository[Product]()

# Работа с пользователями
user1 = user_repo.add(User("Иван", "ivan@example.com"))
user2 = user_repo.add(User("Мария", "maria@example.com"))
print(f"Создано пользователей: {user_repo.count()}")  # 2
print(user_repo.get_all())
# [User(id=1, name='Иван', email='ivan@example.com'), 
#  User(id=2, name='Мария', email='maria@example.com')]

# Работа с продуктами
product1 = product_repo.add(Product("Ноутбук", 50000))
product2 = product_repo.add(Product("Мышка", 1500))
print(f"\nСоздано товаров: {product_repo.count()}")  # 2

# Получение по ID
user = user_repo.get_by_id(1)
print(f"\nНайден пользователь: {user}")  # User(id=1, name='Иван', ...)

# Удаление
user_repo.delete(2)
print(f"Осталось пользователей: {user_repo.count()}")  # 1
```

### Пример 4: Обобщённая функция

```python
from typing import TypeVar, List, Callable

T = TypeVar('T')

def filter_items(items: List[T], predicate: Callable[[T], bool]) -> List[T]:
    """Обобщённая функция фильтрации"""
    return [item for item in items if predicate(item)]


def map_items(items: List[T], transformer: Callable[[T], T]) -> List[T]:
    """Обобщённая функция преобразования"""
    return [transformer(item) for item in items]


# Использование с числами
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
even_numbers = filter_items(numbers, lambda x: x % 2 == 0)
print(even_numbers)  # [2, 4, 6, 8, 10]

squared = map_items(numbers, lambda x: x ** 2)
print(squared)  # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

# Использование со строками
words = ["apple", "banana", "cherry", "date"]
long_words = filter_items(words, lambda w: len(w) > 5)
print(long_words)  # ['banana', 'cherry']

uppercase = map_items(words, lambda w: w.upper())
print(uppercase)  # ['APPLE', 'BANANA', 'CHERRY', 'DATE']
```

## `29.5` Композиция
[Композиция](https://youtu.be/7xSDYgktsqY?si=4JtviBueKZCk7-Tf)

**Композиция** — это альтернатива наследованию, где один класс содержит экземпляры других классов. Это реализует принцип "имеет" (has-a) вместо "является" (is-a).

### Наследование vs Композиция

**Наследование (is-a):**
- Собака **является** животным
- Жёсткая связь между классами
- Изменения в родителе влияют на детей

**Композиция (has-a):**
- Машина **имеет** двигатель
- Гибкая связь, легко заменить компоненты
- Изменения в одном компоненте не влияют на другие

### Пример 1: Композиция — автомобиль

```python
class Engine:
    """Двигатель"""
    
    def __init__(self, horsepower, fuel_type):
        self.horsepower = horsepower
        self.fuel_type = fuel_type
        self.is_running = False
    
    def start(self):
        self.is_running = True
        print(f"🔥 Двигатель запущен ({self.horsepower} л.с., {self.fuel_type})")
    
    def stop(self):
        self.is_running = False
        print("⛔ Двигатель остановлен")


class Transmission:
    """Трансмиссия"""
    
    def __init__(self, transmission_type):
        self.type = transmission_type  # "автомат", "механика"
        self.gear = 0
    
    def shift_up(self):
        self.gear += 1
        print(f"⚙️ Переключение на {self.gear} передачу")
    
    def shift_down(self):
        if self.gear > 0:
            self.gear -= 1
            print(f"⚙️ Переключение на {self.gear} передачу")


class GPS:
    """GPS навигация"""
    
    def __init__(self):
        self.destination = None
    
    def set_destination(self, place):
        self.destination = place
        print(f"🗺️ Маршрут построен до: {place}")
    
    def navigate(self):
        if self.destination:
            print(f"🧭 Навигация к {self.destination}")
        else:
            print("❌ Пункт назначения не задан")


class Car:
    """Автомобиль использует композицию"""
    
    def __init__(self, model, engine, transmission, has_gps=False):
        self.model = model
        self.engine = engine  # Композиция: машина ИМЕЕТ двигатель
        self.transmission = transmission  # Композиция: машина ИМЕЕТ трансмиссию
        self.gps = GPS() if has_gps else None  # Опциональный компонент
    
    def start_journey(self):
        print(f"\n🚗 {self.model} готовится к поездке")
        self.engine.start()
        if self.gps:
            self.gps.navigate()
    
    def drive(self):
        if self.engine.is_running:
            self.transmission.shift_up()
            print("🏎️ Автомобиль движется")
        else:
            print("❌ Сначала запустите двигатель!")
    
    def stop_journey(self):
        print(f"\n🛑 {self.model} завершает поездку")
        self.engine.stop()


# Использование
# Создаём компоненты отдельно
v8_engine = Engine(450, "бензин")
auto_transmission = Transmission("автомат")

# Собираем машину из компонентов
bmw = Car("BMW X5", v8_engine, auto_transmission, has_gps=True)

bmw.gps.set_destination("Аэропорт Шереметьево")
bmw.start_journey()
bmw.drive()
bmw.drive()
bmw.stop_journey()

# Вывод:
# 🗺️ Маршрут построен до: Аэропорт Шереметьево
# 
# 🚗 BMW X5 готовится к поездке
# 🔥 Двигатель запущен (450 л.с., бензин)
# 🧭 Навигация к Аэропорт Шереметьево
# ⚙️ Переключение на 1 передачу
# 🏎️ Автомобиль движется
# ⚙️ Переключение на 2 передачу
# 🏎️ Автомобиль движется
# 
# 🛑 BMW X5 завершает поездку
# ⛔ Двигатель остановлен

# Можем легко создать другую машину с другими компонентами
electric_engine = Engine(300, "электричество")
manual_transmission = Transmission("механика")
tesla = Car("Tesla Model 3", electric_engine, manual_transmission, has_gps=True)
```

### Пример 2: Композиция — компьютер

```python
class CPU:
    """Процессор"""
    
    def __init__(self, model, cores, frequency):
        self.model = model
        self.cores = cores
        self.frequency = frequency
    
    def process(self, task):
        print(f"🔷 {self.model} ({self.cores} ядер, {self.frequency} ГГц) обрабатывает: {task}")


class RAM:
    """Оперативная память"""
    
    def __init__(self, size_gb):
        self.size = size_gb
        self.used = 0
    
    def allocate(self, amount_gb):
        if self.used + amount_gb <= self.size:
            self.used += amount_gb
            print(f"💾 Выделено {amount_gb} ГБ ОЗУ (всего используется: {self.used}/{self.size} ГБ)")
        else:
            print(f"❌ Недостаточно памяти! Доступно: {self.size - self.used} ГБ")
    
    def free(self, amount_gb):
        self.used = max(0, self.used - amount_gb)
        print(f"💾 Освобождено {amount_gb} ГБ ОЗУ")


class Storage:
    """Хранилище данных"""
    
    def __init__(self, storage_type, capacity_gb):
        self.type = storage_type  # "SSD", "HDD"
        self.capacity = capacity_gb
        self.used = 0
    
    def save_file(self, filename, size_gb):
        if self.used + size_gb <= self.capacity:
            self.used += size_gb
            print(f"💽 Файл '{filename}' сохранён на {self.type} ({size_gb} ГБ)")
        else:
            print(f"❌ Недостаточно места на диске!")


class GPU:
    """Видеокарта (опциональный компонент)"""
    
    def __init__(self, model, vram_gb):
        self.model = model
        self.vram = vram_gb
    
    def render(self, scene):
        print(f"🎮 {self.model} ({self.vram} ГБ VRAM) рендерит: {scene}")


class Computer:
    """Компьютер собран из компонентов через композицию"""
    
    def __init__(self, name, cpu, ram, storage, gpu=None):
        self.name = name
        self.cpu = cpu
        self.ram = ram
        self.storage = storage
        self.gpu = gpu  # Опциональный компонент
        self.is_on = False
    
    def power_on(self):
        self.is_on = True
        print(f"\n💻 {self.name} включается...")
        print(f"   CPU: {self.cpu.model}")
        print(f"   RAM: {self.ram.size} ГБ")
        print(f"   Storage: {self.storage.type} {self.storage.capacity} ГБ")
        if self.gpu:
            print(f"   GPU: {self.gpu.model}")
    
    def run_application(self, app_name, ram_needed, storage_needed):
        if not self.is_on:
            print("❌ Компьютер выключен!")
            return
        
        print(f"\n▶️ Запуск приложения: {app_name}")
        self.cpu.process(app_name)
        self.ram.allocate(ram_needed)
        self.storage.save_file(f"{app_name}_data", storage_needed)
    
    def play_game(self, game_name):
        if not self.gpu:
            print("❌ Видеокарта не установлена!")
            return
        
        print(f"\n🎮 Запуск игры: {game_name}")
        self.cpu.process(f"игровая логика {game_name}")
        self.gpu.render(f"сцена из {game_name}")
        self.ram.allocate(4)


# Использование

# Офисный компьютер (без видеокарты)
office_pc = Computer(
    "Офисный ПК",
    CPU("Intel i5", 6, 3.2),
    RAM(16),
    Storage("SSD", 512)
)

office_pc.power_on()
office_pc.run_application("Microsoft Word", ram_needed=2, storage_needed=0.5)
office_pc.run_application("Chrome", ram_needed=4, storage_needed=1)

# Вывод:
# 💻 Офисный ПК включается...
#    CPU: Intel i5
#    RAM: 16 ГБ
#    Storage: SSD 512 ГБ
# 
# ▶️ Запуск приложения: Microsoft Word
# 🔷 Intel i5 (6 ядер, 3.2 ГГц) обрабатывает: Microsoft Word
# 💾 Выделено 2 ГБ ОЗУ (всего используется: 2/16 ГБ)
# 💽 Файл 'Microsoft Word_data' сохранён на SSD (0.5 ГБ)
# 
# ▶️ Запуск приложения: Chrome
# 🔷 Intel i5 (6 ядер, 3.2 ГГц) обрабатывает: Chrome
# 💾 Выделено 4 ГБ ОЗУ (всего используется: 6/16 ГБ)
# 💽 Файл 'Chrome_data' сохранён на SSD (1 ГБ)

# Игровой компьютер (с видеокартой)
gaming_pc = Computer(
    "Игровой ПК",
    CPU("AMD Ryzen 9", 16, 4.5),
    RAM(32),
    Storage("SSD", 2000),
    GPU("NVIDIA RTX 4090", 24)
)

gaming_pc.power_on()
gaming_pc.play_game("Cyberpunk 2077")

# Вывод:
# 💻 Игровой ПК включается...
#    CPU: AMD Ryzen 9
#    RAM: 32 ГБ
#    Storage: SSD 2000 ГБ
#    GPU: NVIDIA RTX 4090
# 
# 🎮 Запуск игры: Cyberpunk 2077
# 🔷 AMD Ryzen 9 (16 ядер, 4.5 ГГц) обрабатывает: игровая логика Cyberpunk 2077
# 🎮 NVIDIA RTX 4090 (24 ГБ VRAM) рендерит: сцена из Cyberpunk 2077
# 💾 Выделено 4 ГБ ОЗУ (всего используется: 4/32 ГБ)
```

### Пример 3: Композиция vs Наследование — сравнение

```python
# ❌ ПЛОХО: Использование наследования там, где нужна композиция

class Bird:
    def fly(self):
        print("Птица летит")


class Penguin(Bird):
    # Проблема: пингвин не может летать!
    def fly(self):
        raise NotImplementedError("Пингвины не летают!")


# ✅ ХОРОШО: Использование композиции

class FlyingAbility:
    """Способность летать как отдельный компонент"""
    
    def fly(self):
        print("✈️ Летит в небе")


class SwimmingAbility:
    """Способность плавать как отдельный компонент"""
    
    def swim(self):
        print("🏊 Плывёт в воде")


class WalkingAbility:
    """Способность ходить как отдельный компонент"""
    
    def walk(self):
        print("🚶 Идёт по земле")


class Animal:
    """Базовый класс животного"""
    
    def __init__(self, name):
        self.name = name
        self.abilities = []
    
    def add_ability(self, ability):
        self.abilities.append(ability)
    
    def perform_actions(self):
        print(f"\n{self.name}:")
        for ability in self.abilities:
            if hasattr(ability, 'fly'):
                ability.fly()
            if hasattr(ability, 'swim'):
                ability.swim()
            if hasattr(ability, 'walk'):
                ability.walk()


# Создаём разных животных с разными способностями
eagle = Animal("Орёл")
eagle.add_ability(FlyingAbility())
eagle.add_ability(WalkingAbility())

penguin = Animal("Пингвин")
penguin.add_ability(SwimmingAbility())
penguin.add_ability(WalkingAbility())

duck = Animal("Утка")
duck.add_ability(FlyingAbility())
duck.add_ability(SwimmingAbility())
duck.add_ability(WalkingAbility())

fish = Animal("Рыба")
fish.add_ability(SwimmingAbility())

# Демонстрация
for animal in [eagle, penguin, duck, fish]:
    animal.perform_actions()

# Вывод:
# Орёл:
# ✈️ Летит в небе
# 🚶 Идёт по земле
# 
# Пингвин:
# 🏊 Плывёт в воде
# 🚶 Идёт по земле
# 
# Утка:
# ✈️ Летит в небе
# 🏊 Плывёт в воде
# 🚶 Идёт по земле
# 
# Рыба:
# 🏊 Плывёт в воде
```

### Пример 4: Реальный кейс — система уведомлений

```python
class EmailSender:
    """Компонент для отправки email"""
    
    def send(self, recipient, message):
        print(f"📧 Email отправлен на {recipient}: {message}")


class SMSSender:
    """Компонент для отправки SMS"""
    
    def send(self, phone, message):
        print(f"📱 SMS отправлено на {phone}: {message}")


class PushSender:
    """Компонент для отправки push-уведомлений"""
    
    def send(self, device_id, message):
        print(f"🔔 Push отправлен на устройство {device_id}: {message}")


class Logger:
    """Компонент для логирования"""
    
    def log(self, message):
        print(f"📝 [LOG] {message}")


class NotificationService:
    """Сервис уведомлений использует композицию"""
    
    def __init__(self, email_sender=None, sms_sender=None, push_sender=None, logger=None):
        self.email_sender = email_sender
        self.sms_sender = sms_sender
        self.push_sender = push_sender
        self.logger = logger
    
    def notify(self, user, message, channels):
        """Отправить уведомление по выбранным каналам"""
        if self.logger:
            self.logger.log(f"Отправка уведомления пользователю {user['name']}")
        
        if 'email' in channels and self.email_sender:
            self.email_sender.send(user['email'], message)
        
        if 'sms' in channels and self.sms_sender:
            self.sms_sender.send(user['phone'], message)
        
        if 'push' in channels and self.push_sender:
            self.push_sender.send(user['device_id'], message)
        
        print()


# Использование — легко настроить разные конфигурации

# Полная конфигурация со всеми компонентами
full_service = NotificationService(
    email_sender=EmailSender(),
    sms_sender=SMSSender(),
    push_sender=PushSender(),
    logger=Logger()
)

user1 = {
    'name': 'Иван',
    'email': 'ivan@example.com',
    'phone': '+79001234567',
    'device_id': 'device_123'
}

full_service.notify(user1, "Ваш заказ готов!", channels=['email', 'sms', 'push'])

# Вывод:
# 📝 [LOG] Отправка уведомления пользователю Иван
# 📧 Email отправлен на ivan@example.com: Ваш заказ готов!
# 📱 SMS отправлено на +79001234567: Ваш заказ готов!
# 🔔 Push отправлен на устройство device_123: Ваш заказ готов!

# Минимальная конфигурация — только email
minimal_service = NotificationService(email_sender=EmailSender())

user2 = {
    'name': 'Мария',
    'email': 'maria@example.com',
    'phone': '+79007654321',
    'device_id': 'device_456'
}

minimal_service.notify(user2, "Добро пожаловать!", channels=['email', 'sms'])
# Вывод:
# 📧 Email отправлен на maria@example.com: Добро пожаловать!
# (SMS не отправлено, т.к. компонент не подключён)
```


## Когда использовать что?

### Используй наследование когда:
- Есть отношение **"является"** (is-a)
  - Собака **является** животным
  - Квадрат **является** фигурой
- Нужно переиспользовать код из базового класса
- Дочерние классы — это специализация родительского

### Используй композицию когда:
- Есть отношение **"имеет"** (has-a)
  - Машина **имеет** двигатель
  - Компьютер **имеет** процессор
- Нужна гибкость и возможность заменить компоненты
- Требуется комбинировать разные возможности
- Хочешь избежать сложных иерархий наследования

### Используй абстрактные классы когда:
- Нужно определить обязательный интерфейс для наследников
- Хочешь гарантировать, что все дочерние классы реализуют определённые методы
- Создаёшь фреймворк или библиотеку

### Используй протоколы когда:
- Нужна структурная типизация без явного наследования
- Работаешь с утиной типизацией, но хочешь типобезопасность
- Хочешь проверять наличие методов статически (через mypy)


## Резюме

- **Наследование** — создание новых классов на основе существующих (отношение "является")
- **Полиморфизм** — единообразная работа с объектами разных классов через общий интерфейс
- **Абстрактные классы** — шаблоны с обязательными методами для наследников
- **Протоколы** — структурная типизация без явного наследования
- **Generics** — создание обобщённых типов для работы с разными данными
- **Композиция** — построение сложных объектов из простых компонентов (отношение "имеет")

**Правило**: Предпочитай композицию наследованию (Composition over Inheritance) — это делает код более гибким и легче тестируемым!

----

# `30` (`*`) Extra OOP
## `30.1` `__slots__`, `__dict__`
### `__dict__` — словарь атрибутов

По умолчанию Python хранит атрибуты объекта в специальном словаре `__dict__`. Это даёт гибкость — можно динамически добавлять и удалять атрибуты, но требует больше памяти.

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

person = Person("Иван", 25)

# Доступ к словарю атрибутов
print(person.__dict__)  # {'name': 'Иван', 'age': 25}

# Можно динамически добавлять атрибуты
person.city = "Москва"
print(person.__dict__)  # {'name': 'Иван', 'age': 25, 'city': 'Москва'}

# Можно изменять через __dict__
person.__dict__['email'] = 'ivan@example.com'
print(person.email)  # ivan@example.com
```

### `__slots__` — оптимизация памяти
[СЛОТЫ В ПИТОНЕ!!!](https://habr.com/ru/articles/686220/)

`__slots__` позволяет явно указать, какие атрибуты может иметь класс. Это:
- **Экономит память** (особенно при создании тысяч объектов)
- **Ускоряет доступ** к атрибутам
- **Запрещает** динамическое добавление новых атрибутов

```python
class OptimizedPerson:
    __slots__ = ('name', 'age')  # Только эти атрибуты разрешены
    
    def __init__(self, name, age):
        self.name = name
        self.age = age

person = OptimizedPerson("Мария", 30)
print(person.name, person.age)  # Мария 30

# У объекта больше нет __dict__
try:
    print(person.__dict__)
except AttributeError as e:
    print(f"Ошибка: {e}")  # 'OptimizedPerson' object has no attribute '__dict__'

# Нельзя добавить новый атрибут
try:
    person.city = "Санкт-Петербург"
except AttributeError as e:
    print(f"Ошибка: {e}")  # 'OptimizedPerson' object has no attribute 'city'
```

### Пример 1: Сравнение памяти с `__slots__` и без

```python
import sys

class RegularPoint:
    """Обычный класс с __dict__"""
    def __init__(self, x, y):
        self.x = x
        self.y = y

class OptimizedPoint:
    """Класс с __slots__"""
    __slots__ = ('x', 'y')
    
    def __init__(self, x, y):
        self.x = x
        self.y = y

# Создаём объекты
regular = RegularPoint(10, 20)
optimized = OptimizedPoint(10, 20)

# Сравниваем размер в памяти
print(f"Размер RegularPoint: {sys.getsizeof(regular.__dict__)} байт")
print(f"Размер OptimizedPoint: {sys.getsizeof(optimized)} байт")

# При создании миллиона объектов разница будет огромной!
import time

# Тест: создание 1 миллиона обычных объектов
start = time.time()
regular_objects = [RegularPoint(i, i*2) for i in range(1_000_000)]
regular_time = time.time() - start

# Тест: создание 1 миллиона оптимизированных объектов
start = time.time()
optimized_objects = [OptimizedPoint(i, i*2) for i in range(1_000_000)]
optimized_time = time.time() - start

print(f"\n⏱️ Создание 1 млн RegularPoint: {regular_time:.3f} сек")
print(f"⏱️ Создание 1 млн OptimizedPoint: {optimized_time:.3f} сек")
print(f"⚡ Ускорение: {regular_time / optimized_time:.2f}x")
```

### Пример 2: `__slots__` с наследованием

```python
class Animal:
    __slots__ = ('name', 'age')
    
    def __init__(self, name, age):
        self.name = name
        self.age = age

class Dog(Animal):
    # Добавляем дополнительные слоты для дочернего класса
    __slots__ = ('breed',)
    
    def __init__(self, name, age, breed):
        super().__init__(name, age)
        self.breed = breed

dog = Dog("Бобик", 3, "Лабрадор")
print(f"{dog.name}, {dog.age} лет, порода: {dog.breed}")

# Доступны только атрибуты из slots родителя и дочернего класса
try:
    dog.color = "чёрный"
except AttributeError as e:
    print(f"Ошибка: {e}")
```

### Пример 3: Когда НЕ использовать `__slots__`

```python
class ConfigurableObject:
    """Объект, который должен поддерживать динамические атрибуты"""
    # НЕ используем __slots__, т.к. нужна гибкость
    
    def __init__(self, **kwargs):
        for key, value in kwargs.items():
            setattr(self, key, value)

# Пользователь может добавлять любые атрибуты
config = ConfigurableObject(host="localhost", port=8080, debug=True)
print(config.host, config.port, config.debug)  # localhost 8080 True

# Легко добавляем новые параметры
config.timeout = 30
config.max_connections = 100
print(config.timeout)  # 30
```

## `30.2` Enum
[Enum в Python](https://habr.com/ru/companies/timeweb/articles/564826/)

**Enum (перечисление)** — это класс для создания именованных констант. Помогает избежать "магических чисел" и строк в коде, делая его более читаемым и безопасным.

### Базовое использование

```python
from enum import Enum

class Color(Enum):
    RED = 1
    GREEN = 2
    BLUE = 3

# Доступ к элементам
print(Color.RED)        # Color.RED
print(Color.RED.name)   # RED
print(Color.RED.value)  # 1

# Сравнение
print(Color.RED == Color.GREEN)  # False
print(Color.RED is Color.RED)    # True

# Итерация
for color in Color:
    print(f"{color.name} = {color.value}")
# RED = 1
# GREEN = 2
# BLUE = 3
```

### Пример 1: Статусы заказа

```python
from enum import Enum, auto

class OrderStatus(Enum):
    """Статусы заказа в интернет-магазине"""
    PENDING = auto()      # auto() автоматически генерирует значения
    CONFIRMED = auto()
    PROCESSING = auto()
    SHIPPED = auto()
    DELIVERED = auto()
    CANCELLED = auto()

class Order:
    def __init__(self, order_id):
        self.order_id = order_id
        self.status = OrderStatus.PENDING
    
    def confirm(self):
        if self.status == OrderStatus.PENDING:
            self.status = OrderStatus.CONFIRMED
            print(f"✅ Заказ {self.order_id} подтверждён")
        else:
            print(f"❌ Нельзя подтвердить заказ в статусе {self.status.name}")
    
    def ship(self):
        if self.status == OrderStatus.PROCESSING:
            self.status = OrderStatus.SHIPPED
            print(f"📦 Заказ {self.order_id} отправлен")
        else:
            print(f"❌ Нельзя отправить заказ в статусе {self.status.name}")
    
    def cancel(self):
        if self.status in (OrderStatus.PENDING, OrderStatus.CONFIRMED):
            self.status = OrderStatus.CANCELLED
            print(f"🚫 Заказ {self.order_id} отменён")
        else:
            print(f"❌ Нельзя отменить заказ в статусе {self.status.name}")
    
    def __repr__(self):
        return f"Order(id={self.order_id}, status={self.status.name})"

# Использование
order = Order(12345)
print(order)  # Order(id=12345, status=PENDING)

order.confirm()
print(order)  # Order(id=12345, status=CONFIRMED)

order.cancel()
print(order)  # Order(id=12345, status=CANCELLED)

order.ship()  # ❌ Нельзя отправить заказ в статусе CANCELLED
```

### Пример 2: Уровни логирования

```python
from enum import IntEnum

class LogLevel(IntEnum):
    """Уровни логирования с числовыми значениями"""
    DEBUG = 10
    INFO = 20
    WARNING = 30
    ERROR = 40
    CRITICAL = 50

class Logger:
    def __init__(self, min_level=LogLevel.INFO):
        self.min_level = min_level
    
    def log(self, level, message):
        if level >= self.min_level:
            emoji = {
                LogLevel.DEBUG: "🐛",
                LogLevel.INFO: "ℹ️",
                LogLevel.WARNING: "⚠️",
                LogLevel.ERROR: "❌",
                LogLevel.CRITICAL: "🔥"
            }
            print(f"{emoji[level]} [{level.name}] {message}")
    
    def debug(self, message):
        self.log(LogLevel.DEBUG, message)
    
    def info(self, message):
        self.log(LogLevel.INFO, message)
    
    def warning(self, message):
        self.log(LogLevel.WARNING, message)
    
    def error(self, message):
        self.log(LogLevel.ERROR, message)
    
    def critical(self, message):
        self.log(LogLevel.CRITICAL, message)

# Логгер с минимальным уровнем WARNING
logger = Logger(min_level=LogLevel.WARNING)

logger.debug("Это отладочное сообщение")      # Не выведется
logger.info("Это информационное сообщение")   # Не выведется
logger.warning("Это предупреждение")          # ⚠️ [WARNING] Это предупреждение
logger.error("Это ошибка")                    # ❌ [ERROR] Это ошибка
logger.critical("Это критическая ошибка!")    # 🔥 [CRITICAL] Это критическая ошибка!
```

### Пример 3: HTTP методы и коды ответов

```python
from enum import Enum

class HTTPMethod(Enum):
    """HTTP методы"""
    GET = "GET"
    POST = "POST"
    PUT = "PUT"
    PATCH = "PATCH"
    DELETE = "DELETE"

class HTTPStatus(Enum):
    """HTTP статус-коды"""
    OK = 200
    CREATED = 201
    BAD_REQUEST = 400
    UNAUTHORIZED = 401
    FORBIDDEN = 403
    NOT_FOUND = 404
    INTERNAL_SERVER_ERROR = 500
    
    def is_success(self):
        """Проверка на успешный код (2xx)"""
        return 200 <= self.value < 300
    
    def is_client_error(self):
        """Проверка на клиентскую ошибку (4xx)"""
        return 400 <= self.value < 500
    
    def is_server_error(self):
        """Проверка на серверную ошибку (5xx)"""
        return 500 <= self.value < 600

class Request:
    def __init__(self, method, url):
        self.method = method
        self.url = url
    
    def __repr__(self):
        return f"{self.method.value} {self.url}"

class Response:
    def __init__(self, status, data=None):
        self.status = status
        self.data = data
    
    def __repr__(self):
        return f"Response({self.status.value} {self.status.name})"

# Использование
request = Request(HTTPMethod.GET, "/api/users")
print(request)  # GET /api/users

response = Response(HTTPStatus.OK, {"users": []})
print(response)  # Response(200 OK)
print(f"Успешный запрос: {response.status.is_success()}")  # True

error_response = Response(HTTPStatus.NOT_FOUND)
print(error_response)  # Response(404 NOT_FOUND)
print(f"Клиентская ошибка: {error_response.status.is_client_error()}")  # True
```

### Пример 4: Enum со строками (StrEnum в Python 3.11+)

```python
from enum import Enum

class Currency(str, Enum):
    """Валюты (наследуются от str для удобного сравнения)"""
    USD = "USD"
    EUR = "EUR"
    RUB = "RUB"
    GBP = "GBP"
    JPY = "JPY"
    
    @property
    def symbol(self):
        """Символ валюты"""
        symbols = {
            Currency.USD: "$",
            Currency.EUR: "€",
            Currency.RUB: "₽",
            Currency.GBP: "£",
            Currency.JPY: "¥"
        }
        return symbols[self]

class Money:
    def __init__(self, amount, currency):
        self.amount = amount
        self.currency = currency
    
    def __repr__(self):
        return f"{self.amount}{self.currency.symbol}"
    
    def __add__(self, other):
        if self.currency != other.currency:
            raise ValueError(f"Нельзя складывать {self.currency.value} и {other.currency.value}")
        return Money(self.amount + other.amount, self.currency)

# Использование
price1 = Money(100, Currency.USD)
price2 = Money(50, Currency.USD)
print(price1)  # 100$
print(price2)  # 50$

total = price1 + price2
print(f"Итого: {total}")  # Итого: 150$

# Попытка сложить разные валюты
try:
    wrong = Money(100, Currency.EUR) + Money(50, Currency.RUB)
except ValueError as e:
    print(f"Ошибка: {e}")  # Ошибка: Нельзя складывать EUR и RUB
```

## `30.3` Миксины
[Миксины в Python](https://docs-python.ru/tutorial/klassy-jazyke-python/takoe-klassy-miksiny/)

**Миксин (Mixin)** — это класс, который предоставляет дополнительную функциональность другим классам через множественное наследование. Миксины не используются самостоятельно, а "подмешиваются" к основным классам.

### Основные правила миксинов:
1. Миксин не должен иметь `__init__` (или должен корректно работать с `super()`)
2. Название обычно заканчивается на `Mixin`
3. Миксин предоставляет одну конкретную функциональность

### Пример 1: Миксины для сериализации

```python
import json
import pickle

class JSONSerializerMixin:
    """Миксин для сериализации в JSON"""
    
    def to_json(self):
        """Преобразовать объект в JSON"""
        return json.dumps(self.__dict__, ensure_ascii=False, indent=2)
    
    @classmethod
    def from_json(cls, json_string):
        """Создать объект из JSON"""
        data = json.loads(json_string)
        return cls(**data)

class PickleSerializerMixin:
    """Миксин для сериализации через pickle"""
    
    def to_pickle(self):
        """Преобразовать объект в bytes через pickle"""
        return pickle.dumps(self)
    
    @classmethod
    def from_pickle(cls, data):
        """Создать объект из pickle bytes"""
        return pickle.loads(data)

class ReprMixin:
    """Миксин для красивого __repr__"""
    
    def __repr__(self):
        attrs = ', '.join(f"{k}={v!r}" for k, v in self.__dict__.items())
        return f"{self.__class__.__name__}({attrs})"

# Класс использует несколько миксинов
class User(JSONSerializerMixin, PickleSerializerMixin, ReprMixin):
    def __init__(self, username, email, age):
        self.username = username
        self.email = email
        self.age = age

# Использование
user = User("john_doe", "john@example.com", 25)
print(user)  # User(username='john_doe', email='john@example.com', age=25)

# JSON сериализация
json_data = user.to_json()
print("\nJSON:")
print(json_data)
# {
#   "username": "john_doe",
#   "email": "john@example.com",
#   "age": 25
# }

# Восстановление из JSON
restored_user = User.from_json(json_data)
print(f"\nВосстановлен из JSON: {restored_user}")

# Pickle сериализация
pickle_data = user.to_pickle()
print(f"\nPickle bytes: {pickle_data[:50]}...")

restored_from_pickle = User.from_pickle(pickle_data)
print(f"Восстановлен из Pickle: {restored_from_pickle}")
```

### Пример 2: Миксины для валидации

```python
class ValidationMixin:
    """Миксин для валидации данных"""
    
    def validate(self):
        """Валидация всех полей с правилами"""
        errors = []
        
        for field_name, rules in self._validation_rules.items():
            value = getattr(self, field_name, None)
            
            # Проверка required
            if rules.get('required') and not value:
                errors.append(f"{field_name} обязателен")
                continue
            
            # Проверка min_length
            if 'min_length' in rules and len(str(value)) < rules['min_length']:
                errors.append(f"{field_name} должен быть не короче {rules['min_length']} символов")
            
            # Проверка max_length
            if 'max_length' in rules and len(str(value)) > rules['max_length']:
                errors.append(f"{field_name} должен быть не длиннее {rules['max_length']} символов")
            
            # Проверка min_value
            if 'min_value' in rules and value < rules['min_value']:
                errors.append(f"{field_name} должен быть не меньше {rules['min_value']}")
            
            # Проверка max_value
            if 'max_value' in rules and value > rules['max_value']:
                errors.append(f"{field_name} должен быть не больше {rules['max_value']}")
        
        return errors
    
    def is_valid(self):
        """Проверка валидности"""
        return len(self.validate()) == 0

class TimestampMixin:
    """Миксин для автоматических временных меток"""
    
    def __init__(self, *args, **kwargs):
        from datetime import datetime
        super().__init__(*args, **kwargs)
        self.created_at = datetime.now()
        self.updated_at = datetime.now()
    
    def touch(self):
        """Обновить временную метку"""
        from datetime import datetime
        self.updated_at = datetime.now()

class Product(ValidationMixin, TimestampMixin):
    """Продукт с валидацией и временными метками"""
    
    _validation_rules = {
        'name': {'required': True, 'min_length': 3, 'max_length': 100},
        'price': {'required': True, 'min_value': 0, 'max_value': 1_000_000},
        'quantity': {'required': True, 'min_value': 0}
    }
    
    def __init__(self, name, price, quantity):
        self.name = name
        self.price = price
        self.quantity = quantity
        super().__init__()  # Вызываем __init__ миксинов
    
    def __repr__(self):
        return f"Product(name='{self.name}', price={self.price}, quantity={self.quantity})"

# Использование
# Валидный продукт
product = Product("Ноутбук", 50000, 10)
print(product)
print(f"Валиден: {product.is_valid()}")  # True
print(f"Создан: {product.created_at}")

# Невалидный продукт
invalid_product = Product("AB", -100, 5)
print(f"\nВалиден: {invalid_product.is_valid()}")  # False
print("Ошибки валидации:")
for error in invalid_product.validate():
    print(f"  - {error}")
# Ошибки валидации:
#   - name должен быть не короче 3 символов
#   - price должен быть не меньше 0

# Обновление временной метки
import time
time.sleep(0.1)
product.touch()
print(f"\nОбновлён: {product.updated_at}")
print(f"Разница: {(product.updated_at - product.created_at).total_seconds():.2f} сек")
```

### Пример 3: Миксин для сравнения

```python
class ComparableMixin:
    """Миксин для автоматической реализации операторов сравнения"""
    
    def _comparable_value(self):
        """Метод должен быть переопределён в дочернем классе"""
        raise NotImplementedError
    
    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return NotImplemented
        return self._comparable_value() == other._comparable_value()
    
    def __lt__(self, other):
        if not isinstance(other, self.__class__):
            return NotImplemented
        return self._comparable_value() < other._comparable_value()
    
    def __le__(self, other):
        return self == other or self < other
    
    def __gt__(self, other):
        return not self <= other
    
    def __ge__(self, other):
        return not self < other
    
    def __ne__(self, other):
        return not self == other

class Student(ComparableMixin):
    """Студент сравнивается по среднему баллу"""
    
    def __init__(self, name, grades):
        self.name = name
        self.grades = grades
    
    def _comparable_value(self):
        return sum(self.grades) / len(self.grades) if self.grades else 0
    
    def average(self):
        return self._comparable_value()
    
    def __repr__(self):
        return f"Student('{self.name}', avg={self.average():.2f})"

# Использование
student1 = Student("Иван", [5, 4, 5, 5, 4])
student2 = Student("Мария", [5, 5, 5, 4, 5])
student3 = Student("Пётр", [3, 4, 3, 4, 3])

print(student1)  # Student('Иван', avg=4.60)
print(student2)  # Student('Мария', avg=4.80)
print(student3)  # Student('Пётр', avg=3.40)

print(f"\n{student2.name} лучше {student1.name}: {student2 > student1}")  # True
print(f"{student3.name} хуже {student1.name}: {student3 < student1}")    # True
print(f"{student1.name} == {student2.name}: {student1 == student2}")     # False

# Сортировка студентов
students = [student3, student1, student2]
sorted_students = sorted(students)
print("\nСтуденты по среднему баллу:")
for student in sorted_students:
    print(f"  {student}")
# Student('Пётр', avg=3.40)
# Student('Иван', avg=4.60)
# Student('Мария', avg=4.80)
```

## `30.4` dataclasses
[dataclasses в Python (видео)](https://www.youtube.com/watch?v=aH5sgOxuCnk)
[dataclasses в Python (статья)](https://habr.com/ru/companies/otus/articles/650257/)

**dataclasses** (появились в Python 3.7) — это декоратор, который автоматически генерирует специальные методы (`__init__`, `__repr__`, `__eq__` и другие) для классов, которые в основном хранят данные.

### Базовое использование

```python
from dataclasses import dataclass

@dataclass
class Point:
    x: int
    y: int

# Автоматически создаётся __init__
point = Point(10, 20)

# Автоматически создаётся __repr__
print(point)  # Point(x=10, y=20)

# Автоматически создаётся __eq__
point2 = Point(10, 20)
print(point == point2)  # True
```

### Пример 1: Dataclass с значениями по умолчанию

```python
from dataclasses import dataclass, field
from typing import List

@dataclass
class Book:
    title: str
    author: str
    year: int
    pages: int
    isbn: str = ""  # Значение по умолчанию
    tags: List[str] = field(default_factory=list)  # Для изменяемых типов
    
    def __post_init__(self):
        """Вызывается после __init__ для дополнительной логики"""
        if self.year < 0:
            raise ValueError("Год не может быть отрицательным")
    
    @property
    def age(self):
        """Сколько лет книге"""
        from datetime import datetime
        return datetime.now().year - self.year

# Использование
book = Book(
    title="Война и мир",
    author="Лев Толстой",
    year=1869,
    pages=1225,
    tags=["классика", "роман", "исторический"]
)

print(book)
# Book(title='Война и мир', author='Лев Толстой', year=1869, pages=1225, isbn='', tags=['классика', 'роман', 'исторический'])

print(f"Возраст книги: {book.age} лет")  # Возраст книги: 156 лет

# Создание без опциональных полей
book2 = Book("1984", "Джордж Оруэлл", 1949, 328)
print(book2)
# Book(title='1984', author='Джордж Оруэлл', year=1949, pages=328, isbn='', tags=[])
```

### Пример 2: Замороженные dataclasses (неизменяемые)

```python
from dataclasses import dataclass

@dataclass(frozen=True)
class Coordinate:
    """Неизменяемая координата"""
    latitude: float
    longitude: float
    
    def distance_to(self, other):
        """Упрощённое вычисление расстояния"""
        return ((self.latitude - other.latitude) ** 2 + 
                (self.longitude - other.longitude) ** 2) ** 0.5

# Использование
moscow = Coordinate(55.7558, 37.6173)
spb = Coordinate(59.9311, 30.3609)

print(moscow)  # Coordinate(latitude=55.7558, longitude=37.6173)
print(f"Расстояние: {moscow.distance_to(spb):.2f}")  # Упрощённое

# Попытка изменить вызовет ошибку
try:
    moscow.latitude = 60.0
except Exception as e:
    print(f"Ошибка: {e}")  # Ошибка: cannot assign to field 'latitude'

# frozen dataclasses можно использовать как ключи в словаре
locations = {
    moscow: "Москва",
    spb: "Санкт-Петербург"
}
print(locations[moscow])  # Москва
```

### Пример 3: Dataclass с вычисляемыми полями

```python
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional

@dataclass
class Task:
    """Задача в трекере"""
    title: str
    description: str = ""
    priority: int = 1  # 1-5
    created_at: datetime = field(default_factory=datetime.now)
    completed_at: Optional[datetime] = None
    
    @property
    def is_completed(self) -> bool:
        return self.completed_at is not None
    
    @property
    def duration(self) -> Optional[float]:
        """Время выполнения в часах"""
        if self.completed_at:
            delta = self.completed_at - self.created_at
            return delta.total_seconds() / 3600
        return None
    
    def complete(self):
        """Отметить задачу как выполненную"""
        if not self.is_completed:
            self.completed_at = datetime.now()
            print(f"✅ Задача '{self.title}' выполнена!")
        else:
            print(f"⚠️ Задача '{self.title}' уже выполнена")
    
    def __str__(self):
        status = "✅" if self.is_completed else "⏳"
        return f"{status} [{self.priority}] {self.title}"

# Использование
task1 = Task("Написать код", priority=3)
task2 = Task("Написать тесты", "Покрыть тестами модуль user", priority=4)
task3 = Task("Развернуть на сервере", priority=5)

print(task1)  # ⏳ [3] Написать код
print(task2)  # ⏳ [4] Написать тесты
print(task3)  # ⏳ [5] Развернуть на сервере

# Выполняем задачу
import time
time.sleep(0.01)  # Имитация выполнения
task1.complete()  # ✅ Задача 'Написать код' выполнена!

print(f"\n{task1}")  # ✅ [3] Написать код
print(f"Время выполнения: {task1.duration:.4f} часов")

# Сортировка задач по приоритету
tasks = [task1, task2, task3]
sorted_tasks = sorted(tasks, key=lambda t: t.priority, reverse=True)
print("\nЗадачи по приоритету:")
for task in sorted_tasks:
    print(f"  {task}")
# ⏳ [5] Развернуть на сервере
# ⏳ [4] Написать тесты
# ✅ [3] Написать код
```

### Пример 4: Сложные dataclasses с вложенными структурами

```python
from dataclasses import dataclass, field
from typing import List
from enum import Enum

class Department(Enum):
    """Отделы компании"""
    IT = "IT"
    HR = "HR"
    SALES = "Sales"
    MARKETING = "Marketing"

@dataclass
class Address:
    """Адрес"""
    street: str
    city: str
    country: str
    postal_code: str
    
    def __str__(self):
        return f"{self.street}, {self.city}, {self.postal_code}, {self.country}"

@dataclass
class Employee:
    """Сотрудник"""
    first_name: str
    last_name: str
    department: Department
    salary: float
    email: str
    
    @property
    def full_name(self):
        return f"{self.first_name} {self.last_name}"
    
    def __str__(self):
        return f"{self.full_name} ({self.department.value})"

@dataclass
class Company:
    """Компания"""
    name: str
    address: Address
    employees: List[Employee] = field(default_factory=list)
    
    def hire(self, employee: Employee):
        """Нанять сотрудника"""
        self.employees.append(employee)
        print(f"✅ {employee.full_name} принят в отдел {employee.department.value}")
    
    def fire(self, employee: Employee):
        """Уволить сотрудника"""
        if employee in self.employees:
            self.employees.remove(employee)
            print(f"❌ {employee.full_name} уволен")
    
    def get_by_department(self, department: Department) -> List[Employee]:
        """Получить сотрудников отдела"""
        return [emp for emp in self.employees if emp.department == department]
    
    def total_salary(self) -> float:
        """Общий фонд заработной платы"""
        return sum(emp.salary for emp in self.employees)
    
    def __str__(self):
        return f"{self.name} ({len(self.employees)} сотрудников)"

# Использование
address = Address(
    street="ул. Ленина, 10",
    city="Москва",
    country="Россия",
    postal_code="101000"
)

company = Company("TechCorp", address)
print(f"{company.name}\nАдрес: {company.address}\n")

# Нанимаем сотрудников
emp1 = Employee("Иван", "Петров", Department.IT, 100000, "ivan@techcorp.com")
emp2 = Employee("Мария", "Сидорова", Department.IT, 120000, "maria@techcorp.com")
emp3 = Employee("Пётр", "Иванов", Department.SALES, 80000, "petr@techcorp.com")
emp4 = Employee("Анна", "Смирнова", Department.HR, 90000, "anna@techcorp.com")

for emp in [emp1, emp2, emp3, emp4]:
    company.hire(emp)

print(f"\n{company}")
print(f"Общий фонд ЗП: {company.total_salary():,.0f} ₽")

# Сотрудники IT отдела
print("\nIT отдел:")
for emp in company.get_by_department(Department.IT):
    print(f"  - {emp.full_name}: {emp.salary:,.0f} ₽")
```

### Пример 5: Dataclass с дополнительными параметрами

```python
from dataclasses import dataclass, field, asdict, astuple

@dataclass(order=True)  # Добавляет операторы сравнения
class Score:
    """Результат игрока (сравнивается по очкам)"""
    points: int = field(compare=True)  # Используется для сравнения
    player_name: str = field(compare=False)  # НЕ используется для сравнения
    level: int = field(default=1, compare=False)
    
    def __str__(self):
        return f"{self.player_name}: {self.points} очков (уровень {self.level})"

# Создание результатов
score1 = Score(1500, "Игрок1", 5)
score2 = Score(2000, "Игрок2", 7)
score3 = Score(1200, "Игрок3", 3)

# Сравнение работает автоматически благодаря order=True
print(score2 > score1)  # True
print(score3 < score1)  # True

# Сортировка
scores = [score1, score2, score3]
sorted_scores = sorted(scores, reverse=True)  # От большего к меньшему

print("\nТаблица лидеров:")
for i, score in enumerate(sorted_scores, 1):
    print(f"{i}. {score}")
# 1. Игрок2: 2000 очков (уровень 7)
# 2. Игрок1: 1500 очков (уровень 5)
# 3. Игрок3: 1200 очков (уровень 3)

# Преобразование в словарь
score_dict = asdict(score1)
print(f"\nКак словарь: {score_dict}")
# {'points': 1500, 'player_name': 'Игрок1', 'level': 5}

# Преобразование в кортеж
score_tuple = astuple(score1)
print(f"Как кортеж: {score_tuple}")
# (1500, 'Игрок1', 5)
```

### Пример 6: Dataclass для API ответов

```python
from dataclasses import dataclass, field
from typing import Optional, List, Dict, Any
from datetime import datetime
import json

@dataclass
class User:
    """Пользователь из API"""
    id: int
    username: str
    email: str
    is_active: bool = True
    created_at: Optional[datetime] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    @classmethod
    def from_dict(cls, data: dict):
        """Создать объект из словаря (например, из JSON API)"""
        # Преобразуем строку даты в datetime если есть
        if 'created_at' in data and isinstance(data['created_at'], str):
            data['created_at'] = datetime.fromisoformat(data['created_at'])
        return cls(**data)
    
    def to_dict(self):
        """Преобразовать в словарь для JSON"""
        result = {
            'id': self.id,
            'username': self.username,
            'email': self.email,
            'is_active': self.is_active,
            'metadata': self.metadata
        }
        if self.created_at:
            result['created_at'] = self.created_at.isoformat()
        return result

@dataclass
class APIResponse:
    """Ответ API"""
    success: bool
    data: Optional[Any] = None
    error: Optional[str] = None
    timestamp: datetime = field(default_factory=datetime.now)
    
    def to_json(self):
        """Преобразовать в JSON"""
        result = {
            'success': self.success,
            'timestamp': self.timestamp.isoformat()
        }
        if self.data is not None:
            # Если data это dataclass, преобразуем в dict
            if hasattr(self.data, 'to_dict'):
                result['data'] = self.data.to_dict()
            elif isinstance(self.data, list) and self.data and hasattr(self.data[0], 'to_dict'):
                result['data'] = [item.to_dict() for item in self.data]
            else:
                result['data'] = self.data
        if self.error:
            result['error'] = self.error
        return json.dumps(result, indent=2, ensure_ascii=False)

# Симуляция API

def get_user(user_id: int) -> APIResponse:
    """Получить пользователя по ID"""
    if user_id == 1:
        user = User(
            id=1,
            username="john_doe",
            email="john@example.com",
            created_at=datetime(2024, 1, 15),
            metadata={"country": "Russia", "premium": True}
        )
        return APIResponse(success=True, data=user)
    else:
        return APIResponse(success=False, error="Пользователь не найден")

def get_users() -> APIResponse:
    """Получить список пользователей"""
    users = [
        User(1, "john_doe", "john@example.com", metadata={"premium": True}),
        User(2, "jane_smith", "jane@example.com"),
        User(3, "bob_wilson", "bob@example.com", is_active=False)
    ]
    return APIResponse(success=True, data=users)

# Использование
print("=== Получение одного пользователя ===")
response1 = get_user(1)
print(response1.to_json())

print("\n=== Пользователь не найден ===")
response2 = get_user(999)
print(response2.to_json())

print("\n=== Список пользователей ===")
response3 = get_users()
print(response3.to_json())

# Работа с данными
if response1.success:
    user = response1.data
    print(f"\nПолучен пользователь: {user.username} ({user.email})")
    print(f"Метаданные: {user.metadata}")
```

### Пример 7: Dataclass с валидацией

```python
from dataclasses import dataclass
import re

@dataclass
class UserRegistration:
    """Регистрация пользователя с валидацией"""
    username: str
    email: str
    password: str
    age: int
    
    def __post_init__(self):
        """Валидация после создания объекта"""
        errors = []
        
        # Валидация username
        if len(self.username) < 3:
            errors.append("Username должен быть не менее 3 символов")
        if not self.username.isalnum():
            errors.append("Username должен содержать только буквы и цифры")
        
        # Валидация email
        email_pattern = r'^[\w\.-]+@[\w\.-]+\.\w+$'
        if not re.match(email_pattern, self.email):
            errors.append("Некорректный формат email")
        
        # Валидация password
        if len(self.password) < 8:
            errors.append("Пароль должен быть не менее 8 символов")
        if not any(c.isupper() for c in self.password):
            errors.append("Пароль должен содержать хотя бы одну заглавную букву")
        if not any(c.isdigit() for c in self.password):
            errors.append("Пароль должен содержать хотя бы одну цифру")
        
        # Валидация возраста
        if self.age < 18:
            errors.append("Возраст должен быть не менее 18 лет")
        if self.age > 120:
            errors.append("Некорректный возраст")
        
        if errors:
            raise ValueError("Ошибки валидации:\n  - " + "\n  - ".join(errors))

# Правильная регистрация
try:
    user1 = UserRegistration("john123", "john@example.com", "SecurePass123", 25)
    print(f"✅ Пользователь {user1.username} зарегистрирован")
except ValueError as e:
    print(f"❌ {e}")

# Неправильная регистрация
try:
    user2 = UserRegistration("ab", "invalid-email", "weak", 15)
    print(f"✅ Пользователь {user2.username} зарегистрирован")
except ValueError as e:
    print(f"❌ {e}")
# ❌ Ошибки валидации:
#   - Username должен быть не менее 3 символов
#   - Некорректный формат email
#   - Пароль должен быть не менее 8 символов
#   - Пароль должен содержать хотя бы одну заглавную букву
#   - Пароль должен содержать хотя бы одну цифру
#   - Возраст должен быть не менее 18 лет
```

### Сравнение: обычный класс vs dataclass

```python
# ❌ Обычный класс — много шаблонного кода
class PersonRegular:
    def __init__(self, name, age, city):
        self.name = name
        self.age = age
        self.city = city
    
    def __repr__(self):
        return f"PersonRegular(name='{self.name}', age={self.age}, city='{self.city}')"
    
    def __eq__(self, other):
        if not isinstance(other, PersonRegular):
            return NotImplemented
        return (self.name == other.name and 
                self.age == other.age and 
                self.city == other.city)

# ✅ Dataclass — лаконично и понятно
from dataclasses import dataclass

@dataclass
class PersonDataclass:
    name: str
    age: int
    city: str

# Оба работают одинаково
p1 = PersonRegular("Иван", 25, "Москва")
p2 = PersonDataclass("Мария", 30, "Санкт-Петербург")

print(p1)  # PersonRegular(name='Иван', age=25, city='Москва')
print(p2)  # PersonDataclass(name='Мария', age=30, city='Санкт-Петербург')

# Но dataclass требует гораздо меньше кода!
```

## Резюме

### `__slots__` и `__dict__`:
- **`__dict__`** — динамический словарь атрибутов (по умолчанию)
- **`__slots__`** — фиксированный набор атрибутов для экономии памяти
- Используй `__slots__` для классов, где создаются тысячи экземпляров

### Enum:
- **Перечисления** для именованных констант
- Заменяют "магические числа" и строки
- Делают код безопаснее и читабельнее
- Используй `auto()` для автогенерации значений

### Миксины:
- **Классы для добавления функциональности** через множественное наследование
- Один миксин = одна конкретная возможность
- Название обычно с суффиксом `Mixin`
- Не используются самостоятельно

### Dataclasses:
- **Автогенерация** `__init__`, `__repr__`, `__eq__` и других методов
- Идеальны для классов, хранящих данные
- Поддержка значений по умолчанию, frozen (неизменяемые), сортировки
- Используй для DTO (Data Transfer Objects), конфигураций, API моделей

**Когда что использовать:**
- **Много объектов** → `__slots__`
- **Константы** → `Enum`
- **Переиспользуемая функциональность** → Миксины
- **Классы с данными** → Dataclasses

----

# `31` (`*`) Виртуальное окружение
## `31.1` Что такое виртуальное окружение и зачем?
[Виртуальное окружение](https://www.youtube.com/watch?v=rsG1Y5k-9jo)

Представь, что ты работаешь над двумя проектами на Python. Один проект требует библиотеку `requests` версии 2.25.0, а другой — версии 2.31.0. Если установить обе версии глобально (на весь компьютер), возникнет конфликт — Python не может одновременно использовать две разные версии одной библиотеки.

**Виртуальное окружение** — это изолированная папка на твоём компьютере, где хранятся отдельная копия Python и все библиотеки для конкретного проекта. Это как отдельная "песочница" для каждого проекта.

### Зачем нужны виртуальные окружения?

1. **Изоляция зависимостей** — каждый проект имеет свои версии библиотек
2. **Чистота системы** — не засоряешь глобальный Python сотнями библиотек
3. **Воспроизводимость** — коллеги могут легко установить те же версии библиотек
4. **Безопасность** — экспериментируешь без риска сломать другие проекты

## `31.1` venv
`venv` — это встроенный модуль Python для создания виртуальных окружений. Он входит в стандартную библиотеку, поэтому ничего дополнительно устанавливать не нужно.

### Пример 1: Создание и активация виртуального окружения

```bash
# Создаём виртуальное окружение в папке venv
python -m venv venv

# Активация на Windows
venv\Scripts\activate

# Активация на macOS/Linux
source venv/bin/activate

# После активации в терминале появится (venv) перед строкой ввода
# (venv) C:\Users\User\myproject>
```

После активации все команды `pip install` будут устанавливать библиотеки только в это окружение.

### Пример 2: Работа с зависимостями

```bash
# Активируем окружение
source venv/bin/activate  # или venv\Scripts\activate на Windows

# Устанавливаем библиотеки
pip install requests flask

# Сохраняем список всех установленных библиотек
pip freeze > requirements.txt

# Деактивация окружения (выход из "песочницы")
deactivate
```

Файл `requirements.txt` будет выглядеть примерно так:
```
requests==2.31.0
flask==3.0.0
click==8.1.7
...
```

### Пример 3: Установка окружения на другом компьютере

```bash
# Твой коллега клонировал проект и хочет установить все зависимости

# Создаёт своё виртуальное окружение
python -m venv venv

# Активирует его
source venv/bin/activate

# Устанавливает все библиотеки из файла requirements.txt
pip install -r requirements.txt
```

Теперь у коллеги точно такие же версии библиотек, как у тебя!

## `31.1` poetry
[Видео по poetry](https://youtu.be/KOC0Gbo_0HY?si=Bnx6w1b-yf_ggU6L)

`poetry` — это более современный и мощный инструмент для управления зависимостями и виртуальными окружениями. Он автоматически создаёт окружения, разрешает конфликты версий и упрощает публикацию пакетов.

### Установка poetry

```bash
# На Windows (PowerShell)
(Invoke-WebRequest -Uri https://install.python-poetry.org -UseBasicParsing).Content | python -

# На macOS/Linux
curl -sSL https://install.python-poetry.org | python3 -
```

### Пример 1: Создание нового проекта

```bash
# Создаём новый проект с готовой структурой
poetry new my_project

cd my_project

# Poetry автоматически создаст файл pyproject.toml
```

Файл `pyproject.toml` содержит всю информацию о проекте:
```toml
[tool.poetry]
name = "my-project"
version = "0.1.0"
description = ""
authors = ["Your Name <you@example.com>"]

[tool.poetry.dependencies]
python = "^3.9"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"
```

### Пример 2: Установка зависимостей

```bash
# Добавляем библиотеку (Poetry автоматически найдёт совместимую версию)
poetry add requests

# Добавляем библиотеку только для разработки (например, для тестов)
poetry add --group dev pytest

# Устанавливаем все зависимости из pyproject.toml
poetry install
```

Poetry автоматически обновит `pyproject.toml` и создаст файл `poetry.lock`, который фиксирует точные версии всех библиотек.

### Пример 3: Запуск кода в виртуальном окружении

```bash
# Запуск Python-скрипта через Poetry
poetry run python main.py

# Запуск команды в виртуальном окружении
poetry run pytest

# Активация виртуального окружения в текущем терминале
poetry shell

# Теперь можешь запускать команды без poetry run:
python main.py
pytest
```

### Сравнение venv и poetry

| Критерий | venv | poetry |
|----------|------|--------|
| **Установка** | Встроен в Python | Требует установки |
| **Простота** | Проще для новичков | Больше возможностей |
| **Управление зависимостями** | Вручную через pip | Автоматически |
| **Файлы конфигурации** | requirements.txt | pyproject.toml + poetry.lock |
| **Разрешение конфликтов** | Нет | Да |

**Когда использовать venv:** для простых проектов, обучения, быстрых экспериментов.

**Когда использовать poetry:** для серьёзных проектов, работы в команде, публикации библиотек.

### Резюме

- **Виртуальное окружение** — изолированная среда для каждого проекта
- **venv** — простой встроенный инструмент для создания окружений
- **poetry** — продвинутый менеджер зависимостей с автоматическим управлением версиями
- Всегда используй виртуальные окружения, чтобы избежать конфликтов библиотек!

----

# `32` (`*`) Многопоточность
[Must have video](https://youtu.be/JIp14T9bvvc?si=uHOZNBIKbo7ZTk68)

## `32.1` Что такое многопоточность и зачем она нужна
**Многопоточность (multithreading)** — это способность программы выполнять несколько задач одновременно в рамках одного процесса. Каждая задача выполняется в отдельном **потоке (thread)** — это независимая последовательность инструкций внутри программы.

### **Простая аналогия:**

Представьте ресторан:
- **Без многопоточности:** один официант обслуживает столики по очереди. Пока он принимает заказ у первого стола, второй и третий ждут.
- **С многопоточностью:** несколько официантов работают одновременно. Один принимает заказ, другой приносит еду, третий убирает посуду — всё происходит параллельно.

### **Как работает обычная программа (однопоточная):**

```python
import time

def download_file(file_name):
    print(f"Начинаю загрузку {file_name}")
    time.sleep(2)  # Имитация загрузки файла (2 секунды)
    print(f"Загрузка {file_name} завершена")

# Загружаем файлы по очереди
start = time.time()

download_file("файл1.txt")
download_file("файл2.txt")
download_file("файл3.txt")

end = time.time()
print(f"Общее время: {end - start:.2f} секунд")

# Вывод:
# Начинаю загрузку файл1.txt
# Загрузка файл1.txt завершена
# Начинаю загрузку файл2.txt
# Загрузка файл2.txt завершена
# Начинаю загрузку файл3.txt
# Загрузка файл3.txt завершена
# Общее время: 6.00 секунд (2+2+2)
```

**Проблема:** каждый файл загружается по очереди. Пока первый файл загружается, программа простаивает и ждёт. Общее время = 6 секунд.

### **С многопоточностью:**

```python
import time
import threading

def download_file(file_name):
    print(f"Начинаю загрузку {file_name}")
    time.sleep(2)  # Имитация загрузки
    print(f"Загрузка {file_name} завершена")

# Создаём потоки для загрузки файлов одновременно
start = time.time()

thread1 = threading.Thread(target=download_file, args=("файл1.txt",))
thread2 = threading.Thread(target=download_file, args=("файл2.txt",))
thread3 = threading.Thread(target=download_file, args=("файл3.txt",))

# Запускаем все потоки
thread1.start()
thread2.start()
thread3.start()

# Ждём завершения всех потоков
thread1.join()
thread2.join()
thread3.join()

end = time.time()
print(f"Общее время: {end - start:.2f} секунд")

# Вывод:
# Начинаю загрузку файл1.txt
# Начинаю загрузку файл2.txt
# Начинаю загрузку файл3.txt
# Загрузка файл1.txt завершена
# Загрузка файл2.txt завершена
# Загрузка файл3.txt завершена
# Общее время: 2.00 секунд (все одновременно!)
```

**Результат:** все три файла загружаются параллельно. Общее время = 2 секунды вместо 6!

### **Зачем нужна многопоточность:**

#### **1. Ускорение I/O операций (ввод-вывод)**

Когда программа ждёт внешние операции (чтение файлов, сетевые запросы, работа с БД), процессор простаивает. Потоки позволяют делать другую работу во время ожидания.

```python
import time
import threading

def check_website(url):
    print(f"Проверяю {url}")
    time.sleep(1)  # Имитация HTTP-запроса
    print(f"{url} доступен")

websites = ["site1.com", "site2.com", "site3.com", "site4.com"]

# Без многопоточности — 4 секунды
start = time.time()
for site in websites:
    check_website(site)
print(f"Время без потоков: {time.time() - start:.2f} сек")  # ~4 секунды

# С многопоточностью — 1 секунда
start = time.time()
threads = []
for site in websites:
    thread = threading.Thread(target=check_website, args=(site,))
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()

print(f"Время с потоками: {time.time() - start:.2f} сек")  # ~1 секунда
```

#### **2. Отзывчивость интерфейса**

В GUI-приложениях длительные операции выполняются в отдельном потоке, чтобы интерфейс не зависал.

```python
import threading
import time

def long_operation():
    """Долгая операция (обработка данных, загрузка файла)"""
    print("Начинаю долгую операцию...")
    time.sleep(5)
    print("Операция завершена!")

# Без потоков — интерфейс зависнет на 5 секунд
# long_operation()  # Программа заморожена!

# С потоками — интерфейс работает
thread = threading.Thread(target=long_operation)
thread.start()

# Основной поток может продолжать работу
print("Интерфейс продолжает работать")
print("Пользователь может нажимать кнопки")
# ... интерфейс отзывчив

thread.join()  # Дожидаемся завершения в конце
```

#### **3. Параллельная обработка независимых задач**

```python
import threading
import time

def process_data(data_chunk, result_list, index):
    """Обработка части данных"""
    print(f"Обрабатываю часть {index}")
    time.sleep(1)  # Имитация обработки
    result = sum(data_chunk)  # Простая обработка
    result_list[index] = result
    print(f"Часть {index} обработана, результат: {result}")

# Большой массив данных
data = list(range(100))

# Делим на 4 части
chunk_size = 25
chunks = [data[i:i+chunk_size] for i in range(0, len(data), chunk_size)]

# Обрабатываем каждую часть в отдельном потоке
results = [0] * 4
threads = []

start = time.time()

for i, chunk in enumerate(chunks):
    thread = threading.Thread(target=process_data, args=(chunk, results, i))
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()

total = sum(results)
print(f"Итоговый результат: {total}")
print(f"Время: {time.time() - start:.2f} сек")

# Вывод:
# Обрабатываю часть 0
# Обрабатываю часть 1
# Обрабатываю часть 2
# Обрабатываю часть 3
# Часть 0 обработана, результат: 300
# Часть 1 обработана, результат: 925
# Часть 2 обработана, результат: 1550
# Часть 3 обработана, результат: 2175
# Итоговый результат: 4950
# Время: ~1 секунда (вместо 4)
```

### **Когда многопоточность полезна:**

✅ **Подходит для:**
- Загрузка файлов из интернета
- Работа с несколькими API одновременно
- Чтение/запись множества файлов
- Работа с базами данных (много запросов)
- GUI приложения (фоновые задачи)
- Сетевые серверы (обработка клиентов)

❌ **НЕ подходит для:**
- Тяжёлые вычисления (математика, обработка изображений)
- CPU-интенсивные задачи (для них нужна многопроцессность)

### **Ключевые моменты:**

- **Поток** — независимая последовательность выполнения кода
- **Многопоточность** — несколько потоков работ

## `32.2` Потоки vs Процессы — основные различия
**Потоки (Threads)** и **процессы (Processes)** — два способа параллельного выполнения задач, но они работают по-разному.

### **Основные различия:**

| Характеристика | Потоки (Threads) | Процессы (Processes) |
|----------------|------------------|---------------------|
| **Память** | Общая (делят память программы) | Изолированная (своя копия памяти) |
| **Создание** | Быстрое и лёгкое | Медленное, требует больше ресурсов |
| **Коммуникация** | Простая (общие переменные) | Сложная (нужны специальные механизмы) |
| **Изоляция** | Низкая (ошибка в одном влияет на все) | Высокая (независимы друг от друга) |
| **Использование** | I/O операции (файлы, сеть, БД) | CPU-интенсивные вычисления |

### **Визуальная аналогия:**

**Потоки** — это как несколько поваров на одной кухне:
- Делят одно пространство (общая память)
- Быстро передают друг другу продукты
- Могут мешать друг другу
- Если один сломает плиту, пострадают все

**Процессы** — это как несколько отдельных кухонь:
- У каждого своя кухня (своя память)
- Медленнее передавать продукты между кухнями
- Не мешают друг другу
- Если сломается одна кухня, другие работают

### **Пример с потоками:**

```python
import threading

# Общая переменная (все потоки видят её)
counter = 0

def increment():
    global counter
    for _ in range(100000):
        counter += 1

# Два потока работают с общей переменной
thread1 = threading.Thread(target=increment)
thread2 = threading.Thread(target=increment)

thread1.start()
thread2.start()

thread1.join()
thread2.join()

print(f"Counter: {counter}")  # Может быть не 200000! (race condition)
```

### **Когда использовать что:**

**Используйте потоки для:**
- Загрузка файлов из интернета
- Множественные запросы к API
- Работа с базой данных
- Чтение/запись файлов
- Сетевые операции

**Используйте процессы для:**
- Тяжёлые математические вычисления
- Обработка изображений/видео
- Машинное обучение
- Любые CPU-интенсивные задачи

## `32.3` GIL (Global Interpreter Lock) — что это и как влияет на многопоточность в Python
**GIL (Global Interpreter Lock)** — это механизм в CPython (стандартная реализация Python), который позволяет выполняться только одному потоку Python-кода одновременно, даже на многоядерном процессоре.

### **Простыми словами:**

Представьте, что у вас 4 повара (потока) и 4 плиты (ядра процессора), но есть только один ключ от кухни (GIL). Только один повар может готовить в данный момент, остальные ждут своей очереди с ключом.

### **Как это влияет:**

**Для I/O операций (файлы, сеть, БД):**
- ✅ GIL **не мешает** — потоки эффективны
- Во время ожидания (чтение файла, HTTP-запрос) GIL отпускается
- Другие потоки могут работать

**Для CPU-интенсивных вычислений:**
- ❌ GIL **блокирует** — потоки неэффективны
- Только один поток вычисляет в момент времени
- Многопоточность может быть даже медленнее

### **Пример влияния GIL:**

```python
import threading
import time

# CPU-интенсивная задача (вычисления)
def calculate():
    result = 0
    for i in range(10_000_000):
        result += i
    return result

# I/O задача (ожидание)
def wait():
    time.sleep(2)
    return "done"

# CPU задача — GIL мешает
start = time.time()
thread1 = threading.Thread(target=calculate)
thread2 = threading.Thread(target=calculate)
thread1.start()
thread2.start()
thread1.join()
thread2.join()
print(f"CPU с потоками: {time.time() - start:.2f} сек")  # ~1.5 сек

# Без потоков
start = time.time()
calculate()
calculate()
print(f"CPU без потоков: {time.time() - start:.2f} сек")  # ~1.5 сек
# Почти одинаково! GIL не даёт ускорения

# I/O задача — GIL не мешает
start = time.time()
thread1 = threading.Thread(target=wait)
thread2 = threading.Thread(target=wait)
thread1.start()
thread2.start()
thread1.join()
thread2.join()
print(f"I/O с потоками: {time.time() - start:.2f} сек")  # ~2 сек

# Без потоков
start = time.time()
wait()
wait()
print(f"I/O без потоков: {time.time() - start:.2f} сек")  # ~4 сек
# В 2 раза быстрее с потоками!
```

### **Решения проблемы GIL:**

1. **Для CPU задач:** используйте `multiprocessing` (процессы вместо потоков)
2. **Для I/O задач:** используйте `threading` или `asyncio`
3. **Альтернативные реализации Python:** Jython, IronPython (без GIL)

### **Ключевые моменты:**

- **GIL** — ограничение CPython, не самого языка Python
- **Не влияет на I/O операции** — потоки эффективны для файлов, сети, БД
- **Блокирует CPU вычисления** — для них используйте процессы
- **Упрощает разработку** — защищает от некоторых проблем многопоточности
- **Не проблема в большинстве случаев** — Python часто используется для I/O задач

## `32.4` Модуль threading — основной инструмент для работы с потоками
`threading` — это встроенный модуль Python для создания и управления потоками. Он предоставляет высокоуровневый интерфейс для многопоточного программирования.

### **Базовый импорт и проверка:**

```python
import threading

# Узнать количество активных потоков
print(f"Активных потоков: {threading.active_count()}")  # 1 (главный поток)

# Получить текущий поток
current = threading.current_thread()
print(f"Текущий поток: {current.name}")  # MainThread

# Список всех активных потоков
print(f"Все потоки: {threading.enumerate()}")  # [<_MainThread(MainThread, started ...)>]
```

### **Основные компоненты модуля:**

```python
import threading

# Thread — класс для создания потоков
# Lock — блокировка для синхронизации
# Event — событие для сигнализации между потоками
# Semaphore — семафор для ограничения доступа
# Queue — очередь для безопасного обмена данными

# Пример простого потока
def worker():
    print(f"Поток {threading.current_thread().name} работает")

thread = threading.Thread(target=worker, name="Worker-1")
thread.start()
thread.join()

# Вывод:
# Поток Worker-1 работает
```

### **Информация о потоке:**

```python
import threading
import time

def task():
    print(f"Имя потока: {threading.current_thread().name}")
    print(f"ID потока: {threading.get_ident()}")
    time.sleep(1)

# Создание именованного потока
thread = threading.Thread(target=task, name="MyWorker")
print(f"Поток создан: {thread.name}")
print(f"Поток живой: {thread.is_alive()}")  # False (ещё не запущен)

thread.start()
print(f"Поток живой: {thread.is_alive()}")  # True (запущен)

thread.join()
print(f"Поток живой: {thread.is_alive()}")  # False (завершён)

# Вывод:
# Поток создан: MyWorker
# Поток живой: False
# Поток живой: True
# Имя потока: MyWorker
# ID потока: 123145472000000 (пример)
# Поток живой: False
```

## `32.5` Создание и запуск потоков:
### **Класс `Thread` — создание потока**

`Thread` — основной класс для создания потоков. Ему передаётся функция, которую нужно выполнить в отдельном потоке.

```python
import threading
import time

def print_numbers():
    for i in range(5):
        print(f"Число: {i}")
        time.sleep(0.5)

# Создаём поток
thread = threading.Thread(target=print_numbers)

# target — функция, которая будет выполнена в потоке
# Поток создан, но ещё не запущен!
```

### **Параметр `target` — функция для выполнения**

`target` — это функция, которую поток будет выполнять.

```python
import threading

def greet():
    print("Привет из потока!")

def calculate():
    result = sum(range(1000000))
    print(f"Результат: {result}")

# Разные функции — разные потоки
thread1 = threading.Thread(target=greet)
thread2 = threading.Thread(target=calculate)

thread1.start()
thread2.start()

thread1.join()
thread2.join()

# Вывод:
# Привет из потока!
# Результат: 499999500000
```

### **Параметры `args` и `kwargs` — передача аргументов**

`args` — позиционные аргументы (кортеж)  
`kwargs` — именованные аргументы (словарь)

```python
import threading
import time

# Функция с параметрами
def download_file(filename, size, delay=1):
    print(f"Загружаю {filename} ({size} MB)")
    time.sleep(delay)
    print(f"{filename} загружен")

# Передача аргументов через args (кортеж)
thread1 = threading.Thread(
    target=download_file,
    args=("file1.txt", 100)  # позиционные аргументы
)

# Передача через args и kwargs
thread2 = threading.Thread(
    target=download_file,
    args=("file2.txt", 50),
    kwargs={"delay": 2}  # именованные аргументы
)

thread1.start()
thread2.start()

thread1.join()
thread2.join()

# Вывод:
# Загружаю file1.txt (100 MB)
# Загружаю file2.txt (50 MB)
# file1.txt загружен
# file2.txt загружен
```

**Ещё примеры с аргументами:**

```python
import threading

# Пример 1: только args
def add(a, b):
    print(f"{a} + {b} = {a + b}")

thread = threading.Thread(target=add, args=(5, 3))
thread.start()
thread.join()
# Вывод: 5 + 3 = 8

# Пример 2: только kwargs
def greet(name, greeting="Привет"):
    print(f"{greeting}, {name}!")

thread = threading.Thread(target=greet, kwargs={"name": "Alice", "greeting": "Здравствуй"})
thread.start()
thread.join()
# Вывод: Здравствуй, Alice!

# Пример 3: args + kwargs
def process(data, mode, verbose=False):
    if verbose:
        print(f"Обрабатываю {data} в режиме {mode}")
    else:
        print(f"Обработка {data}")

thread = threading.Thread(
    target=process,
    args=("данные", "fast"),
    kwargs={"verbose": True}
)
thread.start()
thread.join()
# Вывод: Обрабатываю данные в режиме fast
```

### **Метод `start()` — запуск потока**

`start()` запускает выполнение потока. После вызова `start()` поток начинает работать параллельно с основной программой.

```python
import threading
import time

def worker(name):
    print(f"{name}: начал работу")
    time.sleep(2)
    print(f"{name}: закончил работу")

# Создаём потоки
thread1 = threading.Thread(target=worker, args=("Поток-1",))
thread2 = threading.Thread(target=worker, args=("Поток-2",))

print("Запускаю потоки...")

# Запускаем потоки
thread1.start()  # Поток-1 начинает работать
thread2.start()  # Поток-2 начинает работать

print("Потоки запущены, основная программа продолжает работу")

# ВАЖНО: start() вызывается только один раз!
# thread1.start()  # RuntimeError: threads can only be started once

# Основная программа продолжает работать параллельно
for i in range(3):
    print(f"Основной поток: {i}")
    time.sleep(0.5)

# Вывод:
# Запускаю потоки...
# Поток-1: начал работу
# Поток-2: начал работу
# Потоки запущены, основная программа продолжает работу
# Основной поток: 0
# Основной поток: 1
# Основной поток: 2
# Поток-1: закончил работу
# Поток-2: закончил работу
```

### **Метод `join()` — ожидание завершения потока**

`join()` блокирует выполнение основной программы до тех пор, пока поток не завершится. Это нужно, чтобы дождаться результата работы потока.

```python
import threading
import time

def long_task(name, duration):
    print(f"{name}: начинаю задачу на {duration} сек")
    time.sleep(duration)
    print(f"{name}: задача завершена")

# Создаём и запускаем потоки
thread1 = threading.Thread(target=long_task, args=("Поток-1", 2))
thread2 = threading.Thread(target=long_task, args=("Поток-2", 3))

thread1.start()
thread2.start()

print("Потоки запущены")

# БЕЗ join() — основная программа не ждёт
# print("Программа завершена")
# Программа может завершиться до окончания потоков!

# С join() — ждём завершения
thread1.join()  # Ждём, пока Поток-1 закончит
print("Поток-1 завершён")

thread2.join()  # Ждём, пока Поток-2 закончит
print("Поток-2 завершён")

print("Все потоки завершены, программа завершается")

# Вывод:
# Поток-1: начинаю задачу на 2 сек
# Поток-2: начинаю задачу на 3 сек
# Потоки запущены
# Поток-1: задача завершена
# Поток-1 завершён
# Поток-2: задача завершена
# Поток-2 завершён
# Все потоки завершены, программа завершается
```

**`join()` с таймаутом:**

```python
import threading
import time

def slow_task():
    print("Начинаю долгую задачу...")
    time.sleep(5)
    print("Задача завершена")

thread = threading.Thread(target=slow_task)
thread.start()

# Ждём максимум 2 секунды
thread.join(timeout=2)

# Проверяем, завершился ли поток
if thread.is_alive():
    print("Поток всё ещё работает (превышен таймаут)")
else:
    print("Поток завершён")

# Вывод:
# Начинаю долгую задачу...
# Поток всё ещё работает (превышен таймаут)
# (через 3 секунды)
# Задача завершена
```

### **Практический пример — загрузка файлов:**

```python
import threading
import time

def download_file(url, filename):
    print(f"Начинаю загрузку {filename} с {url}")
    time.sleep(2)  # Имитация загрузки
    print(f"✓ {filename} загружен")

# Список файлов для загрузки
files = [
    ("http://site.com/file1.pdf", "документ1.pdf"),
    ("http://site.com/file2.jpg", "фото1.jpg"),
    ("http://site.com/file3.zip", "архив1.zip"),
]

# Создаём потоки для каждого файла
threads = []

start_time = time.time()

for url, filename in files:
    thread = threading.Thread(
        target=download_file,
        args=(url, filename)
    )
    threads.append(thread)
    thread.start()

# Ждём завершения всех потоков
for thread in threads:
    thread.join()

elapsed = time.time() - start_time
print(f"\nВсе файлы загружены за {elapsed:.2f} секунд")

# Вывод:
# Начинаю загрузку документ1.pdf с http://site.com/file1.pdf
# Начинаю загрузку фото1.jpg с http://site.com/file2.jpg
# Начинаю загрузку архив1.zip с http://site.com/file3.zip
# ✓ документ1.pdf загружен
# ✓ фото1.jpg загружен
# ✓ архив1.zip загружен
#
# Все файлы загружены за 2.00 секунд
```

**Ключевые моменты:**

- `Thread(target=func)` — создаёт поток для выполнения функции
- `args=(...)` — передаёт позиционные аргументы (кортеж)
- `kwargs={...}` — передаёт именованные аргументы (словарь)
- `start()` — запускает поток (вызывается один раз!)
- `join()` — ждёт завершения потока
- `join(timeout=N)` — ждёт максимум N секунд
- `is_alive()` — проверяет, работает ли поток

## `32.6` Наследование от класса Thread — создание собственных потоков
Вместо передачи функции в `target`, можно создать собственный класс, унаследованный от `Thread`, и переопределить метод `run()`. Это удобно для сложных потоков с собственным состоянием и логикой.

### **Базовый синтаксис:**

```python
import threading
import time

class MyThread(threading.Thread):
    def run(self):
        """Этот метод выполняется при вызове start()"""
        print(f"Поток {self.name} запущен")
        time.sleep(2)
        print(f"Поток {self.name} завершён")

# Создание и запуск
thread = MyThread()
thread.start()
thread.join()

# Вывод:
# Поток Thread-1 запущен
# Поток Thread-1 завершён
```

### **Пример с параметрами в конструкторе:**

```python
import threading
import time

class DownloadThread(threading.Thread):
    def __init__(self, url, filename):
        super().__init__()  # ВАЖНО: вызвать конструктор родителя!
        self.url = url
        self.filename = filename
        self.result = None
    
    def run(self):
        """Логика загрузки файла"""
        print(f"Загружаю {self.filename} с {self.url}")
        time.sleep(2)  # Имитация загрузки
        self.result = f"{self.filename} загружен"
        print(f"✓ {self.result}")

# Создание и запуск потоков
thread1 = DownloadThread("http://site.com/file1.pdf", "документ.pdf")
thread2 = DownloadThread("http://site.com/file2.jpg", "фото.jpg")

thread1.start()
thread2.start()

thread1.join()
thread2.join()

# Получение результатов
print(f"Результат 1: {thread1.result}")
print(f"Результат 2: {thread2.result}")

# Вывод:
# Загружаю документ.pdf с http://site.com/file1.pdf
# Загружаю фото.jpg с http://site.com/file2.jpg
# ✓ документ.pdf загружен
# ✓ фото.jpg загружен
# Результат 1: документ.pdf загружен
# Результат 2: фото.jpg загружен
```

### **Пример с обработкой данных:**

```python
import threading
import time

class DataProcessor(threading.Thread):
    def __init__(self, data, processor_id):
        super().__init__()
        self.data = data
        self.processor_id = processor_id
        self.result = 0
    
    def run(self):
        print(f"Процессор {self.processor_id}: начинаю обработку {len(self.data)} элементов")
        time.sleep(1)  # Имитация обработки
        self.result = sum(self.data)
        print(f"Процессор {self.processor_id}: результат = {self.result}")

# Данные для обработки
data = list(range(100))
chunk_size = 25

# Создаём несколько процессоров
processors = []
for i in range(4):
    chunk = data[i*chunk_size:(i+1)*chunk_size]
    processor = DataProcessor(chunk, i+1)
    processors.append(processor)
    processor.start()

# Ждём завершения
for processor in processors:
    processor.join()

# Собираем результаты
total = sum(p.result for p in processors)
print(f"\nИтоговый результат: {total}")

# Вывод:
# Процессор 1: начинаю обработку 25 элементов
# Процессор 2: начинаю обработку 25 элементов
# Процессор 3: начинаю обработку 25 элементов
# Процессор 4: начинаю обработку 25 элементов
# Процессор 1: результат = 300
# Процессор 2: результат = 925
# Процессор 3: результат = 1550
# Процессор 4: результат = 2175
#
# Итоговый результат: 4950
```

### **Когда использовать наследование:**

✅ **Используйте класс, если:**
- Поток имеет сложную логику
- Нужно хранить состояние (результаты, промежуточные данные)
- Требуется переиспользование логики потока
- Нужны дополнительные методы

❌ **Используйте `target`, если:**
- Простая функция без состояния
- Одноразовая задача
- Не нужны дополнительные методы

**Ключевые моменты:**
- Наследуйтесь от `threading.Thread`
- Вызовите `super().__init__()` в конструкторе
- Переопределите метод `run()` с логикой потока
- Результаты храните в атрибутах экземпляра
- Запускайте через `start()`, а не `run()`!


## `32.7` Daemon потоки — что это и когда использовать
**Daemon поток (фоновый поток)** — это поток, который автоматически завершается при завершении главной программы. В отличие от обычных потоков, программа не ждёт завершения daemon-потоков.

### **Обычные vs Daemon потоки:**

```python
import threading
import time

def worker(name, is_daemon):
    print(f"{name}: начал работу")
    time.sleep(3)
    print(f"{name}: закончил работу")

# Обычный поток
normal_thread = threading.Thread(target=worker, args=("Обычный", False))

# Daemon поток (устанавливается ПЕРЕД start!)
daemon_thread = threading.Thread(target=worker, args=("Daemon", True))
daemon_thread.daemon = True  # Помечаем как daemon

print("Запускаю потоки...")
normal_thread.start()
daemon_thread.start()

print("Главная программа ждёт 1 секунду и завершается")
time.sleep(1)
print("Главная программа завершена")

# Вывод:
# Запускаю потоки...
# Обычный: начал работу
# Daemon: начал работу
# Главная программа ждёт 1 секунду и завершается
# Главная программа завершена
# Обычный: закончил работу
# (Daemon поток принудительно завершён, не выведет "закончил работу")
```

### **Как создать daemon поток:**

```python
import threading

def task():
    print("Работаю...")

# Способ 1: через атрибут daemon (ПЕРЕД start!)
thread1 = threading.Thread(target=task)
thread1.daemon = True
thread1.start()

# Способ 2: через параметр конструктора
thread2 = threading.Thread(target=task, daemon=True)
thread2.
```

### **Примеры из реальной жизни**
1) `Автоматическая очистка мусора`
Например, служба, удаляющая временные файлы на сервере — она просто работает в фоне и всё завершает, когда сервер отключается.

2) `Мониторинг состояния системы`
Системные утилиты, отслеживающие температуру CPU, загрузку диска, состояние сетевого подключения — работают в фоне и не требуют ручного контроля.

3) `Логгирование событий`
Приложения, которые пишут логи в отдельном потоке: поток логгирования работает в фоне, не блокируя основную работу.

4) `Фоновые проверки почты или обновлений`
Почтовые клиенты периодически проверяют новые письма в фоне; обновлялка приложений раз в час ищет апдейты и завершает работу с выходом из программы.

5) `Слежение за действиями пользователя`
В IDE или браузере отдельный поток может следить за действиями пользователя (например, автосохранение или запись макросов), завершаясь, если пользователь закроет приложение.

6) `Сетевые "сердцебиения" (heartbeat)`
Сервис отправляет регулярные сообщения, чтобы показать, что всё работает — такой поток завершится, если программа выключится.


## `32.8` Проблема гонки данных (race condition)
### Что такое race condition?
**Race condition (гонка данных)** — это ситуация, когда результат работы программы зависит от порядка выполнения потоков, который невозможно предсказать. Возникает, когда несколько потоков одновременно пытаются читать и изменять общие данные.

#### Почему это происходит?

Даже простая операция `counter += 1` на самом деле состоит из нескольких шагов:
1. Прочитать текущее значение `counter`
2. Увеличить его на 1
3. Записать новое значение обратно

Если два потока выполняют эти шаги одновременно, они могут "наступить друг другу на пятки".

### Пример проблемы

```python
import threading
import time

counter = 0

def increment():
    global counter
    for _ in range(100000):
        counter += 1

# Создаём 5 потоков
threads = []
for _ in range(5):
    t = threading.Thread(target=increment)
    threads.append(t)
    t.start()

# Ждём завершения всех потоков
for t in threads:
    t.join()

print(f"Ожидаемое значение: {5 * 100000}")
print(f"Реальное значение: {counter}")
```

**Вывод (может варьироваться):**
```
Ожидаемое значение: 500000
Реальное значение: 287463
```

Значение меньше ожидаемого! Это классический пример race condition — потоки "затёрли" изменения друг друга.

### Как избежать race condition?

#### 1. Использование блокировок (Lock)

Самый простой способ — использовать `threading.Lock()`, чтобы только один поток мог изменять данные в определённый момент времени.

```python
import threading

counter = 0
lock = threading.Lock()

def increment_safe():
    global counter
    for _ in range(100000):
        with lock:  # Блокируем доступ для других потоков
            counter += 1

threads = []
for _ in range(5):
    t = threading.Thread(target=increment_safe)
    threads.append(t)
    t.start()

for t in threads:
    t.join()

print(f"Ожидаемое значение: {5 * 100000}")
print(f"Реальное значение: {counter}")
```

**Вывод:**
```
Ожидаемое значение: 500000
Реальное значение: 500000
```

Теперь результат правильный! Блокировка гарантирует, что только один поток за раз может выполнять код внутри `with lock:`.

#### 2. Работа со списками

```python
import threading

results = []
lock = threading.Lock()

def add_items(start, end):
    for i in range(start, end):
        with lock:
            results.append(i)

threads = []
for i in range(5):
    t = threading.Thread(target=add_items, args=(i*1000, (i+1)*1000))
    threads.append(t)
    t.start()

for t in threads:
    t.join()

print(f"Добавлено элементов: {len(results)}")
print(f"Первые 10: {sorted(results)[:10]}")
```

#### 3. Банковский счёт — классический пример

```python
import threading
import time
import random

class BankAccount:
    def __init__(self, balance):
        self.balance = balance
        self.lock = threading.Lock()
    
    def withdraw(self, amount):
        with self.lock:
            if self.balance >= amount:
                # Имитируем задержку (проверка, обработка и т.д.)
                time.sleep(0.001)
                self.balance -= amount
                return True
            return False
    
    def deposit(self, amount):
        with self.lock:
            self.balance += amount

account = BankAccount(1000)

def make_transactions(account_obj):
    for _ in range(10):
        # Случайная операция: снятие или пополнение
        if random.choice([True, False]):
            amount = random.randint(10, 100)
            if account_obj.withdraw(amount):
                print(f"Снято {amount}, баланс: {account_obj.balance}")
        else:
            amount = random.randint(10, 100)
            account_obj.deposit(amount)
            print(f"Пополнено {amount}, баланс: {account_obj.balance}")

threads = []
for _ in range(3):
    t = threading.Thread(target=make_transactions, args=(account,))
    threads.append(t)
    t.start()

for t in threads:
    t.join()

print(f"\nИтоговый баланс: {account.balance}")
```

Без блокировки баланс мог бы стать отрицательным или операции могли бы "потеряться".

### Когда блокировки не нужны?

Есть случаи, когда race condition не возникает:

#### 1. Потоки работают с разными данными

```python
import threading

def process_range(start, end, results, index):
    # Каждый поток записывает в свою ячейку списка
    results[index] = sum(range(start, end))

results = [0, 0, 0, 0]
threads = []

for i in range(4):
    t = threading.Thread(
        target=process_range,
        args=(i*250, (i+1)*250, results, i)
    )
    threads.append(t)
    t.start()

for t in threads:
    t.join()

print(f"Результаты: {results}")
print(f"Сумма: {sum(results)}")
```

Здесь блокировка не нужна, потому что каждый поток работает со своим индексом.

#### 2. Только чтение данных

```python
import threading

# Общие данные, которые только читаются
config = {
    'timeout': 30,
    'max_retries': 3,
    'server': 'example.com'
}

def worker(worker_id):
    # Только читаем данные — безопасно без блокировок
    timeout = config['timeout']
    print(f"Воркер {worker_id} использует timeout={timeout}")

threads = []
for i in range(5):
    t = threading.Thread(target=worker, args=(i,))
    threads.append(t)
    t.start()

for t in threads:
    t.join()
```

### Резюме

**Race condition возникает когда:**
- Несколько потоков обращаются к общим данным
- Хотя бы один поток изменяет эти данные
- Операции не синхронизированы

**Как избежать:**
- Используйте `threading.Lock()` для критических секций
- Применяйте контекстный менеджер `with lock:` для автоматического освобождения блокировки
- Проектируйте код так, чтобы потоки работали с разными данными
- Используйте потокобезопасные структуры данных (о них в следующих топиках)


## `32.9` Синхронизация потоков: `Lock`, `RLock`, `Semaphore`, `Event`, `Condition`
Модуль `threading` предоставляет несколько примитивов синхронизации для координации работы потоков. Каждый из них решает свои задачи.

### 1. Lock — базовая блокировка

`Lock` — самый простой примитив синхронизации. Работает как замок: один поток "запирает" его, другие ждут, пока он не "откроется".

#### Основные методы:
- `acquire()` — захватить блокировку (заблокировать, если уже занята)
- `release()` — освободить блокировку
- `locked()` — проверить, занята ли блокировка

```python
import threading
import time

lock = threading.Lock()
counter = 0

def increment_with_lock():
    global counter
    for _ in range(100000):
        lock.acquire()
        try:
            counter += 1
        finally:
            lock.release()  # Обязательно освобождаем в finally

# Или используем контекстный менеджер (рекомендуется)
def increment_safe():
    global counter
    for _ in range(100000):
        with lock:  # Автоматически вызывает acquire и release
            counter += 1

threads = [threading.Thread(target=increment_safe) for _ in range(5)]

for t in threads:
    t.start()
for t in threads:
    t.join()

print(f"Counter: {counter}")
```

#### Важно!
Lock нельзя захватить дважды в одном потоке:

```python
lock = threading.Lock()

lock.acquire()
lock.acquire()  # Зависнет навсегда! Deadlock
lock.release()
```

### 2. RLock — рекурсивная блокировка

`RLock` (Reentrant Lock) позволяет одному и тому же потоку захватывать блокировку несколько раз. Полезно для рекурсивных функций.

```python
import threading

rlock = threading.RLock()

def recursive_function(n):
    with rlock:
        print(f"Уровень {n}")
        if n > 0:
            recursive_function(n - 1)  # Повторный захват той же блокировки

thread = threading.Thread(target=recursive_function, args=(5,))
thread.start()
thread.join()
```

**Вывод:**
```
Уровень 5
Уровень 4
Уровень 3
Уровень 2
Уровень 1
Уровень 0
```

#### Пример с классом

```python
import threading

class Counter:
    def __init__(self):
        self.value = 0
        self.lock = threading.RLock()
    
    def increment(self):
        with self.lock:
            self.value += 1
    
    def increment_by(self, amount):
        with self.lock:  # Первый захват блокировки
            for _ in range(amount):
                self.increment()  # Повторный захват — работает благодаря RLock!

counter = Counter()
threads = [threading.Thread(target=counter.increment_by, args=(1000,)) for _ in range(5)]

for t in threads:
    t.start()
for t in threads:
    t.join()

print(f"Counter: {counter.value}")
```

### 3. Semaphore — ограничение количества доступов

`Semaphore` позволяет ограничить количество потоков, которые могут одновременно выполнять определённый код. Это как турникет с несколькими проходами.

```python
import threading
import time

# Разрешаем только 3 одновременных подключения
semaphore = threading.Semaphore(3)

def access_resource(worker_id):
    print(f"Воркер {worker_id} ждёт доступа...")
    with semaphore:
        print(f"Воркер {worker_id} получил доступ к ресурсу")
        time.sleep(2)  # Имитация работы с ресурсом
        print(f"Воркер {worker_id} освободил ресурс")

threads = [threading.Thread(target=access_resource, args=(i,)) for i in range(10)]

for t in threads:
    t.start()
for t in threads:
    t.join()
```

**Вывод (с задержками):**
```
Воркер 0 ждёт доступа...
Воркер 1 ждёт доступа...
Воркер 2 ждёт доступа...
Воркер 0 получил доступ к ресурсу
Воркер 1 получил доступ к ресурсу
Воркер 2 получил доступ к ресурсу
Воркер 3 ждёт доступа...
Воркер 4 ждёт доступа...
...
```

#### Практический пример: ограничение запросов к API

```python
import threading
import time
import random

# Ограничиваем до 5 одновременных запросов
api_semaphore = threading.Semaphore(5)

def make_api_request(request_id):
    with api_semaphore:
        print(f"Запрос {request_id} отправлен")
        time.sleep(random.uniform(0.5, 2))  # Имитация запроса
        print(f"Запрос {request_id} завершён")

threads = [threading.Thread(target=make_api_request, args=(i,)) for i in range(20)]

for t in threads:
    t.start()
for t in threads:
    t.join()

print("Все запросы выполнены")
```

### 4. Event — сигнализация между потоками

`Event` используется для оповещения потоков о каких-то событиях. Работает как флаг: установлен или не установлен.

#### Основные методы:
- `set()` — установить флаг (событие произошло)
- `clear()` — сбросить флаг
- `wait(timeout=None)` — ждать, пока флаг не будет установлен
- `is_set()` — проверить состояние флага

```python
import threading
import time

event = threading.Event()

def waiter(name):
    print(f"{name}: Жду сигнала...")
    event.wait()  # Блокируется до вызова event.set()
    print(f"{name}: Получил сигнал! Начинаю работу")

def sender():
    print("Sender: Готовлю данные...")
    time.sleep(3)
    print("Sender: Данные готовы, отправляю сигнал")
    event.set()  # Разблокирует все ожидающие потоки

# Создаём несколько ожидающих потоков
waiters = [threading.Thread(target=waiter, args=(f"Воркер-{i}",)) for i in range(3)]
sender_thread = threading.Thread(target=sender)

for t in waiters:
    t.start()

sender_thread.start()

for t in waiters:
    t.join()
sender_thread.join()
```

**Вывод:**
```
Воркер-0: Жду сигнала...
Воркер-1: Жду сигнала...
Воркер-2: Жду сигнала...
Sender: Готовлю данные...
Sender: Данные готовы, отправляю сигнал
Воркер-0: Получил сигнал! Начинаю работу
Воркер-1: Получил сигнал! Начинаю работу
Воркер-2: Получил сигнал! Начинаю работу
```

#### Пример: запуск задач по сигналу

```python
import threading
import time

start_event = threading.Event()
stop_event = threading.Event()

def worker(worker_id):
    print(f"Воркер {worker_id} готов")
    start_event.wait()  # Ждём команды на старт
    
    print(f"Воркер {worker_id} начал работу")
    while not stop_event.is_set():
        print(f"Воркер {worker_id} работает...")
        time.sleep(1)
    
    print(f"Воркер {worker_id} остановлен")

threads = [threading.Thread(target=worker, args=(i,)) for i in range(3)]

for t in threads:
    t.start()

time.sleep(2)
print("Даём команду на старт!")
start_event.set()

time.sleep(5)
print("Даём команду на остановку!")
stop_event.set()

for t in threads:
    t.join()
```

### 5. Condition — условная синхронизация

`Condition` — это комбинация блокировки и события. Позволяет потокам ждать определённого условия и уведомлять друг друга.

#### Основные методы:
- `wait()` — ждать уведомления
- `notify(n=1)` — уведомить n ожидающих потоков
- `notify_all()` — уведомить все ожидающие потоки

```python
import threading
import time
import random

condition = threading.Condition()
items = []

def producer():
    for i in range(5):
        time.sleep(random.uniform(0.5, 1.5))
        with condition:
            item = f"Товар-{i}"
            items.append(item)
            print(f"Производитель создал: {item}")
            condition.notify()  # Уведомляем одного потребителя

def consumer(consumer_id):
    while True:
        with condition:
            while not items:  # Пока список пуст
                print(f"Потребитель {consumer_id} ждёт товара...")
                condition.wait()  # Ждём уведомления
            
            item = items.pop(0)
            print(f"Потребитель {consumer_id} получил: {item}")
            
            if "Товар-4" in item:  # Последний товар
                break

producer_thread = threading.Thread(target=producer)
consumer_threads = [threading.Thread(target=consumer, args=(i,)) for i in range(2)]

producer_thread.start()
for t in consumer_threads:
    t.start()

producer_thread.join()
for t in consumer_threads:
    t.join()
```

#### Пример: очередь задач с ограничением

```python
import threading
import time

class TaskQueue:
    def __init__(self, max_size):
        self.queue = []
        self.max_size = max_size
        self.condition = threading.Condition()
    
    def put(self, task):
        with self.condition:
            while len(self.queue) >= self.max_size:
                print(f"Очередь полна, ждём...")
                self.condition.wait()
            
            self.queue.append(task)
            print(f"Добавлена задача: {task}")
            self.condition.notify()  # Уведомляем потребителя
    
    def get(self):
        with self.condition:
            while not self.queue:
                print("Очередь пуста, ждём задачи...")
                self.condition.wait()
            
            task = self.queue.pop(0)
            print(f"Получена задача: {task}")
            self.condition.notify()  # Уведомляем производителя
            return task

task_queue = TaskQueue(max_size=3)

def producer():
    for i in range(10):
        time.sleep(0.5)
        task_queue.put(f"Задача-{i}")

def consumer():
    for _ in range(10):
        task = task_queue.get()
        time.sleep(1)  # Обработка задачи

producer_thread = threading.Thread(target=producer)
consumer_thread = threading.Thread(target=consumer)

producer_thread.start()
consumer_thread.start()

producer_thread.join()
consumer_thread.join()
```

### Сравнительная таблица

| Примитив | Когда использовать |
|----------|-------------------|
| **Lock** | Защита общих данных от одновременного изменения |
| **RLock** | Когда один поток может захватывать блокировку несколько раз (рекурсия) |
| **Semaphore** | Ограничение количества одновременных доступов к ресурсу |
| **Event** | Простая сигнализация между потоками (старт/стоп) |
| **Condition** | Сложная координация: ожидание определённых условий и уведомления |

### Резюме

- **Lock** — базовая защита от race condition
- **RLock** — для случаев с повторным захватом блокировки в одном потоке
- **Semaphore** — ограничение числа одновременных доступов (например, к API или БД)
- **Event** — простая сигнализация (флаг "да/нет")
- **Condition** — продвинутая координация с ожиданием условий

Выбирайте примитив в зависимости от задачи. В большинстве случаев достаточно `Lock` или `RLock`. Для более сложных сценариев используйте `Semaphore`, `Event` или `Condition`.


## `32.10` Deadlock (взаимная блокировка) — что это и как предотвратить
**Deadlock (взаимная блокировка)** — это ситуация, когда два или более потока бесконечно ждут друг друга, и ни один не может продолжить выполнение. Это одна из самых опасных проблем в многопоточном программировании.

### Как возникает Deadlock?

Представь две комнаты с двумя дверьми. Для входа в комнату нужны оба ключа:
- Поток 1: взял ключ А, ждёт ключ Б
- Поток 2: взял ключ Б, ждёт ключ А
- Результат: оба потока застряли навечно 🔒

### Пример 1: Классический Deadlock

```python
import threading
import time

lock_a = threading.Lock()
lock_b = threading.Lock()

def task_1():
    """Поток 1: берёт lock_a, потом lock_b"""
    print("🔵 Поток 1: пытается взять lock_a")
    with lock_a:
        print("🔵 Поток 1: взял lock_a")
        time.sleep(0.1)  # Имитация работы
        
        print("🔵 Поток 1: пытается взять lock_b")
        with lock_b:
            print("🔵 Поток 1: взял lock_b")
            print("🔵 Поток 1: завершил работу")

def task_2():
    """Поток 2: берёт lock_b, потом lock_a"""
    print("🔴 Поток 2: пытается взять lock_b")
    with lock_b:
        print("🔴 Поток 2: взял lock_b")
        time.sleep(0.1)  # Имитация работы
        
        print("🔴 Поток 2: пытается взять lock_a")
        with lock_a:
            print("🔴 Поток 2: взял lock_a")
            print("🔴 Поток 2: завершил работу")

# Запуск потоков - DEADLOCK!
thread1 = threading.Thread(target=task_1)
thread2 = threading.Thread(target=task_2)

thread1.start()
thread2.start()

thread1.join()
thread2.join()

# Вывод:
# 🔵 Поток 1: пытается взять lock_a
# 🔵 Поток 1: взял lock_a
# 🔴 Поток 2: пытается взять lock_b
# 🔴 Поток 2: взял lock_b
# 🔵 Поток 1: пытается взять lock_b  ← застрял
# 🔴 Поток 2: пытается взять lock_a  ← застрял
# [Программа зависает навсегда]
```

### Способ 1: Упорядочивание блокировок

**Правило:** Всегда берите блокировки в одном и том же порядке во всех потоках.

```python
import threading
import time

lock_a = threading.Lock()
lock_b = threading.Lock()

def task_1():
    """Поток 1: берёт блокировки в порядке A -> B"""
    print("🔵 Поток 1: начал работу")
    with lock_a:
        print("🔵 Поток 1: взял lock_a")
        time.sleep(0.1)
        with lock_b:
            print("🔵 Поток 1: взял lock_b")
            print("🔵 Поток 1: завершил работу")

def task_2():
    """Поток 2: ТОЖЕ берёт блокировки в порядке A -> B (не B -> A!)"""
    print("🔴 Поток 2: начал работу")
    with lock_a:  # ← Изменили порядок!
        print("🔴 Поток 2: взял lock_a")
        time.sleep(0.1)
        with lock_b:
            print("🔴 Поток 2: взял lock_b")
            print("🔴 Поток 2: завершил работу")

# Запуск потоков - НЕТ DEADLOCK!
thread1 = threading.Thread(target=task_1)
thread2 = threading.Thread(target=task_2)

thread1.start()
thread2.start()

thread1.join()
thread2.join()

print("✅ Все потоки завершились успешно!")
```

### Способ 2: Использование timeout при блокировке

```python
import threading
import time

lock_a = threading.Lock()
lock_b = threading.Lock()

def task_with_timeout(name, first_lock, second_lock):
    """Поток с таймаутом - если не может взять блокировку, отпускает первую"""
    max_attempts = 5
    
    for attempt in range(max_attempts):
        print(f"{name}: попытка #{attempt + 1}")
        
        # Берём первую блокировку
        if first_lock.acquire(timeout=0.5):
            print(f"{name}: взял первую блокировку")
            
            # Пытаемся взять вторую блокировку с таймаутом
            if second_lock.acquire(timeout=0.5):
                try:
                    print(f"{name}: взял вторую блокировку")
                    print(f"{name}: ✅ выполнил работу!")
                    return  # Успешно завершили
                finally:
                    second_lock.release()
            else:
                print(f"{name}: ⚠️ не смог взять вторую блокировку, освобождаю первую")
            
            first_lock.release()
            time.sleep(0.1)  # Небольшая пауза перед повтором
        else:
            print(f"{name}: ⚠️ не смог взять первую блокировку")
            time.sleep(0.1)
    
    print(f"{name}: ❌ превышено количество попыток")

# Запуск потоков
thread1 = threading.Thread(target=task_with_timeout, args=("Поток 1", lock_a, lock_b))
thread2 = threading.Thread(target=task_with_timeout, args=("Поток 2", lock_b, lock_a))

thread1.start()
thread2.start()

thread1.join()
thread2.join()
```

### Способ 3: Использование RLock (рекурсивная блокировка)

```python
import threading
import time

# RLock позволяет одному потоку захватывать блокировку несколько раз
lock = threading.RLock()

class BankAccount:
    """Банковский счёт с защитой от deadlock"""
    
    def __init__(self, name, balance):
        self.name = name
        self.balance = balance
        self.lock = threading.RLock()  # Рекурсивная блокировка
    
    def withdraw(self, amount):
        """Снять деньги"""
        with self.lock:
            if self.balance >= amount:
                print(f"💰 {self.name}: снимаем {amount}₽")
                time.sleep(0.1)
                self.balance -= amount
                print(f"💳 {self.name}: остаток {self.balance}₽")
                return True
            return False
    
    def deposit(self, amount):
        """Положить деньги"""
        with self.lock:
            print(f"💵 {self.name}: кладём {amount}₽")
            self.balance += amount
            print(f"💳 {self.name}: остаток {self.balance}₽")
    
    def transfer(self, to_account, amount):
        """Перевод между счетами"""
        # Можем безопасно вызывать методы, которые тоже используют lock
        with self.lock:
            print(f"🔄 Перевод {amount}₽ с {self.name} на {to_account.name}")
            if self.withdraw(amount):  # Уже использует self.lock, но RLock позволяет
                to_account.deposit(amount)  # И здесь тоже lock, но другого объекта
                print(f"✅ Перевод завершён")
            else:
                print(f"❌ Недостаточно средств")

# Использование
account1 = BankAccount("Счёт Ивана", 1000)
account2 = BankAccount("Счёт Марии", 500)

def do_transfers():
    account1.transfer(account2, 200)
    time.sleep(0.1)
    account2.transfer(account1, 100)

thread1 = threading.Thread(target=do_transfers)
thread2 = threading.Thread(target=do_transfers)

thread1.start()
thread2.start()

thread1.join()
thread2.join()

print(f"\n💰 Итоговый баланс:")
print(f"  {account1.name}: {account1.balance}₽")
print(f"  {account2.name}: {account2.balance}₽")
```

### Пример 4: Визуализация Deadlock

```python
import threading
import time
from datetime import datetime

class Resource:
    """Ресурс с логированием блокировок"""
    
    def __init__(self, name):
        self.name = name
        self.lock = threading.Lock()
        self.holder = None
    
    def acquire(self, thread_name):
        """Взять ресурс"""
        print(f"[{self._timestamp()}] {thread_name} ожидает {self.name}")
        self.lock.acquire()
        self.holder = thread_name
        print(f"[{self._timestamp()}] {thread_name} 🔒 захватил {self.name}")
    
    def release(self, thread_name):
        """Освободить ресурс"""
        self.holder = None
        self.lock.release()
        print(f"[{self._timestamp()}] {thread_name} 🔓 освободил {self.name}")
    
    @staticmethod
    def _timestamp():
        return datetime.now().strftime("%H:%M:%S.%f")[:-3]

# Создаём ресурсы
resource_a = Resource("Ресурс A")
resource_b = Resource("Ресурс B")

def philosopher_1():
    """Философ 1: A -> B"""
    name = "Философ 1"
    resource_a.acquire(name)
    time.sleep(0.5)  # Думает...
    resource_b.acquire(name)  # ← Застрянет здесь
    
    # Работа с ресурсами
    print(f"{name}: использует оба ресурса")
    
    resource_b.release(name)
    resource_a.release(name)

def philosopher_2():
    """Философ 2: B -> A"""
    name = "Философ 2"
    resource_b.acquire(name)
    time.sleep(0.5)  # Думает...
    resource_a.acquire(name)  # ← Застрянет здесь
    
    # Работа с ресурсами
    print(f"{name}: использует оба ресурса")
    
    resource_a.release(name)
    resource_b.release(name)

print("=== Запуск потоков (будет Deadlock) ===\n")

t1 = threading.Thread(target=philosopher_1)
t2 = threading.Thread(target=philosopher_2)

t1.start()
t2.start()

# Ждём 3 секунды и проверяем статус
time.sleep(3)
print("\n⚠️ Прошло 3 секунды - потоки всё ещё работают (Deadlock!)")
print("Остановите программу вручную (Ctrl+C)")

# Не вызываем join(), т.к. потоки никогда не завершатся
```

### Правила предотвращения Deadlock

1. **Упорядочивание блокировок** — всегда захватывайте в одном порядке
2. **Таймауты** — используйте `lock.acquire(timeout=...)` 
3. **Минимизация блокировок** — держите критические секции короткими
4. **Избегайте вложенных блокировок** — по возможности используйте одну блокировку
5. **Используйте высокоуровневые примитивы** — Queue, Condition, Semaphore вместо Lock

## `32.11` Модуль queue для безопасного обмена данными между потоками:
Модуль **`queue`** предоставляет потокобезопасные очереди для обмена данными между потоками. Это один из самых безопасных и рекомендуемых способов работы с многопоточностью.

### Queue — FIFO очередь

**FIFO (First In, First Out)** — первым вошёл, первым вышел. Как очередь в магазине.

```python
from queue import Queue
import threading
import time
import random

# Создаём очередь
task_queue = Queue()

def producer(name, count):
    """Производитель: добавляет задачи в очередь"""
    for i in range(count):
        task = f"Задача-{i+1} от {name}"
        print(f"➕ {name} добавил: {task}")
        task_queue.put(task)  # Потокобезопасно!
        time.sleep(random.uniform(0.1, 0.3))
    print(f"✅ {name} завершил работу")

def consumer(name):
    """Потребитель: берёт задачи из очереди и обрабатывает"""
    while True:
        # Берём задачу из очереди (блокируется, если очередь пуста)
        task = task_queue.get(timeout=2)  # Ждём максимум 2 секунды
        
        if task is None:  # Сигнал завершения
            print(f"🛑 {name} получил сигнал завершения")
            break
        
        print(f"⚙️  {name} обрабатывает: {task}")
        time.sleep(random.uniform(0.2, 0.5))  # Имитация работы
        print(f"✅ {name} завершил: {task}")
        
        task_queue.task_done()  # Сообщаем, что задача выполнена

# Запуск производителей
producer1 = threading.Thread(target=producer, args=("Производитель-1", 5))
producer2 = threading.Thread(target=producer, args=("Производитель-2", 5))

# Запуск потребителей
consumer1 = threading.Thread(target=consumer, args=("Потребитель-1",))
consumer2 = threading.Thread(target=consumer, args=("Потребитель-2",))
consumer3 = threading.Thread(target=consumer, args=("Потребитель-3",))

# Стартуем потребителей (они будут ждать задачи)
consumer1.start()
consumer2.start()
consumer3.start()

# Стартуем производителей
producer1.start()
producer2.start()

# Ждём завершения производителей
producer1.join()
producer2.join()

# Ждём, пока все задачи будут выполнены
task_queue.join()

# Отправляем сигналы завершения потребителям
for _ in range(3):
    task_queue.put(None)

# Ждём завершения потребителей
consumer1.join()
consumer2.join()
consumer3.join()

print("\n🎉 Все задачи выполнены!")
```

### Пример: Скачивание файлов с использованием Queue

```python
from queue import Queue
import threading
import time
import random

class FileDownloader:
    """Симулятор скачивания файлов"""
    
    def __init__(self, num_workers=3):
        self.download_queue = Queue()
        self.num_workers = num_workers
        self.workers = []
        self.downloaded = []
        self.lock = threading.Lock()
    
    def download_file(self, url):
        """Симуляция скачивания файла"""
        filename = url.split('/')[-1]
        print(f"📥 Скачивание: {filename}")
        
        # Имитация скачивания
        time.sleep(random.uniform(0.5, 2))
        
        # Симуляция размера файла
        size = random.randint(100, 1000)
        
        with self.lock:
            self.downloaded.append({
                'file': filename,
                'size': size,
                'url': url
            })
        
        print(f"✅ Скачан: {filename} ({size} KB)")
    
    def worker(self, worker_id):
        """Рабочий поток для скачивания"""
        print(f"🔧 Воркер-{worker_id} запущен")
        
        while True:
            try:
                # Берём URL из очереди с таймаутом
                url = self.download_queue.get(timeout=1)
                
                if url is None:  # Сигнал завершения
                    print(f"🛑 Воркер-{worker_id} завершает работу")
                    break
                
                self.download_file(url)
                self.download_queue.task_done()
                
            except Exception as e:
                print(f"❌ Воркер-{worker_id} ошибка: {e}")
                break
    
    def download_batch(self, urls):
        """Скачать пакет файлов"""
        print(f"📦 Начинаем скачивание {len(urls)} файлов\n")
        
        # Запускаем воркеров
        for i in range(self.num_workers):
            worker = threading.Thread(target=self.worker, args=(i+1,))
            worker.start()
            self.workers.append(worker)
        
        # Добавляем URLs в очередь
        for url in urls:
            self.download_queue.put(url)
        
        # Ждём выполнения всех задач
        self.download_queue.join()
        
        # Отправляем сигналы завершения воркерам
        for _ in range(self.num_workers):
            self.download_queue.put(None)
        
        # Ждём завершения всех воркеров
        for worker in self.workers:
            worker.join()
        
        # Результаты
        print(f"\n📊 Статистика:")
        print(f"  Скачано файлов: {len(self.downloaded)}")
        total_size = sum(f['size'] for f in self.downloaded)
        print(f"  Общий размер: {total_size} KB")

# Использование
downloader = FileDownloader(num_workers=3)

urls = [
    "https://example.com/file1.pdf",
    "https://example.com/file2.jpg",
    "https://example.com/file3.zip",
    "https://example.com/file4.mp4",
    "https://example.com/file5.doc",
    "https://example.com/file6.txt",
    "https://example.com/file7.png",
]

downloader.download_batch(urls)
```


### LifoQueue — LIFO очередь (стек)

**LIFO (Last In, First Out)** — последним вошёл, первым вышел. Как стопка тарелок.

```python
from queue import LifoQueue
import threading

# Создаём LIFO очередь (стек)
stack = LifoQueue()

def add_tasks():
    """Добавляем задачи в стек"""
    for i in range(1, 6):
        task = f"Задача {i}"
        print(f"➕ Добавлена: {task}")
        stack.put(task)

def process_tasks():
    """Обрабатываем задачи из стека"""
    print("\n📤 Обработка задач (в обратном порядке):")
    while not stack.empty():
        task = stack.get()
        print(f"  ⚙️  Обработка: {task}")
        stack.task_done()

# Использование
add_tasks()
process_tasks()

# Вывод:
# ➕ Добавлена: Задача 1
# ➕ Добавлена: Задача 2
# ➕ Добавлена: Задача 3
# ➕ Добавлена: Задача 4
# ➕ Добавлена: Задача 5
#
# 📤 Обработка задач (в обратном порядке):
#   ⚙️  Обработка: Задача 5  ← последняя добавленная
#   ⚙️  Обработка: Задача 4
#   ⚙️  Обработка: Задача 3
#   ⚙️  Обработка: Задача 2
#   ⚙️  Обработка: Задача 1  ← первая добавленная
```

### Пример: История действий (Undo/Redo)

```python
from queue import LifoQueue
import threading

class TextEditor:
    """Текстовый редактор с историей (Undo)"""
    
    def __init__(self):
        self.text = ""
        self.history = LifoQueue()  # Стек для истории
        self.lock = threading.Lock()
    
    def type_text(self, new_text):
        """Напечатать текст"""
        with self.lock:
            # Сохраняем текущее состояние в историю
            self.history.put(self.text)
            self.text += new_text
            print(f"✍️  Напечатано: '{new_text}'")
            print(f"📝 Текст: '{self.text}'")
    
    def undo(self):
        """Отменить последнее действие"""
        with self.lock:
            if not self.history.empty():
                self.text = self.history.get()
                print(f"↩️  Отмена")
                print(f"📝 Текст: '{self.text}'")
            else:
                print("❌ Нечего отменять")

# Использование
editor = TextEditor()

editor.type_text("Hello")
editor.type_text(" World")
editor.type_text("!")
print()
editor.undo()
print()
editor.undo()

# Вывод:
# ✍️  Напечатано: 'Hello'
# 📝 Текст: 'Hello'
# ✍️  Напечатано: ' World'
# 📝 Текст: 'Hello World'
# ✍️  Напечатано: '!'
# 📝 Текст: 'Hello World!'
#
# ↩️  Отмена
# 📝 Текст: 'Hello World'
#
# ↩️  Отмена
# 📝 Текст: 'Hello'
```


### PriorityQueue — очередь с приоритетами

Элементы извлекаются в порядке приоритета (меньшее число = выше приоритет).

```python
from queue import PriorityQueue
import threading
import time

# Создаём очередь с приоритетами
pq = PriorityQueue()

class Task:
    """Задача с приоритетом"""
    
    def __init__(self, priority, name, description):
        self.priority = priority  # Чем меньше, тем важнее
        self.name = name
        self.description = description
    
    def __lt__(self, other):
        """Сравнение для PriorityQueue"""
        return self.priority < other.priority
    
    def __repr__(self):
        return f"Task(priority={self.priority}, name='{self.name}')"

def add_tasks():
    """Добавляем задачи с разными приоритетами"""
    tasks = [
        Task(3, "Ответить на email", "Обычный приоритет"),
        Task(1, "Исправить критический баг", "СРОЧНО!"),
        Task(5, "Обновить документацию", "Низкий приоритет"),
        Task(2, "Провести код-ревью", "Высокий приоритет"),
        Task(4, "Рефакторинг кода", "Средний приоритет"),
    ]
    
    print("➕ Добавление задач:")
    for task in tasks:
        pq.put(task)
        print(f"   {task}")

def process_tasks():
    """Обрабатываем задачи по приоритету"""
    print("\n⚙️  Обработка задач (по приоритету):")
    while not pq.empty():
        task = pq.get()
        print(f"   🔧 Выполняем: {task.name} (приоритет: {task.priority})")
        time.sleep(0.5)
        pq.task_done()

# Использование
add_tasks()
process_tasks()

# Вывод:
# ➕ Добавление задач:
#    Task(priority=3, name='Ответить на email')
#    Task(priority=1, name='Исправить критический баг')
#    Task(priority=5, name='Обновить документацию')
#    Task(priority=2, name='Провести код-ревью')
#    Task(priority=4, name='Рефакторинг кода')
#
# ⚙️  Обработка задач (по приоритету):
#    🔧 Выполняем: Исправить критический баг (приоритет: 1)  ← самый важный
#    🔧 Выполняем: Провести код-ревью (приоритет: 2)
#    🔧 Выполняем: Ответить на email (приоритет: 3)
#    🔧 Выполняем: Рефакторинг кода (приоритет: 4)
#    🔧 Выполняем: Обновить документацию (приоритет: 5)  ← наименее важный
```

### Пример: Система обработки заявок

```python
from queue import PriorityQueue
import threading
import time
import random

class Ticket:
    """Заявка в службу поддержки"""
    
    CRITICAL = 1
    HIGH = 2
    MEDIUM = 3
    LOW = 4
    
    def __init__(self, ticket_id, priority, customer, issue):
        self.ticket_id = ticket_id
        self.priority = priority
        self.customer = customer
        self.issue = issue
    
    def __lt__(self, other):
        # Сначала по приоритету, потом по ID (раньше созданные первыми)
        if self.priority != other.priority:
            return self.priority < other.priority
        return self.ticket_id < other.ticket_id
    
    def __repr__(self):
        priority_names = {1: "🔴 КРИТИЧНЫЙ", 2: "🟠 ВЫСОКИЙ", 
                         3: "🟡 СРЕДНИЙ", 4: "🟢 НИЗКИЙ"}
        return f"#{self.ticket_id} [{priority_names[self.priority]}] {self.customer}: {self.issue}"

class SupportSystem:
    """Система обработки заявок"""
    
    def __init__(self, num_agents=2):
        self.ticket_queue = PriorityQueue()
        self.num_agents = num_agents
        self.processed = []
        self.lock = threading.Lock()
    
    def submit_ticket(self, ticket):
        """Подать заявку"""
        print(f"📨 Новая заявка: {ticket}")
        self.ticket_queue.put(ticket)
    
    def agent_worker(self, agent_id):
        """Агент обрабатывает заявки"""
        print(f"👤 Агент-{agent_id} начал работу")
        
        while True:
            try:
                ticket = self.ticket_queue.get(timeout=2)
                
                if ticket is None:
                    print(f"🛑 Агент-{agent_id} завершает работу")
                    break
                
                print(f"\n👤 Агент-{agent_id} обрабатывает: {ticket}")
                
                # Имитация обработки (критичные обрабатываются быстрее)
                processing_time = 3 - ticket.priority + random.random()
                time.sleep(processing_time)
                
                with self.lock:
                    self.processed.append(ticket)
                
                print(f"✅ Агент-{agent_id} решил заявку #{ticket.ticket_id}")
                self.ticket_queue.task_done()
                
            except:
                print(f"🛑 Агент-{agent_id} завершает работу (таймаут)")
                break
    
    def start_processing(self):
        """Запустить обработку заявок"""
        agents = []
        for i in range(self.num_agents):
            agent = threading.Thread(target=self.agent_worker, args=(i+1,))
            agent.start()
            agents.append(agent)
        
        return agents

# Использование
support = SupportSystem(num_agents=2)

# Подаём заявки
tickets = [
    Ticket(1, Ticket.LOW, "Иван", "Вопрос по функционалу"),
    Ticket(2, Ticket.CRITICAL, "Мария", "Сайт не работает!"),
    Ticket(3, Ticket.MEDIUM, "Пётр", "Нужна помощь с настройкой"),
    Ticket(4, Ticket.HIGH, "Анна", "Ошибка при оплате"),
    Ticket(5, Ticket.LOW, "Сергей", "Запрос на новую функцию"),
    Ticket(6, Ticket.CRITICAL, "Ольга", "Потеря данных"),
    Ticket(7, Ticket.MEDIUM, "Дмитрий", "Медленная работа системы"),
]

print("=== Подача заявок ===\n")
for ticket in tickets:
    support.submit_ticket(ticket)
    time.sleep(0.2)  # Небольшая задержка между заявками

print("\n=== Начало обработки ===\n")
agents = support.start_processing()

# Ждём обработки всех заявок
support.ticket_queue.join()

# Останавливаем агентов
for _ in range(support.num_agents):
    support.ticket_queue.put(None)

for agent in agents:
    agent.join()

# Результаты
print("\n=== Статистика ===")
print(f"Обработано заявок: {len(support.processed)}")
print("\nПорядок обработки:")
for i, ticket in enumerate(support.processed, 1):
    print(f"  {i}. {ticket}")

# Вывод покажет, что критичные заявки обработаны первыми:
# 1. #2 [🔴 КРИТИЧНЫЙ] Мария: Сайт не работает!
# 2. #6 [🔴 КРИТИЧНЫЙ] Ольга: Потеря данных
# 3. #4 [🟠 ВЫСОКИЙ] Анна: Ошибка при оплате
# 4. #3 [🟡 СРЕДНИЙ] Пётр: Нужна помощь с настройкой
# ...
```


### Сравнение типов очередей

```python
from queue import Queue, LifoQueue, PriorityQueue

print("=== Демонстрация разных типов очередей ===\n")

# FIFO Queue
print("1️⃣ Queue (FIFO):")
fifo = Queue()
for i in [1, 2, 3, 4, 5]:
    fifo.put(i)

print("   Добавлено: 1, 2, 3, 4, 5")
print("   Извлечение:", end=" ")
while not fifo.empty():
    print(fifo.get(), end=" ")
print(" (первым вошёл - первым вышел)\n")

# LIFO Queue (Stack)
print("2️⃣ LifoQueue (LIFO/Stack):")
lifo = LifoQueue()
for i in [1, 2, 3, 4, 5]:
    lifo.put(i)

print("   Добавлено: 1, 2, 3, 4, 5")
print("   Извлечение:", end=" ")
while not lifo.empty():
    print(lifo.get(), end=" ")
print(" (последним вошёл - первым вышел)\n")

# Priority Queue
print("3️⃣ PriorityQueue:")
pq = PriorityQueue()
# Добавляем пары (приоритет, значение)
for priority, value in [(3, "C"), (1, "A"), (5, "E"), (2, "B"), (4, "D")]:
    pq.put((priority, value))

print("   Добавлено: (3,C), (1,A), (5,E), (2,B), (4,D)")
print("   Извлечение:", end=" ")
while not pq.empty():
    priority, value = pq.get()
    print(f"{value}", end=" ")
print(" (по возрастанию приоритета)")
```


### Полезные методы Queue

```python
from queue import Queue, Empty, Full
import threading
import time

# Создание очереди с ограниченным размером
limited_queue = Queue(maxsize=3)

print("=== Методы Queue ===\n")

# 1. put() - добавить элемент
print("1. put() - добавление элементов:")
limited_queue.put("Задача 1")
print("   ✅ Добавлена: Задача 1")
limited_queue.put("Задача 2")
print("   ✅ Добавлена: Задача 2")
limited_queue.put("Задача 3")
print("   ✅ Добавлена: Задача 3")

# 2. full() - проверка на заполненность
print(f"\n2. full() - Очередь заполнена? {limited_queue.full()}")

# 3. put_nowait() - добавить без ожидания (вызовет исключение если полная)
print("\n3. put_nowait() - попытка добавить в полную очередь:")
try:
    limited_queue.put_nowait("Задача 4")
except Full:
    print("   ❌ Ошибка: очередь заполнена!")

# 4. get() - извлечь элемент
print("\n4. get() - извлечение элементов:")
task = limited_queue.get()
print(f"   📤 Извлечено: {task}")

# 5. empty() - проверка на пустоту
print(f"\n5. empty() - Очередь пуста? {limited_queue.empty()}")

# 6. qsize() - размер очереди
print(f"\n6. qsize() - Элементов в очереди: {limited_queue.qsize()}")

# 7. get() с timeout
print("\n7. get(timeout) - извлечение с таймаутом:")
try:
    task = limited_queue.get(timeout=1)
    print(f"   📤 Извлечено: {task}")
    
    task = limited_queue.get(timeout=1)
    print(f"   📤 Извлечено: {task}")
    
    # Очередь пуста, будет ждать 1 секунду
    task = limited_queue.get(timeout=1)
except Empty:
    print("   ⏱️ Таймаут: очередь пуста!")

# 8. task_done() и join()
print("\n8. task_done() и join() - ожидание выполнения:")

work_queue = Queue()

def worker():
    while True:
        item = work_queue.get()
        if item is None:
            break
        print(f"   ⚙️  Обработка: {item}")
        time.sleep(0.5)
        work_queue.task_done()  # Сообщаем, что задача выполнена

# Запускаем воркер
thread = threading.Thread(target=worker)
thread.start()

# Добавляем задачи
for i in range(3):
    work_queue.put(f"Задача {i+1}")

# Ждём выполнения всех задач
print("   ⏳ Ожидание выполнения всех задач...")
work_queue.join()
print("   ✅ Все задачи выполнены!")

# Останавливаем воркер
work_queue.put(None)
thread.join()
```


### Практический пример: Web Scraper с очередями

```python
from queue import Queue, PriorityQueue
import threading
import time
import random

class WebPage:
    """Веб-страница для скрейпинга"""
    
    def __init__(self, url, priority=5):
        self.url = url
        self.priority = priority
        self.content = None
        self.links = []
    
    def __lt__(self, other):
        return self.priority < other.priority
    
    def __repr__(self):
        return f"WebPage('{self.url}', priority={self.priority})"

class WebScraper:
    """Многопоточный веб-скрейпер"""
    
    def __init__(self, num_workers=3):
        self.url_queue = PriorityQueue()
        self.result_queue = Queue()
        self.visited = set()
        self.lock = threading.Lock()
        self.num_workers = num_workers
        self.workers = []
    
    def fetch_page(self, page):
        """Симуляция скачивания страницы"""
        print(f"🌐 Скачивание: {page.url}")
        
        # Имитация HTTP запроса
        time.sleep(random.uniform(0.5, 1.5))
        
        # Симуляция контента
        page.content = f"Контент страницы {page.url}"
        
        # Симуляция найденных ссылок
        if "page" in page.url:
            page_num = int(page.url.split("page")[1])
            if page_num < 10:  # Ограничение глубины
                page.links = [
                    f"https://example.com/page{page_num + 1}",
                    f"https://example.com/page{page_num + 2}"
                ]
        
        print(f"✅ Скачано: {page.url} (найдено {len(page.links)} ссылок)")
        return page
    
    def worker(self, worker_id):
        """Рабочий поток"""
        print(f"🔧 Воркер-{worker_id} запущен")
        
        while True:
            try:
                page = self.url_queue.get(timeout=3)
                
                if page is None:
                    print(f"🛑 Воркер-{worker_id} завершает работу")
                    break
                
                # Проверяем, не посещали ли мы эту страницу
                with self.lock:
                    if page.url in self.visited:
                        self.url_queue.task_done()
                        continue
                    self.visited.add(page.url)
                
                # Скачиваем страницу
                page = self.fetch_page(page)
                
                # Добавляем найденные ссылки в очередь
                for link in page.links:
                    new_page = WebPage(link, priority=page.priority + 1)
                    self.url_queue.put(new_page)
                
                # Сохраняем результат
                self.result_queue.put(page)
                
                self.url_queue.task_done()
                
            except Exception as e:
                print(f"⚠️ Воркер-{worker_id}: {e}")
                break
    
    def scrape(self, start_urls):
        """Начать скрейпинг"""
        print(f"🚀 Начало скрейпинга с {len(start_urls)} стартовых URL\n")
        
        # Добавляем стартовые URL
        for url in start_urls:
            self.url_queue.put(WebPage(url, priority=1))
        
        # Запускаем воркеров
        for i in range(self.num_workers):
            worker = threading.Thread(target=self.worker, args=(i+1,))
            worker.start()
            self.workers.append(worker)
        
        # Ждём выполнения
        self.url_queue.join()
        
        # Останавливаем воркеров
        for _ in range(self.num_workers):
            self.url_queue.put(None)
        
        for worker in self.workers:
            worker.join()
        
        # Собираем результаты
        results = []
        while not self.result_queue.empty():
            results.append(self.result_queue.get())
        
        print(f"\n📊 Статистика:")
        print(f"  Скачано страниц: {len(results)}")
        print(f"  Посещено URL: {len(self.visited)}")
        
        return results

# Использование
scraper = WebScraper(num_workers=2)

start_urls = [
    "https://example.com/page1",
    "https://example.com/page2",
]

results = scraper.scrape(start_urls)

print("\n📄 Скачанные страницы:")
for page in results[:5]:  # Показываем первые 5
    print(f"  - {page.url}")
```


### Резюме по модулю queue

#### Преимущества использования queue:

1. **Потокобезопасность** — не нужны дополнительные блокировки
2. **Простота** — легко организовать producer-consumer паттерн
3. **Гибкость** — разные типы очередей для разных задач
4. **Надёжность** — встроенные механизмы для отслеживания выполнения задач

### Когда использовать какую очередь:

| Тип очереди | Использование | Пример |
|-------------|---------------|--------|
| **Queue (FIFO)** | Стандартная обработка задач по порядку | Обработка запросов, скачивание файлов |
| **LifoQueue (LIFO)** | Нужна обработка в обратном порядке | История действий (Undo), обход графа в глубину |
| **PriorityQueue** | Задачи с разными приоритетами | Служба поддержки, планировщик задач |

#### Основные методы:

```python
# Добавление элементов
queue.put(item)              # Блокируется если очередь полная
queue.put(item, block=False) # Вызовет Full если полная
queue.put_nowait(item)       # То же что и block=False

# Извлечение элементов
item = queue.get()              # Блокируется если пустая
item = queue.get(timeout=5)     # Ждёт максимум 5 секунд
item = queue.get_nowait()       # Вызовет Empty если пустая

# Проверки
queue.empty()    # Пустая ли очередь
queue.full()     # Заполнена ли очередь
queue.qsize()    # Количество элементов

# Синхронизация
queue.task_done()  # Сообщить, что задача выполнена
queue.join()       # Ждать выполнения всех задач
```

### Паттерн Producer-Consumer:

```python
from queue import Queue
import threading

def producer(queue, items):
    """Производитель добавляет задачи"""
    for item in items:
        queue.put(item)

def consumer(queue):
    """Потребитель обрабатывает задачи"""
    while True:
        item = queue.get()
        if item is None:  # Сигнал завершения
            break
        # Обработка item
        queue.task_done()

# Использование
q = Queue()

# Запускаем потребителей
consumers = [threading.Thread(target=consumer, args=(q,)) for _ in range(3)]
for c in consumers:
    c.start()

# Запускаем производителей
producer(q, range(100))

# Ждём выполнения
q.join()

# Останавливаем потребителей
for _ in consumers:
    q.put(None)
for c in consumers:
    c.join()
```

**Правило**: Используйте `queue` вместо ручных блокировок для обмена данными между потоками — это проще, безопаснее и надёжнее!
















## `32.12` threading.local() — thread-local данные
**Thread-local данные** — это данные, которые уникальны для каждого потока. Каждый поток видит только свою копию данных, даже если переменная имеет одно и то же имя.

### Зачем нужны thread-local данные?

Представь, что у тебя несколько потоков, и каждому нужна своя база данных соединения, свой ID пользователя или свой контекст запроса. Вместо передачи этих данных через параметры функций, можно использовать `threading.local()`.

### Пример 1: Проблема без thread-local данных

```python
import threading
import time

# Глобальная переменная - ПРОБЛЕМА!
user_id = None

def process_request(request_user_id):
    """Обработка запроса"""
    global user_id
    user_id = request_user_id
    print(f"🔵 Поток {threading.current_thread().name}: установил user_id={user_id}")
    
    time.sleep(0.1)  # Имитация работы
    
    # ОШИБКА: user_id мог измениться другим потоком!
    print(f"🔵 Поток {threading.current_thread().name}: использует user_id={user_id}")

# Запускаем несколько потоков
threads = []
for i in range(1, 4):
    thread = threading.Thread(target=process_request, args=(i,), name=f"Thread-{i}")
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()

# Вывод покажет, что user_id перезаписывается между потоками:
# 🔵 Поток Thread-1: установил user_id=1
# 🔵 Поток Thread-2: установил user_id=2
# 🔵 Поток Thread-3: установил user_id=3
# 🔵 Поток Thread-1: использует user_id=3  ← ОШИБКА! Должно быть 1
# 🔵 Поток Thread-2: использует user_id=3  ← ОШИБКА! Должно быть 2
# 🔵 Поток Thread-3: использует user_id=3  ← Правильно
```

### Пример 2: Решение с threading.local()

```python
import threading
import time

# Thread-local хранилище - каждый поток видит свои данные
thread_local_data = threading.local()

def process_request(request_user_id):
    """Обработка запроса с thread-local данными"""
    # Каждый поток устанавливает свой user_id
    thread_local_data.user_id = request_user_id
    thread_local_data.request_time = time.time()
    
    print(f"🟢 Поток {threading.current_thread().name}: установил user_id={thread_local_data.user_id}")
    
    time.sleep(0.1)  # Имитация работы
    
    # Каждый поток видит СВОЙ user_id
    print(f"🟢 Поток {threading.current_thread().name}: использует user_id={thread_local_data.user_id}")
    print(f"   Время запроса: {thread_local_data.request_time:.2f}")

# Запускаем несколько потоков
threads = []
for i in range(1, 4):
    thread = threading.Thread(target=process_request, args=(i,), name=f"Thread-{i}")
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()

# Вывод покажет, что каждый поток видит СВОИ данные:
# 🟢 Поток Thread-1: установил user_id=1
# 🟢 Поток Thread-2: установил user_id=2
# 🟢 Поток Thread-3: установил user_id=3
# 🟢 Поток Thread-1: использует user_id=1  ✅ Правильно!
# 🟢 Поток Thread-2: использует user_id=2  ✅ Правильно!
# 🟢 Поток Thread-3: использует user_id=3  ✅ Правильно!
```

### Пример 3: Database connection pool с thread-local

```python
import threading
import time
import random

class DatabaseConnection:
    """Симуляция подключения к БД"""
    
    _connection_counter = 0
    _lock = threading.Lock()
    
    def __init__(self):
        with DatabaseConnection._lock:
            DatabaseConnection._connection_counter += 1
            self.connection_id = DatabaseConnection._connection_counter
        
        print(f"🔌 Создано подключение #{self.connection_id} в потоке {threading.current_thread().name}")
    
    def execute_query(self, query):
        """Выполнить запрос"""
        print(f"  🗄️ Подключение #{self.connection_id}: выполняет '{query}'")
        time.sleep(random.uniform(0.1, 0.3))
        return f"Результат от подключения #{self.connection_id}"
    
    def close(self):
        print(f"🔒 Закрыто подключение #{self.connection_id}")

class DatabasePool:
    """Пул подключений с thread-local хранилищем"""
    
    def __init__(self):
        self._local = threading.local()
    
    def get_connection(self):
        """Получить подключение для текущего потока"""
        # Проверяем, есть ли уже подключение для этого потока
        if not hasattr(self._local, 'connection'):
            self._local.connection = DatabaseConnection()
        
        return self._local.connection
    
    def close_connection(self):
        """Закрыть подключение текущего потока"""
        if hasattr(self._local, 'connection'):
            self._local.connection.close()
            del self._local.connection

# Глобальный пул
db_pool = DatabasePool()

def worker(worker_id, queries):
    """Рабочий поток выполняет несколько запросов"""
    print(f"\n👤 Воркер-{worker_id} начал работу")
    
    # Получаем подключение для этого потока (создастся один раз)
    connection = db_pool.get_connection()
    
    # Выполняем несколько запросов с ОДНИМ подключением
    for query in queries:
        result = connection.execute_query(query)
        print(f"  ✅ {result}")
    
    # Закрываем подключение
    db_pool.close_connection()
    print(f"👤 Воркер-{worker_id} завершил работу")

# Запускаем несколько воркеров
threads = []
for i in range(1, 4):
    queries = [f"SELECT * FROM users WHERE id={i}", 
               f"UPDATE users SET name='User{i}' WHERE id={i}"]
    
    thread = threading.Thread(target=worker, args=(i, queries), name=f"Worker-{i}")
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()

print("\n✅ Все воркеры завершили работу")

# Вывод покажет, что каждый поток использует СВОЁ подключение:
# 👤 Воркер-1 начал работу
# 🔌 Создано подключение #1 в потоке Worker-1
# 👤 Воркер-2 начал работу
# 🔌 Создано подключение #2 в потоке Worker-2
# 👤 Воркер-3 начал работу
# 🔌 Создано подключение #3 в потоке Worker-3
# ...
```

### Пример 4: Request context в веб-приложении

```python
import threading
import time
import uuid

# Thread-local для хранения контекста запроса
request_context = threading.local()

class RequestContext:
    """Контекст HTTP запроса"""
    
    def __init__(self, request_id, user_id, method, path):
        self.request_id = request_id
        self.user_id = user_id
        self.method = method
        self.path = path
        self.start_time = time.time()
    
    def __repr__(self):
        return f"Request({self.method} {self.path}, user={self.user_id})"

def set_request_context(user_id, method, path):
    """Установить контекст запроса для текущего потока"""
    request_context.current = RequestContext(
        request_id=str(uuid.uuid4())[:8],
        user_id=user_id,
        method=method,
        path=path
    )

def get_request_context():
    """Получить контекст запроса текущего потока"""
    return getattr(request_context, 'current', None)

def log(message):
    """Логирование с контекстом запроса"""
    ctx = get_request_context()
    if ctx:
        print(f"[{ctx.request_id}] [{ctx.user_id}] {message}")
    else:
        print(f"[NO_CONTEXT] {message}")

def database_query(query):
    """Имитация запроса к БД"""
    log(f"🗄️ Выполняем запрос: {query}")
    time.sleep(0.1)
    log(f"✅ Запрос выполнен")

def handle_request(user_id, method, path):
    """Обработка HTTP запроса"""
    # Устанавливаем контекст для этого потока
    set_request_context(user_id, method, path)
    
    ctx = get_request_context()
    log(f"📨 Начало обработки {ctx}")
    
    # Выполняем какую-то работу
    database_query(f"SELECT * FROM users WHERE id={user_id}")
    database_query(f"INSERT INTO logs (user_id, action) VALUES ({user_id}, '{method}')")
    
    # Вычисляем время выполнения
    elapsed = time.time() - ctx.start_time
    log(f"✅ Запрос обработан за {elapsed:.3f}с")

# Симуляция нескольких HTTP запросов в разных потоках
requests = [
    (101, "GET", "/api/users/101"),
    (102, "POST", "/api/users/102/update"),
    (103, "DELETE", "/api/users/103"),
]

threads = []
for user_id, method, path in requests:
    thread = threading.Thread(target=handle_request, args=(user_id, method, path))
    threads.append(thread)
    thread.start()
    time.sleep(0.05)  # Небольшая задержка между запросами

for thread in threads:
    thread.join()

# Вывод покажет, что каждый поток имеет свой контекст:
# [a3f9c2d1] [101] 📨 Начало обработки Request(GET /api/users/101, user=101)
# [a3f9c2d1] [101] 🗄️ Выполняем запрос: SELECT * FROM users WHERE id=101
# [b7e4a8f2] [102] 📨 Начало обработки Request(POST /api/users/102/update, user=102)
# ...
```

## `32.13` (`**`) concurrent.futures.ThreadPoolExecutor — пул потоков для упрощённой работы
**ThreadPoolExecutor** — это высокоуровневый интерфейс для работы с пулом потоков. Он автоматически управляет созданием, переиспользованием и уничтожением потоков.

### Преимущества ThreadPoolExecutor:

1. **Автоматическое управление потоками** — не нужно создавать и присоединять потоки вручную
2. **Переиспользование потоков** — эффективнее, чем создавать новый поток для каждой задачи
3. **Простота использования** — меньше кода, чем с обычным threading
4. **Future объекты** — удобная работа с результатами асинхронных операций

### Пример 1: Базовое использование

```python
from concurrent.futures import ThreadPoolExecutor
import time

def task(n):
    """Простая задача"""
    print(f"⚙️ Задача {n} начата в потоке {threading.current_thread().name}")
    time.sleep(1)
    result = n * n
    print(f"✅ Задача {n} завершена, результат: {result}")
    return result

# Создаём пул с 3 потоками
with ThreadPoolExecutor(max_workers=3) as executor:
    # Отправляем задачи в пул
    futures = [executor.submit(task, i) for i in range(1, 6)]
    
    # Получаем результаты
    for future in futures:
        result = future.result()  # Блокируется до получения результата
        print(f"📊 Получен результат: {result}")

print("🎉 Все задачи выполнены!")

# Вывод:
# ⚙️ Задача 1 начата в потоке ThreadPoolExecutor-0_0
# ⚙️ Задача 2 начата в потоке ThreadPoolExecutor-0_1
# ⚙️ Задача 3 начата в потоке ThreadPoolExecutor-0_2
# ✅ Задача 1 завершена, результат: 1
# ⚙️ Задача 4 начата в потоке ThreadPoolExecutor-0_0  ← Поток переиспользован!
# ...
```

### Пример 2: map() — обработка списка данных

```python
from concurrent.futures import ThreadPoolExecutor
import time

def download_page(url):
    """Симуляция скачивания страницы"""
    print(f"📥 Скачивание: {url}")
    time.sleep(1)  # Имитация HTTP запроса
    return f"Контент с {url}"

urls = [
    "https://example.com/page1",
    "https://example.com/page2",
    "https://example.com/page3",
    "https://example.com/page4",
    "https://example.com/page5",
]

print("=== Без многопоточности ===")
start = time.time()
results = [download_page(url) for url in urls]
print(f"⏱️ Время выполнения: {time.time() - start:.2f}с\n")

print("=== С ThreadPoolExecutor (map) ===")
start = time.time()
with ThreadPoolExecutor(max_workers=3) as executor:
    # map() обрабатывает элементы параллельно
    results = list(executor.map(download_page, urls))
print(f"⏱️ Время выполнения: {time.time() - start:.2f}с")

print(f"\n📄 Скачано страниц: {len(results)}")

# Вывод покажет ускорение примерно в 3 раза!
# Без многопоточности: ~5 секунд
# С ThreadPoolExecutor: ~2 секунды (3 потока обрабатывают параллельно)
```

### Пример 3: as_completed() — обработка по мере готовности

```python
from concurrent.futures import ThreadPoolExecutor, as_completed
import time
import random

def process_task(task_id):
    """Задача с разным временем выполнения"""
    duration = random.uniform(0.5, 2.0)
    print(f"⚙️ Задача {task_id} начата (займёт {duration:.2f}с)")
    time.sleep(duration)
    print(f"✅ Задача {task_id} завершена")
    return task_id, duration

# Создаём пул
with ThreadPoolExecutor(max_workers=3) as executor:
    # Отправляем задачи
    futures = {executor.submit(process_task, i): i for i in range(1, 6)}
    
    # Обрабатываем результаты по мере готовности
    print("\n📊 Обработка результатов по мере готовности:\n")
    for future in as_completed(futures):
        task_id, duration = future.result()
        print(f"📦 Получен результат задачи {task_id} (выполнялась {duration:.2f}с)")

# Вывод покажет, что результаты приходят не по порядку,
# а по мере завершения задач:
# ⚙️ Задача 1 начата (займёт 1.23с)
# ⚙️ Задача 2 начата (займёт 0.67с)
# ⚙️ Задача 3 начата (займёт 1.89с)
# ✅ Задача 2 завершена
# 📦 Получен результат задачи 2 (выполнялась 0.67с)  ← Первая завершилась
# ⚙️ Задача 4 начата (займёт 1.45с)
# ...
```

### Пример 4: Обработка исключений

```python
from concurrent.futures import ThreadPoolExecutor
import time
import random

def risky_task(task_id):
    """Задача, которая может упасть с ошибкой"""
    print(f"⚙️ Задача {task_id} начата")
    time.sleep(0.5)
    
    # Некоторые задачи падают с ошибкой
    if random.random() < 0.3:  # 30% вероятность ошибки
        raise ValueError(f"Ошибка в задаче {task_id}!")
    
    print(f"✅ Задача {task_id} выполнена успешно")
    return task_id * 10

# Обработка с проверкой исключений
with ThreadPoolExecutor(max_workers=3) as executor:
    futures = [executor.submit(risky_task, i) for i in range(1, 8)]
    
    for future in futures:
        try:
            result = future.result()
            print(f"📊 Результат: {result}")
        except Exception as e:
            print(f"❌ Ошибка: {e}")

# Вывод:
# ⚙️ Задача 1 начата
# ⚙️ Задача 2 начата
# ⚙️ Задача 3 начата
# ✅ Задача 1 выполнена успешно
# 📊 Результат: 10
# ❌ Ошибка: Ошибка в задаче 2!  ← Обработали ошибку
# ✅ Задача 3 выполнена успешно
# ...
```

### Пример 5: Реальный кейс — параллельная обработка изображений

```python
from concurrent.futures import ThreadPoolExecutor, as_completed
import time
import random

class Image:
    """Симуляция изображения"""
    
    def __init__(self, filename):
        self.filename = filename
        self.width = random.randint(800, 1920)
        self.height = random.randint(600, 1080)
        self.processed = False
    
    def __repr__(self):
        return f"Image('{self.filename}', {self.width}x{self.height})"

def resize_image(image, target_width):
    """Изменение размера изображения"""
    print(f"🖼️ Обработка: {image.filename} ({image.width}x{image.height})")
    
    # Имитация обработки изображения
    time.sleep(random.uniform(0.5, 1.5))
    
    # Вычисляем новую высоту с сохранением пропорций
    aspect_ratio = image.height / image.width
    new_height = int(target_width * aspect_ratio)
    
    image.width = target_width
    image.height = new_height
    image.processed = True
    
    print(f"✅ Обработано: {image.filename} → {image.width}x{image.height}")
    return image

# Список изображений для обработки
images = [Image(f"photo_{i}.jpg") for i in range(1, 11)]

print("=== Последовательная обработка ===")
start = time.time()
for img in images[:3]:  # Обработаем только 3 для примера
    resize_image(img, 800)
sequential_time = time.time() - start
print(f"⏱️ Время: {sequential_time:.2f}с\n")

print("=== Параллельная обработка с ThreadPoolExecutor ===")
start = time.time()

# Сбрасываем состояние изображений
images = [Image(f"photo_{i}.jpg") for i in range(1, 11)]

with ThreadPoolExecutor(max_workers=4) as executor:
    # Отправляем все задачи
    futures = {
        executor.submit(resize_image, img, 800): img 
        for img in images
    }
    
    # Обрабатываем по мере готовности
    processed_count = 0
    for future in as_completed(futures):
        try:
            processed_image = future.result()
            processed_count += 1
            print(f"📦 Готово {processed_count}/{len(images)}")
        except Exception as e:
            print(f"❌ Ошибка: {e}")

parallel_time = time.time() - start
print(f"\n⏱️ Время: {parallel_time:.2f}с")
print(f"⚡ Ускорение: {sequential_time / parallel_time * 3:.2f}x")  # *3 т.к. сравниваем с 3 изображениями

# Статистика
processed_images = [img for img in images if img.processed]
print(f"\n📊 Обработано изображений: {len(processed_images)}/{len(images)}")
```

### Пример 6: Timeout и отмена задач

```python
from concurrent.futures import ThreadPoolExecutor, TimeoutError
import time

def slow_task(task_id):
    """Медленная задача"""
    print(f"⚙️ Задача {task_id} начата")
    time.sleep(task_id * 2)  # Задача 1 = 2с, задача 2 = 4с, и т.д.
    print(f"✅ Задача {task_id} завершена")
    return task_id * 100

with ThreadPoolExecutor(max_workers=3) as executor:
    futures = [executor.submit(slow_task, i) for i in range(1, 5)]
    
    for future in futures:
        try:
            # Ждём максимум 3 секунды
            result = future.result(timeout=3)
            print(f"📊 Результат: {result}")
        except TimeoutError:
            print(f"⏱️ Таймаут! Задача не завершилась за 3 секунды")
            future.cancel()  # Попытка отменить задачу
        except Exception as e:
            print(f"❌ Ошибка: {e}")

# Вывод:
# ⚙️ Задача 1 начата
# ⚙️ Задача 2 начата
# ⚙️ Задача 3 начата
# ✅ Задача 1 завершена
# 📊 Результат: 100
# ⏱️ Таймаут! Задача не завершилась за 3 секунды  ← Задача 2 (4 секунды)
# ⚙️ Задача 4 начата
# ...
```

## `32.14` Контекстный менеджер для работы с блокировками
Python блокировки поддерживают протокол контекстного менеджера, что делает работу с ними безопаснее и удобнее.

### Почему использовать `with`?

1. **Автоматическое освобождение** — блокировка освободится даже при ошибке
2. **Меньше кода** — не нужно вручную вызывать `acquire()` и `release()`
3. **Безопасность** — невозможно забыть освободить блокировку

### Пример 1: Lock с контекстным менеджером

```python
import threading
import time

class BankAccount:
    """Банковский счёт с безопасной блокировкой"""
    
    def __init__(self, balance):
        self.balance = balance
        self.lock = threading.Lock()
    
    def withdraw_unsafe(self, amount):
        """❌ НЕБЕЗОПАСНЫЙ способ без контекстного менеджера"""
        self.lock.acquire()
        if self.balance >= amount:
            print(f"💰 Снимаем {amount}₽")
            time.sleep(0.1)
            self.balance -= amount
            self.lock.release()  # ← Можем забыть вызвать!
            return True
        self.lock.release()
        return False
    
    def withdraw_safe(self, amount):
        """✅ БЕЗОПАСНЫЙ способ с контекстным менеджером"""
        with self.lock:  # Автоматически вызовет acquire и release
            if self.balance >= amount:
                print(f"💰 Снимаем {amount}₽")
                time.sleep(0.1)
                self.balance -= amount
                return True
            return False
    
    def deposit(self, amount):
        """Положить деньги"""
        with self.lock:
            print(f"💵 Кладём {amount}₽")
            self.balance += amount

# Использование
account = BankAccount(1000)

def make_withdrawals():
    for _ in range(3):
        account.withdraw_safe(100)
        time.sleep(0.05)

threads = [threading.Thread(target=make_withdrawals) for _ in range(3)]
for t in threads:
    t.start()
for t in threads:
    t.join()

print(f"\n💳 Итоговый баланс: {account.balance}₽")
```

### Пример 2: RLock (рекурсивная блокировка) с контекстным менеджером

```python
import threading

class Counter:
    """Счётчик с вложенными вызовами методов"""
    
    def __init__(self):
        self.value = 0
        self.lock = threading.RLock()  # Рекурсивная блокировка
    
    def increment(self):
        """Увеличить на 1"""
        with self.lock:
            self.value += 1
            print(f"➕ Значение: {self.value}")
    
    def increment_by(self, n):
        """Увеличить на n (вызывает increment несколько раз)"""
        with self.lock:  # Берём блокировку
            for _ in range(n):
                self.increment()  # Вызывает метод, который ТОЖЕ берёт блокировку
                # RLock позволяет одному потоку брать блокировку несколько раз
    
    def get_value(self):
        """Получить значение"""
        with self.lock:
            return self.value

counter = Counter()
counter.increment_by(3)  # Работает благодаря RLock!
print(f"📊 Итоговое значение: {counter.get_value()}")
```

### Пример 3: Condition с контекстным менеджером

```python
import threading
import time
import random

class Queue:
    """Простая очередь с условной переменной"""
    
    def __init__(self):
        self.items = []
        self.condition = threading.Condition()
    
    def put(self, item):
        """Добавить элемент"""
        with self.condition:  # Берём блокировку Condition
            self.items.append(item)
            print(f"➕ Добавлен: {item} (размер очереди: {len(self.items)})")
            self.condition.notify()  # Уведомляем ожидающие потоки
    
    def get(self):
        """Получить элемент (ждёт, если очередь пуста)"""
        with self.condition:
            # Ждём, пока очередь не станет непустой
            while not self.items:
                print("⏳ Очередь пуста, ждём...")
                self.condition.wait()  # Освобождает блокировку и ждёт notify
            
            item = self.items.pop(0)
            print(f"📤 Извлечён: {item} (размер очереди: {len(self.items)})")
            return item

# Использование
queue = Queue()

def producer():
    """Производитель"""
    for i in range(1, 6):
        time.sleep(random.uniform(0.5, 1.0))
        queue.put(f"Задача-{i}")

def consumer(name):
    """Потребитель"""
    for _ in range(3):
        item = queue.get()
        print(f"  {name} обработал: {item}")
        time.sleep(0.5)

# Запускаем потоки
producer_thread = threading.Thread(target=producer)
consumer1 = threading.Thread(target=consumer, args=("Потребитель-1",))
consumer2 = threading.Thread(target=consumer, args=("Потребитель-2",))

consumer1.start()
consumer2.start()
time.sleep(0.1)  # Даём потребителям запуститься первыми
producer_thread.start()

producer_thread.join()
consumer1.join()
consumer2.join()
```

### Пример 4: Semaphore с контекстным менеджером

```python
import threading
import time
import random

class ConnectionPool:
    """Пул подключений с ограничением"""
    
    def __init__(self, max_connections=3):
        self.semaphore = threading.Semaphore(max_connections)
        self.active_connections = 0
        self.lock = threading.Lock()
    
    def connect(self, client_name):
        """Подключиться (ждёт, если все слоты заняты)"""
        print(f"🔌 {client_name} ожидает подключения...")
        
        with self.semaphore:  # Автоматически acquire/release
            with self.lock:
                self.active_connections += 1
                print(f"✅ {client_name} подключился (активных: {self.active_connections})")
            
            # Работа с подключением
            time.sleep(random.uniform(1, 3))
            
            with self.lock:
                self.active_connections -= 1
                print(f"🔒 {client_name} отключился (активных: {self.active_connections})")

# Использование
pool = ConnectionPool(max_connections=3)

def client(client_id):
    pool.connect(f"Клиент-{client_id}")

# Запускаем 7 клиентов, но только 3 могут подключиться одновременно
threads = [threading.Thread(target=client, args=(i,)) for i in range(1, 8)]

for t in threads:
    t.start()
    time.sleep(0.1)

for t in threads:
    t.join()

print("\n✅ Все клиенты обслужены")

# Вывод покажет, что одновременно работают максимум 3 клиента:
# 🔌 Клиент-1 ожидает подключения...
# ✅ Клиент-1 подключился (активных: 1)
# 🔌 Клиент-2 ожидает подключения...
# ✅ Клиент-2 подключился (активных: 2)
# 🔌 Клиент-3 ожидает подключения...
# ✅ Клиент-3 подключился (активных: 3)
# 🔌 Клиент-4 ожидает подключения...  ← Ждёт освобождения
# 🔒 Клиент-1 отключился (активных: 2)
# ✅ Клиент-4 подключился (активных: 3)  ← Получил слот
```

### Пример 5: Создание собственного контекстного менеджера для блокировки

```python
import threading
import time
from contextlib import contextmanager

class TimedLock:
    """Блокировка с измерением времени ожидания"""
    
    def __init__(self, name="Lock"):
        self.lock = threading.Lock()
        self.name = name
    
    @contextmanager
    def timed_acquire(self, timeout=None):
        """Контекстный менеджер с таймером"""
        start_time = time.time()
        
        # Пытаемся захватить блокировку
        acquired = self.lock.acquire(timeout=timeout)
        
        if acquired:
            wait_time = time.time() - start_time
            print(f"🔒 {self.name}: захвачена за {wait_time:.3f}с")
            
            try:
                yield  # Выполняется код внутри with
            finally:
                # Освобождаем блокировку
                hold_time = time.time() - start_time
                self.lock.release()
                print(f"🔓 {self.name}: освобождена (удерживалась {hold_time:.3f}с)")
        else:
            print(f"⏱️ {self.name}: таймаут!")
            yield None  # Блокировка не получена

# Использование
resource_lock = TimedLock("ResourceLock")

def worker(worker_id, work_duration):
    print(f"\n👤 Воркер-{worker_id} начал работу")
    
    with resource_lock.timed_acquire(timeout=2):
        print(f"  ⚙️ Воркер-{worker_id} работает с ресурсом")
        time.sleep(work_duration)
        print(f"  ✅ Воркер-{worker_id} завершил работу")

# Запускаем несколько воркеров
threads = [
    threading.Thread(target=worker, args=(1, 1.0)),
    threading.Thread(target=worker, args=(2, 0.5)),
    threading.Thread(target=worker, args=(3, 1.5)),
]

for t in threads:
    t.start()

for t in threads:
    t.join()
```

### Пример 6: Множественные блокировки с контекстным менеджером

```python
import threading
import time
from contextlib import ExitStack

lock_a = threading.Lock()
lock_b = threading.Lock()
lock_c = threading.Lock()

def task_with_multiple_locks():
    """Задача, которая работает с несколькими блокировками"""
    
    # ExitStack позволяет работать с несколькими контекстными менеджерами
    with ExitStack() as stack:
        # Захватываем все блокировки в правильном порядке
        stack.enter_context(lock_a)
        print("🔒 Захвачена lock_a")
        
        stack.enter_context(lock_b)
        print("🔒 Захвачена lock_b")
        
        stack.enter_context(lock_c)
        print("🔒 Захвачена lock_c")
        
        # Работа с ресурсами
        print("⚙️ Работа с тремя ресурсами")
        time.sleep(1)
        print("✅ Работа завершена")
        
        # Все блокировки автоматически освободятся в обратном порядке

task_with_multiple_locks()

# Альтернативный способ - вложенные with
def task_with_nested_locks():
    with lock_a:
        print("🔒 Захвачена lock_a")
        with lock_b:
            print("🔒 Захвачена lock_b")
            with lock_c:
                print("🔒 Захвачена lock_c")
                print("⚙️ Работа")
                time.sleep(0.5)

task_with_nested_locks()
```

## `32.15` Когда использовать многопоточность: I/O-bound задачи
**I/O-bound задачи** — это задачи, которые большую часть времени ждут ввода-вывода (сеть, диск, пользовательский ввод), а не выполняют вычисления.

### I/O-bound vs CPU-bound

```python
import time
import threading
from concurrent.futures import ThreadPoolExecutor

# CPU-bound задача (вычисления)
def cpu_bound_task(n):
    """Вычислительная задача - считает сумму"""
    result = sum(i * i for i in range(n))
    return result

# I/O-bound задача (ожидание)
def io_bound_task(duration):
    """Задача с ожиданием - имитирует сетевой запрос"""
    time.sleep(duration)
    return f"Завершено за {duration}с"

print("=== CPU-bound (вычисления) ===")

# Последовательно
start = time.time()
for _ in range(4):
    cpu_bound_task(1_000_000)
seq_time = time.time() - start
print(f"Последовательно: {seq_time:.2f}с")

# С потоками - НЕ будет быстрее из-за GIL!
start = time.time()
with ThreadPoolExecutor(max_workers=4) as executor:
    futures = [executor.submit(cpu_bound_task, 1_000_000) for _ in range(4)]
    for f in futures:
        f.result()
thread_time = time.time() - start
print(f"С потоками: {thread_time:.2f}с")
print(f"Ускорение: {seq_time / thread_time:.2f}x ❌ Почти нет!\n")

print("=== I/O-bound (ожидание) ===")

# Последовательно
start = time.time()
for _ in range(4):
    io_bound_task(1)
seq_time = time.time() - start
print(f"Последовательно: {seq_time:.2f}с")

# С потоками - БУДЕТ быстрее!
start = time.time()
with ThreadPoolExecutor(max_workers=4) as executor:
    futures = [executor.submit(io_bound_task, 1) for _ in range(4)]
    for f in futures:
        f.result()
thread_time = time.time() - start
print(f"С потоками: {thread_time:.2f}с")
print(f"Ускорение: {seq_time / thread_time:.2f}x ✅ Почти в 4 раза!")
```

### Примеры I/O-bound задач (ИСПОЛЬЗУЙ потоки):

1. **Сетевые запросы** — HTTP API, веб-скрейпинг
2. **Работа с файлами** — чтение/запись больших файлов
3. **Работа с БД** — SQL запросы
4. **Внешние сервисы** — отправка email, загрузка на S3

### Примеры CPU-bound задач (НЕ используй потоки):

1. **Математические вычисления** — обработка данных, ML
2. **Обработка изображений** — ресайз, фильтры
3. **Шифрование** — хеширование, криптография
4. **Парсинг** — обработка больших JSON/XML

### Пример 1: Сетевые запросы (I/O-bound) ✅ ПОТОКИ

```python
import time
import requests
from concurrent.futures import ThreadPoolExecutor

def fetch_url(url):
    """Скачать содержимое URL"""
    try:
        response = requests.get(url, timeout=5)
        return len(response.content)
    except Exception as e:
        return 0

urls = [
    "https://httpbin.org/delay/1",
    "https://httpbin.org/delay/1",
    "https://httpbin.org/delay/1",
    "https://httpbin.org/delay/1",
]

print("=== Последовательное скачивание ===")
start = time.time()
sizes = [fetch_url(url) for url in urls]
seq_time = time.time() - start
print(f"⏱️ Время: {seq_time:.2f}с")
print(f"📦 Скачано байт: {sum(sizes)}\n")

print("=== Параллельное скачивание ===")
start = time.time()
with ThreadPoolExecutor(max_workers=4) as executor:
    sizes = list(executor.map(fetch_url, urls))
parallel_time = time.time() - start
print(f"⏱️ Время: {parallel_time:.2f}с")
print(f"📦 Скачано байт: {sum(sizes)}")
print(f"⚡ Ускорение: {seq_time / parallel_time:.2f}x")

# Вывод:
# Последовательно: ~4 секунды (1с × 4)
# Параллельно: ~1 секунда (все одновременно)
# Ускорение: 4x
```

### Пример 2: Работа с файлами (I/O-bound) ✅ ПОТОКИ

```python
import time
import os
from concurrent.futures import ThreadPoolExecutor

def process_file(filename):
    """Чтение и обработка файла"""
    # Создаём тестовый файл
    with open(filename, 'w') as f:
        f.write("x" * 1_000_000)  # 1MB данных
    
    # Читаем файл
    with open(filename, 'r') as f:
        content = f.read()
    
    # Обработка (подсчёт символов)
    char_count = len(content)
    
    # Удаляем файл
    os.remove(filename)
    
    return char_count

files = [f"test_file_{i}.txt" for i in range(10)]

print("=== Последовательная обработка файлов ===")
start = time.time()
results = [process_file(f) for f in files]
seq_time = time.time() - start
print(f"⏱️ Время: {seq_time:.2f}с\n")

print("=== Параллельная обработка файлов ===")
start = time.time()
with ThreadPoolExecutor(max_workers=4) as executor:
    results = list(executor.map(process_file, files))
parallel_time = time.time() - start
print(f"⏱️ Время: {parallel_time:.2f}с")
print(f"⚡ Ускорение: {seq_time / parallel_time:.2f}x")
```

### Пример 3: Когда НЕ использовать потоки (CPU-bound) ❌

```python
import time
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor

def fibonacci(n):
    """CPU-bound задача - вычисление числа Фибоначчи"""
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

numbers = [35, 35, 35, 35]

print("=== CPU-bound задача: Fibonacci ===\n")

# Последовательно
print("1️⃣ Последовательно:")
start = time.time()
results = [fibonacci(n) for n in numbers]
seq_time = time.time() - start
print(f"   ⏱️ Время: {seq_time:.2f}с\n")

# С потоками (ThreadPoolExecutor) - НЕ эффективно!
print("2️⃣ С ThreadPoolExecutor (потоки):")
start = time.time()
with ThreadPoolExecutor(max_workers=4) as executor:
    results = list(executor.map(fibonacci, numbers))
thread_time = time.time() - start
print(f"   ⏱️ Время: {thread_time:.2f}с")
print(f"   ⚡ Ускорение: {seq_time / thread_time:.2f}x ❌ Почти нет!\n")

# С процессами (ProcessPoolExecutor) - Эффективно!
print("3️⃣ С ProcessPoolExecutor (процессы):")
start = time.time()
with ProcessPoolExecutor(max_workers=4) as executor:
    results = list(executor.map(fibonacci, numbers))
process_time = time.time() - start
print(f"   ⏱️ Время: {process_time:.2f}с")
print(f"   ⚡ Ускорение: {seq_time / process_time:.2f}x ✅ Почти в 4 раза!")
```

### Таблица: Когда использовать что

| Тип задачи | Характеристика | Решение | Пример |
|-----------|---------------|---------|--------|
| **I/O-bound** | Много ожидания (сеть, диск) | ✅ `ThreadPoolExecutor` | API запросы, скачивание файлов |
| **I/O-bound** | Очень много параллельных задач | ✅ `asyncio` | Тысячи HTTP запросов |
| **CPU-bound** | Много вычислений | ✅ `ProcessPoolExecutor` | Обработка изображений, ML |
| **CPU-bound** | Простые вычисления | ✅ Последовательно | Мелкие операции |

### Пример 4: Комбинированная задача

```python
import time
import requests
from concurrent.futures import ThreadPoolExecutor
import hashlib

def download_and_process(url):
    """
    I/O-bound: скачивание
    CPU-bound: обработка (хеширование)
    """
    # I/O-bound часть - потоки помогают
    print(f"📥 Скачивание: {url}")
    try:
        response = requests.get(url, timeout=5)
        content = response.content
        print(f"✅ Скачано: {len(content)} байт")
    except Exception as e:
        print(f"❌ Ошибка: {e}")
        return None
    
    # CPU-bound часть - потоки не помогут, но она быстрая
    print(f"⚙️ Вычисление хеша...")
    hash_value = hashlib.sha256(content).hexdigest()
    print(f"✅ Хеш: {hash_value[:16]}...")
    
    return hash_value

urls = [
    "https://httpbin.org/bytes/100000",
    "https://httpbin.org/bytes/100000",
    "https://httpbin.org/bytes/100000",
]

# I/O-часть занимает большую часть времени, поэтому потоки эффективны
print("=== С ThreadPoolExecutor ===")
start = time.time()
with ThreadPoolExecutor(max_workers=3) as executor:
    results = list(executor.map(download_and_process, urls))
print(f"\n⏱️ Общее время: {time.time() - start:.2f}с")
print(f"📊 Обработано URL: {len([r for r in results if r])}")
```

### Практические рекомендации:

```python
# ✅ ХОРОШО: Используй потоки для I/O
def good_example():
    urls = ["url1", "url2", "url3"]
    
    with ThreadPoolExecutor(max_workers=5) as executor:
        results = executor.map(download_url, urls)
    
    return list(results)

# ❌ ПЛОХО: Используешь потоки для CPU-bound
def bad_example():
    data = [large_array_1, large_array_2, large_array_3]
    
    with ThreadPoolExecutor(max_workers=5) as executor:
        results = executor.map(process_array, data)  # Не будет быстрее!
    
    return list(results)

# ✅ ХОРОШО: Используй процессы для CPU-bound
def good_cpu_example():
    data = [large_array_1, large_array_2, large_array_3]
    
    from concurrent.futures import ProcessPoolExecutor
    with ProcessPoolExecutor(max_workers=4) as executor:
        results = executor.map(process_array, data)  # Будет быстрее!
    
    return list(results)
```

## Резюме по многопоточности

### threading.local():
- **Для чего**: Хранение данных, уникальных для каждого потока
- **Использование**: Database connections, request context, user sessions
- **Пример**: `thread_local.user_id = 123`

### ThreadPoolExecutor:
- **Для чего**: Упрощённая работа с пулом потоков
- **Преимущества**: Автоматическое управление потоками, Future объекты
- **Методы**: `submit()`, `map()`, `as_completed()`

### Контекстные менеджеры:
- **Для чего**: Безопасная работа с блокировками
- **Преимущество**: Автоматическое освобождение даже при ошибках
- **Синтаксис**: `with lock: ...`

### Когда использовать потоки:
- ✅ **I/O-bound задачи**: Сеть, файлы, БД
- ❌ **CPU-bound задачи**: Вычисления (используй `multiprocessing`)
- ✅ **Много коротких операций ожидания**
- ❌ **Мало длинных вычислительных операций**

**Золотое правило**: Если задача больше ждёт, чем считает — используй потоки!

----

# `33` (`*`) Асинхронность
[Асинхронный код видео](https://youtu.be/_4QY1nGFRY8?si=Bh13XvuBmru9DAaM)
[Асинхронный код видео 2](https://youtu.be/h-EFkclgCc8?si=sBUa-RIadlAI0ukw)
[Статья asyncio посмотреть разные части](https://habr.com/ru/companies/wunderfund/articles/700474/)

## `33.1` Что такое асинхронность и чем отличается от многопоточности
**Асинхронность** — это способ написания программ, где один поток может эффективно выполнять множество задач, переключаясь между ними во время ожидания (например, ответа от сервера или чтения файла).

### Аналогия из жизни

**Синхронный подход (обычный код):**
- Ты варишь кофе → ждёшь 5 минут → кофе готов
- Потом готовишь тост → ждёшь 3 минуты → тост готов
- **Итого: 8 минут**

**Многопоточный подход (threading):**
- Нанимаешь двух помощников
- Один варит кофе (5 минут), другой готовит тост (3 минуты) одновременно
- **Итого: 5 минут** (но нужны дополнительные ресурсы - помощники)

**Асинхронный подход (asyncio):**
- Включаешь кофеварку → пока она работает, идёшь готовить тост
- Переключаешься между задачами, не тратя время на ожидание
- **Итого: 5 минут** (работаешь один, но эффективно)

### Ключевые различия

| Характеристика | Синхронный | Многопоточный (Threading) | Асинхронный (Asyncio) |
|---------------|------------|---------------------------|------------------------|
| **Потоки** | 1 поток | Много потоков | 1 поток |
| **Параллелизм** | Нет | Да (настоящий) | Нет (кооперативный) |
| **Переключение** | Нет | ОС решает | Программист контролирует |
| **Overhead** | Минимальный | Средний-высокий | Низкий |
| **Подходит для** | Простые задачи | I/O + CPU (ограничено GIL) | Много I/O операций |
| **Масштабируемость** | Плохая | Средняя | Отличная |

### Пример 1: Сравнение подходов

```python
import time
import asyncio
import threading

# Функция, имитирующая I/O операцию (загрузка данных)
def sync_fetch_data(source):
    """Синхронная загрузка данных"""
    print(f"⏳ Начинаем загрузку из {source}")
    time.sleep(2)  # Имитация ожидания (I/O)
    print(f"✅ Загружено из {source}")
    return f"Данные из {source}"

def threaded_fetch_data(source):
    """Загрузка данных в отдельном потоке"""
    print(f"⏳ Начинаем загрузку из {source}")
    time.sleep(2)
    print(f"✅ Загружено из {source}")
    return f"Данные из {source}"

async def async_fetch_data(source):
    """Асинхронная загрузка данных"""
    print(f"⏳ Начинаем загрузку из {source}")
    await asyncio.sleep(2)  # Асинхронное ожидание
    print(f"✅ Загружено из {source}")
    return f"Данные из {source}"

# 1️⃣ СИНХРОННЫЙ ПОДХОД
print("=== 1. Синхронный подход ===")
start = time.time()
result1 = sync_fetch_data("API-1")
result2 = sync_fetch_data("API-2")
result3 = sync_fetch_data("API-3")
print(f"⏱️  Время выполнения: {time.time() - start:.2f}с\n")
# Вывод: ~6 секунд (2с + 2с + 2с) - выполняется последовательно

# 2️⃣ МНОГОПОТОЧНЫЙ ПОДХОД
print("=== 2. Многопоточный подход (Threading) ===")
start = time.time()
threads = []
for i in range(1, 4):
    thread = threading.Thread(target=threaded_fetch_data, args=(f"API-{i}",))
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()
print(f"⏱️  Время выполнения: {time.time() - start:.2f}с\n")
# Вывод: ~2 секунды (все три потока работают параллельно)

# 3️⃣ АСИНХРОННЫЙ ПОДХОД
print("=== 3. Асинхронный подход (Asyncio) ===")
async def main():
    start = time.time()
    # Запускаем все задачи конкурентно
    results = await asyncio.gather(
        async_fetch_data("API-1"),
        async_fetch_data("API-2"),
        async_fetch_data("API-3")
    )
    print(f"⏱️  Время выполнения: {time.time() - start:.2f}с")
    return results

asyncio.run(main())
# Вывод: ~2 секунды (все три задачи выполняются конкурентно в одном потоке)
```

### Пример 2: Когда что использовать

```python
import time
import asyncio
import threading

# CPU-bound задача (много вычислений)
def cpu_heavy_task(n):
    """Вычислительная задача"""
    result = sum(i * i for i in range(n))
    return result

# I/O-bound задача (ожидание)
async def io_task():
    """Задача с ожиданием"""
    await asyncio.sleep(1)
    return "Готово"

print("=== CPU-bound задача ===")
print("❌ Asyncio НЕ поможет (нет реального ожидания):")
async def test_cpu_async():
    start = time.time()
    # Даже с gather, выполнится последовательно
    await asyncio.gather(
        asyncio.to_thread(cpu_heavy_task, 1_000_000),
        asyncio.to_thread(cpu_heavy_task, 1_000_000)
    )
    print(f"   Время: {time.time() - start:.2f}с")

asyncio.run(test_cpu_async())

print("\n=== I/O-bound задача ===")
print("✅ Asyncio идеально подходит:")
async def test_io_async():
    start = time.time()
    await asyncio.gather(
        io_task(),
        io_task(),
        io_task()
    )
    print(f"   Время: {time.time() - start:.2f}с (все 3 задачи параллельно)")

asyncio.run(test_io_async())

# Вывод:
# CPU-bound: asyncio не даст преимущества
# I/O-bound: asyncio выполнит всё конкурентно за время самой долгой операции
```

## `33.2` Синхронный vs асинхронный код — основные различия
### Синхронный код

**Синхронный код** выполняется последовательно, одна операция за другой. Если операция блокирующая (ожидание), вся программа стоит на месте.

```python
import time

def download_file(filename):
    print(f"📥 Начинаем загрузку {filename}")
    time.sleep(2)  # Блокирующая операция
    print(f"✅ {filename} загружен")
    return f"Содержимое {filename}"

# Синхронное выполнение
print("=== Синхронный код ===")
start = time.time()

result1 = download_file("file1.txt")  # Ждём 2 секунды
result2 = download_file("file2.txt")  # Ждём ещё 2 секунды
result3 = download_file("file3.txt")  # Ждём ещё 2 секунды

print(f"⏱️  Общее время: {time.time() - start:.2f}с")
# Вывод: ~6 секунд

# Проблемы:
# ❌ Неэффективное использование времени
# ❌ Программа "замирает" во время ожидания
# ❌ Плохо масштабируется для множества операций
```

### Асинхронный код

**Асинхронный код** может переключаться между операциями во время ожидания, не блокируя выполнение других задач.

```python
import asyncio

async def download_file_async(filename):
    print(f"📥 Начинаем загрузку {filename}")
    await asyncio.sleep(2)  # НЕблокирующее ожидание
    print(f"✅ {filename} загружен")
    return f"Содержимое {filename}"

# Асинхронное выполнение
async def main():
    print("=== Асинхронный код ===")
    start = time.time()
    
    # Запускаем все загрузки конкурентно
    results = await asyncio.gather(
        download_file_async("file1.txt"),
        download_file_async("file2.txt"),
        download_file_async("file3.txt")
    )
    
    print(f"⏱️  Общее время: {time.time() - start:.2f}с")
    return results

asyncio.run(main())
# Вывод: ~2 секунды

# Преимущества:
# ✅ Эффективное использование времени
# ✅ Программа не "замирает"
# ✅ Отлично масштабируется
```

### Пример: Наглядное сравнение

```python
import time
import asyncio

# СИНХРОННЫЙ КОД
def make_coffee_sync():
    print("☕ Варим кофе...")
    time.sleep(3)  # Блокируем выполнение
    print("✅ Кофе готов!")
    return "Кофе"

def make_toast_sync():
    print("🍞 Готовим тост...")
    time.sleep(2)  # Блокируем выполнение
    print("✅ Тост готов!")
    return "Тост"

print("=== СИНХРОННЫЙ ЗАВТРАК ===")
start = time.time()
coffee = make_coffee_sync()  # Ждём 3 секунды
toast = make_toast_sync()    # Потом ждём 2 секунды
print(f"🍽️  Завтрак готов за {time.time() - start:.2f}с\n")
# Итого: 5 секунд (3 + 2)

# АСИНХРОННЫЙ КОД
async def make_coffee_async():
    print("☕ Варим кофе...")
    await asyncio.sleep(3)  # НЕ блокируем, можем переключиться на другую задачу
    print("✅ Кофе готов!")
    return "Кофе"

async def make_toast_async():
    print("🍞 Готовим тост...")
    await asyncio.sleep(2)  # НЕ блокируем
    print("✅ Тост готов!")
    return "Тост"

async def breakfast():
    print("=== АСИНХРОННЫЙ ЗАВТРАК ===")
    start = time.time()
    
    # Запускаем обе задачи одновременно
    coffee_task = asyncio.create_task(make_coffee_async())
    toast_task = asyncio.create_task(make_toast_async())
    
    # Ждём завершения обеих
    coffee = await coffee_task
    toast = await toast_task
    
    print(f"🍽️  Завтрак готов за {time.time() - start:.2f}с")

asyncio.run(breakfast())
# Итого: 3 секунды (время самой долгой задачи)
```

## `33.3` Event Loop (цикл событий) — что это и как работает

**Event Loop (цикл событий)** — это сердце асинхронного программирования. Это бесконечный цикл, который управляет выполнением асинхронных задач, переключаясь между ними.

### Как работает Event Loop

1. **Инициализация:** Event loop создается и инициализируется для управления асинхронными задачами.
2. **Очередь задач:** Event loop имеет очередь задач (Task Queue), где хранятся корутины и callback-функции, готовые к выполнению.
3. **Выбор задачи:** Event loop выбирает первую задачу из очереди для выполнения.
4. **Выполнение задачи:** Если задача — корутина, она начинает выполняться до тех пор, пока не встретит `await`.
5. **Приостановка:** При встрече `await`, корутина приостанавливается, и её текущее состояние (локальные переменные, точка выполнения) сохраняется. Управление возвращается в event loop. В Python это реализовано с использованием генераторов и протокола `__await__`, `__iter__` и `__next__`. `await` по сути "разворачивает" awaitable объект (например, Future) до тех пор, пока не получит результат, который можно "вернуть" в корутину.
6. **Переключение:** Event loop переключается на другую задачу из очереди и выполняет её.
7. **Завершение асинхронной операции:** Операционная система (например, с использованием `select`, `epoll`) уведомляет event loop о завершении асинхронной операции.
8. **Возобновление корутины:** Event loop не "кладет" корутину непосредственно в очередь после получения уведомления, а решает, какую корутину нужно возобновить и планирует её для дальнейшего выполнения. Event loop добавляет корутину обратно в очередь задач для выполнения. Она возобновляется с места, где была приостановлена.
9. **Повторение цикла:** Процесс повторяется: event loop снова выбирает задачи из очереди и выполняет их до тех пор, пока не завершатся все задачи или не будет вызвано завершение работы.

```
┌─────────────────────────────────────┐
│     Event Loop (Цикл событий)       │
│                                     │
│  1. Есть ли готовые задачи?        │
│     └─> Да: выполни их             │
│     └─> Нет: жди                   │
│                                     │
│  2. Задача встретила await?         │
│     └─> Приостанови её             │
│     └─> Переключись на другую      │
│                                     │
│  3. Операция завершилась?           │
│     └─> Возобнови задачу           │
│                                     │
│  4. Повторяй пока есть задачи      │
└─────────────────────────────────────┘
```

### Пример 1: Визуализация работы Event Loop

```python
import asyncio
import time

async def task(name, duration):
    print(f"[{time.time():.2f}] {name} начата")
    await asyncio.sleep(duration)  # Здесь задача "засыпает", loop переключается
    print(f"[{time.time():.2f}] {name} завершена")
    return f"Результат {name}"

async def main():
    print("=== Работа Event Loop ===\n")
    start = time.time()
    
    # Создаём задачи (они попадут в event loop)
    task1 = asyncio.create_task(task("Задача-1", 2))
    task2 = asyncio.create_task(task("Задача-2", 1))
    task3 = asyncio.create_task(task("Задача-3", 3))
    
    # Event loop управляет их выполнением
    results = await asyncio.gather(task1, task2, task3)
    
    print(f"\n⏱️  Общее время: {time.time() - start:.2f}с")
    return results

asyncio.run(main())

# Вывод покажет, как event loop переключается:
# [0.00] Задача-1 начата
# [0.00] Задача-2 начата
# [0.00] Задача-3 начата
# [1.00] Задача-2 завершена    ← Первая завершилась
# [2.00] Задача-1 завершена    ← Вторая
# [3.00] Задача-3 завершена    ← Последняя
```

### Пример 2: Блокирующая vs неблокирующая операция

```python
import asyncio
import time

async def blocking_task():
    """❌ ПЛОХО: Блокирующая операция"""
    print("⚠️  Блокирующая задача начата")
    time.sleep(2)  # Блокирует весь event loop!
    print("⚠️  Блокирующая задача завершена")

async def non_blocking_task():
    """✅ ХОРОШО: Неблокирующая операция"""
    print("✅ Неблокирующая задача начата")
    await asyncio.sleep(2)  # НЕ блокирует event loop
    print("✅ Неблокирующая задача завершена")

async def other_task():
    print("🔵 Другая задача работает")
    await asyncio.sleep(0.5)
    print("🔵 Другая задача завершена")

# Тест с блокирующей операцией
print("=== С БЛОКИРУЮЩЕЙ операцией ===")
async def test_blocking():
    start = time.time()
    await asyncio.gather(
        blocking_task(),
        other_task()
    )
    print(f"⏱️  Время: {time.time() - start:.2f}с\n")

asyncio.run(test_blocking())
# Вывод: other_task не выполнится параллельно!
# ⚠️  Блокирующая задача начата
# ⚠️  Блокирующая задача завершена  ← Весь loop заблокирован 2 секунды
# 🔵 Другая задача работает
# 🔵 Другая задача завершена

# Тест с неблокирующей операцией
print("=== С НЕБЛОКИРУЮЩЕЙ операцией ===")
async def test_non_blocking():
    start = time.time()
    await asyncio.gather(
        non_blocking_task(),
        other_task()
    )
    print(f"⏱️  Время: {time.time() - start:.2f}с")

asyncio.run(test_non_blocking())
# Вывод: задачи выполняются конкурентно!
# ✅ Неблокирующая задача начата
# 🔵 Другая задача работает
# 🔵 Другая задача завершена        ← Выполнилась параллельно
# ✅ Неблокирующая задача завершена
```

## `33.4` Ключевые слова `async` и `await` — основы async/await синтаксиса
### `async` — объявление асинхронной функции

`async def` создаёт **корутину** (coroutine) — специальную функцию, которая может быть приостановлена и возобновлена.

```python
# Обычная функция
def regular_function():
    return "Результат"

# Асинхронная функция (корутина)
async def async_function():
    return "Результат"

# Различия:
result1 = regular_function()  # Выполняется сразу
print(result1)  # "Результат"

result2 = async_function()    # НЕ выполняется, возвращает корутину
print(result2)  # <coroutine object async_function at 0x...>

# Чтобы выполнить корутину, нужен event loop:
import asyncio
result2 = asyncio.run(async_function())
print(result2)  # "Результат"
```

### `await` — ожидание асинхронной операции

`await` приостанавливает выполнение корутины до завершения awaitable объекта, передавая управление обратно в event loop.

```python
import asyncio

async def fetch_data():
    print("📥 Начинаем загрузку...")
    await asyncio.sleep(2)  # Приостанавливаем на 2 секунды
    print("✅ Данные загружены")
    return "Данные"

async def process_data():
    print("⚙️  Начинаем обработку...")
    data = await fetch_data()  # Ждём завершения fetch_data()
    print(f"⚙️  Обрабатываем: {data}")
    return f"Обработанные {data}"

# Запуск
result = asyncio.run(process_data())
print(f"📊 Результат: {result}")

# Вывод:
# ⚙️  Начинаем обработку...
# 📥 Начинаем загрузку...
# ✅ Данные загружены
# ⚙️  Обрабатываем: Данные
# 📊 Результат: Обработанные Данные
```

### Пример 1: Правила использования async/await

```python
import asyncio

# ✅ ПРАВИЛЬНО
async def correct_async():
    await asyncio.sleep(1)  # await только внутри async функции
    return "OK"

# ❌ ОШИБКА: await вне async функции
def wrong_sync():
    await asyncio.sleep(1)  # SyntaxError!
    return "Error"

# ❌ ОШИБКА: вызов async функции без await
async def wrong_async():
    result = correct_async()  # Вернёт корутину, а не результат!
    print(result)  # <coroutine object correct_async at 0x...>
    return result

# ✅ ПРАВИЛЬНО: вызов async функции с await
async def correct_call():
    result = await correct_async()  # Получим "OK"
    print(result)  # "OK"
    return result

# ✅ ПРАВИЛЬНО: можно не использовать await
async def no_await():
    # Если в функции нет await, она всё равно async
    return "Результат"

asyncio.run(correct_call())
```

### Пример 2: Параллельное vs последовательное выполнение

```python
import asyncio
import time

async def task(name, duration):
    print(f"▶️  {name} начата")
    await asyncio.sleep(duration)
    print(f"✅ {name} завершена")
    return name

# 🐌 ПОСЛЕДОВАТЕЛЬНОЕ выполнение (медленно)
async def sequential():
    print("=== Последовательное выполнение ===")
    start = time.time()
    
    result1 = await task("Задача-1", 2)  # Ждём 2 секунды
    result2 = await task("Задача-2", 2)  # Потом ждём ещё 2 секунды
    result3 = await task("Задача-3", 2)  # Потом ещё 2 секунды
    
    print(f"⏱️  Время: {time.time() - start:.2f}с\n")
    return [result1, result2, result3]

asyncio.run(sequential())
# Вывод: ~6 секунд

# ⚡ ПАРАЛЛЕЛЬНОЕ выполнение (быстро)
async def parallel():
    print("=== Параллельное выполнение ===")
    start = time.time()
    
    # Запускаем все задачи одновременно
    results = await asyncio.gather(
        task("Задача-1", 2),
        task("Задача-2", 2),
        task("Задача-3", 2)
    )
    
    print(f"⏱️  Время: {time.time() - start:.2f}с\n")
    return results

asyncio.run(parallel())
# Вывод: ~2 секунды (все 3 задачи выполняются конкурентно)
```

## `33.5` Корутины (coroutines) — что это и как их создавать
**Корутина (coroutine)** — это функция, объявленная с `async def`, которая может быть приостановлена и возобновлена. Корутины — это основа асинхронного программирования в Python.

### Создание корутины

```python
import asyncio

# Способ 1: async def (основной способ)
async def my_coroutine():
    await asyncio.sleep(1)
    return "Результат"

# Способ 2: с помощью декоратора (устаревший)
@asyncio.coroutine
def old_style_coroutine():
    yield from asyncio.sleep(1)
    return "Результат"

# Проверка типа
print(type(my_coroutine()))  # <class 'coroutine'>
print(asyncio.iscoroutine(my_coroutine()))  # True

# Запуск корутины
result = asyncio.run(my_coroutine())
print(result)  # "Результат"
```

### Пример 1: Простая корутина

```python
import asyncio

async def greet(name, delay):
    """Корутина для приветствия"""
    print(f"👋 Привет, {name}!")
    await asyncio.sleep(delay)  # Асинхронное ожидание
    print(f"👋 До свидания, {name}!")
    return f"Встреча с {name} завершена"

async def main():
    # Способ 1: последовательный вызов
    result1 = await greet("Иван", 1)
    print(f"📝 {result1}")
    
    result2 = await greet("Мария", 1)
    print(f"📝 {result2}")

asyncio.run(main())

# Вывод:
# 👋 Привет, Иван!
# 👋 До свидания, Иван!
# 📝 Встреча с Иван завершена
# 👋 Привет, Мария!
# 👋 До свидания, Мария!
# 📝 Встреча с Мария завершена
```

### Пример 2: Корутины с разными состояниями

```python
import asyncio
import time

async def download(file_id):
    """Корутина для загрузки файла"""
    states = ["Подключение", "Загрузка", "Проверка", "Завершено"]
    
    for state in states:
        print(f"📁 Файл-{file_id}: {state}")
        await asyncio.sleep(0.5)
    
    return f"Файл-{file_id}"

async def main():
    print("=== Загрузка файлов ===\n")
    start = time.time()
    
    # Запускаем 3 корутины параллельно
    results = await asyncio.gather(
        download(1),
        download(2),
        download(3)
    )
    
    print(f"\n✅ Загружено: {', '.join(results)}")
    print(f"⏱️  Время: {time.time() - start:.2f}с")

asyncio.run(main())

# Вывод покажет, как корутины переключаются:
# 📁 Файл-1: Подключение
# 📁 Файл-2: Подключение
# 📁 Файл-3: Подключение
# 📁 Файл-1: Загрузка
# 📁 Файл-2: Загрузка
# 📁 Файл-3: Загрузка
# ...
```

## `33.6` Модуль `asyncio` — основной инструмент для асинхронного программирования

**`asyncio`** — это встроенный модуль Python для написания асинхронного кода. Он предоставляет event loop, корутины, задачи (tasks), синхронизационные примитивы и многое другое.

### Основные компоненты asyncio

```
┌─────────────────────────────────────────────────┐
│              Модуль asyncio                     │
├─────────────────────────────────────────────────┤
│                                                 │
│  📌 Event Loop (цикл событий)                   │
│     └─ asyncio.run()                           │
│     └─ asyncio.get_event_loop()                │
│                                                 │
│  📌 Корутины и Задачи                           │
│     └─ async def (создание корутины)           │
│     └─ asyncio.create_task()                   │
│     └─ asyncio.gather()                        │
│                                                 │
│  📌 Синхронизация                               │
│     └─ asyncio.Lock                            │
│     └─ asyncio.Semaphore                       │
│     └─ asyncio.Event                           │
│                                                 │
│  📌 Утилиты                                     │
│     └─ asyncio.sleep()                         │
│     └─ asyncio.wait()                          │
│     └─ asyncio.wait_for()                      │
│                                                 │
│  📌 Потоки и процессы                           │
│     └─ asyncio.to_thread()                     │
│     └─ asyncio.create_subprocess_exec()        │
│                                                 │
│  📌 Очереди                                     │
│     └─ asyncio.Queue                           │
│                                                 │
└─────────────────────────────────────────────────┘
```

### Философия asyncio

1. **Кооперативная многозадачность** — задачи сами решают, когда передать управление
2. **Один поток** — нет проблем с race conditions и deadlock
3. **Явный контроль** — вы точно знаете, где происходит переключение (`await`)
4. **Высокая производительность** — десятки тысяч конкурентных операций

### Пример: Обзор возможностей asyncio

```python
import asyncio
import time

async def fetch_data(source, delay):
    """Имитация загрузки данных"""
    print(f"🔍 Получаем данные из {source}")
    await asyncio.sleep(delay)  # Асинхронное ожидание
    print(f"✅ Данные из {source} получены")
    return f"Data from {source}"

async def process_data(data):
    """Обработка данных"""
    print(f"⚙️  Обрабатываем: {data}")
    await asyncio.sleep(0.5)
    return f"Processed: {data}"

async def save_data(data):
    """Сохранение данных"""
    print(f"💾 Сохраняем: {data}")
    await asyncio.sleep(0.3)
    return True

async def full_pipeline(source, delay):
    """Полный пайплайн: загрузка → обработка → сохранение"""
    # Последовательное выполнение этапов
    data = await fetch_data(source, delay)
    processed = await process_data(data)
    saved = await save_data(processed)
    return processed

async def main():
    print("=== Демонстрация asyncio ===\n")
    start = time.time()
    
    # Запускаем несколько пайплайнов параллельно
    results = await asyncio.gather(
        full_pipeline("API-1", 1.0),
        full_pipeline("API-2", 0.8),
        full_pipeline("API-3", 1.2)
    )
    
    print(f"\n📊 Результаты: {results}")
    print(f"⏱️  Общее время: {time.time() - start:.2f}с")
    print(f"💡 Без asyncio заняло бы: ~6 секунд")

# Запуск
asyncio.run(main())

# Вывод покажет конкурентное выполнение:
# 🔍 Получаем данные из API-1
# 🔍 Получаем данные из API-2
# 🔍 Получаем данные из API-3
# ✅ Данные из API-2 получены
# ⚙️  Обрабатываем: Data from API-2
# ✅ Данные из API-1 получены
# ⚙️  Обрабатываем: Data from API-1
# ...
```

## `33.7` Запуск асинхронного кода:

### `asyncio.run()` — запуск корутины

**`asyncio.run()`** — это главная точка входа в асинхронную программу. Он создаёт event loop, запускает корутину и закрывает loop после завершения.

```python
import asyncio

async def hello():
    await asyncio.sleep(1)
    return "Hello, World!"

# ✅ ПРАВИЛЬНО: запуск через asyncio.run()
result = asyncio.run(hello())
print(result)  # "Hello, World!"

# ❌ ОШИБКА: нельзя вызвать корутину напрямую
# result = hello()  # Вернёт корутину, а не результат
# print(result)  # <coroutine object hello at 0x...>
```

**Важно:** `asyncio.run()` можно вызвать только один раз в программе. Нельзя вызывать его внутри уже запущенного event loop.

```python
import asyncio

async def outer():
    # ❌ ОШИБКА: asyncio.run() уже запущен!
    result = asyncio.run(inner())  # RuntimeError!
    return result

async def inner():
    await asyncio.sleep(1)
    return "Inner"

# Это вызовет ошибку
# asyncio.run(outer())

# ✅ ПРАВИЛЬНО: используй await вместо asyncio.run()
async def outer_correct():
    result = await inner()  # Просто await
    return result

asyncio.run(outer_correct())
```

### `asyncio.create_task()` — создание задачи

**`asyncio.create_task()`** создаёт Task (задачу), которая начинает выполняться немедленно в фоне, параллельно с текущим кодом.

```python
import asyncio
import time

async def say_after(delay, message):
    await asyncio.sleep(delay)
    print(message)
    return message

async def main():
    print("=== Без create_task (последовательно) ===")
    start = time.time()
    
    await say_after(2, "Первое")
    await say_after(1, "Второе")
    
    print(f"⏱️  Время: {time.time() - start:.2f}с\n")
    # Вывод: ~3 секунды

    print("=== С create_task (параллельно) ===")
    start = time.time()
    
    # Создаём задачи - они начинают выполняться сразу!
    task1 = asyncio.create_task(say_after(2, "Первое"))
    task2 = asyncio.create_task(say_after(1, "Второе"))
    
    # Ждём завершения обеих
    result1 = await task1
    result2 = await task2
    
    print(f"⏱️  Время: {time.time() - start:.2f}с")
    # Вывод: ~2 секунды (время самой долгой задачи)

asyncio.run(main())
```

**Разница между `await coroutine()` и `create_task()`:**

```python
import asyncio
import time

async def task(name, duration):
    print(f"▶️  {name} начата")
    await asyncio.sleep(duration)
    print(f"✅ {name} завершена")
    return name

async def sequential_approach():
    """Последовательное выполнение с await"""
    print("=== Последовательное (await) ===")
    start = time.time()
    
    result1 = await task("Задача-1", 2)  # Ждём завершения
    result2 = await task("Задача-2", 2)  # Потом ждём следующую
    
    print(f"⏱️  Время: {time.time() - start:.2f}с\n")

async def concurrent_approach():
    """Параллельное выполнение с create_task"""
    print("=== Параллельное (create_task) ===")
    start = time.time()
    
    task1 = asyncio.create_task(task("Задача-1", 2))  # Запустили
    task2 = asyncio.create_task(task("Задача-2", 2))  # Запустили
    
    # Обе задачи УЖЕ выполняются в фоне!
    result1 = await task1  # Ждём результат
    result2 = await task2  # Ждём результат
    
    print(f"⏱️  Время: {time.time() - start:.2f}с")

asyncio.run(sequential_approach())  # ~4 секунды
asyncio.run(concurrent_approach())   # ~2 секунды
```

### `asyncio.gather()` — параллельное выполнение корутин

**`asyncio.gather()`** запускает несколько корутин параллельно и ждёт завершения всех. Возвращает список результатов в том же порядке.

```python
import asyncio
import time

async def fetch_user(user_id):
    print(f"👤 Загружаем пользователя {user_id}")
    await asyncio.sleep(1)
    return {"id": user_id, "name": f"User-{user_id}"}

async def fetch_posts(user_id):
    print(f"📝 Загружаем посты пользователя {user_id}")
    await asyncio.sleep(1.5)
    return [f"Post-{i}" for i in range(3)]

async def fetch_comments(user_id):
    print(f"💬 Загружаем комментарии пользователя {user_id}")
    await asyncio.sleep(0.8)
    return [f"Comment-{i}" for i in range(5)]

async def main():
    print("=== Использование gather ===\n")
    start = time.time()
    
    # Запускаем все операции параллельно
    user, posts, comments = await asyncio.gather(
        fetch_user(123),
        fetch_posts(123),
        fetch_comments(123)
    )
    
    print(f"\n✅ Пользователь: {user}")
    print(f"✅ Постов: {len(posts)}")
    print(f"✅ Комментариев: {len(comments)}")
    print(f"⏱️  Время: {time.time() - start:.2f}с")
    print(f"💡 Последовательно заняло бы: ~3.3 секунды")

asyncio.run(main())

# Вывод:
# 👤 Загружаем пользователя 123
# 📝 Загружаем посты пользователя 123
# 💬 Загружаем комментарии пользователя 123
# ✅ Пользователь: {'id': 123, 'name': 'User-123'}
# ✅ Постов: 3
# ✅ Комментариев: 5
# ⏱️  Время: 1.50с (время самой долгой операции)
```

**Обработка ошибок в gather:**

```python
import asyncio

async def task_success():
    await asyncio.sleep(1)
    return "Успех"

async def task_failure():
    await asyncio.sleep(0.5)
    raise ValueError("Ошибка в задаче!")

async def task_another():
    await asyncio.sleep(1.5)
    return "Другая задача"

async def main():
    print("=== Обработка ошибок в gather ===\n")
    
    try:
        # По умолчанию gather прерывается при первой ошибке
        results = await asyncio.gather(
            task_success(),
            task_failure(),
            task_another()
        )
    except ValueError as e:
        print(f"❌ Поймана ошибка: {e}\n")
    
    # Чтобы не прерываться на ошибках, используй return_exceptions=True
    print("=== С return_exceptions=True ===\n")
    results = await asyncio.gather(
        task_success(),
        task_failure(),
        task_another(),
        return_exceptions=True  # Ошибки возвращаются как результаты
    )
    
    for i, result in enumerate(results, 1):
        if isinstance(result, Exception):
            print(f"Задача {i}: ❌ {result}")
        else:
            print(f"Задача {i}: ✅ {result}")

asyncio.run(main())

# Вывод:
# ❌ Поймана ошибка: Ошибка в задаче!
# 
# === С return_exceptions=True ===
# Задача 1: ✅ Успех
# Задача 2: ❌ Ошибка в задаче!
# Задача 3: ✅ Другая задача
```

### Сравнение способов запуска

```python
import asyncio
import time

async def task(name, duration):
    print(f"▶️  {name} начата")
    await asyncio.sleep(duration)
    print(f"✅ {name} завершена")
    return f"Результат {name}"

# Способ 1: Последовательный await
async def method1():
    print("=== Способ 1: await (последовательно) ===")
    start = time.time()
    
    r1 = await task("A", 1)
    r2 = await task("B", 1)
    r3 = await task("C", 1)
    
    print(f"⏱️  Время: {time.time() - start:.2f}с\n")
    return [r1, r2, r3]

# Способ 2: create_task + await
async def method2():
    print("=== Способ 2: create_task ===")
    start = time.time()
    
    t1 = asyncio.create_task(task("A", 1))
    t2 = asyncio.create_task(task("B", 1))
    t3 = asyncio.create_task(task("C", 1))
    
    r1 = await t1
    r2 = await t2
    r3 = await t3
    
    print(f"⏱️  Время: {time.time() - start:.2f}с\n")
    return [r1, r2, r3]

# Способ 3: gather
async def method3():
    print("=== Способ 3: gather ===")
    start = time.time()
    
    results = await asyncio.gather(
        task("A", 1),
        task("B", 1),
        task("C", 1)
    )
    
    print(f"⏱️  Время: {time.time() - start:.2f}с\n")
    return results

asyncio.run(method1())  # ~3 секунды
asyncio.run(method2())  # ~1 секунда
asyncio.run(method3())  # ~1 секунда
```

## `33.8` Awaitable объекты — что можно await'ить
**Awaitable объект** — это любой объект, который можно использовать с оператором `await`. В Python есть три типа awaitable объектов:

1. **Корутины** (coroutines) — функции, объявленные с `async def`
2. **Task** (задачи) — обёртки для корутин, созданные через `create_task()`
3. **Future** — низкоуровневые объекты для представления будущего результата

### Типы Awaitable объектов

```python
import asyncio

# 1️⃣ Корутина
async def my_coroutine():
    await asyncio.sleep(1)
    return "Результат корутины"

# 2️⃣ Task (создаётся из корутины)
async def example_task():
    task = asyncio.create_task(my_coroutine())
    print(f"Task: {task}")  # <Task pending...>
    result = await task
    return result

# 3️⃣ Future (низкоуровневый)
async def example_future():
    loop = asyncio.get_event_loop()
    future = loop.create_future()
    
    # Future используется для низкоуровневых операций
    # Обычно не создаётся вручную
    future.set_result("Результат future")
    result = await future
    return result

# Все три типа можно await'ить
async def main():
    # Awaiting корутины
    result1 = await my_coroutine()
    print(f"1️⃣ Корутина: {result1}")
    
    # Awaiting task
    result2 = await example_task()
    print(f"2️⃣ Task: {result2}")
    
    # Awaiting future
    result3 = await example_future()
    print(f"3️⃣ Future: {result3}")

asyncio.run(main())
```

### Что НЕЛЬЗЯ await'ить

```python
import asyncio
import time

# ❌ Нельзя await обычную функцию
def regular_function():
    time.sleep(1)
    return "Результат"

# ❌ Нельзя await синхронную блокирующую операцию
async def wrong_example():
    # result = await regular_function()  # TypeError!
    # result = await time.sleep(1)  # TypeError!
    pass

# ✅ Правильно: используй асинхронные альтернативы
async def correct_example():
    await asyncio.sleep(1)  # Асинхронная задержка
    
    # Если нужно вызвать синхронную функцию, используй to_thread
    result = await asyncio.to_thread(regular_function)
    return result

asyncio.run(correct_example())
```

### Большой практический пример: Веб-скрейпер

```python
import asyncio
import time
from typing import List, Dict

# Имитация HTTP-запросов
async def fetch_url(url: str) -> Dict:
    """Асинхронная загрузка URL"""
    print(f"🌐 Загружаем: {url}")
    
    # Имитация сетевой задержки (разная для каждого URL)
    delay = 1.0 + (hash(url) % 10) / 10  # 1.0-2.0 секунд
    await asyncio.sleep(delay)
    
    print(f"✅ Загружено: {url}")
    
    return {
        "url": url,
        "status": 200,
        "content_length": len(url) * 100,
        "load_time": delay
    }

async def extract_links(url: str) -> List[str]:
    """Извлечение ссылок со страницы"""
    print(f"🔍 Извлекаем ссылки из: {url}")
    await asyncio.sleep(0.3)
    
    # Имитация найденных ссылок
    links = [f"{url}/page{i}" for i in range(1, 4)]
    print(f"📎 Найдено {len(links)} ссылок на {url}")
    
    return links

async def parse_content(data: Dict) -> Dict:
    """Парсинг содержимого страницы"""
    print(f"⚙️  Парсим содержимое: {data['url']}")
    await asyncio.sleep(0.2)
    
    return {
        **data,
        "title": f"Заголовок для {data['url']}",
        "word_count": data['content_length'] // 5,
        "parsed": True
    }

async def save_to_database(data: Dict) -> bool:
    """Сохранение данных в БД"""
    print(f"💾 Сохраняем в БД: {data['url']}")
    await asyncio.sleep(0.1)
    print(f"✅ Сохранено: {data['url']}")
    return True

async def scrape_page(url: str) -> Dict:
    """
    Полный цикл обработки одной страницы:
    1. Загрузка
    2. Парсинг
    3. Сохранение
    """
    # Этап 1: Загрузка (awaitable корутина)
    data = await fetch_url(url)
    
    # Этап 2: Парсинг (awaitable корутина)
    parsed_data = await parse_content(data)
    
    # Этап 3: Сохранение (awaitable корутина)
    await save_to_database(parsed_data)
    
    return parsed_data

async def scrape_with_depth(start_url: str, max_depth: int = 2):
    """
    Скрейпинг с глубиной:
    - Загружает стартовую страницу
    - Извлекает ссылки
    - Загружает найденные страницы параллельно
    """
    print(f"🚀 Начинаем скрейпинг: {start_url} (глубина: {max_depth})\n")
    start_time = time.time()
    
    all_results = []
    
    # Уровень 0: Стартовая страница
    print(f"{'='*60}")
    print(f"📍 УРОВЕНЬ 0: Стартовая страница")
    print(f"{'='*60}\n")
    
    main_page = await scrape_page(start_url)
    all_results.append(main_page)
    
    if max_depth > 0:
        # Извлекаем ссылки
        print(f"\n{'='*60}")
        print(f"🔗 Извлечение ссылок")
        print(f"{'='*60}\n")
        
        links = await extract_links(start_url)
        
        # Уровень 1: Найденные страницы
        print(f"\n{'='*60}")
        print(f"📍 УРОВЕНЬ 1: Загрузка {len(links)} страниц параллельно")
        print(f"{'='*60}\n")
        
        # Создаём задачи для всех ссылок (awaitable tasks)
        tasks = [asyncio.create_task(scrape_page(link)) for link in links]
        
        # Ждём завершения всех задач параллельно (awaitable gather)
        level1_results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # Фильтруем успешные результаты
        for result in level1_results:
            if isinstance(result, Dict):
                all_results.append(result)
            else:
                print(f"❌ Ошибка: {result}")
    
    # Статистика
    elapsed = time.time() - start_time
    
    print(f"\n{'='*60}")
    print(f"📊 СТАТИСТИКА")
    print(f"{'='*60}")
    print(f"✅ Обработано страниц: {len(all_results)}")
    print(f"⏱️  Общее время: {elapsed:.2f}с")
    
    # Расчёт теоретического времени без asyncio
    total_load_time = sum(r['load_time'] for r in all_results)
    print(f"💡 Без asyncio заняло бы: {total_load_time:.2f}с")
    print(f"⚡ Ускорение: {total_load_time / elapsed:.2f}x")
    
    return all_results

async def main():
    """Главная функция"""
    # Запускаем скрейпер
    results = await scrape_with_depth("https://example.com", max_depth=1)
    
    # Дополнительная обработка результатов
    print(f"\n{'='*60}")
    print(f"📄 РЕЗУЛЬТАТЫ")
    print(f"{'='*60}\n")
    
    for i, result in enumerate(results, 1):
        print(f"{i}. {result['url']}")
        print(f"   📝 Заголовок: {result['title']}")
        print(f"   📏 Слов: {result['word_count']}")
        print(f"   ⏱️  Время загрузки: {result['load_time']:.2f}с\n")

# Запуск
if __name__ == "__main__":
    asyncio.run(main())

# Пример вывода:
# 🚀 Начинаем скрейпинг: https://example.com (глубина: 1)
# 
# ============================================================
# 📍 УРОВЕНЬ 0: Стартовая страница
# ============================================================
# 
# 🌐 Загружаем: https://example.com
# ✅ Загружено: https://example.com
# ⚙️  Парсим содержимое: https://example.com
# 💾 Сохраняем в БД: https://example.com
# ✅ Сохранено: https://example.com
# 
# ============================================================
# 🔗 Извлечение ссылок
# ============================================================
# 
# 🔍 Извлекаем ссылки из: https://example.com
# 📎 Найдено 3 ссылок на https://example.com
# 
# ============================================================
# 📍 УРОВЕНЬ 1: Загрузка 3 страниц параллельно
# ============================================================
# 
# 🌐 Загружаем: https://example.com/page1
# 🌐 Загружаем: https://example.com/page2
# 🌐 Загружаем: https://example.com/page3
# ✅ Загружено: https://example.com/page2
# ⚙️  Парсим содержимое: https://example.com/page2
# 💾 Сохраняем в БД: https://example.com/page2
# ✅ Сохранено: https://example.com/page2
# ✅ Загружено: https://example.com/page1
# ...
```

### Модуль asyncio:
- **Основной инструмент** для асинхронного программирования
- Предоставляет event loop, корутины, задачи, примитивы синхронизации
- Работает в одном потоке с кооперативной многозадачностью

### Запуск асинхронного кода:
- **`asyncio.run()`** — точка входа, запускает корутину
- **`asyncio.create_task()`** — создаёт задачу, выполняется в фоне
- **`asyncio.gather()`** — запускает несколько корутин параллельно

### Awaitable объекты:
- **Корутины** — `async def` функции
- **Tasks** — обёртки для корутин
- **Futures** — низкоуровневые объекты
- Только awaitable объекты можно использовать с `await`

**Главное правило:** Используй `create_task()` или `gather()` для параллельного выполнения. Просто `await` выполняет корутины последовательно!
















## `33.9` Task (задачи) — управление асинхронными операциями

**Task (задача)** — это обёртка для корутины, которая планирует её выполнение в event loop. Task позволяет управлять выполнением корутины: отслеживать статус, отменять, получать результаты и обрабатывать исключения.

### Что такое Task?

```python
import asyncio

async def my_coroutine():
    await asyncio.sleep(1)
    return "Результат"

# Корутина - это "рецепт"
coro = my_coroutine()
print(type(coro))  # <class 'coroutine'>

# Task - это "запущенная работа"
async def main():
    task = asyncio.create_task(my_coroutine())
    print(type(task))  # <class '_asyncio.Task'>
    result = await task
    return result

asyncio.run(main())
```

### Создание Task

```python
import asyncio
import time

async def delayed_greeting(name, delay):
    """Корутина с задержкой"""
    await asyncio.sleep(delay)
    return f"Привет, {name}!"

async def main():
    print("=== Создание Task ===\n")
    
    # Способ 1: asyncio.create_task() (рекомендуется)
    task1 = asyncio.create_task(delayed_greeting("Иван", 2))
    
    # Способ 2: asyncio.ensure_future() (старый способ)
    task2 = asyncio.ensure_future(delayed_greeting("Мария", 1))
    
    # Способ 3: loop.create_task() (низкоуровневый)
    loop = asyncio.get_event_loop()
    task3 = loop.create_task(delayed_greeting("Пётр", 1.5))
    
    # Задачи уже выполняются в фоне!
    print("Задачи созданы и выполняются...")
    
    # Ждём результаты
    result1 = await task1
    result2 = await task2
    result3 = await task3
    
    print(f"\n✅ {result1}")
    print(f"✅ {result2}")
    print(f"✅ {result3}")

asyncio.run(main())
```

### Методы и атрибуты Task

```python
import asyncio

async def long_task(duration):
    """Длительная задача"""
    print(f"⏳ Задача начата (длительность: {duration}с)")
    await asyncio.sleep(duration)
    print(f"✅ Задача завершена")
    return f"Результат за {duration}с"

async def main():
    print("=== Методы Task ===\n")
    
    task = asyncio.create_task(long_task(2))
    
    # 1. done() - проверка завершения
    print(f"1️⃣ task.done(): {task.done()}")  # False
    
    # 2. cancelled() - проверка отмены
    print(f"2️⃣ task.cancelled(): {task.cancelled()}")  # False
    
    # 3. get_name() / set_name() - имя задачи
    task.set_name("Моя важная задача")
    print(f"3️⃣ task.get_name(): {task.get_name()}")
    
    # 4. Ждём немного
    await asyncio.sleep(0.5)
    
    # 5. Проверяем статус снова
    print(f"\n⏱️ После 0.5с:")
    print(f"   task.done(): {task.done()}")  # Всё ещё False
    
    # 6. result() - получение результата (блокирующий если не готов)
    result = await task  # Ждём завершения
    
    print(f"\n✅ После завершения:")
    print(f"   task.done(): {task.done()}")  # True
    print(f"   task.result(): {task.result()}")  # Результат без await
    
    # 7. exception() - получение исключения (если было)
    print(f"   task.exception(): {task.exception()}")  # None (не было ошибки)

asyncio.run(main())
```

### Отмена задач

```python
import asyncio

async def cancellable_task(task_id):
    """Задача, которую можно отменить"""
    try:
        print(f"🔵 Задача {task_id} начата")
        
        for i in range(10):
            print(f"   Задача {task_id} работает: шаг {i+1}/10")
            await asyncio.sleep(0.5)
        
        print(f"✅ Задача {task_id} завершена")
        return f"Результат {task_id}"
        
    except asyncio.CancelledError:
        print(f"❌ Задача {task_id} была отменена!")
        # Можно выполнить очистку ресурсов
        raise  # Важно: пробросить исключение дальше

async def main():
    print("=== Отмена задач ===\n")
    
    # Создаём несколько задач
    task1 = asyncio.create_task(cancellable_task(1))
    task2 = asyncio.create_task(cancellable_task(2))
    task3 = asyncio.create_task(cancellable_task(3))
    
    # Даём задачам поработать
    await asyncio.sleep(2)
    
    # Отменяем задачу 2
    print("\n🛑 Отменяем задачу 2...")
    task2.cancel()
    
    # Даём остальным задачам доработать
    await asyncio.sleep(1)
    
    # Отменяем задачу 3
    print("\n🛑 Отменяем задачу 3...")
    task3.cancel()
    
    # Собираем результаты
    results = await asyncio.gather(task1, task2, task3, return_exceptions=True)
    
    print("\n📊 Результаты:")
    for i, result in enumerate(results, 1):
        if isinstance(result, asyncio.CancelledError):
            print(f"   Задача {i}: Отменена")
        elif isinstance(result, Exception):
            print(f"   Задача {i}: Ошибка - {result}")
        else:
            print(f"   Задача {i}: {result}")

asyncio.run(main())
```

### Таймаут для задач

```python
import asyncio

async def slow_operation(duration):
    """Медленная операция"""
    print(f"⏳ Начинаем операцию ({duration}с)")
    await asyncio.sleep(duration)
    print(f"✅ Операция завершена")
    return f"Результат за {duration}с"

async def main():
    print("=== Таймаут для задач ===\n")
    
    # Способ 1: asyncio.wait_for()
    print("1️⃣ Используем wait_for (таймаут 2с)")
    try:
        result = await asyncio.wait_for(
            slow_operation(3),  # Операция займёт 3 секунды
            timeout=2  # Но мы ждём только 2
        )
        print(f"✅ Результат: {result}")
    except asyncio.TimeoutError:
        print(f"⏱️ Таймаут! Операция не завершилась за 2с\n")
    
    # Способ 2: Ручная отмена через Task
    print("2️⃣ Ручная отмена через Task")
    task = asyncio.create_task(slow_operation(3))
    
    try:
        await asyncio.wait_for(task, timeout=2)
    except asyncio.TimeoutError:
        print(f"⏱️ Таймаут! Отменяем задачу...")
        task.cancel()
        try:
            await task
        except asyncio.CancelledError:
            print(f"❌ Задача отменена")

asyncio.run(main())
```

### Практический пример: Task Manager

```python
import asyncio
import time
from enum import Enum
from typing import List, Dict

class TaskStatus(Enum):
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"

class TaskInfo:
    """Информация о задаче"""
    
    def __init__(self, task_id: int, name: str, task: asyncio.Task):
        self.task_id = task_id
        self.name = name
        self.task = task
        self.start_time = time.time()
        self.end_time = None
        self.status = TaskStatus.RUNNING
        self.result = None
        self.error = None
    
    def duration(self):
        """Длительность выполнения"""
        if self.end_time:
            return self.end_time - self.start_time
        return time.time() - self.start_time
    
    def __repr__(self):
        return f"TaskInfo(id={self.task_id}, name='{self.name}', status={self.status.value})"

class TaskManager:
    """Менеджер асинхронных задач"""
    
    def __init__(self):
        self.tasks: Dict[int, TaskInfo] = {}
        self.next_id = 1
    
    def add_task(self, coro, name: str = None) -> int:
        """Добавить новую задачу"""
        task_id = self.next_id
        self.next_id += 1
        
        if name is None:
            name = f"Task-{task_id}"
        
        task = asyncio.create_task(coro)
        task_info = TaskInfo(task_id, name, task)
        self.tasks[task_id] = task_info
        
        print(f"➕ Создана задача #{task_id}: {name}")
        return task_id
    
    async def wait_for_task(self, task_id: int, timeout: float = None):
        """Ждать завершения конкретной задачи"""
        if task_id not in self.tasks:
            raise ValueError(f"Задача #{task_id} не найдена")
        
        task_info = self.tasks[task_id]
        
        try:
            if timeout:
                result = await asyncio.wait_for(task_info.task, timeout=timeout)
            else:
                result = await task_info.task
            
            task_info.status = TaskStatus.COMPLETED
            task_info.result = result
            task_info.end_time = time.time()
            
            print(f"✅ Задача #{task_id} завершена: {result}")
            return result
            
        except asyncio.TimeoutError:
            print(f"⏱️ Задача #{task_id} превысила таймаут")
            task_info.task.cancel()
            task_info.status = TaskStatus.CANCELLED
            raise
            
        except asyncio.CancelledError:
            print(f"❌ Задача #{task_id} отменена")
            task_info.status = TaskStatus.CANCELLED
            task_info.end_time = time.time()
            raise
            
        except Exception as e:
            print(f"💥 Задача #{task_id} завершилась с ошибкой: {e}")
            task_info.status = TaskStatus.FAILED
            task_info.error = e
            task_info.end_time = time.time()
            raise
    
    async def wait_all(self, timeout: float = None):
        """Ждать завершения всех задач"""
        if not self.tasks:
            return []
        
        print(f"\n⏳ Ожидаем завершения {len(self.tasks)} задач...")
        
        task_objects = [info.task for info in self.tasks.values()]
        
        try:
            if timeout:
                results = await asyncio.wait_for(
                    asyncio.gather(*task_objects, return_exceptions=True),
                    timeout=timeout
                )
            else:
                results = await asyncio.gather(*task_objects, return_exceptions=True)
            
            # Обновляем статусы
            for task_info, result in zip(self.tasks.values(), results):
                task_info.end_time = time.time()
                if isinstance(result, asyncio.CancelledError):
                    task_info.status = TaskStatus.CANCELLED
                elif isinstance(result, Exception):
                    task_info.status = TaskStatus.FAILED
                    task_info.error = result
                else:
                    task_info.status = TaskStatus.COMPLETED
                    task_info.result = result
            
            return results
            
        except asyncio.TimeoutError:
            print(f"⏱️ Таймаут ожидания всех задач")
            self.cancel_all()
            raise
    
    def cancel_task(self, task_id: int):
        """Отменить конкретную задачу"""
        if task_id not in self.tasks:
            raise ValueError(f"Задача #{task_id} не найдена")
        
        task_info = self.tasks[task_id]
        if not task_info.task.done():
            task_info.task.cancel()
            print(f"🛑 Задача #{task_id} отменена")
    
    def cancel_all(self):
        """Отменить все активные задачи"""
        cancelled = 0
        for task_info in self.tasks.values():
            if not task_info.task.done():
                task_info.task.cancel()
                cancelled += 1
        
        print(f"🛑 Отменено задач: {cancelled}")
    
    def get_status(self, task_id: int) -> TaskStatus:
        """Получить статус задачи"""
        if task_id not in self.tasks:
            raise ValueError(f"Задача #{task_id} не найдена")
        return self.tasks[task_id].status
    
    def print_summary(self):
        """Вывести сводку по всем задачам"""
        print(f"\n{'='*70}")
        print(f"📊 СВОДКА ПО ЗАДАЧАМ")
        print(f"{'='*70}")
        
        for task_info in self.tasks.values():
            status_emoji = {
                TaskStatus.RUNNING: "⏳",
                TaskStatus.COMPLETED: "✅",
                TaskStatus.FAILED: "💥",
                TaskStatus.CANCELLED: "❌",
                TaskStatus.PENDING: "⏸️"
            }
            
            emoji = status_emoji[task_info.status]
            duration = task_info.duration()
            
            print(f"\n{emoji} Задача #{task_info.task_id}: {task_info.name}")
            print(f"   Статус: {task_info.status.value}")
            print(f"   Длительность: {duration:.2f}с")
            
            if task_info.result:
                print(f"   Результат: {task_info.result}")
            if task_info.error:
                print(f"   Ошибка: {task_info.error}")

# Тестовые корутины
async def download_file(file_id, duration):
    """Имитация загрузки файла"""
    print(f"  📥 Загружаем файл {file_id}...")
    await asyncio.sleep(duration)
    return f"file_{file_id}.dat"

async def process_data(data_id, duration):
    """Имитация обработки данных"""
    print(f"  ⚙️ Обрабатываем данные {data_id}...")
    await asyncio.sleep(duration)
    if data_id == 3:
        raise ValueError(f"Ошибка обработки данных {data_id}")
    return f"processed_{data_id}"

async def send_notification(user_id, duration):
    """Имитация отправки уведомления"""
    print(f"  📧 Отправляем уведомление пользователю {user_id}...")
    await asyncio.sleep(duration)
    return f"notification_sent_to_{user_id}"

# Использование TaskManager
async def main():
    print("=== Task Manager Demo ===\n")
    
    manager = TaskManager()
    
    # Добавляем задачи
    task1 = manager.add_task(download_file(1, 2), "Загрузка файла 1")
    task2 = manager.add_task(download_file(2, 1.5), "Загрузка файла 2")
    task3 = manager.add_task(process_data(3, 3), "Обработка данных 3")  # Упадёт с ошибкой
    task4 = manager.add_task(send_notification(101, 1), "Уведомление 101")
    task5 = manager.add_task(send_notification(102, 4), "Уведомление 102")  # Долгая
    
    # Даём задачам поработать
    await asyncio.sleep(1)
    
    # Отменяем одну задачу
    print(f"\n🛑 Отменяем задачу #{task5}...")
    manager.cancel_task(task5)
    
    # Ждём завершения всех задач
    try:
        await manager.wait_all(timeout=5)
    except asyncio.TimeoutError:
        print("\n⏱️ Некоторые задачи не завершились вовремя")
    
    # Выводим сводку
    manager.print_summary()

asyncio.run(main())
```

## `33.10` `asyncio.sleep()` — асинхронная пауза
**`asyncio.sleep()`** — это асинхронная версия `time.sleep()`. Ключевое отличие: она **НЕ блокирует** event loop, позволяя другим задачам выполняться во время паузы.

### Разница между time.sleep() и asyncio.sleep()

```python
import asyncio
import time

# ❌ БЛОКИРУЮЩАЯ пауза (time.sleep)
async def bad_pause():
    print("⚠️ Начало блокирующей паузы")
    time.sleep(2)  # Блокирует весь event loop!
    print("⚠️ Конец блокирующей паузы")

# ✅ НЕБЛОКИРУЮЩАЯ пауза (asyncio.sleep)
async def good_pause():
    print("✅ Начало неблокирующей паузы")
    await asyncio.sleep(2)  # НЕ блокирует event loop
    print("✅ Конец неблокирующей паузы")

async def other_task():
    for i in range(5):
        print(f"  🔵 Другая задача работает: {i+1}")
        await asyncio.sleep(0.5)

# Тест с time.sleep
async def test_blocking():
    print("=== Тест с time.sleep (БЛОКИРУЮЩИЙ) ===\n")
    start = time.time()
    
    await asyncio.gather(
        bad_pause(),
        other_task()
    )
    
    print(f"⏱️ Время: {time.time() - start:.2f}с\n")

# Тест с asyncio.sleep
async def test_non_blocking():
    print("=== Тест с asyncio.sleep (НЕБЛОКИРУЮЩИЙ) ===\n")
    start = time.time()
    
    await asyncio.gather(
        good_pause(),
        other_task()
    )
    
    print(f"⏱️ Время: {time.time() - start:.2f}с")

asyncio.run(test_blocking())
# Вывод: other_task начнёт работать только после завершения bad_pause

asyncio.run(test_non_blocking())
# Вывод: обе задачи работают параллельно
```

### Использование asyncio.sleep()

```python
import asyncio
import time

async def countdown(name, seconds):
    """Обратный отсчёт"""
    print(f"⏰ {name}: начинаем отсчёт с {seconds}")
    
    for i in range(seconds, 0, -1):
        print(f"   {name}: {i}...")
        await asyncio.sleep(1)  # Пауза 1 секунда
    
    print(f"🎉 {name}: время вышло!")
    return f"{name} завершён"

async def main():
    print("=== Параллельные таймеры ===\n")
    start = time.time()
    
    # Три таймера работают параллельно
    results = await asyncio.gather(
        countdown("Таймер-A", 3),
        countdown("Таймер-B", 5),
        countdown("Таймер-C", 2)
    )
    
    print(f"\n⏱️ Общее время: {time.time() - start:.2f}с")
    print(f"📊 Результаты: {results}")

asyncio.run(main())

# Вывод покажет, что все таймеры работают одновременно:
# ⏰ Таймер-A: начинаем отсчёт с 3
#    Таймер-A: 3...
# ⏰ Таймер-B: начинаем отсчёт с 5
#    Таймер-B: 5...
# ⏰ Таймер-C: начинаем отсчёт с 2
#    Таймер-C: 2...
# ...
```

## `33.11` Async context managers — `async with`
**Async context manager** — это контекстный менеджер для асинхронного кода. Он использует `async with` вместо обычного `with` и поддерживает методы `__aenter__()` и `__aexit__()`.

### Создание async context manager

```python
import asyncio

class AsyncResource:
    """Асинхронный контекстный менеджер"""
    
    def __init__(self, name):
        self.name = name
        self.is_open = False
    
    async def __aenter__(self):
        """Вызывается при входе в блок async with"""
        print(f"🔓 Открываем ресурс: {self.name}")
        await asyncio.sleep(0.5)  # Асинхронная инициализация
        self.is_open = True
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Вызывается при выходе из блока async with"""
        print(f"🔒 Закрываем ресурс: {self.name}")
        await asyncio.sleep(0.3)  # Асинхронная очистка
        self.is_open = False
        return False  # Не подавляем исключения
    
    async def use(self):
        """Использование ресурса"""
        if not self.is_open:
            raise RuntimeError("Ресурс не открыт!")
        print(f"⚙️ Используем ресурс: {self.name}")
        await asyncio.sleep(0.2)

async def main():
    print("=== Async Context Manager ===\n")
    
    # Используем async with
    async with AsyncResource("Database Connection") as resource:
        await resource.use()
        await resource.use()
    
    # Ресурс автоматически закрыт

asyncio.run(main())

# Вывод:
# 🔓 Открываем ресурс: Database Connection
# ⚙️ Используем ресурс: Database Connection
# ⚙️ Используем ресурс: Database Connection
# 🔒 Закрываем ресурс: Database Connection
```

### Создание через @asynccontextmanager

```python
import asyncio
from contextlib import asynccontextmanager

@asynccontextmanager
async def database_connection(db_name):
    """Упрощённое создание async context manager"""
    
    # Код до yield = __aenter__
    print(f"🔌 Подключение к БД: {db_name}")
    await asyncio.sleep(0.5)
    
    connection = {"db": db_name, "connected": True}
    
    try:
        yield connection  # Возвращаем ресурс
    finally:
        # Код после yield = __aexit__
        print(f"🔌 Отключение от БД: {db_name}")
        await asyncio.sleep(0.3)
        connection["connected"] = False

async def main():
    print("=== @asynccontextmanager Demo ===\n")
    
    async with database_connection("users_db") as conn:
        print(f"✅ Подключено: {conn}")
        await asyncio.sleep(1)
        print(f"⚙️ Выполняем запросы...")
    
    print(f"✅ Соединение закрыто")

asyncio.run(main())
```

### Практический пример: Async Database Pool

```python
import asyncio
from contextlib import asynccontextmanager
from typing import List
import random

class DatabaseConnection:
    """Имитация подключения к БД"""
    
    _id_counter = 1
    
    def __init__(self):
        self.conn_id = DatabaseConnection._id_counter
        DatabaseConnection._id_counter += 1
        self.in_use = False
    
    async def connect(self):
        """Подключение к БД"""
        print(f"  🔌 Подключение #{self.conn_id} открывается...")
        await asyncio.sleep(0.3)
        print(f"  ✅ Подключение #{self.conn_id} готово")
    
    async def disconnect(self):
        """Отключение от БД"""
        print(f"  🔒 Подключение #{self.conn_id} закрывается...")
        await asyncio.sleep(0.2)
    
    async def execute_query(self, query: str):
        """Выполнение запроса"""
        await asyncio.sleep(random.uniform(0.1, 0.5))
        return f"Результат '{query}' от подключения #{self.conn_id}"

class AsyncDatabasePool:
    """Пул асинхронных подключений к БД"""
    
    def __init__(self, pool_size: int = 3):
        self.pool_size = pool_size
        self.connections: List[DatabaseConnection] = []
        self.available = asyncio.Queue()
        self.lock = asyncio.Lock()
        self._initialized = False
    
    async def initialize(self):
        """Инициализация пула"""
        if self._initialized:
            return
        
        print(f"🚀 Инициализация пула подключений (размер: {self.pool_size})\n")
        
        for _ in range(self.pool_size):
            conn = DatabaseConnection()
            await conn.connect()
            self.connections.append(conn)
            await self.available.put(conn)
        
        self._initialized = True
        print(f"\n✅ Пул инициализирован: {self.pool_size} подключений\n")
    
    async def close(self):
        """Закрытие всех подключений"""
        print(f"\n🔒 Закрытие пула...")
        
        for conn in self.connections:
            await conn.disconnect()
        
        self.connections.clear()
        self._initialized = False
        print(f"✅ Пул закрыт")
    
    @asynccontextmanager
    async def acquire(self):
        """Получить подключение из пула"""
        if not self._initialized:
            await self.initialize()
        
        # Ждём доступного подключения
        conn = await self.available.get()
        conn.in_use = True
        
        print(f"  📤 Выдано подключение #{conn.conn_id}")
        
        try:
            yield conn  # Возвращаем подключение
        finally:
            # Возвращаем подключение в пул
            conn.in_use = False
            await self.available.put(conn)
            print(f"  📥 Возвращено подключение #{conn.conn_id}")
    
    def get_stats(self):
        """Статистика пула"""
        in_use = sum(1 for conn in self.connections if conn.in_use)
        available = self.available.qsize()
        return {
            "total": len(self.connections),
            "in_use": in_use,
            "available": available
        }

async def worker(worker_id: int, pool: AsyncDatabasePool, queries: List[str]):
    """Воркер, выполняющий запросы к БД"""
    print(f"\n👤 Воркер-{worker_id} начал работу")
    
    for query in queries:
        # Получаем подключение из пула
        async with pool.acquire() as conn:
            print(f"  👤 Воркер-{worker_id}: выполняет запрос '{query}'")
            result = await conn.execute_query(query)
            print(f"  ✅ Воркер-{worker_id}: {result}")
        
        # Небольшая пауза между запросами
        await asyncio.sleep(0.1)
    
    print(f"👤 Воркер-{worker_id} завершил работу")

async def main():
    print("=== Async Database Pool Demo ===\n")
    
    # Создаём пул на 3 подключения
    pool = AsyncDatabasePool(pool_size=3)
    
    # Создаём воркеров с запросами
    workers = [
        worker(1, pool, ["SELECT * FROM users", "UPDATE users SET name='Alice'"]),
        worker(2, pool, ["SELECT * FROM posts", "DELETE FROM posts WHERE id=5"]),
        worker(3, pool, ["INSERT INTO logs", "SELECT * FROM logs"]),
        worker(4, pool, ["SELECT COUNT(*) FROM users"]),
    ]
    
    # Запускаем всех воркеров параллельно
    await asyncio.gather(*workers)
    
    # Статистика
    print(f"\n📊 Статистика пула:")
    stats = pool.get_stats()
    print(f"   Всего подключений: {stats['total']}")
    print(f"   Используется: {stats['in_use']}")
    print(f"   Доступно: {stats['available']}")
    
    # Закрываем пул
    await pool.close()

asyncio.run(main())

# Вывод покажет, как воркеры конкурируют за подключения:
# 🚀 Инициализация пула подключений (размер: 3)
#   🔌 Подключение #1 открывается...
#   ✅ Подключение #1 готово
#   🔌 Подключение #2 открывается...
#   ✅ Подключение #2 готово
#   🔌 Подключение #3 открывается...
#   ✅ Подключение #3 готово
# ✅ Пул инициализирован: 3 подключений
# 
# 👤 Воркер-1 начал работу
#   📤 Выдано подключение #1
#   👤 Воркер-1: выполняет запрос 'SELECT * FROM users'
# 👤 Воркер-2 начал работу
#   📤 Выдано подключение #2
# ...
```

## `33.12` Async iterators и async generators — `async for`
**Async iterator** — это объект, который можно перебирать асинхронно с помощью `async for`. **Async generator** — это простой способ создания async итератора.

### Async Iterator через классы

```python
import asyncio

class AsyncRange:
    """Асинхронный range"""
    
    def __init__(self, start, stop):
        self.current = start
        self.stop = stop
    
    def __aiter__(self):
        """Возвращает сам себя как async итератор"""
        return self
    
    async def __anext__(self):
        """Возвращает следующий элемент"""
        if self.current >= self.stop:
            raise StopAsyncIteration
        
        await asyncio.sleep(0.5)  # Асинхронная задержка
        value = self.current
        self.current += 1
        return value

async def main():
    print("=== Async Iterator ===\n")
    
    # Используем async for
    async for num in AsyncRange(1, 5):
        print(f"🔢 Получено число: {num}")

asyncio.run(main())

# Вывод (с паузами 0.5с):
# 🔢 Получено число: 1
# 🔢 Получено число: 2
# 🔢 Получено число: 3
# 🔢 Получено число: 4
```

### Async Generator (упрощённый способ)

```python
import asyncio

async def async_countdown(n):
    """Асинхронный генератор обратного отсчёта"""
    print(f"⏰ Начинаем отсчёт с {n}")
    
    for i in range(n, 0, -1):
        await asyncio.sleep(1)  # Асинхронная пауза
        yield i  # Возвращаем значение
    
    print("🎉 Отсчёт завершён!")

async def main():
    print("=== Async Generator ===\n")
    
    # Используем async for с генератором
    async for count in async_countdown(5):
        print(f"   ⏱️ {count}...")

asyncio.run(main())

# Вывод:
# ⏰ Начинаем отсчёт с 5
#    ⏱️ 5...
#    ⏱️ 4...
#    ⏱️ 3...
#    ⏱️ 2...
#    ⏱️ 1...
# 🎉 Отсчёт завершён!
```

### Сравнение sync и async генераторов

```python
import asyncio
import time

# Обычный (синхронный) генератор
def sync_generator():
    for i in range(1, 4):
        time.sleep(1)  # Блокирующая пауза
        yield i

# Асинхронный генератор
async def async_generator():
    for i in range(1, 4):
        await asyncio.sleep(1)  # НЕблокирующая пауза
        yield i

# Тест синхронного генератора
def test_sync():
    print("=== Синхронный генератор ===")
    start = time.time()
    
    for value in sync_generator():
        print(f"  Значение: {value}")
    
    print(f"⏱️ Время: {time.time() - start:.2f}с\n")

# Тест асинхронного генератора
async def test_async():
    print("=== Асинхронный генератор ===")
    start = time.time()
    
    async for value in async_generator():
        print(f"  Значение: {value}")
    
    print(f"⏱️ Время: {time.time() - start:.2f}с")

test_sync()
asyncio.run(test_async())
```

### Практический пример: Async Data Stream

```python
import asyncio
import random
from datetime import datetime
from typing import AsyncIterator, Dict

class SensorDataStream:
    """Асинхронный поток данных с сенсора"""
    
    def __init__(self, sensor_id: str, interval: float = 1.0):
        self.sensor_id = sensor_id
        self.interval = interval
        self.reading_count = 0
    
    async def __aiter__(self) -> AsyncIterator[Dict]:
        """Возвращает async iterator"""
        return self
    
    async def __anext__(self) -> Dict:
        """Получить следующее показание"""
        # Имитация задержки между показаниями
        await asyncio.sleep(self.interval)
        
        self.reading_count += 1
        
        # Генерируем случайные данные
        reading = {
            "sensor_id": self.sensor_id,
            "timestamp": datetime.now().isoformat(),
            "temperature": round(20 + random.uniform(-5, 15), 2),
            "humidity": round(random.uniform(30, 80), 2),
            "reading_num": self.reading_count
        }
        
        return reading

async def monitor_sensor(sensor_id: str, duration: int):
    """Мониторинг сенсора в течение заданного времени"""
    print(f"📡 Начинаем мониторинг сенсора {sensor_id}")
    
    stream = SensorDataStream(sensor_id, interval=0.5)
    readings = []
    
    # Читаем данные из потока
    async for reading in stream:
        temp = reading['temperature']
        humidity = reading['humidity']
        num = reading['reading_num']
        
        print(f"  🌡️ {sensor_id} #{num}: {temp}°C, {humidity}% влажности")
        readings.append(reading)
        
        # Проверка аномалий
        if temp > 30:
            print(f"    ⚠️ Высокая температура!")
        
        # Останавливаемся после определённого количества
        if num >= duration:
            break
    
    # Статистика
    avg_temp = sum(r['temperature'] for r in readings) / len(readings)
    avg_humidity = sum(r['humidity'] for r in readings) / len(readings)
    
    print(f"\n📊 Статистика {sensor_id}:")
    print(f"   Показаний: {len(readings)}")
    print(f"   Средняя температура: {avg_temp:.2f}°C")
    print(f"   Средняя влажность: {avg_humidity:.2f}%\n")
    
    return readings

async def main():
    print("=== Мониторинг сенсоров ===\n")
    
    # Мониторим несколько сенсоров параллельно
    results = await asyncio.gather(
        monitor_sensor("SENSOR-A", duration=5),
        monitor_sensor("SENSOR-B", duration=5),
        monitor_sensor("SENSOR-C", duration=5)
    )
    
    total_readings = sum(len(r) for r in results)
    print(f"✅ Всего получено показаний: {total_readings}")

asyncio.run(main())
```

### Async Generator с методами

```python
import asyncio
from typing import AsyncIterator

class AsyncFileReader:
    """Асинхронное чтение файла построчно"""
    
    def __init__(self, filename: str, chunk_size: int = 1024):
        self.filename = filename
        self.chunk_size = chunk_size
    
    async def read_lines(self) -> AsyncIterator[str]:
        """Асинхронный генератор строк"""
        print(f"📖 Открываем файл: {self.filename}")
        
        # Имитация чтения файла
        lines = [
            "Первая строка файла",
            "Вторая строка с данными",
            "Третья строка информации",
            "Четвёртая строка текста",
            "Последняя строка"
        ]
        
        for i, line in enumerate(lines, 1):
            await asyncio.sleep(0.3)  # Имитация I/O задержки
            print(f"  📄 Прочитана строка {i}/{len(lines)}")
            yield line
        
        print(f"✅ Файл прочитан полностью")
    
    async def read_with_filter(self, keyword: str) -> AsyncIterator[str]:
        """Читает только строки, содержащие ключевое слово"""
        print(f"🔍 Ищем строки с '{keyword}'")
        
        async for line in self.read_lines():
            if keyword.lower() in line.lower():
                yield line

async def process_file():
    """Обработка файла"""
    print("=== Async File Reader ===\n")
    
    reader = AsyncFileReader("data.txt")
    
    # Способ 1: Читаем все строки
    print("1️⃣ Чтение всех строк:\n")
    async for line in reader.read_lines():
        print(f"   > {line}")
    
    print("\n" + "="*50 + "\n")
    
    # Способ 2: Читаем с фильтром
    print("2️⃣ Чтение с фильтром:\n")
    async for line in reader.read_with_filter("строка"):
        print(f"   ✓ Найдено: {line}")

asyncio.run(process_file())
```

#### Task (задачи):
- **Обёртка для корутины** в event loop
- Создаются через `asyncio.create_task()`
- Позволяют управлять выполнением: отменять, проверять статус, получать результаты
- Методы: `done()`, `cancel()`, `result()`, `exception()`

#### asyncio.sleep():
- **Асинхронная пауза** — НЕ блокирует event loop
- Использовать вместо `time.sleep()` в async коде
- Позволяет другим задачам выполняться во время ожидания
- Критично для корректной работы асинхронного кода

#### Async context managers:
- Используют `async with` вместо `with`
- Методы: `__aenter__()` и `__aexit__()`
- Упрощённое создание: `@asynccontextmanager`
- Идеальны для управления асинхронными ресурсами (БД, файлы, сетевые соединения)

#### Async iterators и generators:
- **Async iterator**: класс с `__aiter__()` и `__anext__()`
- **Async generator**: функция с `async def` и `yield`
- Используются с `async for`
- Отлично подходят для потоковых данных, пагинации, мониторинга

**Главное правило:** Всегда используй асинхронные версии (`await asyncio.sleep`, `async with`, `async for`) вместо синхронных в async коде!
















## `33.13` Работа с асинхронными очередями — `asyncio.Queue`
**`asyncio.Queue`** — это асинхронная очередь для безопасной передачи данных между корутинами. Она похожа на `queue.Queue` из многопоточного программирования, но работает асинхронно.

### Основы asyncio.Queue

```python
import asyncio

async def producer(queue, producer_id, items_count):
    """Производитель добавляет элементы в очередь"""
    for i in range(items_count):
        item = f"Item-{producer_id}-{i+1}"
        await queue.put(item)  # Асинхронная отправка
        print(f"➕ Производитель-{producer_id} добавил: {item}")
        await asyncio.sleep(0.5)  # Имитация работы
    
    print(f"✅ Производитель-{producer_id} завершил работу")

async def consumer(queue, consumer_id):
    """Потребитель обрабатывает элементы из очереди"""
    while True:
        # Ждём элемент из очереди (блокируется если пусто)
        item = await queue.get()
        
        # Специальный маркер завершения
        if item is None:
            print(f"🛑 Потребитель-{consumer_id} получил сигнал завершения")
            break
        
        print(f"⚙️  Потребитель-{consumer_id} обрабатывает: {item}")
        await asyncio.sleep(0.7)  # Имитация обработки
        
        queue.task_done()  # Сообщаем, что элемент обработан
    
    print(f"✅ Потребитель-{consumer_id} завершил работу")

async def main():
    print("=== asyncio.Queue Demo ===\n")
    
    # Создаём очередь
    queue = asyncio.Queue()
    
    # Запускаем производителей
    producers = [
        asyncio.create_task(producer(queue, 1, 3)),
        asyncio.create_task(producer(queue, 2, 3))
    ]
    
    # Запускаем потребителей
    consumers = [
        asyncio.create_task(consumer(queue, 1)),
        asyncio.create_task(consumer(queue, 2))
    ]
    
    # Ждём завершения производителей
    await asyncio.gather(*producers)
    
    # Ждём обработки всех элементов
    await queue.join()
    
    # Отправляем сигналы завершения потребителям
    for _ in consumers:
        await queue.put(None)
    
    # Ждём завершения потребителей
    await asyncio.gather(*consumers)
    
    print("\n🎉 Все задачи выполнены!")

asyncio.run(main())

# Вывод покажет параллельную работу производителей и потребителей:
# ➕ Производитель-1 добавил: Item-1-1
# ➕ Производитель-2 добавил: Item-2-1
# ⚙️  Потребитель-1 обрабатывает: Item-1-1
# ⚙️  Потребитель-2 обрабатывает: Item-2-1
# ...
```

### Методы asyncio.Queue

```python
import asyncio

async def queue_methods_demo():
    print("=== Методы asyncio.Queue ===\n")
    
    # Создание очереди с ограничением размера
    queue = asyncio.Queue(maxsize=3)
    
    # 1. put() - добавить элемент
    print("1️⃣ Добавление элементов:")
    await queue.put("A")
    await queue.put("B")
    await queue.put("C")
    print(f"   Добавлено: A, B, C")
    
    # 2. full() - проверка заполненности
    print(f"\n2️⃣ queue.full(): {queue.full()}")  # True
    
    # 3. qsize() - размер очереди
    print(f"3️⃣ queue.qsize(): {queue.qsize()}")  # 3
    
    # 4. get() - извлечь элемент
    print(f"\n4️⃣ Извлечение элементов:")
    item1 = await queue.get()
    print(f"   Извлечено: {item1}")
    
    # 5. empty() - проверка пустоты
    print(f"\n5️⃣ queue.empty(): {queue.empty()}")  # False
    
    # 6. get_nowait() - извлечь без ожидания
    print(f"\n6️⃣ get_nowait():")
    try:
        item2 = queue.get_nowait()
        print(f"   Извлечено: {item2}")
    except asyncio.QueueEmpty:
        print(f"   Очередь пуста!")
    
    # 7. put_nowait() - добавить без ожидания
    print(f"\n7️⃣ put_nowait():")
    try:
        queue.put_nowait("D")
        print(f"   Добавлено: D")
    except asyncio.QueueFull:
        print(f"   Очередь заполнена!")
    
    # 8. task_done() и join()
    print(f"\n8️⃣ task_done() и join():")
    
    # Извлекаем оставшиеся элементы
    while not queue.empty():
        item = await queue.get()
        print(f"   Обрабатываем: {item}")
        queue.task_done()
    
    # Ждём завершения всех задач
    await queue.join()
    print(f"   ✅ Все элементы обработаны")

asyncio.run(queue_methods_demo())
```

### Типы очередей в asyncio

```python
import asyncio

async def test_queues():
    print("=== Типы очередей ===\n")
    
    # 1. FIFO Queue (стандартная)
    print("1️⃣ FIFO Queue (First In, First Out):")
    fifo = asyncio.Queue()
    for item in ["A", "B", "C"]:
        await fifo.put(item)
    
    print("   Добавлено: A, B, C")
    print("   Извлечение:", end=" ")
    while not fifo.empty():
        print(await fifo.get(), end=" ")
    print(" (первым вошёл - первым вышел)\n")
    
    # 2. LIFO Queue (стек)
    print("2️⃣ LIFO Queue (Last In, First Out):")
    lifo = asyncio.LifoQueue()
    for item in ["A", "B", "C"]:
        await lifo.put(item)
    
    print("   Добавлено: A, B, C")
    print("   Извлечение:", end=" ")
    while not lifo.empty():
        print(await lifo.get(), end=" ")
    print(" (последним вошёл - первым вышел)\n")
    
    # 3. Priority Queue (с приоритетами)
    print("3️⃣ Priority Queue (по приоритету):")
    pq = asyncio.PriorityQueue()
    
    # Добавляем (приоритет, значение)
    await pq.put((3, "Низкий приоритет"))
    await pq.put((1, "Высокий приоритет"))
    await pq.put((2, "Средний приоритет"))
    
    print("   Добавлено: (3, Низкий), (1, Высокий), (2, Средний)")
    print("   Извлечение:")
    while not pq.empty():
        priority, item = await pq.get()
        print(f"     Приоритет {priority}: {item}")

asyncio.run(test_queues())
```

### Практический пример: Асинхронный Web Scraper с очередью

```python
import asyncio
import random
from typing import Dict, List
from datetime import datetime

class WebPage:
    """Представление веб-страницы"""
    
    def __init__(self, url: str, depth: int = 0):
        self.url = url
        self.depth = depth
        self.content = None
        self.links = []
        self.fetch_time = None

class AsyncWebScraper:
    """Асинхронный веб-скрейпер с очередью задач"""
    
    def __init__(self, max_workers: int = 3, max_depth: int = 2):
        self.url_queue = asyncio.Queue()
        self.result_queue = asyncio.Queue()
        self.max_workers = max_workers
        self.max_depth = max_depth
        self.visited = set()
        self.lock = asyncio.Lock()
        self.stats = {
            "fetched": 0,
            "skipped": 0,
            "errors": 0
        }
    
    async def fetch_page(self, page: WebPage) -> WebPage:
        """Загрузить страницу"""
        print(f"  🌐 Загружаем: {page.url} (глубина: {page.depth})")
        
        # Имитация HTTP запроса
        await asyncio.sleep(random.uniform(0.3, 1.0))
        
        # Имитация содержимого
        page.content = f"Контент страницы {page.url}"
        page.fetch_time = datetime.now()
        
        # Генерируем ссылки только если не достигли максимальной глубины
        if page.depth < self.max_depth:
            # Извлекаем "ссылки" (имитация)
            page.links = [
                f"{page.url}/link{i}" 
                for i in range(random.randint(1, 3))
            ]
        
        print(f"  ✅ Загружено: {page.url} (найдено {len(page.links)} ссылок)")
        return page
    
    async def worker(self, worker_id: int):
        """Рабочий поток для обработки страниц"""
        print(f"🔧 Воркер-{worker_id} запущен")
        
        while True:
            try:
                # Получаем страницу из очереди с таймаутом
                page = await asyncio.wait_for(
                    self.url_queue.get(),
                    timeout=2.0
                )
                
                # Специальный маркер завершения
                if page is None:
                    print(f"🛑 Воркер-{worker_id} получил сигнал завершения")
                    break
                
                # Проверяем, не посещали ли мы этот URL
                async with self.lock:
                    if page.url in self.visited:
                        self.stats["skipped"] += 1
                        self.url_queue.task_done()
                        continue
                    self.visited.add(page.url)
                
                # Загружаем страницу
                try:
                    result = await self.fetch_page(page)
                    
                    # Добавляем найденные ссылки в очередь
                    for link in result.links:
                        new_page = WebPage(link, depth=page.depth + 1)
                        await self.url_queue.put(new_page)
                    
                    # Сохраняем результат
                    await self.result_queue.put(result)
                    
                    async with self.lock:
                        self.stats["fetched"] += 1
                
                except Exception as e:
                    print(f"  ❌ Ошибка при загрузке {page.url}: {e}")
                    async with self.lock:
                        self.stats["errors"] += 1
                
                self.url_queue.task_done()
            
            except asyncio.TimeoutError:
                # Таймаут - возможно, очередь пуста
                print(f"⏱️ Воркер-{worker_id}: таймаут ожидания")
                break
        
        print(f"✅ Воркер-{worker_id} завершил работу")
    
    async def scrape(self, start_urls: List[str]):
        """Начать скрейпинг"""
        print(f"🚀 Начинаем скрейпинг с {len(start_urls)} URL")
        print(f"   Воркеров: {self.max_workers}")
        print(f"   Максимальная глубина: {self.max_depth}\n")
        
        # Добавляем стартовые URL в очередь
        for url in start_urls:
            await self.url_queue.put(WebPage(url, depth=0))
        
        # Запускаем воркеров
        workers = [
            asyncio.create_task(self.worker(i+1))
            for i in range(self.max_workers)
        ]
        
        # Ждём обработки всех URL
        await self.url_queue.join()
        
        # Отправляем сигналы завершения воркерам
        for _ in workers:
            await self.url_queue.put(None)
        
        # Ждём завершения всех воркеров
        await asyncio.gather(*workers)
        
        # Собираем результаты
        results = []
        while not self.result_queue.empty():
            results.append(await self.result_queue.get())
        
        return results
    
    def print_stats(self, results: List[WebPage]):
        """Вывести статистику"""
        print(f"\n{'='*70}")
        print(f"📊 СТАТИСТИКА СКРЕЙПИНГА")
        print(f"{'='*70}")
        print(f"✅ Загружено страниц: {self.stats['fetched']}")
        print(f"⏭️  Пропущено (дубли): {self.stats['skipped']}")
        print(f"❌ Ошибок: {self.stats['errors']}")
        print(f"🔗 Уникальных URL: {len(self.visited)}")
        
        # Группировка по глубине
        by_depth = {}
        for page in results:
            by_depth[page.depth] = by_depth.get(page.depth, 0) + 1
        
        print(f"\n📊 Распределение по глубине:")
        for depth in sorted(by_depth.keys()):
            print(f"   Глубина {depth}: {by_depth[depth]} страниц")

async def main():
    print("=== Асинхронный Web Scraper ===\n")
    
    scraper = AsyncWebScraper(max_workers=3, max_depth=2)
    
    start_urls = [
        "https://example.com",
        "https://example.com/blog"
    ]
    
    results = await scraper.scrape(start_urls)
    scraper.print_stats(results)
    
    # Показываем несколько примеров
    print(f"\n📄 Примеры загруженных страниц:")
    for page in results[:5]:
        print(f"   - {page.url}")

asyncio.run(main())
```

## `33.14` Синхронизация в asyncio:
Примитивы синхронизации в asyncio работают аналогично threading, но асинхронно. Они используются для координации работы нескольких корутин.

### `asyncio.Lock` — блокировка

**Lock** обеспечивает взаимоисключающий доступ к ресурсу. Только одна корутина может владеть блокировкой в данный момент.

```python
import asyncio

# Общий ресурс
shared_counter = 0
lock = asyncio.Lock()

async def increment_without_lock(worker_id):
    """❌ БЕЗ блокировки - race condition"""
    global shared_counter
    
    for _ in range(1000):
        # Читаем значение
        temp = shared_counter
        await asyncio.sleep(0)  # Передаём управление
        # Увеличиваем и записываем
        shared_counter = temp + 1
    
    print(f"Воркер-{worker_id} завершён")

async def increment_with_lock(worker_id):
    """✅ С блокировкой - безопасно"""
    global shared_counter
    
    for _ in range(1000):
        async with lock:  # Захватываем блокировку
            temp = shared_counter
            await asyncio.sleep(0)
            shared_counter = temp + 1
    
    print(f"Воркер-{worker_id} завершён")

async def test_race_condition():
    global shared_counter
    
    print("=== БЕЗ блокировки (race condition) ===")
    shared_counter = 0
    
    await asyncio.gather(
        increment_without_lock(1),
        increment_without_lock(2),
        increment_without_lock(3)
    )
    
    print(f"❌ Ожидалось: 3000, Получено: {shared_counter}\n")

async def test_with_lock():
    global shared_counter
    
    print("=== С блокировкой (безопасно) ===")
    shared_counter = 0
    
    await asyncio.gather(
        increment_with_lock(1),
        increment_with_lock(2),
        increment_with_lock(3)
    )
    
    print(f"✅ Ожидалось: 3000, Получено: {shared_counter}")

asyncio.run(test_race_condition())
asyncio.run(test_with_lock())
```

### Практический пример Lock: Общий кэш

```python
import asyncio
from datetime import datetime, timedelta

class AsyncCache:
    """Потокобезопасный асинхронный кэш"""
    
    def __init__(self, ttl_seconds: int = 60):
        self.cache = {}
        self.lock = asyncio.Lock()
        self.ttl = ttl_seconds
    
    async def get(self, key: str):
        """Получить значение из кэша"""
        async with self.lock:
            if key in self.cache:
                value, timestamp = self.cache[key]
                
                # Проверяем срок действия
                if datetime.now() - timestamp < timedelta(seconds=self.ttl):
                    print(f"  💾 Кэш HIT: {key}")
                    return value
                else:
                    print(f"  ⏱️ Кэш EXPIRED: {key}")
                    del self.cache[key]
            
            print(f"  ❌ Кэш MISS: {key}")
            return None
    
    async def set(self, key: str, value):
        """Установить значение в кэш"""
        async with self.lock:
            self.cache[key] = (value, datetime.now())
            print(f"  💾 Кэш SET: {key} = {value}")
    
    async def size(self):
        """Размер кэша"""
        async with self.lock:
            return len(self.cache)

async def fetch_data(cache: AsyncCache, key: str):
    """Загрузить данные с использованием кэша"""
    # Пытаемся получить из кэша
    cached = await cache.get(key)
    
    if cached is not None:
        return cached
    
    # Если нет в кэше, "загружаем"
    print(f"  🌐 Загружаем данные для {key}...")
    await asyncio.sleep(1)  # Имитация загрузки
    
    data = f"Data for {key}"
    await cache.set(key, data)
    
    return data

async def main():
    print("=== Async Cache with Lock ===\n")
    
    cache = AsyncCache(ttl_seconds=5)
    
    # Первый запрос - кэш пустой
    print("1️⃣ Первый запрос:")
    result1 = await fetch_data(cache, "user:123")
    print(f"   Результат: {result1}\n")
    
    # Второй запрос - данные в кэше
    print("2️⃣ Второй запрос (через 0.5с):")
    await asyncio.sleep(0.5)
    result2 = await fetch_data(cache, "user:123")
    print(f"   Результат: {result2}\n")
    
    # Параллельные запросы
    print("3️⃣ Параллельные запросы:")
    results = await asyncio.gather(
        fetch_data(cache, "user:456"),
        fetch_data(cache, "user:789"),
        fetch_data(cache, "user:456")  # Дубль
    )
    
    print(f"\n📊 Размер кэша: {await cache.size()}")

asyncio.run(main())
```

### `asyncio.Semaphore` — семафор

**Semaphore** ограничивает количество корутин, которые могут одновременно получить доступ к ресурсу.

```python
import asyncio
import time

class RateLimiter:
    """Ограничитель частоты запросов через Semaphore"""
    
    def __init__(self, max_concurrent: int):
        self.semaphore = asyncio.Semaphore(max_concurrent)
        self.active_count = 0
        self.lock = asyncio.Lock()
    
    async def acquire(self):
        """Получить разрешение"""
        await self.semaphore.acquire()
        async with self.lock:
            self.active_count += 1
    
    async def release(self):
        """Освободить разрешение"""
        self.semaphore.release()
        async with self.lock:
            self.active_count -= 1
    
    async def get_active_count(self):
        """Получить количество активных"""
        async with self.lock:
            return self.active_count

async def download_file(file_id: int, limiter: RateLimiter):
    """Загрузить файл с ограничением"""
    await limiter.acquire()
    
    try:
        active = await limiter.get_active_count()
        print(f"📥 Файл-{file_id} начал загрузку (активных: {active})")
        
        # Имитация загрузки
        await asyncio.sleep(2)
        
        print(f"✅ Файл-{file_id} загружен")
        return f"file_{file_id}.dat"
    
    finally:
        await limiter.release()

async def main():
    print("=== Semaphore Demo ===")
    print("Ограничение: максимум 3 одновременные загрузки\n")
    
    # Создаём ограничитель на 3 одновременные операции
    limiter = RateLimiter(max_concurrent=3)
    
    # Пытаемся загрузить 10 файлов
    start = time.time()
    results = await asyncio.gather(*[
        download_file(i, limiter)
        for i in range(1, 11)
    ])
    
    elapsed = time.time() - start
    
    print(f"\n✅ Все файлы загружены")
    print(f"⏱️ Время: {elapsed:.2f}с")
    print(f"📊 Файлов: {len(results)}")

asyncio.run(main())

# Вывод покажет, что одновременно загружается максимум 3 файла:
# 📥 Файл-1 начал загрузку (активных: 1)
# 📥 Файл-2 начал загрузку (активных: 2)
# 📥 Файл-3 начал загрузку (активных: 3)
# 📥 Файл-4 начал загрузку (активных: 3)  ← Ждал освобождения
# ...
```

### `asyncio.Event` — событие

**Event** используется для уведомления нескольких корутин о наступлении события.

```python
import asyncio

async def waiter(event: asyncio.Event, waiter_id: int):
    """Ждёт события"""
    print(f"⏳ Ожидатель-{waiter_id} ждёт события...")
    
    await event.wait()  # Блокируется до set()
    
    print(f"✅ Ожидатель-{waiter_id} получил событие!")

async def setter(event: asyncio.Event, delay: float):
    """Устанавливает событие через delay секунд"""
    print(f"⏰ Событие будет установлено через {delay}с\n")
    
    await asyncio.sleep(delay)
    
    print(f"\n🔔 Событие установлено!")
    event.set()  # Пробуждает всех ожидающих

async def main():
    print("=== Event Demo ===\n")
    
    event = asyncio.Event()
    
    # Запускаем ожидателей
    waiters = [
        asyncio.create_task(waiter(event, i))
        for i in range(1, 4)
    ]
    
    # Запускаем установщика
    setter_task = asyncio.create_task(setter(event, 2))
    
    # Ждём всех
    await asyncio.gather(setter_task, *waiters)
    
    print("\n✅ Все задачи завершены")

asyncio.run(main())

# Вывод:
# ⏳ Ожидатель-1 ждёт события...
# ⏳ Ожидатель-2 ждёт события...
# ⏳ Ожидатель-3 ждёт события...
# ⏰ Событие будет установлено через 2с
# 
# 🔔 Событие установлено!
# ✅ Ожидатель-1 получил событие!
# ✅ Ожидатель-2 получил событие!
# ✅ Ожидатель-3 получил событие!
```

### Практический пример Event: Координация задач

```python
import asyncio
import random

class DataPipeline:
    """Пайплайн обработки данных с координацией через события"""
    
    def __init__(self):
        self.data_ready = asyncio.Event()
        self.processing_done = asyncio.Event()
        self.data = None
        self.result = None
    
    async def fetch_data(self):
        """Этап 1: Загрузка данных"""
        print("📥 Этап 1: Загрузка данных...")
        await asyncio.sleep(2)
        
        self.data = [random.randint(1, 100) for _ in range(10)]
        print(f"✅ Данные загружены: {self.data}")
        
        self.data_ready.set()  # Сигнал: данные готовы!
    
    async def process_data(self):
        """Этап 2: Обработка данных"""
        print("⏳ Этап 2: Ожидание данных...")
        
        await self.data_ready.wait()  # Ждём загрузки
        
        print("⚙️  Этап 2: Обработка данных...")
        await asyncio.sleep(1.5)
        
        self.result = {
            "sum": sum(self.data),
            "avg": sum(self.data) / len(self.data),
            "max": max(self.data),
            "min": min(self.data)
        }
        print(f"✅ Данные обработаны")
        
        self.processing_done.set()  # Сигнал: обработка завершена!
    
    async def save_result(self):
        """Этап 3: Сохранение результата"""
        print("⏳ Этап 3: Ожидание обработки...")
        
        await self.processing_done.wait()  # Ждём обработки
        
        print("💾 Этап 3: Сохранение результата...")
        await asyncio.sleep(0.5)
        
        print(f"✅ Результат сохранён: {self.result}")

async def main():
    print("=== Data Pipeline with Events ===\n")
    
    pipeline = DataPipeline()
    
    # Запускаем все этапы параллельно
    await asyncio.gather(
        pipeline.fetch_data(),
        pipeline.process_data(),
        pipeline.save_result()
    )
    
    print("\n🎉 Пайплайн завершён!")

asyncio.run(main())
```

### `asyncio.Condition` — условная переменная

**Condition** комбинирует Lock и Event для более сложной координации.

```python
import asyncio

class BoundedQueue:
    """Очередь с ограничением через Condition"""
    
    def __init__(self, maxsize: int):
        self.maxsize = maxsize
        self.queue = []
        self.condition = asyncio.Condition()
    
    async def put(self, item):
        """Добавить элемент (ждёт если очередь полная)"""
        async with self.condition:
            # Ждём пока появится место
            while len(self.queue) >= self.maxsize:
                print(f"  ⏸️ Очередь полная ({len(self.queue)}/{self.maxsize}), ждём...")
                await self.condition.wait()
            
            self.queue.append(item)
            print(f"  ➕ Добавлен: {item} (размер: {len(self.queue)})")
            
            # Уведомляем ожидающих о новом элементе
            self.condition.notify()
    
    async def get(self):
        """Извлечь элемент (ждёт если очередь пустая)"""
        async with self.condition:
            # Ждём пока появится элемент
            while not self.queue:
                print(f"  ⏸️ Очередь пустая, ждём...")
                await self.condition.wait()
            
            item = self.queue.pop(0)
            print(f"  📤 Извлечён: {item} (размер: {len(self.queue)})")
            
            # Уведомляем ожидающих об освобождении места
            self.condition.notify()
            
            return item

async def producer(queue: BoundedQueue, producer_id: int):
    """Производитель"""
    for i in range(5):
        item = f"Item-{producer_id}-{i+1}"
        await queue.put(item)
        await asyncio.sleep(0.5)

async def consumer(queue: BoundedQueue, consumer_id: int):
    """Потребитель"""
    for _ in range(5):
        item = await queue.get()
        print(f"    🔹 Потребитель-{consumer_id} обработал: {item}")
        await asyncio.sleep(0.7)

async def main():
    print("=== Condition Demo ===\n")
    
    queue = BoundedQueue(maxsize=3)
    
    # Запускаем производителей и потребителей
    await asyncio.gather(
        producer(queue, 1),
        producer(queue, 2),
        consumer(queue, 1),
        consumer(queue, 2)
    )

asyncio.run(main())
```

## `33.15` `asyncio.wait()` и `asyncio.wait_for()` — управление временем выполнения
### `asyncio.wait_for()` — таймаут для одной корутины

**`wait_for()`** ограничивает время выполнения одной корутины. Если корутина не завершится вовремя, выбрасывается `asyncio.TimeoutError`.

```python
import asyncio

async def slow_operation(duration: float):
    """Медленная операция"""
    print(f"⏳ Операция начата (займёт {duration}с)")
    await asyncio.sleep(duration)
    print(f"✅ Операция завершена")
    return f"Результат за {duration}с"

async def main():
    print("=== wait_for() Demo ===\n")
    
    # Успешное выполнение
    print("1️⃣ Операция укладывается в таймаут:")
    try:
        result = await asyncio.wait_for(
            slow_operation(1.0),
            timeout=2.0  # Даём 2 секунды
        )
        print(f"✅ Результат: {result}\n")
    except asyncio.TimeoutError:
        print(f"⏱️ Таймаут!\n")
    
    # Таймаут
    print("2️⃣ Операция НЕ укладывается в таймаут:")
    try:
        result = await asyncio.wait_for(
            slow_operation(3.0),
            timeout=1.5  # Даём только 1.5 секунды
        )
        print(f"✅ Результат: {result}")
    except asyncio.TimeoutError:
        print(f"⏱️ Таймаут! Операция не успела завершиться за 1.5с")

asyncio.run(main())

# Вывод:
# 1️⃣ Операция укладывается в таймаут:
# ⏳ Операция начата (займёт 1.0с)
# ✅ Операция завершена
# ✅ Результат: Результат за 1.0с
# 
# 2️⃣ Операция НЕ укладывается в таймаут:
# ⏳ Операция начата (займёт 3.0с)
# ⏱️ Таймаут! Операция не успела завершиться за 1.5с
```

### Практический пример wait_for: API с таймаутом

```python
import asyncio
import random

async def api_request(endpoint: str, duration: float):
    """Имитация API запроса"""
    print(f"  🌐 Запрос к {endpoint}...")
    await asyncio.sleep(duration)
    return {"endpoint": endpoint, "data": f"Data from {endpoint}"}

async def fetch_with_timeout(endpoint: str, timeout: float):
    """Запрос с таймаутом"""
    try:
        result = await asyncio.wait_for(
            api_request(endpoint, random.uniform(0.5, 2.5)),
            timeout=timeout
        )
        print(f"  ✅ {endpoint}: успех")
        return result
    
    except asyncio.TimeoutError:
        print(f"  ⏱️ {endpoint}: таймаут ({timeout}с)")
        return {"endpoint": endpoint, "error": "timeout"}

async def main():
    print("=== API Requests с таймаутом ===\n")
    
    endpoints = [
        "/api/users",
        "/api/posts", 
        "/api/comments",
        "/api/analytics",
        "/api/settings"
    ]
    
    # Все запросы с таймаутом 1.5 секунды
    results = await asyncio.gather(*[
        fetch_with_timeout(endpoint, timeout=1.5)
        for endpoint in endpoints
    ])
    
    # Статистика
    successful = sum(1 for r in results if "error" not in r)
    failed = len(results) - successful
    
    print(f"\n📊 Статистика:")
    print(f"   ✅ Успешных: {successful}")
    print(f"   ⏱️ Таймаутов: {failed}")

asyncio.run(main())
```

### `asyncio.wait()` — ожидание нескольких задач

**`wait()`** ждёт завершения набора задач с различными стратегиями. Возвращает два множества: завершённые (done) и незавершённые (pending).

```python
import asyncio

async def task(name: str, duration: float):
    """Задача с заданной длительностью"""
    print(f"▶️  {name} начата")
    await asyncio.sleep(duration)
    print(f"✅ {name} завершена")
    return f"Результат {name}"

async def main():
    print("=== wait() Demo ===\n")
    
    # Создаём задачи
    tasks = [
        asyncio.create_task(task("Задача-A", 1.0)),
        asyncio.create_task(task("Задача-B", 2.0)),
        asyncio.create_task(task("Задача-C", 3.0)),
    ]
    
    # Способ 1: FIRST_COMPLETED - ждём первую завершённую
    print("1️⃣ FIRST_COMPLETED (ждём первую завершённую):\n")
    
    done, pending = await asyncio.wait(
        tasks,
        return_when=asyncio.FIRST_COMPLETED
    )
    
    print(f"\n📊 Завершено: {len(done)}, Ожидает: {len(pending)}")
    
    for task in done:
        print(f"   ✅ {task.result()}")
    
    # Отменяем оставшиеся
    for task in pending:
        task.cancel()

asyncio.run(main())
```

### Стратегии wait()

```python
import asyncio

async def worker(worker_id: int, duration: float):
    """Рабочая задача"""
    await asyncio.sleep(duration)
    return f"Worker-{worker_id}"

async def test_wait_strategies():
    print("=== Стратегии wait() ===\n")
    
    # Стратегия 1: FIRST_COMPLETED
    print("1️⃣ FIRST_COMPLETED - возврат при завершении первой:")
    tasks = [
        asyncio.create_task(worker(1, 1.0)),
        asyncio.create_task(worker(2, 2.0)),
        asyncio.create_task(worker(3, 3.0))
    ]
    
    done, pending = await asyncio.wait(
        tasks,
        return_when=asyncio.FIRST_COMPLETED
    )
    
    print(f"   Завершено: {len(done)}, Ожидает: {len(pending)}")
    
    # Отменяем остальные
    for task in pending:
        task.cancel()
    
    await asyncio.sleep(0.5)
    
    # Стратегия 2: FIRST_EXCEPTION
    print("\n2️⃣ FIRST_EXCEPTION - возврат при первой ошибке:")
    
    async def failing_task():
        await asyncio.sleep(0.5)
        raise ValueError("Ошибка!")
    
    tasks = [
        asyncio.create_task(worker(4, 2.0)),
        asyncio.create_task(failing_task()),
        asyncio.create_task(worker(5, 3.0))
    ]
    
    done, pending = await asyncio.wait(
        tasks,
        return_when=asyncio.FIRST_EXCEPTION
    )
    
    print(f"   Завершено: {len(done)}, Ожидает: {len(pending)}")
    
    for task in done:
        try:
            task.result()
        except Exception as e:
            print(f"   ❌ Поймана ошибка: {e}")
    
    # Отменяем остальные
    for task in pending:
        task.cancel()
    
    await asyncio.sleep(0.5)
    
    # Стратегия 3: ALL_COMPLETED (по умолчанию)
    print("\n3️⃣ ALL_COMPLETED - ждём завершения всех:")
    tasks = [
        asyncio.create_task(worker(6, 0.5)),
        asyncio.create_task(worker(7, 1.0)),
        asyncio.create_task(worker(8, 1.5))
    ]
    
    done, pending = await asyncio.wait(
        tasks,
        return_when=asyncio.ALL_COMPLETED
    )
    
    print(f"   Завершено: {len(done)}, Ожидает: {len(pending)}")
    
    for task in done:
        print(f"   ✅ {task.result()}")

asyncio.run(test_wait_strategies())
```

### wait() с таймаутом

```python
import asyncio

async def long_task(task_id: int, duration: float):
    """Долгая задача"""
    print(f"  ▶️ Задача-{task_id} начата ({duration}с)")
    await asyncio.sleep(duration)
    print(f"  ✅ Задача-{task_id} завершена")
    return f"Result-{task_id}"

async def main():
    print("=== wait() с таймаутом ===\n")
    
    # Создаём задачи с разной длительностью
    tasks = [
        asyncio.create_task(long_task(1, 1.0)),
        asyncio.create_task(long_task(2, 2.0)),
        asyncio.create_task(long_task(3, 3.0)),
        asyncio.create_task(long_task(4, 4.0))
    ]
    
    # Ждём максимум 2.5 секунды
    print("⏱️ Ждём максимум 2.5 секунды...\n")
    
    done, pending = await asyncio.wait(
        tasks,
        timeout=2.5
    )
    
    print(f"\n📊 После таймаута:")
    print(f"   ✅ Завершено: {len(done)}")
    print(f"   ⏳ Ожидает: {len(pending)}")
    
    # Результаты завершённых
    print(f"\n📋 Результаты завершённых:")
    for task in done:
        print(f"   {task.result()}")
    
    # Отменяем незавершённые
    print(f"\n🛑 Отменяем незавершённые задачи...")
    for task in pending:
        task.cancel()
    
    # Ждём отмены
    await asyncio.gather(*pending, return_exceptions=True)
    
    print(f"✅ Все задачи обработаны")

asyncio.run(main())

# Вывод:
#   ▶️ Задача-1 начата (1.0с)
#   ▶️ Задача-2 начата (2.0с)
#   ▶️ Задача-3 начата (3.0с)
#   ▶️ Задача-4 начата (4.0с)
#   ✅ Задача-1 завершена
#   ✅ Задача-2 завершена
# 
# 📊 После таймаута:
#    ✅ Завершено: 2
#    ⏳ Ожидает: 2
```

### Практический пример: Resilient API Client

```python
import asyncio
import random
from typing import List, Dict

class ResilientAPIClient:
    """API клиент с таймаутами и повторными попытками"""
    
    def __init__(self, max_retries: int = 3, timeout: float = 2.0):
        self.max_retries = max_retries
        self.timeout = timeout
    
    async def fetch(self, url: str) -> Dict:
        """Запрос с повторными попытками"""
        for attempt in range(1, self.max_retries + 1):
            try:
                print(f"  🌐 {url} - попытка {attempt}/{self.max_retries}")
                
                result = await asyncio.wait_for(
                    self._make_request(url),
                    timeout=self.timeout
                )
                
                print(f"  ✅ {url} - успех")
                return result
            
            except asyncio.TimeoutError:
                print(f"  ⏱️ {url} - таймаут (попытка {attempt})")
                if attempt == self.max_retries:
                    return {"url": url, "error": "timeout", "attempts": attempt}
                await asyncio.sleep(0.5)  # Пауза перед повтором
            
            except Exception as e:
                print(f"  ❌ {url} - ошибка: {e}")
                if attempt == self.max_retries:
                    return {"url": url, "error": str(e), "attempts": attempt}
                await asyncio.sleep(0.5)
        
        return {"url": url, "error": "max_retries_exceeded"}
    
    async def _make_request(self, url: str) -> Dict:
        """Имитация HTTP запроса"""
        # Случайная задержка (иногда больше таймаута)
        duration = random.uniform(0.5, 3.0)
        
        # Иногда падаем с ошибкой
        if random.random() < 0.2:
            await asyncio.sleep(0.5)
            raise RuntimeError("Connection error")
        
        await asyncio.sleep(duration)
        
        return {
            "url": url,
            "status": 200,
            "data": f"Data from {url}",
            "duration": duration
        }
    
    async def fetch_all(self, urls: List[str]) -> List[Dict]:
        """Загрузить все URL параллельно"""
        tasks = [asyncio.create_task(self.fetch(url)) for url in urls]
        results = await asyncio.gather(*tasks)
        return results
    
    async def fetch_with_deadline(self, urls: List[str], deadline: float) -> List[Dict]:
        """Загрузить все URL с общим дедлайном"""
        print(f"⏰ Дедлайн: {deadline}с для всех запросов\n")
        
        tasks = [asyncio.create_task(self.fetch(url)) for url in urls]
        
        # Ждём с таймаутом
        done, pending = await asyncio.wait(
            tasks,
            timeout=deadline
        )
        
        # Собираем результаты завершённых
        results = []
        for task in done:
            results.append(task.result())
        
        # Отменяем незавершённые
        for task in pending:
            task.cancel()
            results.append({
                "url": "unknown",
                "error": "deadline_exceeded"
            })
        
        return results

async def main():
    print("=== Resilient API Client ===\n")
    
    client = ResilientAPIClient(max_retries=3, timeout=2.0)
    
    urls = [
        "https://api.example.com/users",
        "https://api.example.com/posts",
        "https://api.example.com/comments",
        "https://api.example.com/analytics"
    ]
    
    # Тест с общим дедлайном
    results = await client.fetch_with_deadline(urls, deadline=5.0)
    
    # Статистика
    print(f"\n{'='*60}")
    print(f"📊 СТАТИСТИКА")
    print(f"{'='*60}")
    
    successful = sum(1 for r in results if "error" not in r)
    timeouts = sum(1 for r in results if r.get("error") == "timeout")
    errors = sum(1 for r in results if "error" in r and r.get("error") != "timeout")
    
    print(f"✅ Успешных: {successful}")
    print(f"⏱️ Таймаутов: {timeouts}")
    print(f"❌ Ошибок: {errors}")

asyncio.run(main())
```

#### asyncio.Queue:
- **Асинхронная очередь** для передачи данных между корутинами
- Методы: `put()`, `get()`, `task_done()`, `join()`
- Типы: `Queue` (FIFO), `LifoQueue` (LIFO), `PriorityQueue`
- Идеально для producer-consumer паттерна

#### Синхронизация:
- **Lock** — взаимоисключающий доступ (один владелец)
- **Semaphore** — ограничение количества одновременных операций
- **Event** — уведомление о событии (многие ожидающие)
- **Condition** — комбинация Lock + Event для сложной координации

#### Управление временем:
- **`wait_for(coro, timeout)`** — таймаут для одной корутины
- **`wait(tasks, timeout, return_when)`** — ожидание набора задач
- Стратегии: `FIRST_COMPLETED`, `FIRST_EXCEPTION`, `ALL_COMPLETED`
- Используй для устойчивости к медленным операциям

**Главное правило:** Всегда используй таймауты для внешних операций (API, БД, файлы) и примитивы синхронизации для координации корутин!















## `33.16` Обработка исключений в асинхронном коде
Обработка исключений в async коде работает аналогично синхронному, но есть важные нюансы, связанные с параллельным выполнением задач.

### Базовая обработка исключений

```python
import asyncio

async def risky_operation(operation_id: int):
    """Операция, которая может упасть"""
    print(f"⚙️ Операция-{operation_id} начата")
    await asyncio.sleep(0.5)
    
    if operation_id == 2:
        raise ValueError(f"Ошибка в операции-{operation_id}!")
    
    print(f"✅ Операция-{operation_id} успешна")
    return f"Результат-{operation_id}"

async def safe_operation(operation_id: int):
    """Операция с обработкой исключений"""
    try:
        result = await risky_operation(operation_id)
        return result
    except ValueError as e:
        print(f"❌ Поймана ошибка: {e}")
        return None
    except Exception as e:
        print(f"❌ Неожиданная ошибка: {e}")
        return None

async def main():
    print("=== Базовая обработка исключений ===\n")
    
    # Последовательное выполнение с обработкой
    for i in range(1, 4):
        result = await safe_operation(i)
        print(f"   Результат: {result}\n")

asyncio.run(main())

# Вывод:
# ⚙️ Операция-1 начата
# ✅ Операция-1 успешна
#    Результат: Результат-1
# 
# ⚙️ Операция-2 начата
# ❌ Поймана ошибка: Ошибка в операции-2!
#    Результат: None
```

### Обработка исключений в gather()

```python
import asyncio

async def task_with_error(task_id: int):
    """Задача, которая может упасть"""
    await asyncio.sleep(0.3)
    
    if task_id == 2:
        raise RuntimeError(f"Ошибка в задаче {task_id}")
    
    return f"Результат-{task_id}"

async def test_gather_exceptions():
    print("=== gather() и исключения ===\n")
    
    # По умолчанию gather() прерывается на первой ошибке
    print("1️⃣ Без return_exceptions (прерывается на ошибке):")
    try:
        results = await asyncio.gather(
            task_with_error(1),
            task_with_error(2),  # Упадёт здесь
            task_with_error(3)
        )
        print(f"   Результаты: {results}")
    except RuntimeError as e:
        print(f"   ❌ Поймана ошибка: {e}")
        print(f"   ⚠️ Задача 3 не выполнилась!\n")
    
    # С return_exceptions=True все задачи выполняются
    print("2️⃣ С return_exceptions=True (все задачи выполняются):")
    results = await asyncio.gather(
        task_with_error(1),
        task_with_error(2),
        task_with_error(3),
        return_exceptions=True  # Исключения возвращаются как результаты
    )
    
    print(f"   Результаты:")
    for i, result in enumerate(results, 1):
        if isinstance(result, Exception):
            print(f"     Задача {i}: ❌ {result}")
        else:
            print(f"     Задача {i}: ✅ {result}")

asyncio.run(test_gather_exceptions())
```

### Обработка в нескольких уровнях

```python
import asyncio

async def level3_operation():
    """Самый глубокий уровень"""
    await asyncio.sleep(0.1)
    raise ValueError("Ошибка на уровне 3!")

async def level2_operation():
    """Средний уровень - пробрасывает ошибку"""
    try:
        return await level3_operation()
    except ValueError as e:
        print(f"  🔸 Уровень 2: перехватили {e}")
        raise  # Пробрасываем выше

async def level1_operation():
    """Верхний уровень - обрабатывает ошибку"""
    try:
        return await level2_operation()
    except ValueError as e:
        print(f"  🔹 Уровень 1: обработали {e}")
        return "Безопасное значение по умолчанию"

async def main():
    print("=== Многоуровневая обработка ===\n")
    
    result = await level1_operation()
    print(f"\n✅ Итоговый результат: {result}")

asyncio.run(main())

# Вывод:
#   🔸 Уровень 2: перехватили Ошибка на уровне 3!
#   🔹 Уровень 1: обработали Ошибка на уровне 3!
# 
# ✅ Итоговый результат: Безопасное значение по умолчанию
```

## `33.17` `asyncio.shield()` — защита задач от отмены
**`asyncio.shield()`** защищает корутину или задачу от отмены. Даже если внешняя задача отменяется, защищённая продолжит выполнение.

### Базовое использование shield()

```python
import asyncio

async def important_operation():
    """Важная операция, которую нельзя прерывать"""
    print("🔒 Важная операция начата")
    await asyncio.sleep(2)
    print("✅ Важная операция завершена")
    return "Критичные данные"

async def test_without_shield():
    """Без защиты - операция прерывается"""
    print("=== БЕЗ shield() ===\n")
    
    try:
        task = asyncio.create_task(important_operation())
        
        # Ждём 1 секунду, потом отменяем
        await asyncio.sleep(1)
        print("🛑 Отменяем задачу...")
        task.cancel()
        
        result = await task
        print(f"Результат: {result}")
    
    except asyncio.CancelledError:
        print("❌ Задача была отменена (операция прервана)\n")

async def test_with_shield():
    """С защитой - операция продолжается"""
    print("=== С shield() ===\n")
    
    try:
        # Защищаем операцию
        task = asyncio.create_task(important_operation())
        shielded = asyncio.shield(task)
        
        # Ждём 1 секунду, потом отменяем shield
        await asyncio.sleep(1)
        print("🛑 Отменяем shield...")
        shielded.cancel()
        
        # Пытаемся дождаться shield (будет CancelledError)
        await shielded
    
    except asyncio.CancelledError:
        print("⚠️ Shield отменён, но задача продолжается...")
        
        # Ждём завершения исходной задачи
        result = await task
        print(f"✅ Результат получен: {result}\n")

asyncio.run(test_without_shield())
asyncio.run(test_with_shield())

# Вывод:
# === БЕЗ shield() ===
# 🔒 Важная операция начата
# 🛑 Отменяем задачу...
# ❌ Задача была отменена (операция прервана)
# 
# === С shield() ===
# 🔒 Важная операция начата
# 🛑 Отменяем shield...
# ⚠️ Shield отменён, но задача продолжается...
# ✅ Важная операция завершена
# ✅ Результат получен: Критичные данные
```

### Практический пример: Сохранение данных

```python
import asyncio

async def save_to_database(data: dict):
    """Критичная операция сохранения"""
    print(f"💾 Сохраняем данные: {data}")
    await asyncio.sleep(1.5)
    print(f"✅ Данные сохранены")
    return {"saved": True, "id": 12345}

async def process_with_save(data: dict, timeout: float):
    """Обработка с защитой сохранения"""
    print(f"⚙️ Обработка данных с таймаутом {timeout}с")
    
    try:
        # Защищаем операцию сохранения
        save_task = asyncio.create_task(save_to_database(data))
        
        # Применяем таймаут
        result = await asyncio.wait_for(
            asyncio.shield(save_task),
            timeout=timeout
        )
        
        print(f"📊 Результат: {result}")
        return result
    
    except asyncio.TimeoutError:
        print(f"⏱️ Таймаут! Но сохранение продолжается...")
        
        # Дожидаемся сохранения
        result = await save_task
        print(f"✅ Сохранение завершилось: {result}")
        return result

async def main():
    print("=== Shield для критичных операций ===\n")
    
    data = {"user_id": 123, "action": "purchase", "amount": 100}
    
    # Таймаут 1с, но сохранение займёт 1.5с
    result = await process_with_save(data, timeout=1.0)
    
    print(f"\n🎯 Финальный результат: {result}")

asyncio.run(main())

# Вывод:
# ⚙️ Обработка данных с таймаутом 1.0с
# 💾 Сохраняем данные: {'user_id': 123, 'action': 'purchase', 'amount': 100}
# ⏱️ Таймаут! Но сохранение продолжается...
# ✅ Данные сохранены
# ✅ Сохранение завершилось: {'saved': True, 'id': 12345}
# 
# 🎯 Финальный результат: {'saved': True, 'id': 12345}
```

## `33.18` Отмена задач — `task.cancel()` и обработка `CancelledError`
### Базовая отмена задачи

```python
import asyncio

async def cancellable_task(task_id: int):
    """Задача, которую можно отменить"""
    try:
        print(f"▶️ Задача-{task_id} начата")
        await asyncio.sleep(3)
        print(f"✅ Задача-{task_id} завершена")
        return f"Результат-{task_id}"
    
    except asyncio.CancelledError:
        # Важно: можем выполнить очистку ресурсов
        print(f"🧹 Задача-{task_id} выполняет очистку...")
        await asyncio.sleep(0.1)  # Имитация очистки
        print(f"❌ Задача-{task_id} отменена")
        raise  # Обязательно пробрасываем!

async def main():
    print("=== Отмена задачи ===\n")
    
    task = asyncio.create_task(cancellable_task(1))
    
    # Даём задаче поработать 1 секунду
    await asyncio.sleep(1)
    
    # Отменяем задачу
    print("🛑 Отменяем задачу...\n")
    task.cancel()
    
    try:
        await task
    except asyncio.CancelledError:
        print("\n✅ Отмена обработана")

asyncio.run(main())
```

### Отмена группы задач

```python
import asyncio

async def worker(worker_id: int):
    """Рабочая задача"""
    try:
        print(f"👷 Воркер-{worker_id} работает")
        for i in range(10):
            await asyncio.sleep(0.5)
            print(f"  Воркер-{worker_id}: шаг {i+1}")
        
        return f"Воркер-{worker_id} завершён"
    
    except asyncio.CancelledError:
        print(f"🛑 Воркер-{worker_id} отменён")
        raise

async def main():
    print("=== Отмена группы задач ===\n")
    
    # Создаём задачи
    tasks = [asyncio.create_task(worker(i)) for i in range(1, 4)]
    
    # Даём им поработать 2 секунды
    await asyncio.sleep(2)
    
    # Отменяем все задачи
    print("\n🛑 Отменяем все задачи...\n")
    for task in tasks:
        task.cancel()
    
    # Ждём завершения (с обработкой отмены)
    results = await asyncio.gather(*tasks, return_exceptions=True)
    
    # Проверяем результаты
    cancelled = sum(1 for r in results if isinstance(r, asyncio.CancelledError))
    print(f"\n📊 Отменено задач: {cancelled}/{len(tasks)}")

asyncio.run(main())
```

#### Обработка исключений:
- Используй `try/except` как в синхронном коде
- `gather()` с `return_exceptions=True` для обработки всех задач
- Создавай retry механизмы для нестабильных операций
- Используй контекстные менеджеры для единообразной обработки

#### asyncio.shield():
- **Защищает** задачу от отмены
- Используй для критичных операций (сохранение в БД, транзакции)
- Shield может быть отменён, но исходная задача продолжит работу
- Всегда дожидайся завершения защищённой задачи

#### Отмена задач:
- `task.cancel()` отменяет задачу
- Обрабатывай `CancelledError` для очистки ресурсов
- **Обязательно** пробрасывай `CancelledError` дальше (`raise`)
- Используй `gather(..., return_exceptions=True)` для массовой отмены

**Главное правило:** Всегда обрабатывай исключения и корректно освобождай ресурсы, особенно при отмене задач!

## `33.19` (`**`) Работа с subprocess асинхронно — `asyncio.create_subprocess_exec()`
**`asyncio.create_subprocess_exec()`** позволяет запускать внешние процессы асинхронно, не блокируя event loop. Это альтернатива синхронному `subprocess.run()`.

### Базовое использование

```python
import asyncio

async def run_command(command: str, *args):
    """Запустить команду асинхронно"""
    print(f"🔧 Выполняем: {command} {' '.join(args)}")
    
    # Создаём процесс
    process = await asyncio.create_subprocess_exec(
        command,
        *args,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE
    )
    
    # Ждём завершения и получаем вывод
    stdout, stderr = await process.communicate()
    
    print(f"✅ Код возврата: {process.returncode}")
    
    if stdout:
        print(f"📤 STDOUT:\n{stdout.decode().strip()}")
    
    if stderr:
        print(f"⚠️ STDERR:\n{stderr.decode().strip()}")
    
    return process.returncode, stdout, stderr

async def main():
    print("=== Асинхронный subprocess ===\n")
    
    # Пример 1: Простая команда
    await run_command("echo", "Hello from subprocess!")
    
    print("\n" + "="*50 + "\n")
    
    # Пример 2: Команда с выводом
    await run_command("ls", "-la")

# Для Windows используйте:
# await run_command("cmd", "/c", "dir")

asyncio.run(main())
```

### Параллельное выполнение команд

```python
import asyncio
import time

async def run_long_command(command_id: int, duration: int):
    """Имитация долгой команды"""
    print(f"⏳ Команда-{command_id} начата (займёт {duration}с)")
    
    # Для демо используем sleep (на практике это реальные команды)
    process = await asyncio.create_subprocess_exec(
        "python", "-c", f"import time; time.sleep({duration}); print('Done {command_id}')",
        stdout=asyncio.subprocess.PIPE
    )
    
    stdout, _ = await process.communicate()
    print(f"✅ Команда-{command_id} завершена: {stdout.decode().strip()}")
    
    return command_id

async def main():
    print("=== Параллельное выполнение команд ===\n")
    
    start = time.time()
    
    # Запускаем 3 команды параллельно
    results = await asyncio.gather(
        run_long_command(1, 2),
        run_long_command(2, 3),
        run_long_command(3, 1)
    )
    
    elapsed = time.time() - start
    
    print(f"\n⏱️ Все команды завершены за {elapsed:.2f}с")
    print(f"💡 Последовательно заняло бы: 6с")
    print(f"📊 Результаты: {results}")

asyncio.run(main())

# Вывод покажет, что команды выполняются параллельно:
# ⏳ Команда-1 начата (займёт 2с)
# ⏳ Команда-2 начата (займёт 3с)
# ⏳ Команда-3 начата (займёт 1с)
# ✅ Команда-3 завершена: Done 3
# ✅ Команда-1 завершена: Done 1
# ✅ Команда-2 завершена: Done 2
# 
# ⏱️ Все команды завершены за 3.xx с
```

### Практический пример: Обработка видео

```python
import asyncio
from pathlib import Path

class VideoProcessor:
    """Асинхронный обработчик видео"""
    
    async def get_video_info(self, video_path: str):
        """Получить информацию о видео"""
        print(f"📹 Получаем информацию: {video_path}")
        
        # Используем ffprobe для получения информации
        process = await asyncio.create_subprocess_exec(
            "ffprobe",
            "-v", "error",
            "-show_entries", "format=duration,size",
            "-of", "default=noprint_wrappers=1",
            video_path,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )
        
        stdout, stderr = await process.communicate()
        
        if process.returncode == 0:
            info = stdout.decode().strip()
            print(f"✅ Информация получена")
            return info
        else:
            print(f"❌ Ошибка: {stderr.decode()}")
            return None
    
    async def convert_video(self, input_path: str, output_path: str):
        """Конвертировать видео"""
        print(f"🔄 Конвертация: {input_path} -> {output_path}")
        
        process = await asyncio.create_subprocess_exec(
            "ffmpeg",
            "-i", input_path,
            "-c:v", "libx264",
            "-preset", "fast",
            output_path,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )
        
        # Ждём завершения
        await process.wait()
        
        if process.returncode == 0:
            print(f"✅ Конвертация завершена: {output_path}")
            return output_path
        else:
            print(f"❌ Ошибка конвертации")
            return None
    
    async def extract_thumbnail(self, video_path: str, output_path: str, time: str = "00:00:01"):
        """Извлечь миниатюру из видео"""
        print(f"🖼️ Извлечение миниатюры на {time}")
        
        process = await asyncio.create_subprocess_exec(
            "ffmpeg",
            "-i", video_path,
            "-ss", time,
            "-vframes", "1",
            output_path,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )
        
        await process.wait()
        
        if process.returncode == 0:
            print(f"✅ Миниатюра сохранена: {output_path}")
            return output_path
        else:
            print(f"❌ Ошибка извлечения")
            return None
    
    async def process_batch(self, video_files: list):
        """Обработать несколько видео параллельно"""
        print(f"🎬 Начинаем пакетную обработку {len(video_files)} видео\n")
        
        tasks = []
        for video in video_files:
            # Для каждого видео: получаем инфо, конвертируем, создаём миниатюру
            task = asyncio.create_task(self.process_single_video(video))
            tasks.append(task)
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        successful = sum(1 for r in results if r and not isinstance(r, Exception))
        print(f"\n📊 Обработано успешно: {successful}/{len(video_files)}")
        
        return results
    
    async def process_single_video(self, video_path: str):
        """Полная обработка одного видео"""
        print(f"\n{'='*60}")
        print(f"📹 Обработка: {video_path}")
        print(f"{'='*60}\n")
        
        # Последовательные операции для одного видео
        info = await self.get_video_info(video_path)
        
        output_path = video_path.replace(".mp4", "_converted.mp4")
        converted = await self.convert_video(video_path, output_path)
        
        thumb_path = video_path.replace(".mp4", "_thumb.jpg")
        thumbnail = await self.extract_thumbnail(video_path, thumb_path)
        
        return {
            "input": video_path,
            "info": info,
            "converted": converted,
            "thumbnail": thumbnail
        }

async def main():
    print("=== Асинхронная обработка видео ===\n")
    
    processor = VideoProcessor()
    
    # Имитация списка видеофайлов
    videos = [
        "video1.mp4",
        "video2.mp4",
        "video3.mp4"
    ]
    
    # Обрабатываем все видео параллельно
    results = await processor.process_batch(videos)

# Примечание: этот пример требует установленный ffmpeg
# asyncio.run(main())
```

### Чтение вывода построчно

```python
import asyncio

async def stream_command_output(command: str, *args):
    """Читать вывод команды построчно в реальном времени"""
    print(f"🔧 Запускаем: {command} {' '.join(args)}\n")
    
    process = await asyncio.create_subprocess_exec(
        command,
        *args,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE
    )
    
    # Читаем stdout построчно
    async def read_stream(stream, prefix):
        while True:
            line = await stream.readline()
            if not line:
                break
            print(f"{prefix} {line.decode().strip()}")
    
    # Читаем stdout и stderr параллельно
    await asyncio.gather(
        read_stream(process.stdout, "📤"),
        read_stream(process.stderr, "⚠️")
    )
    
    # Ждём завершения процесса
    await process.wait()
    
    print(f"\n✅ Процесс завершён с кодом: {process.returncode}")

async def main():
    print("=== Потоковое чтение вывода ===\n")
    
    # Пример с командой, которая выводит много строк
    await stream_command_output("python", "-c", 
        "for i in range(5): print(f'Line {i+1}')")

asyncio.run(main())
```

## `33.20` Интеграция синхронного кода в асинхронный:
### `asyncio.to_thread()` — выполнение блокирующего кода

**`asyncio.to_thread()`** (Python 3.9+) запускает синхронную функцию в отдельном потоке, не блокируя event loop.

```python
import asyncio
import time

def blocking_operation(task_id: int):
    """Блокирующая синхронная функция"""
    print(f"🔒 Блокирующая операция-{task_id} начата")
    time.sleep(2)  # Блокирующий sleep
    print(f"✅ Блокирующая операция-{task_id} завершена")
    return f"Результат-{task_id}"

async def async_operation(task_id: int):
    """Асинхронная операция"""
    print(f"⚡ Асинхронная операция-{task_id} начата")
    await asyncio.sleep(1)
    print(f"✅ Асинхронная операция-{task_id} завершена")
    return f"Async-{task_id}"

# ❌ ПЛОХО: Блокирующая функция блокирует весь event loop
async def bad_approach():
    print("=== ❌ ПЛОХОЙ подход (блокирует event loop) ===\n")
    
    start = time.time()
    
    # Это заблокирует event loop!
    result1 = blocking_operation(1)
    result2 = await async_operation(1)
    
    print(f"⏱️ Время: {time.time() - start:.2f}с\n")

# ✅ ХОРОШО: Используем to_thread
async def good_approach():
    print("=== ✅ ХОРОШИЙ подход (to_thread) ===\n")
    
    start = time.time()
    
    # Запускаем блокирующую функцию в потоке
    results = await asyncio.gather(
        asyncio.to_thread(blocking_operation, 1),
        async_operation(1)
    )
    
    print(f"⏱️ Время: {time.time() - start:.2f}с")
    print(f"📊 Результаты: {results}\n")

asyncio.run(bad_approach())   # ~3 секунды (последовательно)
asyncio.run(good_approach())  # ~2 секунды (параллельно)
```

### Практический пример: Работа с файлами

```python
import asyncio
import time
import json
from pathlib import Path

def read_large_file(filepath: str):
    """Синхронное чтение файла (блокирующее)"""
    print(f"📖 Читаем файл: {filepath}")
    with open(filepath, 'r') as f:
        data = f.read()
    time.sleep(0.5)  # Имитация медленного чтения
    return data

def process_data(data: str):
    """Синхронная обработка данных (CPU-intensive)"""
    print(f"⚙️ Обрабатываем данные ({len(data)} символов)")
    time.sleep(1)  # Имитация вычислений
    return {"processed": True, "length": len(data)}

async def async_workflow(filepath: str):
    """Асинхронный рабочий процесс с синхронными операциями"""
    print(f"🚀 Начинаем обработку: {filepath}\n")
    
    # Чтение файла в потоке
    content = await asyncio.to_thread(read_large_file, filepath)
    
    # Обработка данных в потоке
    result = await asyncio.to_thread(process_data, content)
    
    # Асинхронная операция
    await asyncio.sleep(0.5)
    
    print(f"✅ Обработка завершена: {filepath}")
    print(f"📊 Результат: {result}\n")
    
    return result

async def main():
    print("=== Интеграция синхронного кода ===\n")
    
    # Создаём тестовые файлы
    for i in range(1, 4):
        Path(f"test_{i}.txt").write_text(f"Test data {i}" * 100)
    
    files = ["test_1.txt", "test_2.txt", "test_3.txt"]
    
    start = time.time()
    
    # Обрабатываем все файлы параллельно
    results = await asyncio.gather(*[
        async_workflow(file) for file in files
    ])
    
    elapsed = time.time() - start
    
    print(f"⏱️ Общее время: {elapsed:.2f}с")
    print(f"💡 Последовательно заняло бы: ~6с")
    
    # Удаляем тестовые файлы
    for file in files:
        Path(file).unlink()

asyncio.run(main())
```

### `loop.run_in_executor()` — использование executor'ов

**`run_in_executor()`** — более гибкий способ запуска синхронного кода. Позволяет использовать ThreadPoolExecutor или ProcessPoolExecutor.

```python
import asyncio
import time
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor

def cpu_bound_task(n: int):
    """CPU-intensive задача"""
    print(f"💻 CPU задача-{n} начата")
    result = sum(i * i for i in range(10_000_000))
    print(f"✅ CPU задача-{n} завершена")
    return result

def io_bound_task(n: int):
    """I/O-bound задача"""
    print(f"💾 I/O задача-{n} начата")
    time.sleep(2)
    print(f"✅ I/O задача-{n} завершена")
    return f"Result-{n}"

async def test_thread_executor():
    """Использование ThreadPoolExecutor для I/O"""
    print("=== ThreadPoolExecutor (для I/O) ===\n")
    
    loop = asyncio.get_event_loop()
    
    # Создаём executor с 3 потоками
    with ThreadPoolExecutor(max_workers=3) as executor:
        tasks = [
            loop.run_in_executor(executor, io_bound_task, i)
            for i in range(1, 4)
        ]
        
        start = time.time()
        results = await asyncio.gather(*tasks)
        elapsed = time.time() - start
        
        print(f"\n⏱️ Время: {elapsed:.2f}с")
        print(f"📊 Результаты: {results}\n")

async def test_process_executor():
    """Использование ProcessPoolExecutor для CPU"""
    print("=== ProcessPoolExecutor (для CPU) ===\n")
    
    loop = asyncio.get_event_loop()
    
    # Создаём executor с 3 процессами
    with ProcessPoolExecutor(max_workers=3) as executor:
        tasks = [
            loop.run_in_executor(executor, cpu_bound_task, i)
            for i in range(1, 4)
        ]
        
        start = time.time()
        results = await asyncio.gather(*tasks)
        elapsed = time.time() - start
        
        print(f"\n⏱️ Время: {elapsed:.2f}с")
        print(f"📊 Выполнено задач: {len(results)}\n")

asyncio.run(test_thread_executor())
asyncio.run(test_process_executor())
```

### Сравнение to_thread() и run_in_executor()

```python
import asyncio
import time
from concurrent.futures import ThreadPoolExecutor

def blocking_func(value: int):
    """Блокирующая функция"""
    time.sleep(1)
    return value * 2

async def compare_methods():
    print("=== Сравнение методов ===\n")
    
    # Способ 1: asyncio.to_thread() (проще)
    print("1️⃣ asyncio.to_thread():")
    start = time.time()
    
    results1 = await asyncio.gather(*[
        asyncio.to_thread(blocking_func, i)
        for i in range(5)
    ])
    
    print(f"   Результаты: {results1}")
    print(f"   Время: {time.time() - start:.2f}с\n")
    
    # Способ 2: run_in_executor() (больше контроля)
    print("2️⃣ run_in_executor() с кастомным executor:")
    start = time.time()
    
    loop = asyncio.get_event_loop()
    executor = ThreadPoolExecutor(max_workers=2)  # Ограничиваем 2 потоками
    
    results2 = await asyncio.gather(*[
        loop.run_in_executor(executor, blocking_func, i)
        for i in range(5)
    ])
    
    executor.shutdown(wait=True)
    
    print(f"   Результаты: {results2}")
    print(f"   Время: {time.time() - start:.2f}с")

asyncio.run(compare_methods())

# Вывод покажет, что to_thread() использует неограниченный пул,
# а run_in_executor() позволяет контролировать количество потоков
```

## `33.21` (`**`) `concurrent.futures` и asyncio — совместное использование
**concurrent.futures** предоставляет ThreadPoolExecutor и ProcessPoolExecutor, которые отлично интегрируются с asyncio. Это позволяет комбинировать асинхронный код с синхронными блокирующими операциями для достижения максимальной производительности.

### Зачем комбинировать?

В реальных приложениях часто встречается микс разных типов задач:
- **I/O-bound** (сеть, файлы) → asyncio
- **Блокирующий I/O** (legacy библиотеки) → ThreadPoolExecutor
- **CPU-bound** (вычисления, обработка данных) → ProcessPoolExecutor

Комбинируя эти инструменты, можно создавать высокопроизводительные приложения, где каждая задача выполняется оптимальным способом.

### Интеграция ThreadPoolExecutor

ThreadPoolExecutor используется для выполнения блокирующих I/O операций, которые нельзя сделать асинхронными (например, работа с legacy библиотеками, requests, PIL и т.д.).

```python
import asyncio
import time
from concurrent.futures import ThreadPoolExecutor, as_completed

def sync_download(url: str):
    """Синхронная загрузка (имитация)"""
    print(f"📥 Загружаем: {url}")
    time.sleep(2)  # Имитация HTTP запроса через requests
    return {"url": url, "size": len(url) * 100}

async def async_process(data: dict):
    """Асинхронная обработка"""
    print(f"⚙️ Обрабатываем: {data['url']}")
    await asyncio.sleep(0.5)
    data['processed'] = True
    return data

async def hybrid_workflow(urls: list):
    """Гибридный workflow: sync загрузка + async обработка"""
    print(f"🔄 Обрабатываем {len(urls)} URL\n")
    
    loop = asyncio.get_event_loop()
    
    # Этап 1: Параллельная загрузка в потоках
    # Используем ThreadPool для блокирующих HTTP запросов
    with ThreadPoolExecutor(max_workers=3) as executor:
        # Запускаем синхронные загрузки параллельно
        download_tasks = [
            loop.run_in_executor(executor, sync_download, url)
            for url in urls
        ]
        
        # Ждём завершения всех загрузок
        downloaded = await asyncio.gather(*download_tasks)
    
    print(f"\n✅ Загружено: {len(downloaded)} файлов\n")
    
    # Этап 2: Асинхронная обработка
    # Теперь используем чистый asyncio для быстрой обработки
    process_tasks = [
        async_process(data)
        for data in downloaded
    ]
    
    processed = await asyncio.gather(*process_tasks)
    
    print(f"\n✅ Обработано: {len(processed)} файлов")
    
    return processed

async def main():
    print("=== Гибридный workflow ===\n")
    
    urls = [
        "https://example.com/file1",
        "https://example.com/file2",
        "https://example.com/file3",
        "https://example.com/file4"
    ]
    
    start = time.time()
    results = await hybrid_workflow(urls)
    elapsed = time.time() - start
    
    print(f"\n⏱️ Общее время: {elapsed:.2f}с")
    print(f"📊 Результатов: {len(results)}")
    print(f"💡 Это быстрее, чем чистый asyncio (если библиотека не async)")

asyncio.run(main())
```

### Когда использовать ThreadPoolExecutor:

1. **Работа с библиотеками без async поддержки** (requests, PIL, некоторые SDK)
2. **Чтение/запись файлов** (хотя есть aiofiles)
3. **Работа с БД** через синхронные драйверы (хотя лучше использовать async драйверы)
4. **Вызов C-библиотек** через ctypes

### Интеграция ProcessPoolExecutor

ProcessPoolExecutor используется для CPU-intensive операций, чтобы обойти GIL (Global Interpreter Lock) Python.

```python
import asyncio
from concurrent.futures import ProcessPoolExecutor
import time

def cpu_intensive_task(data: dict):
    """CPU-intensive обработка (обходит GIL)"""
    # Имитация сложных вычислений
    result = sum(i * i for i in range(5_000_000))
    return {**data, "computed": result}

async def process_with_workers(items: list):
    """Обработка данных в процессах"""
    print(f"⚙️ Обрабатываем {len(items)} элементов в ProcessPool\n")
    
    loop = asyncio.get_event_loop()
    
    # Используем ProcessPool для CPU-intensive задач
    with ProcessPoolExecutor(max_workers=4) as executor:
        tasks = [
            loop.run_in_executor(executor, cpu_intensive_task, item)
            for item in items
        ]
        
        results = await asyncio.gather(*tasks)
    
    return results

async def main():
    print("=== ProcessPoolExecutor + asyncio ===\n")
    
    items = [{"id": i, "value": i * 10} for i in range(1, 9)]
    
    start = time.time()
    results = await process_with_workers(items)
    elapsed = time.time() - start
    
    print(f"✅ Обработано: {len(results)} элементов")
    print(f"⏱️ Время: {elapsed:.2f}с")
    print(f"💡 На одном процессе заняло бы значительно дольше")

asyncio.run(main())
```

### Когда использовать ProcessPoolExecutor:

1. **Математические вычисления** (numpy, pandas операции)
2. **Обработка изображений** (PIL, OpenCV)
3. **Машинное обучение** (inference моделей)
4. **Криптография** (хеширование, шифрование больших объёмов)
5. **Парсинг больших файлов** (JSON, XML, CSV)

### Практический пример: Web Scraper + Data Processing

Реальный сценарий: загружаем веб-страницы, извлекаем данные (CPU-intensive), сохраняем в БД (I/O).

```python
import asyncio
import time
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor
from typing import List, Dict
import hashlib

# Синхронные функции (блокирующие)
def fetch_page_sync(url: str):
    """Синхронная загрузка страницы (имитация requests.get)"""
    print(f"  📥 Загружаем: {url}")
    time.sleep(1)  # Имитация HTTP запроса
    return {"url": url, "content": f"Content from {url}" * 100}

def compute_hash(content: str):
    """CPU-intensive: вычисление хеша"""
    return hashlib.sha256(content.encode()).hexdigest()

def extract_data(page: dict):
    """CPU-intensive: извлечение и парсинг данных"""
    print(f"  ⚙️ Извлекаем данные из: {page['url']}")
    time.sleep(0.5)  # Имитация парсинга HTML, регулярных выражений
    return {
        "url": page["url"],
        "word_count": len(page["content"].split()),
        "hash": compute_hash(page["content"])
    }

# Асинхронные функции
async def save_to_db(data: dict):
    """Асинхронное сохранение в БД"""
    print(f"  💾 Сохраняем: {data['url']}")
    await asyncio.sleep(0.2)  # Имитация async БД запроса
    return {"saved": True, **data}

class HybridScraper:
    """
    Скрейпер с комбинацией sync/async операций
    
    Архитектура:
    1. Загрузка (ThreadPool) - блокирующие HTTP запросы
    2. Обработка (ProcessPool) - CPU-intensive парсинг
    3. Сохранение (asyncio) - асинхронные БД операции
    """
    
    def __init__(self, thread_workers: int = 5, process_workers: int = 3):
        self.thread_workers = thread_workers
        self.process_workers = process_workers
    
    async def scrape_and_process(self, urls: List[str]) -> List[Dict]:
        """Полный цикл: загрузка → обработка → сохранение"""
        print(f"🚀 Начинаем обработку {len(urls)} URL")
        print(f"   ThreadPool воркеров: {self.thread_workers}")
        print(f"   ProcessPool воркеров: {self.process_workers}\n")
        
        # Этап 1: Загрузка (I/O-bound) → ThreadPool
        print("=" * 60)
        print("📥 ЭТАП 1: Загрузка страниц (ThreadPool)")
        print("=" * 60)
        pages = await self._fetch_pages(urls)
        print(f"✅ Загружено: {len(pages)} страниц\n")
        
        # Этап 2: Извлечение данных (CPU-bound) → ProcessPool
        print("=" * 60)
        print("⚙️ ЭТАП 2: Извлечение данных (ProcessPool)")
        print("=" * 60)
        extracted = await self._extract_data(pages)
        print(f"✅ Извлечено: {len(extracted)} записей\n")
        
        # Этап 3: Сохранение (async I/O)
        print("=" * 60)
        print("💾 ЭТАП 3: Сохранение в БД (asyncio)")
        print("=" * 60)
        saved = await self._save_data(extracted)
        print(f"✅ Сохранено: {len(saved)} записей\n")
        
        return saved
    
    async def _fetch_pages(self, urls: List[str]) -> List[Dict]:
        """Загрузка страниц в ThreadPool"""
        loop = asyncio.get_event_loop()
        
        # ThreadPool для блокирующих I/O операций
        with ThreadPoolExecutor(max_workers=self.thread_workers) as executor:
            tasks = [
                loop.run_in_executor(executor, fetch_page_sync, url)
                for url in urls
            ]
            return await asyncio.gather(*tasks)
    
    async def _extract_data(self, pages: List[Dict]) -> List[Dict]:
        """Извлечение данных в ProcessPool"""
        loop = asyncio.get_event_loop()
        
        # ProcessPool для CPU-intensive операций (обход GIL)
        with ProcessPoolExecutor(max_workers=self.process_workers) as executor:
            tasks = [
                loop.run_in_executor(executor, extract_data, page)
                for page in pages
            ]
            return await asyncio.gather(*tasks)
    
    async def _save_data(self, data: List[Dict]) -> List[Dict]:
        """Асинхронное сохранение"""
        # Чистый asyncio для асинхронных БД операций
        tasks = [save_to_db(item) for item in data]
        return await asyncio.gather(*tasks)

async def main():
    print("=== Hybrid Web Scraper ===\n")
    
    urls = [f"https://example.com/page{i}" for i in range(1, 11)]
    
    scraper = HybridScraper(thread_workers=5, process_workers=3)
    
    start = time.time()
    results = await scraper.scrape_and_process(urls)
    elapsed = time.time() - start
    
    print(f"{'='*60}")
    print(f"📊 ИТОГОВАЯ СТАТИСТИКА")
    print(f"{'='*60}")
    print(f"⏱️ Общее время: {elapsed:.2f}с")
    print(f"📄 Обработано страниц: {len(results)}")
    print(f"⚡ Скорость: {len(results) / elapsed:.2f} страниц/сек")
    print(f"\n💡 Только asyncio: ~15с")
    print(f"💡 Только threads: ~12с")
    print(f"💡 Гибридный подход: ~{elapsed:.0f}с (оптимально!)")

asyncio.run(main())
```

### Лучшие практики комбинирования

```python
import asyncio
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor

# ✅ ПРАВИЛЬНО: Разделяй типы задач

async def optimal_approach():
    """Оптимальный подход: правильный инструмент для каждой задачи"""
    
    loop = asyncio.get_event_loop()
    
    # 1. Async I/O для сетевых операций с async библиотеками
    async_results = await asyncio.gather(
        async_http_request(),
        async_database_query()
    )
    
    # 2. ThreadPool для блокирующего I/O
    with ThreadPoolExecutor(max_workers=5) as executor:
        thread_results = await asyncio.gather(*[
            loop.run_in_executor(executor, sync_file_operation, file)
            for file in files
        ])
    
    # 3. ProcessPool для CPU-intensive
    with ProcessPoolExecutor(max_workers=4) as executor:
        process_results = await asyncio.gather(*[
            loop.run_in_executor(executor, cpu_heavy_computation, data)
            for data in dataset
        ])
    
    return async_results, thread_results, process_results

# ❌ ПЛОХО: Использование ProcessPool для I/O
async def bad_approach():
    """Неэффективно: ProcessPool имеет overhead на создание процессов"""
    loop = asyncio.get_event_loop()
    
    with ProcessPoolExecutor() as executor:
        # Overhead создания процессов больше, чем польза для I/O
        results = await asyncio.gather(*[
            loop.run_in_executor(executor, simple_io_operation, item)
            for item in items
        ])
```

### Таблица выбора инструмента

| Тип задачи | Инструмент | Причина |
|------------|------------|---------|
| **Async I/O** (aiohttp, asyncpg) | `asyncio` | Нативная поддержка, минимальный overhead |
| **Sync I/O** (requests, psycopg2) | `ThreadPoolExecutor` | Обход блокирующих операций |
| **CPU-intensive** (numpy, PIL) | `ProcessPoolExecutor` | Обход GIL, настоящий параллелизм |
| **Быстрые операции** (<1мс) | Последовательно | Overhead параллелизма больше пользы |
| **Множество мелких задач** | `asyncio` | Минимальный overhead переключения |


### asyncio.create_subprocess_exec():
- **Асинхронный запуск** внешних процессов
- Не блокирует event loop
- Методы: `communicate()`, `wait()`, потоковое чтение
- Идеально для параллельного запуска команд (ffmpeg, imagemagick и т.д.)

### Интеграция синхронного кода:
- **`asyncio.to_thread()`** — простой способ для Python 3.9+
- **`loop.run_in_executor()`** — больше контроля, работает со всеми версиями
- ThreadPoolExecutor для I/O-bound
- ProcessPoolExecutor для CPU-bound

### concurrent.futures + asyncio:
- Комбинируй для оптимальной производительности
- ThreadPool для сетевых запросов, чтения файлов
- ProcessPool для вычислений, обработки данных
- Async для координации и I/O операций

**Главное правило:** Используй правильный инструмент для каждой задачи:
- **Async** для I/O с высоким concurrency
- **Threads** для блокирующего I/O
- **Processes** для CPU-intensive операций

## `33.22` Async библиотеки для HTTP-запросов:
Стандартная библиотека Python не включает асинхронный HTTP-клиент, поэтому для работы с HTTP в async коде используются сторонние библиотеки. Две самые популярные — **aiohttp** и **httpx**.

### `aiohttp` — основы

**aiohttp** — это полнофункциональная асинхронная библиотека для HTTP клиента и сервера. Она создана специально для asyncio и является одним из самых популярных решений.

#### Основные особенности aiohttp:

- **Полностью асинхронная** — создана с нуля для asyncio
- **Клиент и сервер** — может использоваться для создания веб-приложений
- **WebSocket поддержка** — встроенная поддержка WebSocket
- **Streaming** — поддержка потоковой передачи данных
- **Middleware** — расширяемая архитектура

#### Базовый пример:

```python
import asyncio
import aiohttp

async def fetch_page(url):
    """Асинхронная загрузка страницы"""
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            content = await response.text()
            return {
                "url": url,
                "status": response.status,
                "content_length": len(content)
            }

async def fetch_multiple(urls):
    """Загрузка нескольких URL параллельно"""
    async with aiohttp.ClientSession() as session:
        tasks = [fetch_single(session, url) for url in urls]
        return await asyncio.gather(*tasks)

async def fetch_single(session, url):
    async with session.get(url) as response:
        return await response.text()

# Установка: pip install aiohttp
```

#### Когда использовать aiohttp:

- ✅ Нужен полнофункциональный async HTTP клиент
- ✅ Создание асинхронных веб-серверов
- ✅ WebSocket соединения
- ✅ Потоковая передача данных
- ✅ Много параллельных HTTP запросов

#### Основные возможности:

```python
# Различные HTTP методы
async with session.get(url) as response: ...
async with session.post(url, json=data) as response: ...
async with session.put(url, data=data) as response: ...
async with session.delete(url) as response: ...

# Заголовки и параметры
await session.get(url, headers={"User-Agent": "MyApp"}, params={"key": "value"})

# Таймауты
timeout = aiohttp.ClientTimeout(total=30)
async with aiohttp.ClientSession(timeout=timeout) as session: ...

# Cookies и аутентификация
async with session.get(url, auth=aiohttp.BasicAuth('user', 'pass')) as response: ...
```

### `httpx` — основы

**httpx** — это современная HTTP-библиотека, которая поддерживает как синхронный, так и асинхронный режимы. Имеет API, совместимый с популярной библиотекой `requests`.

#### Основные особенности httpx:

- **Sync и async** — единый API для обоих режимов
- **HTTP/2 поддержка** — современный протокол
- **Совместимость с requests** — легкая миграция
- **Type hints** — полная типизация
- **Современный дизайн** — актуальные стандарты

#### Базовый пример:

```python
import asyncio
import httpx

async def fetch_page(url):
    """Асинхронная загрузка с httpx"""
    async with httpx.AsyncClient() as client:
        response = await client.get(url)
        return {
            "url": url,
            "status": response.status_code,
            "content": response.text
        }

async def fetch_multiple(urls):
    """Параллельная загрузка"""
    async with httpx.AsyncClient() as client:
        tasks = [client.get(url) for url in urls]
        responses = await asyncio.gather(*tasks)
        return responses

# Установка: pip install httpx
```

#### Когда использовать httpx:

- ✅ Нужна совместимость с requests API
- ✅ Важна поддержка HTTP/2
- ✅ Нужен единый sync/async API
- ✅ Требуется полная типизация
- ✅ Современные стандарты HTTP

#### Основные возможности:

```python
# Единый API для sync и async
response = httpx.get(url)  # Синхронный
response = await httpx.AsyncClient().get(url)  # Асинхронный

# HTTP/2
async with httpx.AsyncClient(http2=True) as client:
    response = await client.get(url)

# Все методы requests доступны
client.post(url, json=data)
client.put(url, data=data)
client.delete(url)
client.head(url)
```

### Сравнение aiohttp и httpx

| Характеристика | aiohttp | httpx |
|----------------|---------|-------|
| **Async/Sync** | Только async | Оба режима |
| **HTTP/2** | ❌ Нет | ✅ Есть |
| **WebSocket** | ✅ Встроен | ❌ Нет (отдельная библиотека) |
| **Сервер** | ✅ Есть | ❌ Только клиент |
| **API** | Свой | Как requests |
| **Streaming** | ✅ Отличная | ✅ Хорошая |
| **Производительность** | Очень высокая | Высокая |

### Практический пример: Выбор библиотеки

```python
import asyncio

# Сценарий 1: Множество простых запросов → aiohttp
async def scrape_with_aiohttp(urls):
    """Тысячи параллельных запросов"""
    import aiohttp
    
    async with aiohttp.ClientSession() as session:
        tasks = [session.get(url) for url in urls]
        responses = await asyncio.gather(*tasks, return_exceptions=True)
    
    return responses

# Сценарий 2: Миграция с requests → httpx
async def migrate_from_requests(urls):
    """Легкая миграция существующего кода"""
    import httpx
    
    # Код почти как в requests!
    async with httpx.AsyncClient() as client:
        tasks = [client.get(url) for url in urls]
        responses = await asyncio.gather(*tasks)
    
    return responses

# Сценарий 3: WebSocket + HTTP → aiohttp
async def realtime_app():
    """Приложение с WebSocket"""
    import aiohttp
    
    async with aiohttp.ClientSession() as session:
        # HTTP запросы
        async with session.get('http://api.example.com') as resp:
            data = await resp.json()
        
        # WebSocket
        async with session.ws_connect('ws://example.com/ws') as ws:
            await ws.send_str('Hello')
            msg = await ws.receive()
```

### Альтернативы

Кроме aiohttp и httpx, существуют и другие библиотеки:

- **`aiohttp-requests`** — обёртка над aiohttp с API requests
- **`asks`** — минималистичный async HTTP клиент
- **`treq`** — для Twisted

## `33.23` Когда использовать асинхронность: I/O-bound задачи с высоким concurrency
**Асинхронность** — это не серебряная пуля. Она эффективна в определённых сценариях и может быть избыточной или даже вредной в других.

### Идеальные сценарии для asyncio

#### 1. Множество сетевых запросов

**Проблема:** Нужно сделать тысячи HTTP запросов, каждый занимает 100-500мс.

```python
import asyncio
import time

# ❌ Синхронный подход: ~1000 секунд для 1000 запросов
def sync_approach(urls):
    results = []
    for url in urls:
        result = requests.get(url)  # Ждём 1 секунду
        results.append(result)
    return results

# ✅ Асинхронный подход: ~1-2 секунды для 1000 запросов!
async def async_approach(urls):
    async with aiohttp.ClientSession() as session:
        tasks = [session.get(url) for url in urls]
        results = await asyncio.gather(*tasks)
    return results

# Ускорение: 500-1000x!
```

**Когда применять:**
- Web scraping (сотни/тысячи страниц)
- Мониторинг множества серверов
- Работа с внешними API
- Микросервисная архитектура (множество inter-service вызовов)

#### 2. WebSocket соединения

**Проблема:** Нужно поддерживать тысячи одновременных WebSocket соединений.

```python
# ✅ Asyncio идеален для WebSocket
async def handle_websocket(websocket):
    """Один воркер обрабатывает тысячи соединений"""
    async for message in websocket:
        response = await process_message(message)
        await websocket.send(response)

# Один процесс может обслуживать 10,000+ соединений
```

**Когда применять:**
- Chat приложения
- Real-time дашборды
- Онлайн игры
- Live обновления (биржевые данные, спортивные результаты)
- IoT устройства

#### 3. Работа с базами данных

**Проблема:** Множество параллельных запросов к БД.

```python
import asyncio
import asyncpg  # Async PostgreSQL драйвер

# ✅ Async БД запросы
async def fetch_users(user_ids):
    """Загрузка тысяч пользователей параллельно"""
    async with asyncpg.create_pool(DATABASE_URL) as pool:
        tasks = [
            pool.fetchrow('SELECT * FROM users WHERE id = $1', user_id)
            for user_id in user_ids
        ]
        users = await asyncio.gather(*tasks)
    return users

# Обрабатывает 1000+ запросов в секунду на одном соединении
```

**Когда применять:**
- Аналитические дашборды (много запросов)
- Batch обработка записей
- Real-time аггregация данных
- Микросервисы с высоким RPS

#### 4. Файловые операции (с async библиотеками)

**Проблема:** Чтение/запись множества файлов.

```python
import aiofiles

# ✅ Async файловые операции
async def process_files(filenames):
    """Обработка сотен файлов параллельно"""
    tasks = []
    for filename in filenames:
        tasks.append(read_and_process(filename))
    
    results = await asyncio.gather(*tasks)
    return results

async def read_and_process(filename):
    async with aiofiles.open(filename, 'r') as f:
        content = await f.read()
        processed = process_content(content)
        return processed
```

**Когда применять:**
- Обработка логов
- Batch конвертация файлов
- Резервное копирование
- Синхронизация файлов

### Когда НЕ использовать асинхронность

#### 1. CPU-intensive задачи ❌

```python
# ❌ Asyncio не поможет с вычислениями
async def bad_use_case():
    """GIL блокирует параллелизм"""
    tasks = [
        asyncio.create_task(calculate_fibonacci(100000)),
        asyncio.create_task(calculate_fibonacci(100000)),
    ]
    results = await asyncio.gather(*tasks)
    # Выполнится последовательно из-за GIL!

# ✅ Используй multiprocessing
from concurrent.futures import ProcessPoolExecutor

def good_use_case():
    with ProcessPoolExecutor() as executor:
        results = executor.map(calculate_fibonacci, [100000, 100000])
    # Настоящий параллелизм!
```

**Не используй asyncio для:**
- Математические вычисления
- Обработка изображений/видео
- Машинное обучение inference
- Криптография
- Компиляция

#### 2. Простые скрипты ❌

```python
# ❌ Избыточно для простых задач
async def overcomplicated():
    result1 = await fetch_data()
    result2 = await process_data(result1)
    result3 = await save_data(result2)
    return result3

# ✅ Обычный код проще и понятнее
def simple_approach():
    result1 = fetch_data()
    result2 = process_data(result1)
    result3 = save_data(result2)
    return result3
```

**Не используй asyncio для:**
- Одноразовые скрипты
- Простые CLI утилиты
- Последовательная обработка
- Учебные проекты (если только не изучаешь asyncio)

#### 3. Legacy код ❌

```python
# ❌ Смешивание sync/async усложняет код
async def messy_code():
    # Куча run_in_executor
    result1 = await asyncio.to_thread(old_sync_function)
    result2 = await asyncio.to_thread(another_sync_function)
    # Потеря преимуществ asyncio

# ✅ Оставь синхронным или перепиши полностью
def clean_code():
    result1 = old_sync_function()
    result2 = another_sync_function()
```

### Таблица принятия решений

| Сценарий | Подход | Причина |
|----------|--------|---------|
| **1000+ HTTP запросов** | ✅ Asyncio | Высокий concurrency, I/O-bound |
| **WebSocket сервер** | ✅ Asyncio | Множество соединений |
| **Обработка изображений** | ❌ Multiprocessing | CPU-bound |
| **Работа с async БД** | ✅ Asyncio | I/O-bound, native поддержка |
| **CLI скрипт (3 запроса)** | ❌ Sync | Избыточная сложность |
| **Real-time дашборд** | ✅ Asyncio | Множество параллельных операций |
| **Data science вычисления** | ❌ Multiprocessing | CPU-bound |
| **REST API сервер** | ✅ Asyncio | Высокий RPS, I/O-bound |
| **Парсинг больших CSV** | ❌ Sync/Multiprocessing | CPU-bound |
| **Микросервисы** | ✅ Asyncio | Много inter-service вызовов |

### Метрики для оценки

**Используй asyncio если:**

```python
# Формула: asyncio эффективен когда
concurrency = количество_параллельных_операций
io_wait_time = время_ожидания_I/O
cpu_time = время_вычислений

if concurrency > 10 and io_wait_time / cpu_time > 10:
    use_asyncio = True  # ✅
else:
    use_asyncio = False  # ❌
```

**Примеры расчёта:**

```python
# Сценарий 1: Web Scraping
concurrency = 1000  # страниц параллельно
io_wait = 500ms     # ожидание HTTP
cpu = 10ms          # парсинг HTML
ratio = 500/10 = 50 # ✅ ОТЛИЧНО для asyncio!

# Сценарий 2: Image Processing
concurrency = 100   # изображений
io_wait = 50ms      # чтение с диска
cpu = 500ms         # обработка PIL
ratio = 50/500 = 0.1 # ❌ ПЛОХО, используй multiprocessing

# Сценарий 3: Simple Script
concurrency = 3     # всего 3 операции
io_wait = 200ms
cpu = 10ms
ratio = 20          # ❌ Слишком мало операций, asyncio избыточен
```

### Практический чеклист

**Используй asyncio когда:**

- ☑️ Больше 10-20 параллельных I/O операций
- ☑️ Время ожидания >> времени вычислений
- ☑️ Нужны WebSocket или long-polling
- ☑️ Работаешь с async библиотеками (aiohttp, asyncpg)
- ☑️ Создаёшь высоконагруженный сервер

**НЕ используй asyncio когда:**

- ☑️ Вычислений больше чем I/O
- ☑️ Мало параллельных операций (<10)
- ☑️ Весь код синхронный (legacy)
- ☑️ Простой скрипт или прототип
- ☑️ Команда не знакома с asyncio

### Гибридный подход

Иногда оптимально комбинировать:

```python
# ✅ Лучшее из двух миров
async def hybrid_approach(urls):
    # Asyncio для сетевых запросов
    async with aiohttp.ClientSession() as session:
        tasks = [session.get(url) for url in urls]
        pages = await asyncio.gather(*tasks)
    
    # Multiprocessing для обработки
    loop = asyncio.get_event_loop()
    with ProcessPoolExecutor() as executor:
        tasks = [
            loop.run_in_executor(executor, process_page, page)
            for page in pages
        ]
        results = await asyncio.gather(*tasks)
    
    return results
```

#### Async HTTP библиотеки:
- **aiohttp** — полнофункциональная, WebSocket, сервер + клиент
- **httpx** — современная, HTTP/2, совместимость с requests
- Выбор зависит от требований проекта

#### Когда использовать asyncio:
- ✅ **I/O-bound + высокий concurrency** (1000+ операций)
- ✅ **WebSocket, real-time** соединения
- ✅ **Микросервисы** с множеством вызовов
- ✅ **Async БД, HTTP, файлы**

#### Когда НЕ использовать:
- ❌ **CPU-bound** задачи (используй multiprocessing)
- ❌ **Простые скрипты** (избыточная сложность)
- ❌ **Legacy код** (смешивание усложняет)
- ❌ **Мало операций** (<10 параллельных)

**Золотое правило:** Asyncio эффективен, когда программа больше **ждёт**, чем **вычисляет**, и ждёт **много раз параллельно**!

## `33.24` (`**`) Продвинутое: создание собственного event loop
**Event loop** — это ядро асинхронного программирования в Python. Это механизм, который управляет выполнением всех асинхронных операций: корутин, задач, callbacks и I/O событий. Понимание внутреннего устройства event loop критически важно для отладки, оптимизации и создания продвинутых асинхронных решений.

### Что такое event loop и как он работает

Event loop — это бесконечный цикл, который постоянно проверяет, какие операции готовы к выполнению, и запускает их. Это центральный диспетчер, координирующий всю асинхронную работу.

**Жизненный цикл event loop:**

1. **Проверка готовых задач** — есть ли корутины, готовые к выполнению?
2. **Выполнение задач** — запуск корутин до первого `await`
3. **Регистрация I/O** — регистрация сетевых операций, файловых дескрипторов
4. **Ожидание событий** — ждёт завершения I/O через системные вызовы (epoll/kqueue/IOCP)
5. **Обработка callbacks** — выполнение отложенных функций
6. **Повторение цикла** — начинается новая итерация

```
┌─────────────────────────────────────────────┐
│         Event Loop (детальная схема)        │
├─────────────────────────────────────────────┤
│                                             │
│  while есть_задачи_или_события:             │
│                                             │
│    1. Проверить готовые задачи (ready)      │
│       ├─ Корутины, готовые продолжить       │
│       └─ Callbacks, запланированные сейчас  │
│                                             │
│    2. Выполнить готовые задачи              │
│       ├─ Запустить корутину до await        │
│       └─ Вызвать callback функции           │
│                                             │
│    3. Проверить I/O события                 │
│       ├─ Опросить ОС (select/epoll/kqueue)  │
│       └─ Какие сокеты/файлы готовы?         │
│                                             │
│    4. Обработать завершённые I/O            │
│       ├─ Возобновить ожидающие корутины     │
│       └─ Вызвать I/O callbacks              │
│                                             │
│    5. Обработать таймеры                    │
│       ├─ Проверить истёкшие таймеры         │
│       └─ Вызвать запланированные callbacks  │
│                                             │
│    6. Если нет задач и событий → выход      │
│                                             │
└─────────────────────────────────────────────┘
```

### Базовая работа с event loop

Python предоставляет несколько способов работы с event loop, от простых высокоуровневых до низкоуровневых с полным контролем.

```python
import asyncio

async def simple_coro():
    """Простая корутина"""
    print("Корутина начата")
    await asyncio.sleep(1)
    print("Корутина завершена")
    return "Результат"

# ✅ Способ 1: asyncio.run() (рекомендуется, Python 3.7+)
# Это высокоуровневый API, который:
# - Создаёт новый event loop
# - Запускает корутину
# - Закрывает loop после завершения
result = asyncio.run(simple_coro())
print(f"Результат: {result}")

# 🔧 Способ 2: Ручное управление loop (низкоуровневый)
# Даёт больше контроля, но требует явного управления
loop = asyncio.new_event_loop()  # Создаём новый loop
asyncio.set_event_loop(loop)     # Устанавливаем как текущий

try:
    result = loop.run_until_complete(simple_coro())
    print(f"Результат: {result}")
finally:
    loop.close()  # Обязательно закрываем!

# 🔍 Способ 3: Получение текущего loop (внутри async контекста)
async def get_current_loop():
    # Только внутри async функции!
    loop = asyncio.get_running_loop()
    print(f"Текущий loop: {loop}")
    print(f"Тип loop: {type(loop)}")

asyncio.run(get_current_loop())
```

**Важные различия:**
- `asyncio.run()` — для простых сценариев, создаёт и закрывает loop автоматически
- Ручное управление — когда нужен контроль над жизненным циклом loop
- `get_running_loop()` — для получения текущего loop внутри async кода

### Методы event loop

Event loop предоставляет множество методов для планирования и управления выполнением кода.

```python
import asyncio

async def explore_loop_methods():
    """Детальное исследование методов event loop"""
    loop = asyncio.get_running_loop()
    
    print("=== Информация о loop ===\n")
    
    # 1. Информация о состоянии
    print(f"Loop запущен: {loop.is_running()}")  # True
    print(f"Loop закрыт: {loop.is_closed()}")    # False
    print(f"Текущее время loop: {loop.time():.2f}с")
    
    print("\n=== Планирование callbacks ===\n")
    
    # 2. Планирование callback'ов
    def callback(name):
        print(f"  ✅ Callback '{name}' выполнен")
    
    # call_soon — выполнить callback как можно скорее
    # (на следующей итерации loop)
    loop.call_soon(callback, "immediate")
    print("📌 Запланирован immediate callback")
    
    # call_later — выполнить callback через N секунд
    loop.call_later(1.0, callback, "delayed-1s")
    print("📌 Запланирован callback через 1с")
    
    # call_at — выполнить callback в определённое время
    when = loop.time() + 2.0
    loop.call_at(when, callback, "at-specific-time")
    print("📌 Запланирован callback на конкретное время")
    
    print("\n=== Создание задач ===\n")
    
    # 3. Создание Task через loop
    async def sample_task(n):
        await asyncio.sleep(0.5)
        return f"Task-{n} result"
    
    task = loop.create_task(sample_task(1))
    print(f"📋 Создана задача: {task}")
    
    print("\n=== Создание Future ===\n")
    
    # 4. Создание Future (низкоуровневый примитив)
    future = loop.create_future()
    print(f"🔮 Создан Future: {future}")
    print(f"   Done: {future.done()}")  # False
    
    # Устанавливаем результат Future
    future.set_result("Future completed!")
    print(f"   Done: {future.done()}")  # True
    
    # Ждём завершения всех запланированных операций
    await asyncio.sleep(2.5)
    
    # Получаем результат задачи
    result = await task
    print(f"\n📊 Результат задачи: {result}")

asyncio.run(explore_loop_methods())
```

**Основные категории методов:**

1. **Информационные:** `is_running()`, `is_closed()`, `time()`
2. **Планирование:** `call_soon()`, `call_later()`, `call_at()`
3. **Создание примитивов:** `create_task()`, `create_future()`
4. **I/O операции:** `sock_connect()`, `sock_recv()`, `sock_sendall()`
5. **Subprocess:** `subprocess_exec()`, `subprocess_shell()`

### Создание упрощённого event loop с нуля

Для глубокого понимания создадим собственную упрощённую версию event loop. Это учебный пример, показывающий основные концепции.

```python
import time
from collections import deque
from typing import Coroutine, Any, Callable

class SimpleEventLoop:
    """
    Упрощённый event loop для демонстрации концепции
    
    Реализует базовые возможности:
    - Очередь готовых задач
    - Планирование по времени
    - Выполнение корутин
    """
    
    def __init__(self):
        # Очередь задач, готовых к немедленному выполнению
        self._ready = deque()
        
        # Список задач, запланированных на определённое время
        # Формат: [(время_выполнения, callback, аргументы), ...]
        self._scheduled = []
        
        # Текущая выполняющаяся задача
        self._current_task = None
        
        # Флаг остановки loop
        self._stopping = False
    
    def create_task(self, coro: Coroutine) -> 'SimpleTask':
        """
        Создать задачу из корутины
        
        Args:
            coro: Корутина для выполнения
            
        Returns:
            SimpleTask объект
        """
        task = SimpleTask(coro, self)
        self._ready.append(task)
        print(f"📋 Создана задача: {task}")
        return task
    
    def call_soon(self, callback: Callable, *args):
        """
        Запланировать callback на следующую итерацию loop
        
        Args:
            callback: Функция для вызова
            *args: Аргументы для функции
        """
        print(f"📌 call_soon: {callback.__name__}")
        self._ready.append((callback, args))
    
    def call_later(self, delay: float, callback: Callable, *args):
        """
        Запланировать callback через delay секунд
        
        Args:
            delay: Задержка в секундах
            callback: Функция для вызова
            *args: Аргументы для функции
        """
        when = time.time() + delay
        print(f"⏰ call_later: {callback.__name__} через {delay}с")
        self._scheduled.append((when, callback, args))
        # Сортируем по времени для эффективности
        self._scheduled.sort(key=lambda x: x[0])
    
    def time(self) -> float:
        """Текущее время loop (timestamp)"""
        return time.time()
    
    def run_until_complete(self, coro: Coroutine) -> Any:
        """
        Запустить loop до завершения корутины
        
        Args:
            coro: Корутина для выполнения
            
        Returns:
            Результат корутины
        """
        print(f"🚀 Запуск loop...\n")
        task = self.create_task(coro)
        self.run()
        print(f"\n✅ Loop завершён")
        return task.result
    
    def run(self):
        """
        Главный цикл event loop
        
        Выполняет итерации пока есть задачи или запланированные события
        """
        iteration = 0
        
        while (self._ready or self._scheduled) and not self._stopping:
            iteration += 1
            print(f"\n--- Итерация #{iteration} ---")
            
            # Шаг 1: Проверяем запланированные задачи
            now = time.time()
            ready_scheduled = []
            
            while self._scheduled and self._scheduled[0][0] <= now:
                _, callback, args = self._scheduled.pop(0)
                ready_scheduled.append((callback, args))
            
            if ready_scheduled:
                print(f"⏰ Истекло таймеров: {len(ready_scheduled)}")
                self._ready.extend(ready_scheduled)
            
            # Шаг 2: Выполняем готовые задачи
            if self._ready:
                print(f"📋 Готовых задач: {len(self._ready)}")
                item = self._ready.popleft()
                
                if isinstance(item, SimpleTask):
                    # Выполняем шаг задачи
                    item.step()
                else:
                    # Выполняем callback
                    callback, args = item
                    print(f"  ▶️ Выполняем callback: {callback.__name__}")
                    callback(*args)
            
            # Шаг 3: Если очередь пуста, но есть запланированные задачи
            elif self._scheduled:
                # Вычисляем время до следующего события
                sleep_time = max(0, self._scheduled[0][0] - time.time())
                if sleep_time > 0:
                    print(f"😴 Ожидание {sleep_time:.3f}с до следующего события")
                    time.sleep(min(sleep_time, 0.01))  # Максимум 10ms
            
            # Даём системе передохнуть
            time.sleep(0.001)
        
        print(f"\n🏁 Выполнено итераций: {iteration}")
    
    def stop(self):
        """Остановить loop"""
        self._stopping = True

class SimpleTask:
    """
    Упрощённая задача для SimpleEventLoop
    
    Представляет выполняющуюся корутину
    """
    
    _counter = 0  # Счётчик для ID задач
    
    def __init__(self, coro: Coroutine, loop: SimpleEventLoop):
        SimpleTask._counter += 1
        self.task_id = SimpleTask._counter
        self.coro = coro
        self.loop = loop
        self.result = None
        self.done = False
    
    def step(self):
        """
        Выполнить один шаг корутины
        
        Отправляет None в корутину, получает следующий awaitable
        """
        if self.done:
            return
        
        try:
            print(f"  ▶️ Шаг задачи #{self.task_id}")
            
            # Отправляем None в корутину, получаем awaitable
            awaitable = self.coro.send(None)
            
            # В реальном asyncio здесь сложная логика обработки awaitable
            # Для упрощения просто планируем задачу снова
            if hasattr(awaitable, '__await__'):
                # Планируем продолжение выполнения
                self.loop.call_soon(lambda: self.step())
            
        except StopIteration as e:
            # Корутина завершена
            self.result = e.value
            self.done = True
            print(f"  ✅ Задача #{self.task_id} завершена: {self.result}")
        
        except Exception as e:
            print(f"  ❌ Ошибка в задаче #{self.task_id}: {e}")
            self.done = True
    
    def __repr__(self):
        status = "done" if self.done else "pending"
        return f"<SimpleTask #{self.task_id} {status}>"

# Демонстрация работы простого loop
def demo_simple_loop():
    """Демонстрация работы упрощённого event loop"""
    print("="*60)
    print("ДЕМОНСТРАЦИЯ SIMPLE EVENT LOOP")
    print("="*60)
    
    async def task1():
        print("    Task 1: начало")
        # await asyncio.sleep(0) — в реальном asyncio
        print("    Task 1: конец")
        return "Result 1"
    
    async def task2():
        print("    Task 2: начало")
        print("    Task 2: конец")
        return "Result 2"
    
    async def main():
        print("  Main: начало")
        r1 = await task1()
        print(f"  Main: получен {r1}")
        r2 = await task2()
        print(f"  Main: получен {r2}")
        return "Main Done"
    
    loop = SimpleEventLoop()
    result = loop.run_until_complete(main())
    print(f"\n🎯 Финальный результат: {result}")

demo_simple_loop()
```

**Что показывает этот пример:**
- Как loop управляет очередью задач
- Как работает планирование callbacks
- Как корутины выполняются пошагово
- Как loop ждёт событий по времени

### Продвинутая работа с реальным loop

В реальных сценариях можно использовать низкоуровневые возможности стандартного loop для особых задач.

```python
import asyncio
import socket

async def low_level_network():
    """
    Низкоуровневая работа с сетью через loop
    
    Демонстрирует прямую работу с сокетами через event loop,
    минуя высокоуровневые абстракции
    """
    loop = asyncio.get_running_loop()
    
    print("🌐 Создаём сокет и подключаемся к example.com")
    
    # Создаём неблокирующий сокет
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setblocking(False)
    
    # Начинаем подключение (неблокирующее)
    try:
        sock.connect(('www.example.com', 80))
    except BlockingIOError:
        # Ожидаемо для неблокирующего сокета
        pass
    
    # Используем loop для асинхронного ожидания подключения
    print("⏳ Ожидаем подключения...")
    await loop.sock_connect(sock, ('www.example.com', 80))
    print("✅ Подключено!")
    
    # Отправляем HTTP запрос
    request = b'GET / HTTP/1.0\r\nHost: www.example.com\r\n\r\n'
    print(f"📤 Отправляем запрос ({len(request)} байт)")
    await loop.sock_sendall(sock, request)
    
    # Читаем ответ
    print("📥 Читаем ответ...")
    response = await loop.sock_recv(sock, 4096)
    print(f"✅ Получено {len(response)} байт")
    
    # Показываем первые 200 символов
    preview = response.decode('utf-8', errors='ignore')[:200]
    print(f"\n📄 Первые 200 символов ответа:")
    print(preview)
    print("...")
    
    sock.close()
    return len(response)

# asyncio.run(low_level_network())
```

**Преимущества низкоуровневого API:**
- Полный контроль над сетевыми операциями
- Оптимизация для специфических задач
- Интеграция с legacy кодом

### Кастомный event loop policy

Event loop policy определяет, какой тип loop создаётся. Можно создать свой policy для кастомизации поведения.

```python
import asyncio
import time

class CustomEventLoop(asyncio.SelectorEventLoop):
    """
    Кастомный event loop с дополнительным логированием
    
    Наследуется от SelectorEventLoop и переопределяет ключевые методы
    для добавления логирования и метрик
    """
    
    def __init__(self):
        super().__init__()
        self.call_soon_count = 0
        self.create_task_count = 0
    
    def call_soon(self, callback, *args, context=None):
        """Переопределяем call_soon для подсчёта"""
        self.call_soon_count += 1
        print(f"📌 call_soon #{self.call_soon_count}: {callback.__name__}")
        return super().call_soon(callback, *args, context=context)
    
    def create_task(self, coro, *, name=None, context=None):
        """Переопределяем create_task для логирования"""
        self.create_task_count += 1
        task_name = name or f"Task-{self.create_task_count}"
        print(f"📋 create_task: {task_name}")
        return super().create_task(coro, name=name, context=context)

class CustomEventLoopPolicy(asyncio.DefaultEventLoopPolicy):
    """
    Policy для создания кастомных event loop'ов
    
    Управляет созданием и получением event loop'ов
    """
    
    def new_event_loop(self):
        """Создаём наш кастомный loop"""
        print("🔧 Создание CustomEventLoop")
        return CustomEventLoop()

# Устанавливаем нашу policy глобально
asyncio.set_event_loop_policy(CustomEventLoopPolicy())

async def test_custom_loop():
    """Тест кастомного loop"""
    print("\n=== Тест CustomEventLoop ===\n")
    
    async def sample_task(n):
        await asyncio.sleep(0.5)
        return f"Result-{n}"
    
    # Создаём несколько задач
    tasks = [
        asyncio.create_task(sample_task(i), name=f"Sample-{i}")
        for i in range(3)
    ]
    
    results = await asyncio.gather(*tasks)
    
    print(f"\n📊 Результаты: {results}")
    
    # Получаем loop и выводим статистику
    loop = asyncio.get_running_loop()
    if isinstance(loop, CustomEventLoop):
        print(f"\n📈 Статистика loop:")
        print(f"   call_soon вызовов: {loop.call_soon_count}")
        print(f"   create_task вызовов: {loop.create_task_count}")

asyncio.run(test_custom_loop())
```

### Практический пример: Event loop с метриками производительности

Реальный пример: loop, который собирает метрики производительности для мониторинга приложения.

```python
import asyncio
import time
from dataclasses import dataclass, field
from typing import Dict, List

@dataclass
class LoopMetrics:
    """Метрики производительности event loop"""
    
    # Счётчики задач
    tasks_created: int = 0
    tasks_completed: int = 0
    tasks_cancelled: int = 0
    tasks_failed: int = 0
    
    # Счётчики callbacks
    callbacks_scheduled: int = 0
    callbacks_executed: int = 0
    
    # Временные метрики
    total_loop_time: float = 0.0
    iterations: int = 0
    iteration_times: List[float] = field(default_factory=list)
    
    # Статистика по задачам
    task_durations: List[float] = field(default_factory=list)
    
    def add_iteration_time(self, duration: float):
        """Добавить время итерации"""
        self.iteration_times.append(duration)
        # Храним только последние 1000 измерений
        if len(self.iteration_times) > 1000:
            self.iteration_times.pop(0)
    
    def get_avg_iteration_time(self) -> float:
        """Среднее время итерации"""
        if not self.iteration_times:
            return 0.0
        return sum(self.iteration_times) / len(self.iteration_times)
    
    def get_max_iteration_time(self) -> float:
        """Максимальное время итерации"""
        return max(self.iteration_times) if self.iteration_times else 0.0

class InstrumentedEventLoop(asyncio.SelectorEventLoop):
    """
    Event loop с подробными метриками производительности
    
    Отслеживает:
    - Создание и завершение задач
    - Планирование callbacks
    - Время выполнения итераций
    - Статистику по задачам
    """
    
    def __init__(self):
        super().__init__()
        self.metrics = LoopMetrics()
        self._iteration_start = None
    
    def create_task(self, coro, *, name=None, context=None):
        """Отслеживаем создание задач"""
        self.metrics.tasks_created += 1
        task = super().create_task(coro, name=name, context=context)
        
        # Запоминаем время создания для статистики
        task._start_time = time.time()
        
        # Добавляем callback на завершение
        task.add_done_callback(self._on_task_done)
        
        return task
    
    def _on_task_done(self, task):
        """Callback при завершении задачи"""
        # Вычисляем длительность
        if hasattr(task, '_start_time'):
            duration = time.time() - task._start_time
            self.metrics.task_durations.append(duration)
            
            # Храним только последние 1000
            if len(self.metrics.task_durations) > 1000:
                self.metrics.task_durations.pop(0)
        
        # Обновляем счётчики
        if task.cancelled():
            self.metrics.tasks_cancelled += 1
        elif task.exception() is not None:
            self.metrics.tasks_failed += 1
        else:
            self.metrics.tasks_completed += 1
    
    def call_soon(self, callback, *args, context=None):
        """Отслеживаем callbacks"""
        self.metrics.callbacks_scheduled += 1
        
        # Оборачиваем callback для подсчёта выполнений
        def wrapped_callback(*args):
            self.metrics.callbacks_executed += 1
            return callback(*args)
        
        return super().call_soon(wrapped_callback, *args, context=context)
    
    def _run_once(self):
        """Переопределяем одну итерацию loop для метрик"""
        start = time.time()
        
        super()._run_once()
        
        duration = time.time() - start
        self.metrics.iterations += 1
        self.metrics.total_loop_time += duration
        self.metrics.add_iteration_time(duration)
    
    def print_metrics(self):
        """Вывести подробные метрики"""
        m = self.metrics
        
        print(f"\n{'='*70}")
        print(f"{'EVENT LOOP PERFORMANCE METRICS':^70}")
        print(f"{'='*70}")
        
        print(f"\n📋 ЗАДАЧИ:")
        print(f"   Создано:      {m.tasks_created:>8}")
        print(f"   Завершено:    {m.tasks_completed:>8}")
        print(f"   Отменено:     {m.tasks_cancelled:>8}")
        print(f"   С ошибками:   {m.tasks_failed:>8}")
        
        if m.task_durations:
            avg_duration = sum(m.task_durations) / len(m.task_durations)
            max_duration = max(m.task_durations)
            min_duration = min(m.task_durations)
            
            print(f"\n   Длительность задач:")
            print(f"     Средняя:    {avg_duration*1000:>8.2f} ms")
            print(f"     Макс:       {max_duration*1000:>8.2f} ms")
            print(f"     Мин:        {min_duration*1000:>8.2f} ms")
        
        print(f"\n📞 CALLBACKS:")
        print(f"   Запланировано: {m.callbacks_scheduled:>8}")
        print(f"   Выполнено:     {m.callbacks_executed:>8}")
        
        print(f"\n⚙️  ИТЕРАЦИИ LOOP:")
        print(f"   Всего:        {m.iterations:>8}")
        print(f"   Общее время:  {m.total_loop_time:>8.4f} s")
        print(f"   Средняя:      {m.get_avg_iteration_time()*1000:>8.2f} ms")
        print(f"   Макс:         {m.get_max_iteration_time()*1000:>8.2f} ms")
        
        print(f"\n{'='*70}\n")

async def workload():
    """Тестовая нагрузка для демонстрации метрик"""
    
    async def quick_task(n):
        """Быстрая задача"""
        await asyncio.sleep(0.05)
        return f"Quick-{n}"
    
    async def slow_task(n):
        """Медленная задача"""
        await asyncio.sleep(0.2)
        return f"Slow-{n}"
    
    async def failing_task(n):
        """Задача с ошибкой"""
        await asyncio.sleep(0.1)
        if n % 3 == 0:
            raise ValueError(f"Task {n} failed")
        return f"Maybe-{n}"
    
    # Создаём разные типы задач
    tasks = []
    
    # Быстрые задачи
    tasks.extend([
        asyncio.create_task(quick_task(i), name=f"Quick-{i}")
        for i in range(10)
    ])
    
    # Медленные задачи
    tasks.extend([
        asyncio.create_task(slow_task(i), name=f"Slow-{i}")
        for i in range(5)
    ])
    
    # Задачи с ошибками
    tasks.extend([
        asyncio.create_task(failing_task(i), name=f"Failing-{i}")
        for i in range(6)
    ])
    
    # Ждём завершения всех задач (с обработкой ошибок)
    results = await asyncio.gather(*tasks, return_exceptions=True)
    
    # Подсчитываем результаты
    successful = sum(1 for r in results if not isinstance(r, Exception))
    failed = sum(1 for r in results if isinstance(r, Exception))
    
    print(f"\n📊 Результаты workload:")
    print(f"   Успешных: {successful}")
    print(f"   С ошибками: {failed}")

def test_instrumented_loop():
    """Тест loop с метриками"""
    print("=== INSTRUMENTED EVENT LOOP DEMO ===\n")
    
    # Создаём и устанавливаем инструментированный loop
    loop = InstrumentedEventLoop()
    asyncio.set_event_loop(loop)
    
    try:
        # Запускаем тестовую нагрузку
        print("🚀 Запуск тестовой нагрузки...\n")
        start = time.time()
        loop.run_until_complete(workload())
        elapsed = time.time() - start
        
        print(f"\n⏱️ Общее время выполнения: {elapsed:.2f}s")
        
        # Выводим метрики
        loop.print_metrics()
        
    finally:
        loop.close()

test_instrumented_loop()
```

**Применение инструментированного loop:**
- Профилирование производительности
- Отладка медленных операций
- Мониторинг в production
- Анализ узких мест

## `33.25` (`**`) Продвинутое: `asyncio.Future` — низкоуровневая работа с результатами
**Future (будущее)** — это как "обещание" получить результат какой-то операции позже, когда она завершится.

### Простая аналогия

Представь, что ты заказал пиццу:
- 🍕 Ты звонишь в пиццерию — они дают тебе **номер заказа** (это и есть Future)
- Пока пицца готовится, ты можешь заниматься своими делами
- Когда пицца готова, ты по номеру заказа получаешь результат

**Future** — это один из фундаментальных строительных блоков asyncio. Это низкоуровневый объект, представляющий результат операции, который будет доступен в будущем. Task, который вы используете каждый день, на самом деле является специализированным Future с прикреплённой корутиной.

### Что такое Future и зачем он нужен

Future — это "обещание" (promise) результата. Когда вы создаёте Future, вы создаёте контейнер, который:
- Изначально пуст (pending)
- Будет заполнен результатом или исключением позже
- Может быть await'нут для получения результата
- Уведомляет ожидающих о завершении

**Ключевые концепции:**

```
Future (Базовый класс)
    ↓
    ├─ Состояния: pending → done
    ├─ Результат: None → значение или исключение
    ├─ Callbacks: функции, вызываемые при завершении
    └─ await'able: можно использовать с await

Task (Наследник Future)
    ↓
    ├─ Всё от Future
    └─ + Корутина для выполнения
```

### Future vs Task: в чём разница

```python
import asyncio

async def demo_future_vs_task():
    """Демонстрация различий между Future и Task"""
    loop = asyncio.get_running_loop()
    
    print("=== Future vs Task ===\n")
    
    # 1. Future — "пустое обещание"
    print("1️⃣ Future (пустое обещание):")
    future = loop.create_future()
    print(f"   Создан: {future}")
    print(f"   Тип: {type(future)}")
    print(f"   Done: {future.done()}")  # False
    print(f"   Cancelled: {future.cancelled()}")  # False
    
    # Future не содержит логику — только результат
    # Мы должны вручную установить результат
    future.set_result("Результат Future")
    print(f"   После set_result — Done: {future.done()}")  # True
    
    # 2. Task — Future + корутина
    print("\n2️⃣ Task (Future + корутина):")
    
    async def my_coroutine():
        """Корутина с логикой"""
        print("   ⚙️ Корутина выполняется...")
        await asyncio.sleep(0.5)
        print("   ✅ Корутина завершена")
        return "Результат Task"
    
    task = asyncio.create_task(my_coroutine())
    print(f"   Создан: {task}")
    print(f"   Тип: {type(task)}")
    print(f"   Task is Future: {isinstance(task, asyncio.Future)}")  # True!
    print(f"   Done: {task.done()}")  # False (выполняется)
    
    # 3. Получение результатов
    print("\n3️⃣ Получение результатов:")
    
    future_result = await future
    print(f"   Future результат: {future_result}")
    
    task_result = await task
    print(f"   Task результат: {task_result}")
    
    # 4. Ключевое различие
    print("\n4️⃣ Ключевое различие:")
    print("   Future: Контейнер для результата (пассивный)")
    print("   Task:   Future + логика выполнения (активный)")

asyncio.run(demo_future_vs_task())
```

**Когда использовать что:**
- **Future** — когда результат приходит извне (callbacks, интеграции)
- **Task** — когда есть корутина для выполнения (99% случаев)

### Создание и базовое использование Future

```python
import asyncio

async def basic_future_operations():
    """Базовые операции с Future"""
    loop = asyncio.get_running_loop()
    
    print("=== Базовые операции Future ===\n")
    
    # 1. Создание Future
    future = loop.create_future()
    print(f"1️⃣ Создан Future: {future}")
    
    # 2. Проверка состояния
    print(f"\n2️⃣ Состояние Future:")
    print(f"   done(): {future.done()}")  # False
    print(f"   cancelled(): {future.cancelled()}")  # False
    
    # Попытка получить результат до завершения вызовет ошибку
    try:
        result = future.result()  # БЕЗ await!
    except asyncio.InvalidStateError as e:
        print(f"   ⚠️ result() до done: {e}")
    
    # 3. Установка результата
    print(f"\n3️⃣ Установка результата:")
    future.set_result("Мой результат!")
    print(f"   set_result() выполнен")
    print(f"   done(): {future.done()}")  # True
    
    # 4. Получение результата
    print(f"\n4️⃣ Получение результата:")
    
    # Способ 1: await (если ещё не done)
    result = await future
    print(f"   await future: {result}")
    
    # Способ 2: result() (только если done)
    result = future.result()
    print(f"   future.result(): {result}")
    
    # 5. Повторная установка результата невозможна
    print(f"\n5️⃣ Попытка повторной установки:")
    try:
        future.set_result("Новый результат")
    except asyncio.InvalidStateError as e:
        print(f"   ⚠️ Ошибка: {e}")

asyncio.run(basic_future_operations())
```

### Future с исключениями

Future может содержать не только результат, но и исключение.

```python
import asyncio

async def future_with_exceptions():
    """Работа с исключениями в Future"""
    loop = asyncio.get_running_loop()
    
    print("=== Future с исключениями ===\n")
    
    # 1. Future с нормальным результатом
    print("1️⃣ Future с результатом:")
    future_ok = loop.create_future()
    future_ok.set_result("OK")
    
    result = await future_ok
    print(f"   Результат: {result}")
    print(f"   exception(): {future_ok.exception()}")  # None
    
    # 2. Future с исключением
    print("\n2️⃣ Future с исключением:")
    future_err = loop.create_future()
    future_err.set_exception(ValueError("Что-то пошло не так!"))
    
    print(f"   done(): {future_err.done()}")  # True
    print(f"   exception(): {future_err.exception()}")  # ValueError
    
    # Получение результата вызовет исключение
    try:
        result = await future_err
    except ValueError as e:
        print(f"   ⚠️ Поймали исключение: {e}")
    
    # 3. Проверка перед получением результата
    print("\n3️⃣ Безопасная проверка:")
    
    def safe_get_result(future):
        """Безопасное получение результата Future"""
        if not future.done():
            return None, "Future не завершён"
        
        exc = future.exception()
        if exc:
            return None, f"Ошибка: {exc}"
        
        return future.result(), None
    
    result, error = safe_get_result(future_ok)
    print(f"   future_ok: result={result}, error={error}")
    
    result, error = safe_get_result(future_err)
    print(f"   future_err: result={result}, error={error}")

asyncio.run(future_with_exceptions())
```

### Callbacks на Future

Future поддерживает callbacks, которые вызываются при завершении.

```python
import asyncio

async def future_callbacks():
    """Работа с callbacks на Future"""
    loop = asyncio.get_running_loop()
    
    print("=== Future Callbacks ===\n")
    
    future = loop.create_future()
    
    # Добавляем callback
    def on_done(f):
        """Callback при завершении Future"""
        print(f"   📞 Callback вызван!")
        print(f"   Future done: {f.done()}")
        
        if f.exception():
            print(f"   ❌ Future завершён с ошибкой: {f.exception()}")
        else:
            print(f"   ✅ Future результат: {f.result()}")
    
    future.add_done_callback(on_done)
    print("1️⃣ Callback добавлен\n")
    
    # Устанавливаем результат (callback вызовется автоматически)
    print("2️⃣ Устанавливаем результат...")
    future.set_result("Успех!")
    
    # Ждём немного для демонстрации
    await asyncio.sleep(0.1)
    
    # Можно добавить callback после завершения
    print("\n3️⃣ Добавляем callback после завершения...")
    
    def late_callback(f):
        print(f"   📞 Поздний callback (вызывается сразу!)")
    
    future.add_done_callback(late_callback)

asyncio.run(future_callbacks())
```

### Практический пример: Интеграция callback API

Одно из главных применений Future — превращение callback-based API в async/await код.

```python
import asyncio
from typing import Callable, Any

class LegacyCallbackAPI:
    """
    Имитация старого callback-based API
    
    Например: библиотека для работы с внешним сервисом,
    которая не поддерживает async/await
    """
    
    def fetch_data(self, url: str, on_success: Callable, on_error: Callable):
        """
        Асинхронная операция с callbacks
        
        Args:
            url: URL для загрузки
            on_success: Callback при успехе
            on_error: Callback при ошибке
        """
        async def _fetch():
            # Имитация сетевого запроса
            await asyncio.sleep(1)
            
            # Случайная ошибка для демонстрации
            import random
            if random.random() < 0.3:
                on_error(Exception(f"Failed to fetch {url}"))
            else:
                on_error(f"Data from {url}")
        
        asyncio.create_task(_fetch())

class AsyncAPIWrapper:
    """
    Обёртка над callback API для использования с async/await
    
    Превращает callbacks в Future, которые можно await'ить
    """
    
    def __init__(self, api: LegacyCallbackAPI):
        self.api = api
    
    async def fetch_data(self, url: str) -> str:
        """
        Async версия fetch_data
        
        Args:
            url: URL для загрузки
            
        Returns:
            Загруженные данные
            
        Raises:
            Exception: При ошибке загрузки
        """
        loop = asyncio.get_running_loop()
        future = loop.create_future()
        
        # Callbacks устанавливают результат Future
        def on_success(data):
            """Callback успеха → set_result"""
            if not future.done():
                future.set_result(data)
        
        def on_error(error):
            """Callback ошибки → set_exception"""
            if not future.done():
                future.set_exception(error)
        
        # Запускаем callback-based операцию
        self.api.fetch_data(url, on_success, on_error)
        
        # Возвращаем Future, который можно await'ить
        return await future

async def main():
    """Демонстрация интеграции"""
    print("=== Интеграция Callback API через Future ===\n")
    
    # Старый callback API
    legacy_api = LegacyCallbackAPI()
    
    # Обёртка для async/await
    async_api = AsyncAPIWrapper(legacy_api)
    
    # Теперь можем использовать await!
    urls = [
        "https://example.com/api/users",
        "https://example.com/api/posts",
        "https://example.com/api/comments"
    ]
    
    for url in urls:
        try:
            print(f"📥 Загружаем: {url}")
            data = await async_api.fetch_data(url)
            print(f"✅ Получено: {data}\n")
        except Exception as e:
            print(f"❌ Ошибка: {e}\n")

asyncio.run(main())
```

**Реальные применения:**
- Интеграция с библиотеками requests (через threading)
- Работа с C-библиотеками через ctypes
- WebSocket callbacks
- GUI frameworks (Tkinter, PyQt)

### Future для координации задач

Future можно использовать для создания примитивов синхронизации.

```python
import asyncio

class AsyncBarrier:
    """
    Барьер для синхронизации задач через Future
    
    Все задачи ждут на барьере, пока не придёт N задач,
    затем все освобождаются одновременно
    """
    
    def __init__(self, n: int):
        """
        Args:
            n: Количество задач, которые должны достичь барьера
        """
        self.n = n
        self.count = 0
        self.future = None
        self.lock = asyncio.Lock()
    
    async def wait(self):
        """
        Ждать на барьере
        
        Блокируется до тех пор, пока n задач не достигнут барьера
        """
        async with self.lock:
            # Создаём Future при первом вызове
            if self.future is None:
                self.future = asyncio.get_running_loop().create_future()
            
            self.count += 1
            print(f"   🚪 Задача достигла барьера ({self.count}/{self.n})")
            
            # Если все пришли, освобождаем барьер
            if self.count >= self.n:
                if not self.future.done():
                    print(f"   🎉 Барьер открыт! Все задачи продолжают")
                    self.future.set_result(None)
        
        # Ждём освобождения барьера
        await self.future

async def worker(worker_id: int, barrier: AsyncBarrier, work_duration: float):
    """
    Рабочая задача с барьером
    
    Args:
        worker_id: ID воркера
        barrier: Барьер для синхронизации
        work_duration: Длительность работы
    """
    print(f"👷 Воркер-{worker_id} начал работу")
    
    # Фаза 1: Индивидуальная работа
    await asyncio.sleep(work_duration)
    print(f"👷 Воркер-{worker_id} закончил работу, идёт к барьеру")
    
    # Фаза 2: Ожидание на барьере
    await barrier.wait()
    
    # Фаза 3: Продолжение после барьера
    print(f"✅ Воркер-{worker_id} продолжает после барьера")
    await asyncio.sleep(0.5)
    print(f"🏁 Воркер-{worker_id} завершён")

async def main():
    """Демонстрация барьера"""
    print("=== Async Barrier через Future ===\n")
    print("Все воркеры ждут друг друга на барьере\n")
    
    # Создаём барьер на 4 задачи
    barrier = AsyncBarrier(n=4)
    
    # Запускаем воркеров с разной длительностью работы
    await asyncio.gather(
        worker(1, barrier, 0.5),
        worker(2, barrier, 1.0),
        worker(3, barrier, 1.5),
        worker(4, barrier, 2.0)
    )
    
    print("\n✅ Все воркеры завершены")

asyncio.run(main())

# Вывод покажет, что все воркеры ждут самого медленного:
# 👷 Воркер-1 начал работу
# 👷 Воркер-2 начал работу
# 👷 Воркер-3 начал работу
# 👷 Воркер-4 начал работу
# 👷 Воркер-1 закончил работу, идёт к барьеру
#    🚪 Задача достигла барьера (1/4)
# 👷 Воркер-2 закончил работу, идёт к барьеру
#    🚪 Задача достигла барьера (2/4)
# 👷 Воркер-3 закончил работу, идёт к барьеру
#    🚪 Задача достигла барьера (3/4)
# 👷 Воркер-4 закончил работу, идёт к барьеру
#    🚪 Задача достигла барьера (4/4)
#    🎉 Барьер открыт! Все задачи продолжают
# ✅ Воркер-1 продолжает после барьера  ← Все одновременно!
# ✅ Воркер-2 продолжает после барьера
# ✅ Воркер-3 продолжает после барьера
# ✅ Воркер-4 продолжает после барьера
```

### Продвинутый пример: Future Pool с ограничением

```python
import asyncio
from typing import List, Callable, Any, TypeVar

T = TypeVar('T')

class ConcurrencyLimiter:
    """
    Ограничитель конкурентности через Future
    
    Позволяет выполнять не более N операций одновременно
    """
    
    def __init__(self, max_concurrent: int):
        """
        Args:
            max_concurrent: Максимум одновременных операций
        """
        self.max_concurrent = max_concurrent
        self.current = 0
        self.waiting: List[asyncio.Future] = []
        self.lock = asyncio.Lock()
    
    async def acquire(self):
        """
        Получить разрешение на выполнение
        
        Блокируется если достигнут лимит конкурентности
        """
        async with self.lock:
            if self.current < self.max_concurrent:
                # Есть свободный слот
                self.current += 1
                return
            
            # Нет свободных слотов, создаём Future и ждём
            loop = asyncio.get_running_loop()
            future = loop.create_future()
            self.waiting.append(future)
        
        # Ждём освобождения слота
        await future
    
    async def release(self):
        """Освободить слот"""
        async with self.lock:
            self.current -= 1
            
            # Если есть ожидающие, разрешаем первому
            if self.waiting:
                future = self.waiting.pop(0)
                self.current += 1
                if not future.done():
                    future.set_result(None)
    
    async def __aenter__(self):
        """Поддержка async with"""
        await self.acquire()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Автоматическое освобождение"""
        await self.release()

async def limited_operation(limiter: ConcurrencyLimiter, op_id: int, duration: float):
    """
    Операция с ограничением конкурентности
    
    Args:
        limiter: Ограничитель
        op_id: ID операции
        duration: Длительность
    """
    print(f"⏳ Операция-{op_id} ждёт разрешения...")
    
    async with limiter:
        print(f"▶️ Операция-{op_id} начата (активных: {limiter.current})")
        await asyncio.sleep(duration)
        print(f"✅ Операция-{op_id} завершена")
    
    return f"Result-{op_id}"

async def main():
    """Демонстрация ограничителя конкурентности"""
    print("=== Concurrency Limiter через Future ===")
    print("Максимум 3 одновременные операции\n")
    
    # Создаём ограничитель на 3 операции
    limiter = ConcurrencyLimiter(max_concurrent=3)
    
    # Запускаем 10 операций
    tasks = [
        limited_operation(limiter, i, 1.0)
        for i in range(1, 11)
    ]
    
    results = await asyncio.gather(*tasks)
    
    print(f"\n📊 Обработано операций: {len(results)}")

asyncio.run(main())
```

#### Event Loop — создание и управление:
- **Event loop** — диспетчер всех асинхронных операций
- Обычно используй `asyncio.run()` для автоматического управления
- Низкоуровневые методы: `call_soon()`, `call_later()`, `create_task()`
- Кастомный loop нужен для: метрик, отладки, специальной логики
- Event loop policy управляет созданием loop'ов

#### asyncio.Future — низкоуровневый примитив:
- **Future** — контейнер для будущего результата
- **Task = Future + корутина** (Task наследуется от Future)
- Состояния: pending → done (с результатом или исключением)
- Методы: `set_result()`, `set_exception()`, `done()`, `result()`, `exception()`
- Callbacks: `add_done_callback()` для уведомления о завершении

#### Когда использовать:
- **Event loop API** — метрики, профилирование, специфические требования
- **Future** — интеграция callback API, создание sync примитивов, координация задач
- **В 99% случаев** — используй высокоуровневое API (`asyncio.run`, `create_task`, `gather`)

#### Практические применения:
- Интеграция legacy библиотек с callbacks
- Создание кастомных примитивов синхронизации
- Профилирование и мониторинг производительности
- Координация сложных асинхронных workflow

**Золотое правило:** Низкоуровневое API даёт максимальный контроль, но требует глубокого понимания. Используй его только когда высокоуровневое API не подходит для твоей задачи!















----

# `34` (`*`) Логирование
## `34.1` Что такое логирование и зачем оно нужно
## `34.2` Логирование vs `print()` — основные различия
## `34.3` Модуль `logging` — стандартный инструмент
## `34.4` Уровни логирования — `DEBUG`, `INFO`, `WARNING`, `ERROR`, `CRITICAL`
## `34.5` Базовое логирование — `logging.basicConfig()` и простые функции
## `34.6` Logger — создание именованных логгеров через `logging.getLogger()`
## `34.7` Handler — куда отправляются логи:
- `StreamHandler` — консоль
- `FileHandler` — файл
- `RotatingFileHandler` — ротация файлов
## `34.8` Formatter — форматирование сообщений и основные переменные
## `34.9` Настройка уровней логирования для logger и handler
## `34.10` Логирование исключений — `logger.exception()` и `exc_info=True`
## `34.11` Конфигурация через словарь — `logging.config.dictConfig()`

----

# `35` (`*`) Паттерны проектирования
## `35.1` Что такое паттерны проектирования и зачем они нужны
`Паттерны проектирования` — это проверенные временем решения типовых проблем, которые возникают при разработке программного обеспечения. Это не готовый код, который можно скопировать, а концептуальные шаблоны для решения конкретных задач.

**Зачем нужны паттерны**:
- **Переиспользование решений** — не нужно изобретать велосипед для типовых задач
- **Общий язык** — разработчики понимают друг друга, когда говорят "здесь нужен Singleton" или "давай используем Factory"
- **Улучшение архитектуры** — код становится более гибким, расширяемым и поддерживаемым
- **Избежание ошибок** — паттерны учитывают подводные камни, с которыми уже столкнулись другие разработчики

## `35.2` Категории паттернов — порождающие, структурные, поведенческие
`Паттерны проектирования` делятся на три основные категории по типу решаемых задач:

### **Порождающие паттерны (Creational Patterns)**
Отвечают за создание объектов. Помогают сделать систему независимой от способа создания, композиции и представления объектов.

**Основные паттерны:**
- **Singleton** — гарантирует единственный экземпляр класса
- **Factory Method** — делегирует создание объектов подклассам
- **Builder** — пошаговое создание сложных объектов
- **Prototype** — создание объектов через клонирование

**Когда использовать:** когда нужно контролировать процесс создания объектов, скрыть сложную логику инициализации или обеспечить гибкость при создании.

### **Структурные паттерны (Structural Patterns)**
Описывают способы композиции классов и объектов. Помогают организовать связи между объектами так, чтобы система оставалась гибкой и эффективной.

**Основные паттерны:**
- **Decorator** — позволяет динамически добавлять объектам новую функциональность, оборачивая их в специальные объекты-обёртки
- **Adapter** — приводит интерфейс класса к ожидаемому виду
- **Facade** — предоставляет простой интерфейс к сложной системе
- **Proxy** — контролирует доступ к объекту
- **Composite** — организует объекты в древовидную структуру

**Когда использовать:** когда нужно упростить сложные связи между объектами, сделать систему модульной или обеспечить совместимость несовместимых интерфейсов.

### **Поведенческие паттерны (Behavioral Patterns)**
Определяют взаимодействие между объектами и распределение обязанностей. Помогают организовать эффективную коммуникацию и управление алгоритмами.

**Основные паттерны:**
- **Strategy** — позволяет менять алгоритмы независимо от клиента
- **Observer** — механизм подписки на события
- **Iterator** — последовательный доступ к элементам коллекции
- **Command** — инкапсулирует запрос как объект
- **State** — изменяет поведение объекта при изменении состояния

**Когда использовать:** когда нужно гибко управлять поведением объектов, организовать взаимодействие между компонентами или инкапсулировать изменяющееся поведение.

## `35.3` Singleton — единственный экземпляр класса
`Singleton` гарантирует, что у класса существует только один экземпляр, и предоставляет глобальную точку доступа к нему.

**Зачем нужен:**
- Управление общими ресурсами — подключение к БД, логгер, конфигурация приложения
- Координация действий в системе через единую точку доступа
- Экономия ресурсов — создаём объект только один раз

**Реализация через `__new__`:**
```python
class Database:
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self, host='localhost'):
        self.host = host

# Использование
db1 = Database('localhost')
db2 = Database('remote')
print(db1 is db2)  # True — один и тот же объект
```

Еще можно реализовать через: `декоратор` и `создания единственный экземпляр в коде, а затем его переиспользование (более Питонячий подход)`

**Когда использовать:**
- Конфигурация приложения
- Пул соединений к БД
- Система логирования
- Кеш или реестр объектов

**Осторожно:**
- Усложняет тестирование (глобальное состояние)
- Может нарушать принцип единственной ответственности
- В многопоточности требует синхронизации

[Больше про Singleton](https://habr.com/ru/companies/otus/articles/779914/)


## `35.4` Factory Method — фабричный метод для создания объектов
`Factory Method` делегирует создание объектов подклассам или отдельным методам, позволяя выбирать тип создаваемого объекта во время выполнения программы.

**Зачем нужен:**
- Скрывает сложную логику создания объектов
- Позволяет создавать разные типы объектов через единый интерфейс
- Упрощает добавление новых типов объектов без изменения существующего кода

**Простой пример — создание транспорта:**
```python
from abc import ABC, abstractmethod

class Transport(ABC):
    @abstractmethod
    def deliver(self):
        pass

class Truck(Transport):
    def deliver(self):
        return "Доставка по земле на грузовике"

class Ship(Transport):
    def deliver(self):
        return "Доставка по морю на корабле"

# Простой фабричный метод
class Logistics:
    @staticmethod
    def create_transport(transport_type: str) -> Transport:
        if transport_type == "ground":
            return Truck()
        elif transport_type == "sea":
            return Ship()
        else:
            raise ValueError(f"Неизвестный тип транспорта: {transport_type}")

# Использование
transport = Logistics.create_transport("ground")
print(transport.deliver())  # Доставка по земле на грузовике

transport = Logistics.create_transport("sea")
print(transport.deliver())  # Доставка по морю на корабле
```

**Pythonic подход — функция-фабрика:**
```python
def create_payment_processor(payment_type: str):
    processors = {
        'credit_card': CreditCardProcessor,
        'paypal': PayPalProcessor,
        'crypto': CryptoProcessor
    }
    
    processor_class = processors.get(payment_type)
    if processor_class is None:
        raise ValueError(f"Неизвестный тип платежа: {payment_type}")
    
    return processor_class()

# Использование
processor = create_payment_processor('paypal')
processor.process_payment(100)
```

**Когда использовать:**
- Когда заранее неизвестно, объекты каких типов нужно создавать
- Когда логика создания объектов сложная и её нужно инкапсулировать
- Когда нужно легко добавлять новые типы объектов
- Для парсеров, обработчиков файлов разных форматов, драйверов БД

**Преимущества:**
- Слабая связанность — клиент не зависит от конкретных классов
- Легко расширяется новыми типами
- Централизованная логика создания

[Больше про Factory Method](https://habr.com/ru/articles/725340/)

## `35.5` Builder — пошаговое создание сложных объектов
`Builder` позволяет создавать сложные объекты пошагово, разделяя процесс конструирования и представления. Особенно полезен, когда объект имеет много параметров или сложную структуру.

**Зачем нужен:**
- Упрощает создание объектов с множеством параметров
- Делает код читаемым и понятным
- Позволяет создавать разные представления объекта через один интерфейс
- Избегает "телескопических конструкторов" с десятками параметров

**Классический пример — построение дома:**
```python
class House:
    def __init__(self):
        self.walls = None
        self.roof = None
        self.windows = None
        self.doors = None
        self.garage = None
    
    def __str__(self):
        parts = []
        if self.walls:
            parts.append(f"Стены: {self.walls}")
        if self.roof:
            parts.append(f"Крыша: {self.roof}")
        if self.windows:
            parts.append(f"Окна: {self.windows}")
        if self.doors:
            parts.append(f"Двери: {self.doors}")
        if self.garage:
            parts.append(f"Гараж: {self.garage}")
        return "Дом с:\n" + "\n".join(parts)

class HouseBuilder:
    def __init__(self):
        self.house = House()
    
    def build_walls(self, material):
        self.house.walls = material
        return self  # Возвращаем self для цепочки вызовов
    
    def build_roof(self, roof_type):
        self.house.roof = roof_type
        return self
    
    def build_windows(self, count):
        self.house.windows = count
        return self
    
    def build_doors(self, count):
        self.house.doors = count
        return self
    
    def build_garage(self, has_garage):
        self.house.garage = has_garage
        return self
    
    def get_house(self):
        return self.house

# Использование — метод цепочки (fluent interface)
builder = HouseBuilder()
house = (builder
         .build_walls("кирпич")
         .build_roof("черепица")
         .build_windows(4)
         .build_doors(2)
         .build_garage(True)
         .get_house())

print(house)
# Дом с:
# Стены: кирпич
# Крыша: черепица
# Окна: 4
# Двери: 2
# Гараж: True
```

**Пример с HTTP-запросом:**
```python
class HttpRequest:
    def __init__(self):
        self.method = "GET"
        self.url = None
        self.headers = {}
        self.body = None
        self.timeout = 30
    
    def __str__(self):
        return f"{self.method} {self.url}\nHeaders: {self.headers}\nBody: {self.body}"

class RequestBuilder:
    def __init__(self, url):
        self.request = HttpRequest()
        self.request.url = url
    
    def method(self, method):
        self.request.method = method
        return self
    
    def header(self, key, value):
        self.request.headers[key] = value
        return self
    
    def body(self, data):
        self.request.body = data
        return self
    
    def timeout(self, seconds):
        self.request.timeout = seconds
        return self
    
    def build(self):
        return self.request

# Использование
request = (RequestBuilder("https://api.example.com/users")
           .method("POST")
           .header("Content-Type", "application/json")
           .header("Authorization", "Bearer token123")
           .body({"name": "John", "age": 30})
           .timeout(60)
           .build())

print(request)
# POST https://api.example.com/users
# Headers: {'Content-Type': 'application/json', 'Authorization': 'Bearer token123'}
# Body: {'name': 'John', 'age': 30}
```

**Pythonic подход — dataclass с Builder:**
```python
from dataclasses import dataclass, field
from typing import Optional, List

@dataclass
class Pizza:
    size: str
    cheese: bool = False
    pepperoni: bool = False
    mushrooms: bool = False
    olives: bool = False
    toppings: List[str] = field(default_factory=list)
    
    def __str__(self):
        base = f"Пицца {self.size}"
        ingredients = []
        if self.cheese:
            ingredients.append("сыр")
        if self.pepperoni:
            ingredients.append("пепперони")
        if self.mushrooms:
            ingredients.append("грибы")
        if self.olives:
            ingredients.append("оливки")
        ingredients.extend(self.toppings)
        
        if ingredients:
            return f"{base} с: {', '.join(ingredients)}"
        return base

class PizzaBuilder:
    def __init__(self, size: str):
        self.size = size
        self._cheese = False
        self._pepperoni = False
        self._mushrooms = False
        self._olives = False
        self._toppings = []
    
    def add_cheese(self):
        self._cheese = True
        return self
    
    def add_pepperoni(self):
        self._pepperoni = True
        return self
    
    def add_mushrooms(self):
        self._mushrooms = True
        return self
    
    def add_olives(self):
        self._olives = True
        return self
    
    def add_topping(self, topping: str):
        self._toppings.append(topping)
        return self
    
    def build(self) -> Pizza:
        return Pizza(
            size=self.size,
            cheese=self._cheese,
            pepperoni=self._pepperoni,
            mushrooms=self._mushrooms,
            olives=self._olives,
            toppings=self._toppings
        )

# Использование
pizza = (PizzaBuilder("большая")
         .add_cheese()
         .add_pepperoni()
         .add_mushrooms()
         .add_topping("бекон")
         .build())

print(pizza)  # Пицца большая с: сыр, пепперони, грибы, бекон
```

**Когда использовать:**
- Объект имеет много необязательных параметров
- Создание объекта требует множества шагов
- Нужно создавать разные представления одного объекта
- Хочется избежать конструктора с десятками параметров

**Преимущества:**
- Читаемый и понятный код
- Пошаговое конструирование
- Возможность повторного использования builder'а
- Изоляция сложной логики создания

[Еще реализация Builder](https://ru.hexlet.io/courses/python-object-oriented-design/lessons/builder/theory_unit)

## `35.6` Strategy — инкапсуляция алгоритмов
`Strategy (Стратегия)` — паттерн проектирования, который выносит набор алгоритмов в отдельные классы с общим интерфейсом и делает их взаимозаменяемыми. Позволяет выбирать алгоритм динамически во время выполнения.

**Проблема:** код с множественными условными операторами для выбора алгоритма становится сложным и негибким.

**Решение:** инкапсулировать каждый алгоритм в отдельный класс, определить общий интерфейс.

### **Классический подход с классами:**

```python
from abc import ABC, abstractmethod

# Интерфейс стратегии
class DiscountStrategy(ABC):
    @abstractmethod
    def calculate(self, price):
        pass

# Конкретные стратегии
class NoDiscount(DiscountStrategy):
    def calculate(self, price):
        return price

class PercentageDiscount(DiscountStrategy):
    def __init__(self, percent):
        self.percent = percent
    
    def calculate(self, price):
        return price * (1 - self.percent / 100)

class FixedDiscount(DiscountStrategy):
    def __init__(self, amount):
        self.amount = amount
    
    def calculate(self, price):
        return max(0, price - self.amount)

# Контекст использует стратегию
class Order:
    def __init__(self, price, discount_strategy):
        self.price = price
        self.discount_strategy = discount_strategy
    
    def final_price(self):
        return self.discount_strategy.calculate(self.price)
    
    def set_discount_strategy(self, strategy):
        self.discount_strategy = strategy

# Использование
order = Order(100, NoDiscount())
print(order.final_price())  # 100

order.set_discount_strategy(PercentageDiscount(20))
print(order.final_price())  # 80.0

order.set_discount_strategy(FixedDiscount(15))
print(order.final_price())  # 85
```

### **Pythonic подход — функции как стратегии:**

В Python функции — это объекты первого класса, поэтому можно использовать их напрямую вместо классов.

```python
# Стратегии как функции
def no_discount(price):
    return price

def percentage_discount(percent):
    return lambda price: price * (1 - percent / 100)

def fixed_discount(amount):
    return lambda price: max(0, price - amount)

# Контекст
class Order:
    def __init__(self, price, discount_strategy=no_discount):
        self.price = price
        self.discount_strategy = discount_strategy
    
    def final_price(self):
        return self.discount_strategy(self.price)

# Использование
order = Order(100)
print(order.final_price())  # 100

order.discount_strategy = percentage_discount(20)
print(order.final_price())  # 80.0

order.discount_strategy = fixed_discount(15)
print(order.final_price())  # 85
```

### **Практический пример — система оплаты:**

```python
from abc import ABC, abstractmethod

class PaymentStrategy(ABC):
    @abstractmethod
    def pay(self, amount):
        pass

class CreditCardPayment(PaymentStrategy):
    def __init__(self, card_number):
        self.card_number = card_number
    
    def pay(self, amount):
        return f"Оплачено {amount}₽ картой {self.card_number[-4:]}"

class PayPalPayment(PaymentStrategy):
    def __init__(self, email):
        self.email = email
    
    def pay(self, amount):
        return f"Оплачено {amount}₽ через PayPal ({self.email})"

class CryptoPayment(PaymentStrategy):
    def __init__(self, wallet):
        self.wallet = wallet
    
    def pay(self, amount):
        return f"Оплачено {amount}₽ криптовалютой на {self.wallet}"

class ShoppingCart:
    def __init__(self):
        self.items = []
        self.payment_strategy = None
    
    def add_item(self, item, price):
        self.items.append((item, price))
    
    def total(self):
        return sum(price for _, price in self.items)
    
    def set_payment_method(self, strategy):
        self.payment_strategy = strategy
    
    def checkout(self):
        if not self.payment_strategy:
            return "Выберите способ оплаты"
        total = self.total()
        return self.payment_strategy.pay(total)

# Использование
cart = ShoppingCart()
cart.add_item("Ноутбук", 50000)
cart.add_item("Мышь", 1500)

cart.set_payment_method(CreditCardPayment("1234-5678-9012-3456"))
print(cart.checkout())  # Оплачено 51500₽ картой 3456

cart.set_payment_method(PayPalPayment("user@example.com"))
print(cart.checkout())  # Оплачено 51500₽ через PayPal (user@example.com)
```

### **Словарь стратегий для динамического выбора:**

```python
# Стратегии сжатия данных
class CompressionStrategy(ABC):
    @abstractmethod
    def compress(self, data):
        pass

class ZipCompression(CompressionStrategy):
    def compress(self, data):
        return f"ZIP: сжато '{data}'"

class RarCompression(CompressionStrategy):
    def compress(self, data):
        return f"RAR: сжато '{data}'"

class GzipCompression(CompressionStrategy):
    def compress(self, data):
        return f"GZIP: сжато '{data}'"

# Регистр стратегий
COMPRESSION_STRATEGIES = {
    'zip': ZipCompression(),
    'rar': RarCompression(),
    'gzip': GzipCompression()
}

class FileCompressor:
    def __init__(self, strategy_name):
        self.strategy = COMPRESSION_STRATEGIES.get(strategy_name)
        if not self.strategy:
            raise ValueError(f"Неизвестная стратегия: {strategy_name}")
    
    def compress_file(self, filename):
        return self.strategy.compress(filename)

# Использование
compressor = FileCompressor('zip')
print(compressor.compress_file('document.txt'))  # ZIP: сжато 'document.txt'

compressor = FileCompressor('gzip')
print(compressor.compress_file('archive.tar'))  # GZIP: сжато 'archive.tar'
```

### **Strategy + Композиция стратегий:**

```python
# Валидация с несколькими стратегиями
class ValidationStrategy(ABC):
    @abstractmethod
    def validate(self, value):
        pass

class LengthValidator(ValidationStrategy):
    def __init__(self, min_length, max_length):
        self.min_length = min_length
        self.max_length = max_length
    
    def validate(self, value):
        return self.min_length <= len(value) <= self.max_length

class RegexValidator(ValidationStrategy):
    def __init__(self, pattern):
        import re
        self.pattern = re.compile(pattern)
    
    def validate(self, value):
        return bool(self.pattern.match(value))

class Validator:
    def __init__(self):
        self.strategies = []
    
    def add_strategy(self, strategy):
        self.strategies.append(strategy)
        return self
    
    def validate(self, value):
        return all(strategy.validate(value) for strategy in self.strategies)

# Использование — композиция валидаторов
password_validator = Validator()
password_validator.add_strategy(LengthValidator(8, 20))
password_validator.add_strategy(RegexValidator(r'^(?=.*[A-Z])(?=.*\d).+$'))

print(password_validator.validate("Pass123"))    # True
print(password_validator.validate("pass"))       # False (нет заглавных и цифр)
print(password_validator.validate("PASSWORD"))   # False (нет цифр)
```

**Когда использовать:**
- Несколько вариантов выполнения одной операции
- Необходимость динамического выбора алгоритма
- Избежание условной логики (`if`/`elif` для выбора алгоритма)
- Алгоритмы должны быть взаимозаменяемыми

**Преимущества:**
- Open/Closed Principle — легко добавлять новые стратегии
- Single Responsibility Principle — каждая стратегия в отдельном классе
- Избавляет от сложных условных конструкций
- Стратегии легко тестировать независимо

**В стандартной библиотеке Python:**
- `sorted(data, key=function)` — функция `key` это стратегия
- `max(data, key=function)` — стратегия выбора максимума
- `json.dumps(obj, cls=CustomEncoder)` — стратегия сериализации

[Еще реализация Strategy](https://docs-python.ru/tutorial/oop-python-primerakh/shablon-strategy/)


## `35.7` Observer — подписка на события и уведомления
`Observer (Наблюдатель)` — паттерн, который создаёт механизм подписки, позволяющий объектам отслеживать и реагировать на события, происходящие в других объектах.

**Проблема:** нужно уведомлять множество объектов об изменениях в другом объекте без создания жёсткой связи между ними.

**Решение:** объект-издатель (Subject) хранит список подписчиков (Observers) и уведомляет их при изменениях.

### **Классический подход:**

```python
from abc import ABC, abstractmethod

# Интерфейс наблюдателя
class Observer(ABC):
    @abstractmethod
    def update(self, message):
        pass

# Издатель (Subject)
class NewsPublisher:
    def __init__(self):
        self._observers = []
        self._latest_news = None
    
    def subscribe(self, observer):
        self._observers.append(observer)
    
    def unsubscribe(self, observer):
        self._observers.remove(observer)
    
    def notify(self):
        for observer in self._observers:
            observer.update(self._latest_news)
    
    def add_news(self, news):
        self._latest_news = news
        self.notify()

# Конкретные наблюдатели
class EmailSubscriber(Observer):
    def __init__(self, email):
        self.email = email
    
    def update(self, message):
        print(f"Email на {self.email}: {message}")

class SMSSubscriber(Observer):
    def __init__(self, phone):
        self.phone = phone
    
    def update(self, message):
        print(f"SMS на {self.phone}: {message}")

# Использование
publisher = NewsPublisher()

subscriber1 = EmailSubscriber("user1@mail.com")
subscriber2 = SMSSubscriber("+7-900-123-45-67")

publisher.subscribe(subscriber1)
publisher.subscribe(subscriber2)

publisher.add_news("Новая статья опубликована!")
# Email на user1@mail.com: Новая статья опубликована!
# SMS на +7-900-123-45-67: Новая статья опубликована!

publisher.unsubscribe(subscriber1)
publisher.add_news("Обновление системы")
# SMS на +7-900-123-45-67: Обновление системы
```

### **Pythonic подход — функции как наблюдатели:**

```python
class EventManager:
    def __init__(self):
        self._subscribers = []
    
    def subscribe(self, callback):
        self._subscribers.append(callback)
    
    def unsubscribe(self, callback):
        self._subscribers.remove(callback)
    
    def notify(self, data):
        for callback in self._subscribers:
            callback(data)

class StockMarket:
    def __init__(self):
        self.price_changed = EventManager()
        self._price = 0
    
    @property
    def price(self):
        return self._price
    
    @price.setter
    def price(self, value):
        self._price = value
        self.price_changed.notify(value)

# Наблюдатели как функции
def trader_alert(price):
    print(f"Трейдер: Цена изменилась на {price}₽")

def analytics(price):
    print(f"Аналитика: Записываю цену {price}₽ в базу")

# Использование
stock = StockMarket()
stock.price_changed.subscribe(trader_alert)
stock.price_changed.subscribe(analytics)

stock.price = 100
# Трейдер: Цена изменилась на 100₽
# Аналитика: Записываю цену 100₽ в базу

stock.price = 150
# Трейдер: Цена изменилась на 150₽
# Аналитика: Записываю цену 150₽ в базу
```

### **Практический пример — система уведомлений:**

```python
class User:
    def __init__(self, name):
        self.name = name
        self.followers = []
    
    def follow(self, user):
        user.followers.append(self)
    
    def unfollow(self, user):
        user.followers.remove(self)
    
    def post_message(self, message):
        print(f"{self.name} опубликовал: {message}")
        self._notify_followers(message)
    
    def _notify_followers(self, message):
        for follower in self.followers:
            follower.receive_notification(self.name, message)
    
    def receive_notification(self, author, message):
        print(f"  → {self.name} получил уведомление от {author}: {message}")

# Использование
alice = User("Alice")
bob = User("Bob")
charlie = User("Charlie")

bob.follow(alice)
charlie.follow(alice)

alice.post_message("Привет всем!")
# Alice опубликовал: Привет всем!
#   → Bob получил уведомление от Alice: Привет всем!
#   → Charlie получил уведомление от Alice: Привет всем!

bob.unfollow(alice)
alice.post_message("Новый пост")
# Alice опубликовал: Новый пост
#   → Charlie получил уведомление от Alice: Новый пост
```

### **С типизированными событиями:**

```python
class Event:
    def __init__(self):
        self._handlers = []
    
    def subscribe(self, handler):
        self._handlers.append(handler)
        return self  # Для chain-вызовов
    
    def unsubscribe(self, handler):
        self._handlers.remove(handler)
    
    def emit(self, *args, **kwargs):
        for handler in self._handlers:
            handler(*args, **kwargs)

class TemperatureSensor:
    def __init__(self):
        self.on_temperature_changed = Event()
        self.on_critical_temperature = Event()
        self._temperature = 0
    
    def set_temperature(self, temp):
        self._temperature = temp
        self.on_temperature_changed.emit(temp)
        
        if temp > 80:
            self.on_critical_temperature.emit(temp)

# Подписчики
def log_temperature(temp):
    print(f"Лог: Температура {temp}°C")

def alert_critical(temp):
    print(f"⚠️ ВНИМАНИЕ! Критическая температура: {temp}°C")

def send_notification(temp):
    print(f"📧 Уведомление: температура достигла {temp}°C")

# Использование
sensor = TemperatureSensor()
sensor.on_temperature_changed.subscribe(log_temperature)
sensor.on_critical_temperature.subscribe(alert_critical)
sensor.on_critical_temperature.subscribe(send_notification)

sensor.set_temperature(50)
# Лог: Температура 50°C

sensor.set_temperature(85)
# Лог: Температура 85°C
# ⚠️ ВНИМАНИЕ! Критическая температура: 85°C
# 📧 Уведомление: температура достигла 85°C
```

**Когда использовать:**
- Изменение одного объекта требует изменения других, но заранее неизвестно каких и сколько
- GUI приложения (кнопки, события)
- Системы уведомлений и логирования
- Реактивное программирование

**Преимущества:**
- Слабая связанность между издателем и подписчиками
- Динамическое добавление/удаление подписчиков
- Один издатель может уведомлять множество подписчиков

**Недостатки:**
- Подписчики уведомляются в произвольном порядке
- Возможны утечки памяти, если забыть отписаться

**В реальных библиотеках:**
- Django signals
- PyQt/PySide signals and slots
- RxPY (Reactive Extensions)

[Еще реализация Observer](https://www.youtube.com/watch?v=MgsQAoHgzlc)

## `35.8` Context Manager — паттерн `with` и протокол `__enter__`/`__exit__`
`Context Manager` — паттерн для управления ресурсами (файлы, соединения, блокировки), который гарантирует их корректное освобождение даже при возникновении ошибок. Реализуется через протокол `__enter__`/`__exit__` и используется с оператором `with`.

**Зачем нужен:** автоматически выполняет действия до и после блока кода (открытие/закрытие ресурса, установка/снятие блокировки).

### **Базовое использование:**

```python
# Без context manager — нужно помнить закрыть файл
file = open('data.txt', 'r')
try:
    content = file.read()
finally:
    file.close()  # Обязательно закрыть даже при ошибке

# С context manager — закрытие автоматическое
with open('data.txt', 'r') as file:
    content = file.read()
# Файл автоматически закрыт после блока with
```

### **Создание своего context manager:**

```python
class DatabaseConnection:
    def __init__(self, host):
        self.host = host
        self.connection = None
    
    def __enter__(self):
        """Вызывается при входе в блок with"""
        print(f"Подключение к {self.host}")
        self.connection = f"Connection to {self.host}"
        return self.connection  # Возвращаемое значение попадает в 'as'
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Вызывается при выходе из блока with"""
        print(f"Отключение от {self.host}")
        self.connection = None
        # exc_type, exc_val, exc_tb — информация об исключении (если было)
        return False  # False = пробросить исключение дальше

# Использование
with DatabaseConnection('localhost') as conn:
    print(f"Работаю с {conn}")
    # Можно использовать соединение
# Автоматически вызовется __exit__

# Вывод:
# Подключение к localhost
# Работаю с Connection to localhost
# Отключение от localhost
```

### **Параметры `__exit__(exc_type, exc_val, exc_tb)`:**

Эти параметры передают информацию об исключении, которое произошло внутри блока `with`. Они позволяют context manager-у реагировать на ошибки и решать, подавить их или пробросить дальше.

**Параметры:**
- `exc_type` — тип исключения (класс, например `ValueError`)
- `exc_val` — значение исключения (само исключение)
- `exc_tb` — traceback (стек вызовов)

**Если ошибки не было:** все три параметра равны `None`

**Возвращаемое значение `__exit__`:**
- `True` или truthy — подавить исключение (не пробрасывать дальше)
- `False` или falsy — пробросить исключение дальше

```python
class ErrorHandler:
    def __enter__(self):
        print("Начало работы")
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type is None:
            print("Завершено успешно, ошибок не было")
            return False
        
        # Если было исключение
        print(f"Тип ошибки: {exc_type.__name__}")
        print(f"Сообщение: {exc_val}")
        print(f"Traceback: {exc_tb}")
        
        # Решаем, что делать с ошибкой
        if exc_type == ValueError:
            print("ValueError подавлен")
            return True  # Подавить ValueError
        
        # Для других ошибок — пробросить дальше
        print("Ошибка будет проброшена")
        return False

# Без ошибки
with ErrorHandler():
    print("Выполняю код...")
# Вывод:
# Начало работы
# Выполняю код...
# Завершено успешно, ошибок не было

# С ValueError (подавляется)
try:
    with ErrorHandler():
        print("Вызываю ошибку...")
        raise ValueError("Это ValueError")
        print("Эта строка не выполнится")
except ValueError:
    print("ValueError не был подавлен")
# Вывод:
# Начало работы
# Вызываю ошибку...
# Тип ошибки: ValueError
# Сообщение: Это ValueError
# Traceback: <traceback object at 0x...>
# ValueError подавлен
# (Исключение НЕ доходит до except)

# С TypeError (пробрасывается)
try:
    with ErrorHandler():
        raise TypeError("Это TypeError")
except TypeError as e:
    print(f"Поймали: {e}")
# Вывод:
# Начало работы
# Тип ошибки: TypeError
# Сообщение: Это TypeError
# Traceback: <traceback object at 0x...>
# Ошибка будет проброшена
# Поймали: Это TypeError
```

### **Практический пример — логирование ошибок:**

```python
import traceback

class ErrorLogger:
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type is not None:
            # Логируем полную информацию об ошибке
            print("=" * 50)
            print("ОШИБКА В БЛОКЕ WITH:")
            print(f"Тип: {exc_type.__name__}")
            print(f"Сообщение: {exc_val}")
            print("Полный traceback:")
            traceback.print_tb(exc_tb)
            print("=" * 50)
            
            # Подавляем ошибку, чтобы программа продолжила работу
            return True
        return False

# Использование
with ErrorLogger():
    x = 10
    y = 0
    result = x / y  # ZeroDivisionError

print("Программа продолжает работу после ошибки")
# Вывод:
# ==================================================
# ОШИБКА В БЛОКЕ WITH:
# Тип: ZeroDivisionError
# Сообщение: division by zero
# Полный traceback:
#   File "...", line ..., in <module>
#     result = x / y
# ==================================================
# Программа продолжает работу после ошибки
```

### **Обработка исключений:**

```python
class Timer:
    def __enter__(self):
        import time
        self.start = time.time()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        import time
        self.elapsed = time.time() - self.start
        print(f"Время выполнения: {self.elapsed:.3f} сек")
        
        if exc_type:
            print(f"Произошла ошибка: {exc_val}")
            return True  # True = подавить исключение
        return False

# Использование
with Timer():
    print("Выполняю задачу...")
    # time.sleep(1)
# Время выполнения: 0.000 сек

with Timer():
    print("Начинаю...")
    raise ValueError("Ошибка!")
# Вывод:
# Начинаю...
# Время выполнения: 0.000 сек
# Произошла ошибка: Ошибка!
# (Исключение подавлено)
```

### **Context manager через `contextlib`:**

```python
from contextlib import contextmanager

@contextmanager
def file_manager(filename, mode):
    print(f"Открываю файл {filename}")
    file = open(filename, mode)
    try:
        yield file  # Все до yield — это __enter__, после — __exit__
    finally:
        print(f"Закрываю файл {filename}")
        file.close()

# Использование
with file_manager('test.txt', 'w') as f:
    f.write("Hello, World!")
# Открываю файл test.txt
# Закрываю файл test.txt
```

### **Практический пример — изменение директории:**

```python
import os
from contextlib import contextmanager

@contextmanager
def change_directory(path):
    original_dir = os.getcwd()
    print(f"Переход в {path}")
    os.chdir(path)
    try:
        yield
    finally:
        print(f"Возврат в {original_dir}")
        os.chdir(original_dir)

# Использование
print(f"Текущая: {os.getcwd()}")
with change_directory('/tmp'):
    print(f"Внутри with: {os.getcwd()}")
print(f"После with: {os.getcwd()}")
```


## `35.9` Async Context Manager — `async with` и `__aenter__`/`__aexit__`
`Async Context Manager` — асинхронная версия context manager для работы с асинхронными ресурсами (async HTTP-соединения, async файлы, async блокировки). Использует `__aenter__`/`__aexit__` и оператор `async with`.

### **Создание async context manager:**

```python
import asyncio

class AsyncDatabaseConnection:
    def __init__(self, host):
        self.host = host
    
    async def __aenter__(self):
        """Асинхронное подключение"""
        print(f"Подключаюсь к {self.host}...")
        await asyncio.sleep(1)  # Имитация подключения
        print(f"Подключено к {self.host}")
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Асинхронное отключение"""
        print(f"Отключаюсь от {self.host}...")
        await asyncio.sleep(0.5)  # Имитация отключения
        print(f"Отключено от {self.host}")
        
        # exc_type, exc_val, exc_tb работают так же, как в обычном context manager
        if exc_type:
            print(f"Async: произошла ошибка {exc_type.__name__}: {exc_val}")
        
        return False
    
    async def query(self, sql):
        print(f"Выполняю запрос: {sql}")
        await asyncio.sleep(0.3)
        return "Result"

# Использование
async def main():
    async with AsyncDatabaseConnection('localhost') as db:
        result = await db.query("SELECT * FROM users")
        print(f"Результат: {result}")

asyncio.run(main())
# Вывод:
# Подключаюсь к localhost...
# Подключено к localhost
# Выполняю запрос: SELECT * FROM users
# Результат: Result
# Отключаюсь от localhost...
# Отключено от localhost
```

### **Async context manager через `@asynccontextmanager`:**

```python
from contextlib import asynccontextmanager
import asyncio

@asynccontextmanager
async def async_timer():
    start = asyncio.get_event_loop().time()
    print("Таймер запущен")
    try:
        yield
    finally:
        elapsed = asyncio.get_event_loop().time() - start
        print(f"Прошло {elapsed:.2f} сек")

# Использование
async def main():
    async with async_timer():
        print("Выполняю асинхронную операцию...")
        await asyncio.sleep(2)

asyncio.run(main())
# Вывод:
# Таймер запущен
# Выполняю асинхронную операцию...
# Прошло 2.00 сек
```

### **Практический пример — HTTP-клиент:**

```python
import asyncio
from contextlib import asynccontextmanager

@asynccontextmanager
async def http_session(url):
    print(f"Открываю HTTP-сессию для {url}")
    session = {"url": url, "connected": True}
    await asyncio.sleep(0.5)  # Имитация установки соединения
    
    try:
        yield session
    finally:
        print(f"Закрываю HTTP-сессию для {url}")
        session["connected"] = False
        await asyncio.sleep(0.2)  # Имитация закрытия

async def fetch_data():
    async with http_session("https://api.example.com") as session:
        print(f"Отправляю запрос к {session['url']}")
        await asyncio.sleep(1)
        print("Получен ответ")

asyncio.run(fetch_data())
# Вывод:
# Открываю HTTP-сессию для https://api.example.com
# Отправляю запрос к https://api.example.com
# Получен ответ
# Закрываю HTTP-сессию для https://api.example.com
```

### **Async блокировки:**

```python
import asyncio

async def worker(lock, worker_id):
    async with lock:  # asyncio.Lock — это async context manager
        print(f"Работник {worker_id} получил доступ")
        await asyncio.sleep(1)
        print(f"Работник {worker_id} завершил работу")

async def main():
    lock = asyncio.Lock()
    await asyncio.gather(
        worker(lock, 1),
        worker(lock, 2),
        worker(lock, 3)
    )

asyncio.run(main())
# Работники выполняются последовательно (по одному)
```

**Ключевые отличия:**

| Context Manager | Async Context Manager |
|----------------|----------------------|
| `__enter__` / `__exit__` | `__aenter__` / `__aexit__` |
| `with` | `async with` |
| Синхронные операции | Асинхронные операции (`await`) |
| Блокирующие вызовы | Неблокирующие вызовы |
| `exc_type, exc_val, exc_tb` в `__exit__` | `exc_type, exc_val, exc_tb` в `__aexit__` |

**Когда использовать:**
- **Context Manager**: файлы, блокировки потоков, транзакции БД
- **Async Context Manager**: async HTTP-клиенты, async БД, async файлы, async блокировки

[Еще реализация Context Manager](https://habr.com/ru/articles/739326/)

## `35.10` Async Decorator — декораторы для асинхронных функций
`Async Decorator` — это декоратор для асинхронных функций (`async def`), который сам должен быть асинхронным или корректно обрабатывать `await`. Позволяет добавлять дополнительную логику (логирование, таймеры, кеширование) к async функциям.

**Проблема:** обычный декоратор не работает с `async` функциями, так как они возвращают корутину, а не результат.

### **Простой async декоратор:**

```python
import asyncio
import functools

def async_timer(func):
    @functools.wraps(func)
    async def wrapper(*args, **kwargs):
        start = asyncio.get_event_loop().time()
        result = await func(*args, **kwargs)  # Важно: await!
        elapsed = asyncio.get_event_loop().time() - start
        print(f"{func.__name__} выполнилась за {elapsed:.2f} сек")
        return result
    return wrapper

@async_timer
async def fetch_data():
    print("Загружаю данные...")
    await asyncio.sleep(2)
    return "Данные получены"

# Использование
async def main():
    result = await fetch_data()
    print(result)

asyncio.run(main())
# Вывод:
# Загружаю данные...
# fetch_data выполнилась за 2.00 сек
# Данные получены
```

### **Декоратор с параметрами:**

```python
import asyncio
import functools

def async_retry(max_attempts=3, delay=1):
    """Повторяет async функцию при ошибке"""
    def decorator(func):
        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            for attempt in range(1, max_attempts + 1):
                try:
                    return await func(*args, **kwargs)
                except Exception as e:
                    print(f"Попытка {attempt}/{max_attempts} не удалась: {e}")
                    if attempt == max_attempts:
                        raise
                    await asyncio.sleep(delay)
        return wrapper
    return decorator

@async_retry(max_attempts=3, delay=0.5)
async def unstable_operation():
    import random
    if random.random() < 0.7:
        raise ValueError("Случайная ошибка")
    return "Успех!"

# Использование
async def main():
    result = await unstable_operation()
    print(result)

asyncio.run(main())
# Попытка 1/3 не удалась: Случайная ошибка
# Попытка 2/3 не удалась: Случайная ошибка
# Успех!
```

### **Кеширование async функций:**

```python
import asyncio
import functools

def async_cache(func):
    cache = {}
    
    @functools.wraps(func)
    async def wrapper(*args):
        if args in cache:
            print(f"Возвращаю из кеша: {args}")
            return cache[args]
        
        result = await func(*args)
        cache[args] = result
        return result
    
    return wrapper

@async_cache
async def expensive_calculation(n):
    print(f"Вычисляю для {n}...")
    await asyncio.sleep(2)
    return n * n

# Использование
async def main():
    print(await expensive_calculation(5))  # Вычисляет
    print(await expensive_calculation(5))  # Из кеша
    print(await expensive_calculation(10)) # Вычисляет

asyncio.run(main())
# Вывод:
# Вычисляю для 5...
# 25
# Возвращаю из кеша: (5,)
# 25
# Вычисляю для 10...
# 100
```

### **Логирование async функций:**

```python
import asyncio
import functools
from datetime import datetime

def async_logger(func):
    @functools.wraps(func)
    async def wrapper(*args, **kwargs):
        timestamp = datetime.now().strftime("%H:%M:%S")
        print(f"[{timestamp}] Вызов {func.__name__} с args={args}, kwargs={kwargs}")
        
        try:
            result = await func(*args, **kwargs)
            print(f"[{timestamp}] {func.__name__} вернула: {result}")
            return result
        except Exception as e:
            print(f"[{timestamp}] {func.__name__} вызвала ошибку: {e}")
            raise
    
    return wrapper

@async_logger
async def process_user(user_id, action="view"):
    await asyncio.sleep(1)
    return f"User {user_id}: {action}"

# Использование
async def main():
    await process_user(123, action="update")

asyncio.run(main())
# [14:30:45] Вызов process_user с args=(123,), kwargs={'action': 'update'}
# [14:30:45] process_user вернула: User 123: update
```

**Ключевые моменты:**
- Async декоратор должен быть `async def` и использовать `await func()`
- Обязательно используйте `@functools.wraps(func)` для сохранения метаданных
- Работает только с `async def` функциями
- Можно комбинировать несколько async декораторов

**Когда использовать:**
- Таймеры для async операций
- Retry логика для нестабильных async запросов
- Кеширование результатов async функций
- Логирование async вызовов


## `35.11` Dependency Injection — внедрение зависимостей
`Dependency Injection (DI)` — паттерн, при котором объект получает свои зависимости извне, а не создаёт их самостоятельно. Это делает код более гибким, тестируемым и слабо связанным.

**Проблема:** жёсткая связь между компонентами — объект сам создаёт свои зависимости, что усложняет тестирование и замену реализации.

**Решение:** передавать зависимости в объект снаружи (через конструктор, параметры функции или setter).

### **Пример 1: Без DI vs с DI**

```python
# Без Dependency Injection (плохо)
class EmailSender:
    def send(self, message):
        print(f"Email: {message}")

class UserService:
    def __init__(self):
        # Жёсткая зависимость — создаём внутри
        self.email_sender = EmailSender()
    
    def register_user(self, username):
        print(f"Регистрирую {username}")
        self.email_sender.send(f"Добро пожаловать, {username}!")

# Проблемы:
# 1. Нельзя заменить EmailSender на другую реализацию
# 2. Сложно тестировать (нельзя подставить mock)
service = UserService()
service.register_user("Alice")


# С Dependency Injection (хорошо)
class EmailSender:
    def send(self, message):
        print(f"Email: {message}")

class SMSSender:
    def send(self, message):
        print(f"SMS: {message}")

class UserService:
    def __init__(self, notifier):
        # Зависимость передаётся извне
        self.notifier = notifier
    
    def register_user(self, username):
        print(f"Регистрирую {username}")
        self.notifier.send(f"Добро пожаловать, {username}!")

# Теперь можно легко менять реализацию
email_service = UserService(EmailSender())
email_service.register_user("Alice")
# Регистрирую Alice
# Email: Добро пожаловать, Alice!

sms_service = UserService(SMSSender())
sms_service.register_user("Bob")
# Регистрирую Bob
# SMS: Добро пожаловать, Bob!
```

### **Пример 2: База данных с разными реализациями**

```python
# Разные реализации БД
class PostgresDB:
    def save(self, data):
        print(f"PostgreSQL: сохраняю {data}")

class InMemoryDB:
    def __init__(self):
        self.storage = []
    
    def save(self, data):
        self.storage.append(data)
        print(f"InMemory: сохранено {data}, всего: {len(self.storage)}")

# Сервис, который не зависит от конкретной БД
class ProductService:
    def __init__(self, database):
        self.db = database
    
    def add_product(self, product):
        print(f"Добавляю продукт: {product}")
        self.db.save(product)

# Production: используем PostgreSQL
prod_service = ProductService(PostgresDB())
prod_service.add_product("Ноутбук")
# Добавляю продукт: Ноутбук
# PostgreSQL: сохраняю Ноутбук

# Testing: используем InMemory
test_service = ProductService(InMemoryDB())
test_service.add_product("Мышь")
test_service.add_product("Клавиатура")
# Добавляю продукт: Мышь
# InMemory: сохранено Мышь, всего: 1
# Добавляю продукт: Клавиатура
# InMemory: сохранено Клавиатура, всего: 2
```

### **Пример 3: Тестирование с mock-объектом**

```python
class MockDatabase:
    """Заглушка для тестирования"""
    def __init__(self):
        self.saved_data = []
    
    def save(self, data):
        self.saved_data.append(data)

# Тестируемый сервис
class UserRepository:
    def __init__(self, db):
        self.db = db
    
    def create_user(self, username):
        user_data = {'username': username}
        self.db.save(user_data)
        return user_data

# Тест с mock-объектом
mock_db = MockDatabase()
repo = UserRepository(mock_db)
repo.create_user("TestUser")

# Проверяем, что данные сохранены
assert len(mock_db.saved_data) == 1
assert mock_db.saved_data[0]['username'] == "TestUser"
print("✓ Тест пройден")
```

**Преимущества:**
- **Гибкость** — легко менять реализацию зависимостей
- **Тестируемость** — можно подставлять mock-объекты
- **Слабая связанность** — компоненты не зависят от конкретных реализаций
- **Переиспользование** — одну зависимость можно использовать в разных местах

**Способы внедрения:**
1. **Constructor Injection** — через `__init__` (самый распространённый)
2. **Setter Injection** — через метод setter
3. **Parameter Injection** — через параметры функции

**Когда использовать:**
- Компонент зависит от внешних сервисов (БД, API, файлы)
- Нужна гибкая замена реализации
- Требуется тестируемость кода

[DI в Python & Популярных фреймворках](https://snyk.io/blog/dependency-injection-python/)

----

