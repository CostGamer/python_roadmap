# Правила
- Все что не отмечено звездочкой надо точно и уверено знать  
- `*` - must have for interview  
- `**` - for flex in the interview

----

# `1` Python
## `1.1` Что такое компилируемых и интерпретируемых языки? В чем их отличие?
**Компилируемые языки** (C, C++, Rust, Go) — код сначала полностью переводится (компилируется) в машинный код (понятный процессору), затем выполняется. Компиляция происходит один раз, потом программа запускается напрямую.

**Интерпретируемые языки** (Python, JavaScript, Ruby) — код выполняется построчно специальной программой (интерпретатором), которая переводит и выполняет команды "на лету", без предварительной компиляции.

**Основные отличия:**

| Характеристика | Компилируемые | Интерпретируемые |
|----------------|---------------|------------------|
| **Скорость выполнения** | Быстрее (машинный код) | Медленнее (перевод на лету) |
| **Запуск** | Нужна компиляция перед запуском | Сразу запускается |
| **Ошибки** | Находятся при компиляции | Находятся при выполнении |
| **Переносимость** | Нужна перекомпиляция для разных ОС | Один код работает везде (где есть интерпретатор) |
| **Отладка** | Сложнее | Проще |

**Важно:** Python — гибридный язык. Код сначала компилируется в байт-код (`.pyc` файлы), который затем выполняется виртуальной машиной Python (PVM). Это промежуточный вариант между чистой интерпретацией и компиляцией.

**Пример:**
```python
# Python — интерпретируемый
print("Hello")  # Выполняется сразу при запуске

# C — компилируемый
// Сначала компиляция: gcc program.c -o program
// Затем запуск: ./program
```

## `1.2` Плюсы и минусы `Python`
**Плюсы:**

✅ **Простой синтаксис** — легко читать и писать, быстрое обучение  
✅ **Кроссплатформенность** — работает на Windows, Linux, macOS  
✅ **Огромная экосистема** — библиотеки для любых задач (numpy, pandas, django, tensorflow)  
✅ **Высокая продуктивность** — быстрая разработка, меньше кода  
✅ **Динамическая типизация** — не нужно объявлять типы переменных  
✅ **Большое сообщество** — много обучающих материалов, готовых решений  
✅ **Универсальность** — веб, анализ данных, ML, автоматизация, скрипты  
✅ **Встроенные структуры данных** — списки, словари, множества из коробки  

**Минусы:**

❌ **Низкая скорость** — медленнее C/C++/Java в 10-100 раз  
❌ **Высокое потребление памяти** — объекты занимают больше места  
❌ **GIL (Global Interpreter Lock)** — проблемы с многопоточностью для CPU-задач  
❌ **Мобильная разработка** — слабая поддержка iOS/Android  
❌ **Динамическая типизация** — ошибки типов находятся только во время выполнения  
❌ **Зависимости** — сложное управление версиями библиотек  
❌ **Плохо для низкоуровневого программирования** — системное ПО, драйверы  

**Пример:**
```python
# Плюс: простота
numbers = [1, 2, 3, 4, 5]
squares = [x**2 for x in numbers]  # Лаконично!

# Минус: скорость
# Сумма 100 млн чисел в Python — несколько секунд
# В C — доли секунды
```

## `1.3` Какие задачи решает `Python`?
**Основные области применения:**

1. **Веб-разработка** (Django, Flask, FastAPI)
   - Бэкенд для сайтов и API
   - Пример: Instagram, Spotify, YouTube используют Python

2. **Анализ данных и Data Science** (pandas, numpy, matplotlib)
   - Обработка больших данных
   - Визуализация
   - Статистический анализ

3. **Machine Learning и AI** (scikit-learn, TensorFlow, PyTorch)
   - Обучение моделей
   - Компьютерное зрение
   - Обработка естественного языка (NLP)

4. **Автоматизация и скрипты**
   - Парсинг сайтов (BeautifulSoup, Selenium)
   - Автоматизация рутинных задач
   - Работа с файлами и системой

5. **Научные вычисления** (scipy, sympy)
   - Математические расчёты
   - Моделирование
   - Исследования

6. **Тестирование** (pytest, unittest)
   - Автоматическое тестирование ПО
   - CI/CD пайплайны

7. **DevOps и администрирование**
   - Настройка серверов (Ansible)
   - Мониторинг систем
   - Деплой приложений

8. **Разработка игр** (Pygame)
   - Инди-игры
   - Прототипирование

**Где Python НЕ используется:**
- Мобильные приложения (лучше Swift/Kotlin)
- Системное программирование (лучше C/Rust)
- Высоконагруженные real-time системы (лучше C++/Go)
- Встроенные системы с малой памятью

----

# `2` Ввод - вывод
## `2.1` print()
### `2.1.1` Как работает `print()`?
`print()` — встроенная функция для вывода данных на экран (в консоль). Она принимает любые значения, преобразует их в строку и отображает.

**Примеры:**
```python
print("Привет, мир!")  # Привет, мир!
print(42)              # 42
print(3.14)            # 3.14
print(True)            # True

# Можно выводить несколько значений через запятую
print("Мне", 25, "лет")  # Мне 25 лет
```

### `2.1.2` Что такон аргумент?
**Аргумент** — это значение, которое мы передаём в функцию в круглых скобках. Функция использует эти значения для своей работы.

**Примеры:**
```python
print("Текст")  # "Текст" — это аргумент функции print()
print(10, 20)   # 10 и 20 — два аргумента

# У функций может быть разное количество аргументов
print()                      # 0 аргументов — выведет пустую строку
print("один")                # 1 аргумент
print("один", "два", "три")  # 3 аргумента
```

## `2.2` input()
### `2.2.1` Как работает `input()`? Что принимает `input()`?
`input()` — функция для получения данных от пользователя. Она:
1. Останавливает программу и ждёт ввода
2. Выводит приглашение (если передан аргумент)
3. Возвращает введённый текст как **строку**

**Важно:** `input()` всегда возвращает строку, даже если вы вводите число!

**Примеры:**
```python
# Без приглашения
name = input()  # Ждёт ввода, курсор мигает

# С приглашением (текстом-подсказкой)
name = input("Введите ваше имя: ")  # Введите ваше имя: _
print("Привет,", name)

age = input("Сколько вам лет? ")  # Сколько вам лет? 25
print(age)        # "25" — это строка!
print(type(age))  # <class 'str'>
```

### `2.2.2` Что такое переменная? Как можно и принято называть переменную?
**Переменная** — это "контейнер" для хранения данных. Она имеет имя, по которому можно обращаться к сохранённому значению.

**Правила именования:**
- Только латинские буквы, цифры и подчёркивание `_`
- Не может начинаться с цифры
- Регистр важен: `name` и `Name` — разные переменные
- Нельзя использовать зарезервированные слова (`if`, `for`, `print` и т.д.)

**Стиль именования (PEP8):**
- `snake_case` — слова через подчёркивание (рекомендуется)
- Имя должно быть понятным и описывать содержимое

**Примеры:**
```python
# Правильные имена
name = "Иван"
user_age = 25
total_price = 1500
is_active = True
_private = 10  # Начинается с _, но допустимо

# Неправильные имена
# 2name = "Ошибка"      # Начинается с цифры
# user-age = 25         # Дефис запрещён
# class = "A"           # Зарезервированное слово

# Плохой стиль (работает, но не рекомендуется)
x = 25          # Неинформативное имя
userName = 25   # camelCase не принят в Python для переменных
USERAGE = 25    # Заглавные буквы для констант

# Хороший стиль
user_name = "Пётр"
user_age = 30
total_sum = 5000
```

### `2.2.3` Что такое комментарий и как его делать?
**Комментарий** — текст, который игнорируется Python и нужен для пояснений в коде. Помогает понять, что делает программа.

**Виды комментариев:**
- `#` — однострочный комментарий
- `'''...'''` или `"""..."""` — многострочный комментарий (технически это строки, но используются как комментарии)

**Примеры:**
```python
# Это однострочный комментарий

print("Привет")  # Комментарий в конце строки

# Вычисляем сумму
a = 10
b = 20
total = a + b  # Сохраняем результат

"""
Это многострочный комментарий.
Он может занимать несколько строк.
Используется для документации.
"""

'''
Тоже многострочный комментарий,
только с одинарными кавычками.
'''
```

### `2.2.4` Несколько переменных в `print()`
`print()` может выводить несколько значений через запятую. Они автоматически разделяются пробелом.

**Примеры:**
```python
name = "Анна"
age = 28

print("Имя:", name)  # Имя: Анна
print("Возраст:", age)  # Возраст: 28

# Несколько переменных сразу
print("Меня зовут", name, "и мне", age, "лет")
# Меня зовут Анна и мне 28 лет

# Можно смешивать переменные и текст
city = "Москва"
print(name, "живёт в городе", city)  # Анна живёт в городе Москва
```

### `2.2.5` Переменные в `input()`
Можно использовать переменные в тексте приглашения `input()`, чтобы делать запросы более персонализированными.

**Примеры:**
```python
name = input("Как вас зовут? ")  # Как вас зовут? Иван
print("Привет,", name)

# Использование переменной в следующем input()
age = input(name + ", сколько вам лет? ")  # Иван, сколько вам лет? 25

# Или через запятую (более читабельно)
city = input("Где вы живёте,", name, "?")  # Где вы живёте, Иван ? 

# Лучше использовать f-строки (об этом позже)
hobby = input(f"{name}, какое у вас хобби? ")  # Иван, какое у вас хобби?
```

### `2.2.6` Параметры `sep` & `end` в `print()`
У `print()` есть дополнительные параметры:
- `sep` (separator) — разделитель между значениями (по умолчанию пробел `" "`)
- `end` — что добавить в конец (по умолчанию перевод строки `"\n"`)

**Примеры:**
```python
# Параметр sep
print(1, 2, 3)           # 1 2 3 (пробелы по умолчанию)
print(1, 2, 3, sep="-")  # 1-2-3
print(1, 2, 3, sep=" | ")  # 1 | 2 | 3
print(1, 2, 3, sep="")   # 123 (без разделителя)

# Параметр end
print("Первая строка")
print("Вторая строка")
# Первая строка
# Вторая строка

print("Первая строка", end=" ")
print("Вторая строка")
# Первая строка Вторая строка (в одной строке!)

print("Загрузка", end="...")
print("Готово!")
# Загрузка...Готово!

# Оба параметра вместе
print("Яблоко", "Груша", "Банан", sep=", ", end=".\n")
# Яблоко, Груша, Банан.

# Практический пример — прогресс бар
print("Загрузка: ", end="")
print("█", "█", "█", sep="", end=" ")
print("30%")
# Загрузка: ███ 30%
```

## `2.3` PEP8
### `2.3.1` Что такое `PEP8`?
**PEP8** (Python Enhancement Proposal 8) — официальный стандарт оформления кода на Python. Это набор правил, которые делают код читабельным и единообразным. Все Python-программисты следуют PEP8.

**Зачем нужен:**
- Код легче читать
- Проще работать в команде
- Меньше ошибок

### `2.3.2` Обшие рекомендации  
**Основные правила PEP8:**

**1. Отступы:**
- 4 пробела (не табуляция!)

**2. Длина строки:**
- Максимум 79 символов

**3. Пустые строки:**
- 2 пустые строки между функциями/классами
- 1 пустая строка между методами

**4. Пробелы:**
- После запятых: `print(1, 2, 3)` ✅, не `print(1,2,3)` ❌
- Вокруг операторов: `x = 5 + 3` ✅, не `x=5+3` ❌
- Не перед скобками: `print("text")` ✅, не `print ("text")` ❌

**5. Имена:**
- Переменные и функции: `snake_case`
- Константы: `UPPER_CASE`
- Классы: `PascalCase`

**Примеры:**
```python
# ✅ Правильно
user_name = "Иван"
user_age = 25
total_sum = user_age * 100

print("Привет,", user_name)
print("Сумма:", total_sum)

# ❌ Неправильно
userName="Иван"  # camelCase и нет пробелов
user_age=25
totalSum=user_age*100  # Нет пробелов вокруг операторов

print("Привет,",user_name)  # Пробел после запятой
print( "Сумма:",totalSum )  # Лишние пробелы внутри скобок
```

## `2.4` Целочисленные операции
### `2.4.1` `int()`, `int(input())`
`int()` — функция для преобразования в целое число.  
`input()` всегда возвращает строку, поэтому для работы с числами нужно преобразование.

**Примеры:**
```python
# Преобразование строки в число
age = "25"
age_number = int(age)
print(age_number + 5)  # 30

# input() возвращает строку
age = input("Возраст: ")  # Возраст: 25
print(age + 5)  # Ошибка! Нельзя складывать строку и число

# Правильно — сначала преобразуем
age = int(input("Возраст: "))  # Возраст: 25
print(age + 5)  # 30

# Несколько чисел
a = int(input("Первое число: "))
b = int(input("Второе число: "))
print("Сумма:", a + b)
```

### `2.4.2` Математические операции

Python поддерживает стандартные математические операции с числами.

**Примеры:**
```python
a = 10
b = 3

print(a + b)  # 13 — сложение
print(a - b)  # 7  — вычитание
print(a * b)  # 30 — умножение
print(a / b)  # 3.333... — деление (всегда float)

# Пример с input()
x = int(input("Введите число: "))  # 5
y = int(input("Введите число: "))  # 2

print("Сумма:", x + y)        # 7
print("Разность:", x - y)     # 3
print("Произведение:", x * y) # 10
print("Частное:", x / y)      # 2.5
```

### `2.4.3` Операторы: (), **, //, %  
Дополнительные математические операторы:
- `()` — скобки (приоритет операций)
- `**` — возведение в степень
- `//` — целочисленное деление (отбрасывает дробную часть)
- `%` — остаток от деления (модуль)

**Примеры:**
```python
# Скобки — приоритет операций
print(2 + 3 * 4)      # 14 (сначала умножение)
print((2 + 3) * 4)    # 20 (сначала скобки)

# Возведение в степень
print(2 ** 3)   # 8 (2 в степени 3)
print(5 ** 2)   # 25 (5 в квадрате)
print(10 ** 0)  # 1 (любое число в степени 0 = 1)

# Целочисленное деление
print(10 / 3)   # 3.333... — обычное деление
print(10 // 3)  # 3 — отбрасываем дробную часть
print(17 // 5)  # 3
print(20 // 6)  # 3

# Остаток от деления (модуль)
print(10 % 3)   # 1 (10 = 3*3 + 1)
print(17 % 5)   # 2 (17 = 5*3 + 2)
print(20 % 6)   # 2 (20 = 6*3 + 2)
print(15 % 5)   # 0 (делится нацело)

# Практические примеры
# Проверка чётности
number = int(input("Число: "))  # 7
print(number % 2)  # 1 (нечётное), если бы 8 — было бы 0 (чётное)

# Вычисление последней цифры числа
number = 12345
last_digit = number % 10
print(last_digit)  # 5

# Конвертация минут в часы и минуты
total_minutes = 125
hours = total_minutes // 60  # 2 часа
minutes = total_minutes % 60 # 5 минут
print(f"{hours} ч {minutes} мин")  # 2 ч 5 мин
```

----

# `3` Условный оператор
## `3.1` `if-else`
`if-else` — конструкция для выполнения кода в зависимости от условия. Если условие истинно (`True`) — выполняется один блок кода, если ложно (`False`) — другой.

**Структура:**
```python
if условие:
    # код, если условие True
else:
    # код, если условие False
```

**Варианты:**
- `if` — только проверка условия
- `if-else` — два варианта (да/нет)
- `if-elif-else` — несколько условий

**Примеры:**

```python
# Пример 1: Простой if
age = 18
if age >= 18:
    print("Вы совершеннолетний")
# Вы совершеннолетний

# Пример 2: if-else
age = 15
if age >= 18:
    print("Вы совершеннолетний")
else:
    print("Вы несовершеннолетний")
# Вы несовершеннолетний

# Пример 3: if-elif-else (несколько условий)
score = 85

if score >= 90:
    print("Отлично!")
elif score >= 70:
    print("Хорошо")
elif score >= 50:
    print("Удовлетворительно")
else:
    print("Неудовлетворительно")
# Хорошо

# Пример 4: Вложенные условия
age = 20
has_license = True

if age >= 18:
    if has_license:
        print("Можете водить автомобиль")
    else:
        print("Нужны права")
else:
    print("Слишком молоды для вождения")
# Можете водить автомобиль

# Пример 5: С input()
password = input("Введите пароль: ")

if password == "secret123":
    print("Доступ разрешён")
else:
    print("Неверный пароль")

# Пример 6: Несколько elif
temperature = int(input("Температура: "))

if temperature > 30:
    print("Жарко")
elif temperature > 20:
    print("Тепло")
elif temperature > 10:
    print("Прохладно")
elif temperature > 0:
    print("Холодно")
else:
    print("Мороз")
```

## `3.2` Что такое табуляция?
**Табуляция (отступ)** — пробелы в начале строки, которые показывают, что код принадлежит определённому блоку. В Python отступы **обязательны** и определяют структуру программы.

**Важно:**
- В Python используются **4 пробела** (стандарт PEP8)
- Нельзя смешивать табуляцию (клавиша Tab) и пробелы
- Отступы показывают вложенность кода

**Примеры:**

```python
# ✅ Правильно — 4 пробела
if True:
    print("Это внутри if")
    print("И это тоже")
print("А это снаружи")

# ❌ Ошибка — нет отступа
if True:
print("Ошибка!")  # IndentationError

# ✅ Вложенные блоки — по 4 пробела на уровень
age = 20
has_ticket = True

if age >= 18:              # 0 пробелов
    if has_ticket:         # 4 пробела
        print("Проходите") # 8 пробелов
    else:                  # 4 пробела
        print("Нужен билет") # 8 пробелов
else:                      # 0 пробелов
    print("Слишком молоды") # 4 пробела

# ❌ Ошибка — разные отступы
if True:
    print("4 пробела")
  print("2 пробела")  # IndentationError!

# Пример с несколькими уровнями
number = 15

if number > 0:                           # Уровень 0
    print("Число положительное")         # Уровень 1
    if number % 2 == 0:                  # Уровень 1
        print("И чётное")                # Уровень 2
    else:                                # Уровень 1
        print("И нечётное")              # Уровень 2
        if number > 10:                  # Уровень 2
            print("И больше 10")         # Уровень 3
```

**Почему это важно:**
```python
# Код без правильных отступов работать не будет
x = 5
if x > 0:
print("Положительное")  # Ошибка!

# С отступами — всё работает
x = 5
if x > 0:
    print("Положительное")  # ✅
```

## `3.3` Какие есть операторы сравнения? Цепочки сравнения и транзитивность
**Операторы сравнения** — специальные символы для сравнения значений. Результат сравнения — всегда `True` или `False`.

**Основные операторы:**
- `==` — равно
- `!=` — не равно
- `>` — больше
- `<` — меньше
- `>=` — больше или равно
- `<=` — меньше или равно

**Важно:** `=` это присваивание, а `==` это сравнение!

**Примеры базовых сравнений:**

```python
# Сравнение чисел
print(5 == 5)   # True
print(5 == 3)   # False
print(5 != 3)   # True
print(5 > 3)    # True
print(5 < 3)    # False
print(5 >= 5)   # True
print(5 <= 4)   # False

# В условиях
age = 18
if age >= 18:
    print("Совершеннолетний")

# Сравнение строк
name = "Иван"
if name == "Иван":
    print("Привет, Иван!")

password = input("Пароль: ")
if password != "12345":
    print("Неверный пароль")
```

**Цепочки сравнений:**
Python позволяет записывать несколько сравнений подряд — это короче и понятнее, чем использовать логические операторы `and`.

**Примеры:**

```python
# Обычный способ (с and)
x = 15
if x > 10 and x < 20:
    print("x между 10 и 20")

# Цепочка сравнений (pythonic way!)
x = 15
if 10 < x < 20:
    print("x между 10 и 20")
# Читается как в математике: "10 меньше x и x меньше 20"

# Проверка диапазона
age = 25
if 18 <= age <= 65:
    print("Трудоспособный возраст")

# Сложные цепочки
a = 5
b = 10
c = 15
if a < b < c:
    print("Возрастающая последовательность")  # ✅

# Можно использовать разные операторы
score = 75
if 0 <= score <= 100:
    print("Корректный балл")

# Эквивалентно:
if score >= 0 and score <= 100:
    print("Корректный балл")

# Практический пример
temperature = int(input("Температура: "))
if 20 <= temperature <= 25:
    print("Комфортная температура")
elif temperature < 20:
    print("Холодно")
else:
    print("Жарко")
```

**Транзитивность:**
**Транзитивность** — математическое свойство: если `a < b` и `b < c`, то автоматически `a < c`. Python использует это в цепочках сравнений.

**Как работает:**
Цепочка `a < b < c` означает `(a < b) and (b < c)`, но:
- **Важно:** `b` вычисляется только один раз
- Python проверяет все части цепочки последовательно
- Если любая часть `False` — вся цепочка `False`

**Примеры:**

```python
# Пример 1: Транзитивность в действии
a = 5
b = 10
c = 15

# Цепочка
if a < b < c:
    print("a меньше b, и b меньше c")  # ✅
    print("Значит, a точно меньше c (транзитивность)")

# Эквивалентно
if (a < b) and (b < c):
    print("То же самое")

# Пример 2: Оптимизация — b вычисляется один раз
def get_value():
    print("Функция вызвана")
    return 10

# С цепочкой — функция вызывается ОДИН раз
if 5 < get_value() < 15:
    print("Условие истинно")
# Функция вызвана
# Условие истинно

# Без цепочки — функция вызывается ДВА раза
if 5 < get_value() and get_value() < 15:
    print("Условие истинно")
# Функция вызвана
# Функция вызвана
# Условие истинно

# Пример 3: Когда транзитивность не работает
x = 10
y = 5
z = 15

if x < y < z:
    print("Не выполнится")
# x < y это False, поэтому вся цепочка False
# Python даже не проверяет y < z

# Пример 4: Смешанные операторы
a = 5
b = 5
c = 10

if a <= b < c:
    print("a меньше или равно b, и b меньше c")  # ✅

# Пример 5: Проверка вхождения в диапазон
min_value = 0
max_value = 100
user_input = int(input("Введите число от 0 до 100: "))

if min_value <= user_input <= max_value:
    print("Число в допустимом диапазоне")
else:
    print("Число вне диапазона")

# Пример 6: Несколько переменных
a = 1
b = 2
c = 3
d = 4

# Длинная цепочка
if a < b < c < d:
    print("Все числа в порядке возрастания")  # ✅

# Эквивалентно (но длиннее):
if (a < b) and (b < c) and (c < d):
    print("То же самое")
```

**Преимущества цепочек:**
- ✅ Короче и понятнее
- ✅ Читается как математическая запись
- ✅ Промежуточное значение вычисляется один раз
- ✅ Меньше скобок

**Когда использовать:**
```python
# ✅ Используй цепочки для диапазонов
if 0 <= age <= 100:
    pass

# ❌ Не используй для несвязанных условий
# Плохо:
if x < 10 < y:  # Непонятно, связаны ли x и y

# Хорошо:
if x < 10 and something_else < y:
    pass
```

## `3.4` Логические операции: `and`, `or`, `not`
Логические операции используются для комбинирования условий и работы с булевыми значениями (`True` и `False`).

### **Оператор `and` (логическое И)**
Возвращает `True`, только если **оба** операнда истинны.

```python
print(True and True)    # True
print(True and False)   # False
print(False and True)   # False
print(False and False)  # False

# Практический пример
age = 25
has_license = True

if age >= 18 and has_license:
    print("Можешь водить машину")  # Выведет: Можешь водить машину

# С числами (непустые значения считаются True)
x = 5
if x > 0 and x < 10:
    print("x находится между 0 и 10")  # Выведет: x находится между 0 и 10
```

### **Оператор `or` (логическое ИЛИ)**
Возвращает `True`, если **хотя бы один** операнд истинен.

```python
print(True or True)     # True
print(True or False)    # True
print(False or True)    # True
print(False or False)   # False

# Практический пример
is_weekend = False
is_holiday = True

if is_weekend or is_holiday:
    print("Можно отдыхать!")  # Выведет: Можно отдыхать!

# Проверка нескольких условий
role = "admin"
if role == "admin" or role == "moderator":
    print("Доступ разрешён")  # Выведет: Доступ разрешён
```

### **Оператор `not` (логическое НЕ)**
Инвертирует булево значение: `True` становится `False` и наоборот.

```python
print(not True)   # False
print(not False)  # True

# Практический пример
is_logged_in = False

if not is_logged_in:
    print("Пожалуйста, войдите в систему")  # Выведет: Пожалуйста, войдите в систему

# Проверка на пустоту
items = []
if not items:
    print("Список пуст")  # Выведет: Список пуст
```

### **Возвращаемые значения (не только True/False)**

В Python логические операторы возвращают **сам операнд**, а не обязательно `True` или `False`.

```python
# and возвращает первый False или последний операнд
print(5 and 10)      # 10 (оба истинны, вернули последний)
print(0 and 10)      # 0 (первый ложный)
print(5 and 0)       # 0 (второй ложный)
print("" and "hi")   # "" (пустая строка ложная)

# or возвращает первый True или последний операнд
print(5 or 10)       # 5 (первый истинный)
print(0 or 10)       # 10 (второй истинный)
print(0 or "")       # "" (оба ложные, вернули последний)
print(None or "default")  # "default" (часто для значений по умолчанию)

# Практическое применение
username = input("Имя: ") or "Гость"  # Если пустой ввод, то "Гость"
print(f"Привет, {username}!")
```


## `3.5` (`*`) Комбинирование и приоритизация логических операций  
При комбинировании нескольких логических операторов важно понимать порядок их выполнения.

### **Приоритет логических операторов:**
1. **`not`** — выполняется первым (наивысший приоритет)
2. **`and`** — выполняется вторым
3. **`or`** — выполняется последним (наименьший приоритет)

```python
# Пример без скобок
result = True or False and False
# Сначала: False and False = False
# Затем: True or False = True
print(result)  # True

# То же самое с явными скобками
result = True or (False and False)
print(result)  # True

# С оператором not
result = not True or False
# Сначала: not True = False
# Затем: False or False = False
print(result)  # False

# Более сложный пример
result = not False and True or False
# 1. not False = True
# 2. True and True = True
# 3. True or False = True
print(result)  # True
```

### **Использование скобок для ясности**

Даже зная приоритет, **всегда используйте скобки** для сложных выражений — это улучшает читаемость.

```python
age = 25
has_license = True
has_car = False

# Без скобок (может быть неочевидно)
can_drive = age >= 18 and has_license or has_car
print(can_drive)  # True

# Со скобками (понятнее)
can_drive = (age >= 18 and has_license) or has_car
print(can_drive)  # True

# Другая группировка даёт другой результат
can_drive = age >= 18 and (has_license or has_car)
print(can_drive)  # True
```

### **Практические примеры комбинирования**

```python
# Проверка диапазона
x = 15
if x > 10 and x < 20:
    print("x между 10 и 20")  # Выведет: x между 10 и 20

# Альтернативная запись (более питоническая)
if 10 < x < 20:
    print("x между 10 и 20")  # Выведет: x между 10 и 20

# Сложное условие с несколькими операторами
role = "user"
is_verified = True
age = 20

if (role == "admin" or role == "moderator") and is_verified and age >= 18:
    print("Полный доступ")
else:
    print("Ограниченный доступ")  # Выведет: Ограниченный доступ

# Проверка с not
password = "12345"
if not (len(password) >= 8 and password.isalnum()):
    print("Слабый пароль")  # Выведет: Слабый пароль

# Множественные условия
score = 85
attendance = 90

# Сначала and, потом or
if score >= 90 or score >= 80 and attendance >= 85:
    print("Отлично!")  # Выведет: Отлично!
    # Выполнится: score >= 80 and attendance >= 85 = True
    # Затем: False or True = True

# С явными скобками для другой логики
if (score >= 90 or score >= 80) and attendance >= 85:
    print("Хорошо!")  # Выведет: Хорошо!
```

### **Таблица истинности для комбинаций**

```python
# Все возможные комбинации для двух переменных
A = True
B = False

print(f"A and B = {A and B}")        # False
print(f"A or B = {A or B}")          # True
print(f"not A = {not A}")            # False
print(f"not A and B = {not A and B}")  # False
print(f"not A or B = {not A or B}")    # False
print(f"A and not B = {A and not B}")  # True
print(f"not (A and B) = {not (A and B)}")  # True (закон Де Моргана)
print(f"not A or not B = {not A or not B}")  # True (эквивалентно предыдущему)
```

**Важные правила:**
- Всегда используйте скобки для сложных выражений
- `not` имеет наивысший приоритет
- `and` выполняется раньше `or`
- Python использует короткое замыкание — вычисления останавливаются, как только результат становится очевидным

## `3.6` Вложенные условия
**Вложенные условия** — это `if` внутри другого `if`. Используются, когда нужно проверить дополнительное условие только после выполнения первого. Каждый уровень вложенности добавляет 4 пробела отступа.

**Когда использовать:**
- Условие зависит от предыдущего
- Нужна последовательная проверка
- Логика требует "если А, то проверить Б"

**Примеры:**

```python
# Пример 1: Простая вложенность
age = 20
has_license = True

if age >= 18:
    print("Возраст подходит")
    if has_license:
        print("Можете водить автомобиль")
    else:
        print("Нужно получить права")
else:
    print("Слишком молоды для вождения")

# Пример 2: Проверка логина и пароля
login = input("Логин: ")
password = input("Пароль: ")

if login == "admin":
    if password == "12345":
        print("Добро пожаловать, администратор!")
    else:
        print("Неверный пароль")
else:
    print("Пользователь не найден")

# Пример 3: Множественная вложенность
number = int(input("Введите число: "))

if number > 0:
    print("Число положительное")
    if number % 2 == 0:
        print("И чётное")
        if number > 100:
            print("И больше 100")
        else:
            print("И меньше или равно 100")
    else:
        print("И нечётное")
else:
    if number == 0:
        print("Это ноль")
    else:
        print("Число отрицательное")

# Пример 4: Проверка скидки
price = 1000
is_member = True
has_coupon = True

if is_member:
    print("Скидка 10% для участников")
    if has_coupon:
        print("Дополнительная скидка 5% по купону")
        final_price = price * 0.85  # 15% общая скидка
    else:
        final_price = price * 0.9   # 10% скидка
else:
    if has_coupon:
        print("Скидка 5% по купону")
        final_price = price * 0.95
    else:
        final_price = price

print(f"Итоговая цена: {final_price}")

# Пример 5: Проверка доступа к контенту
age = int(input("Ваш возраст: "))
has_subscription = input("Есть подписка? (да/нет): ") == "да"

if age >= 18:
    if has_subscription:
        print("Полный доступ ко всему контенту")
    else:
        print("Доступ к бесплатному контенту для взрослых")
        print("Оформите подписку для полного доступа")
else:
    if has_subscription:
        print("Доступ к детскому контенту")
        print("Взрослый контент недоступен")
    else:
        print("Доступ только к демо-версии")
```

**Важно:**
- Не делайте слишком много уровней вложенности (более 3-4 тяжело читать)
- Часто вложенные условия можно упростить логическими операторами

**Упрощение вложенных условий:**

```python
# Вложенные условия (сложнее читать)
age = 20
has_license = True

if age >= 18:
    if has_license:
        print("Можете водить")

# То же самое через логический оператор (проще)
if age >= 18 and has_license:
    print("Можете водить")

# Но иногда вложенность нужна для разных действий
if age >= 18:
    print("Совершеннолетний")  # Выполнится в любом случае
    if has_license:
        print("Можете водить")
else:
    print("Несовершеннолетний")
```

## `3.7` Каскадные условия. Что такое `elif`
**Каскадные условия (elif)** — способ проверить несколько взаимоисключающих условий по порядку. `elif` это сокращение от "else if" (иначе если).

**Как работает:**
1. Python проверяет `if` — если `True`, выполняет его блок и **пропускает остальные**
2. Если `if` был `False`, проверяет первый `elif`
3. Если и он `False`, проверяет следующий `elif`
4. Если все `False`, выполняется `else` (если он есть)

**Важно:** Выполняется **только один** блок — первый, где условие `True`!

**Структура:**
```python
if условие1:
    # код, если условие1 True
elif условие2:
    # код, если условие1 False, а условие2 True
elif условие3:
    # код, если условие1 и условие2 False, а условие3 True
else:
    # код, если все условия False
```

**Примеры:**

```python
# Пример 1: Базовый elif
score = 85

if score >= 90:
    print("Оценка: 5")
elif score >= 70:
    print("Оценка: 4")
elif score >= 50:
    print("Оценка: 3")
else:
    print("Оценка: 2")
# Оценка: 4

# Пример 2: Дни недели
day = int(input("Номер дня (1-7): "))

if day == 1:
    print("Понедельник")
elif day == 2:
    print("Вторник")
elif day == 3:
    print("Среда")
elif day == 4:
    print("Четверг")
elif day == 5:
    print("Пятница")
elif day == 6:
    print("Суббота")
elif day == 7:
    print("Воскресенье")
else:
    print("Некорректный номер дня")

# Пример 3: Определение возрастной категории
age = int(input("Ваш возраст: "))

if age < 0:
    print("Некорректный возраст")
elif age < 7:
    print("Дошкольник")
elif age < 18:
    print("Школьник")
elif age < 25:
    print("Студент")
elif age < 65:
    print("Работающий")
else:
    print("Пенсионер")

# Пример 4: Температурные диапазоны
temperature = int(input("Температура воздуха: "))

if temperature > 35:
    print("Экстремальная жара")
elif temperature > 25:
    print("Жарко")
elif temperature > 15:
    print("Тепло")
elif temperature > 5:
    print("Прохладно")
elif temperature > -5:
    print("Холодно")
elif temperature > -15:
    print("Очень холодно")
else:
    print("Экстремальный мороз")

# Пример 5: Только первое условие выполняется!
number = 100

if number > 50:
    print("Больше 50")  # ✅ Выполнится
elif number > 75:
    print("Больше 75")  # Пропустится, хотя условие True!
elif number > 90:
    print("Больше 90")  # Пропустится
# Вывод: Больше 50

# Чтобы проверить все, нужны отдельные if:
if number > 50:
    print("Больше 50")
if number > 75:
    print("Больше 75")
if number > 90:
    print("Больше 90")
# Вывод:
# Больше 50
# Больше 75
# Больше 90
```

**Сравнение: elif vs несколько if**

```python
# С elif — только одно условие выполнится
score = 85

if score >= 70:
    print("Хорошо")      # ✅ Выполнится
elif score >= 50:
    print("Нормально")   # Пропустится
elif score >= 0:
    print("Плохо")       # Пропустится
# Вывод: Хорошо

# С несколькими if — все True условия выполнятся
score = 85

if score >= 70:
    print("Хорошо")      # ✅ Выполнится
if score >= 50:
    print("Нормально")   # ✅ Выполнится
if score >= 0:
    print("Плохо")       # ✅ Выполнится
# Вывод:
# Хорошо
# Нормально
# Плохо
```

**Когда использовать elif:**
- ✅ Взаимоисключающие варианты (оценка, день недели, категория)
- ✅ Нужно выполнить только один блок кода
- ✅ Проверка диапазонов значений

**Когда использовать отдельные if:**
- ✅ Независимые условия
- ✅ Нужно проверить все условия
- ✅ Несколько действий могут быть одновременно

**Практический пример — калькулятор:**

```python
a = int(input("Первое число: "))
b = int(input("Второе число: "))
operation = input("Операция (+, -, *, /): ")

if operation == "+":
    print(f"Результат: {a + b}")
elif operation == "-":
    print(f"Результат: {a - b}")
elif operation == "*":
    print(f"Результат: {a * b}")
elif operation == "/":
    if b != 0:
        print(f"Результат: {a / b}")
    else:
        print("Ошибка: деление на ноль")
else:
    print("Неизвестная операция")
```

**Типичные ошибки:**

```python
# ❌ Ошибка: неправильный порядок условий
age = 15

if age > 0:
    print("Возраст положительный")  # Всегда выполнится первым
elif age < 18:
    print("Несовершеннолетний")     # Никогда не выполнится!

# ✅ Правильно: от более конкретного к общему
if age < 18:
    print("Несовершеннолетний")
elif age > 0:
    print("Возраст положительный")

# ❌ Ошибка: забыли elif
number = 5

if number > 0:
    print("Положительное")
else number < 0:  # SyntaxError! Нужен elif
    print("Отрицательное")

# ✅ Правильно:
if number > 0:
    print("Положительное")
elif number < 0:
    print("Отрицательное")
else:
    print("Ноль")
```

## `3.8` (`*`) `match-case`
`match-case` — современная конструкция для сопоставления значений с образцами (pattern matching). Появилась в Python 3.10. Это более мощная и читаемая альтернатива длинным цепочкам `if-elif-else`, особенно когда нужно проверить одну переменную на множество значений.

**Структура:**
```python
match переменная:
    case значение1:
        # код для значения1
    case значение2:
        # код для значения2
    case _:
        # код по умолчанию (если ничего не совпало)
```

**Важно:**
- `_` (подчёркивание) — это "wildcard", означает "всё остальное" (аналог `else`)
- В отличие от `if-elif`, здесь нет слова `break` — выполняется только один случай
- Работает только в Python 3.10+

**Примеры:**

```python
# Пример 1: Базовое использование — дни недели
day = int(input("Номер дня (1-7): "))

match day:
    case 1:
        print("Понедельник")
    case 2:
        print("Вторник")
    case 3:
        print("Среда")
    case 4:
        print("Четверг")
    case 5:
        print("Пятница")
    case 6:
        print("Суббота")
    case 7:
        print("Воскресенье")
    case _:
        print("Некорректный номер дня")

# То же самое через if-elif (длиннее и менее читабельно)
if day == 1:
    print("Понедельник")
elif day == 2:
    print("Вторник")
# ... и так далее
```

```python
# Пример 2: Калькулятор
a = int(input("Первое число: "))
b = int(input("Второе число: "))
operation = input("Операция (+, -, *, /): ")

match operation:
    case "+":
        print(f"Результат: {a + b}")
    case "-":
        print(f"Результат: {a - b}")
    case "*":
        print(f"Результат: {a * b}")
    case "/":
        if b != 0:
            print(f"Результат: {a / b}")
        else:
            print("Ошибка: деление на ноль")
    case _:
        print("Неизвестная операция")
```

```python
# Пример 3: Несколько значений в одном case (через |)
status_code = int(input("HTTP код: "))

match status_code:
    case 200 | 201 | 204:
        print("Успех!")
    case 400 | 401 | 403:
        print("Ошибка клиента")
    case 500 | 502 | 503:
        print("Ошибка сервера")
    case _:
        print("Неизвестный код")

# Эквивалент с if-elif (гораздо длиннее)
if status_code in [200, 201, 204]:
    print("Успех!")
elif status_code in [400, 401, 403]:
    print("Ошибка клиента")
# ...
```

```python
# Пример 4: Условия внутри case (guard)
age = int(input("Возраст: "))

match age:
    case n if n < 0:
        print("Некорректный возраст")
    case n if n < 7:
        print("Дошкольник")
    case n if n < 18:
        print("Школьник")
    case n if n < 65:
        print("Работающий")
    case _:
        print("Пенсионер")
```

```python
# Пример 5: Сопоставление строк
command = input("Команда: ").lower()

match command:
    case "start" | "запустить":
        print("Программа запущена")
    case "stop" | "остановить":
        print("Программа остановлена")
    case "help" | "помощь":
        print("Доступные команды: start, stop, help")
    case "exit" | "выход":
        print("До свидания!")
    case _:
        print("Неизвестная команда. Введите 'help' для справки")
```

```python
# Пример 6: Сопоставление с кортежами (более продвинуто)
point = (0, 0)

match point:
    case (0, 0):
        print("Точка в начале координат")
    case (0, y):
        print(f"Точка на оси Y: {y}")
    case (x, 0):
        print(f"Точка на оси X: {x}")
    case (x, y):
        print(f"Точка в координатах ({x}, {y})")
```

```python
# Пример 7: Меню ресторана
choice = input("Выберите блюдо (1-5): ")

match choice:
    case "1":
        print("Вы выбрали: Борщ - 300 руб")
    case "2":
        print("Вы выбрали: Пельмени - 250 руб")
    case "3":
        print("Вы выбрали: Салат - 150 руб")
    case "4":
        print("Вы выбрали: Десерт - 200 руб")
    case "5":
        print("Вы выбрали: Напиток - 100 руб")
    case _:
        print("Блюдо не найдено в меню")
```

**Преимущества match-case:**
- ✅ Короче и понятнее для множества вариантов
- ✅ Удобная группировка значений через `|`
- ✅ Более мощные возможности сопоставления (структур данных)
- ✅ Проще добавлять новые варианты

**Недостатки:**
- ❌ Работает только в Python 3.10+
- ❌ Для простых условий `if-elif` может быть понятнее
- ❌ Нельзя использовать сложные логические выражения напрямую

**Когда использовать match-case:**
- ✅ Проверка одной переменной на много значений
- ✅ Выбор действия на основе кода/команды
- ✅ Меню, калькуляторы, парсеры команд
- ✅ Обработка типов данных или статусов

**Когда использовать if-elif:**
- ✅ Сложные логические условия
- ✅ Сравнение разных переменных
- ✅ Диапазоны значений (хотя можно использовать guard в match)
- ✅ Нужна совместимость со старыми версиями Python

**Сравнение подходов:**

```python
# Задача: определить категорию товара по коду

# С if-elif (старый способ)
code = "A1"

if code == "A1" or code == "A2":
    print("Электроника")
elif code == "B1" or code == "B2":
    print("Одежда")
elif code == "C1" or code == "C2":
    print("Продукты")
else:
    print("Неизвестная категория")

# С match-case (современный способ)
match code:
    case "A1" | "A2":
        print("Электроника")
    case "B1" | "B2":
        print("Одежда")
    case "C1" | "C2":
        print("Продукты")
    case _:
        print("Неизвестная категория")
```

**Практический пример — игра "Камень, ножницы, бумага":**

```python
player = input("Ваш выбор (камень/ножницы/бумага): ").lower()
computer = "ножницы"  # Допустим, компьютер выбрал ножницы

match (player, computer):
    case ("камень", "ножницы") | ("ножницы", "бумага") | ("бумага", "камень"):
        print("Вы победили!")
    case ("камень", "камень") | ("ножницы", "ножницы") | ("бумага", "бумага"):
        print("Ничья!")
    case ("ножницы", "камень") | ("бумага", "ножницы") | ("камень", "бумага"):
        print("Компьютер победил!")
    case _:
        print("Некорректный выбор")
```

**Итог:**
`match-case` — мощный инструмент для чистого и выразительного кода, когда нужно сопоставить значение с множеством вариантов. Однако для простых условий классический `if-elif-else` остаётся вполне подходящим решением.









----

# `4` Типы данных 1
## `4.1` Что такое тип данных и зачем он нужен?
**Тип данных** — это категория данных, которая определяет:
- Какие значения может хранить переменная
- Какие операции можно с ней выполнять
- Сколько памяти она занимает

`Python` — язык с **динамической типизацией**, то есть тип переменной определяется автоматически при присваивании значения. Не нужно явно указывать тип, как в C++ или Java.

**Основные типы данных в Python:**
- `int` — целые числа (1, 42, -100)
- `float` — числа с плавающей точкой (3.14, -0.5)
- `str` — строки ("привет", 'текст')
- `bool` — логические значения (True, False)
- `list` — списки ([1, 2, 3])
- `dict` — словари ({'key': 'value'})
- `tuple` — кортежи ((1, 2, 3))
- `set` — множества ({1, 2, 3})

**Зачем нужны типы данных:**
1. **Безопасность** — предотвращают ошибки (нельзя разделить строку на число)
2. **Оптимизация** — компьютер понимает, как хранить и обрабатывать данные
3. **Ясность** — код становится понятнее (что именно хранится в переменной)
4. **Операции** — каждый тип поддерживает свои операции (сложение чисел ≠ конкатенация строк)

**Примеры:**

```python
# Узнать тип переменной — функция type()
age = 25
print(type(age))  # <class 'int'>

price = 19.99
print(type(price))  # <class 'float'>

name = "Иван"
print(type(name))  # <class 'str'>

is_active = True
print(type(is_active))  # <class 'bool'>

# Python автоматически определяет тип
x = 10        # int
x = 10.5      # Теперь float (тип изменился!)
x = "текст"   # Теперь str

# Разные типы — разные операции
print(5 + 3)        # 8 (сложение чисел)
print("5" + "3")    # "53" (конкатенация строк)
print(5 * 3)        # 15 (умножение чисел)
print("5" * 3)      # "555" (повторение строки)
```

## `4.2` Числовые типы данных. Целые числа и числа с плавающей точкой
### `int` (integer) — целые числа
- Целые числа без дробной части
- Могут быть положительными, отрицательными или нулём
- В Python 3 нет ограничения на размер (ограничены только памятью)
- Используются для подсчёта, индексации, целочисленной арифметики

### `float` (floating point) — числа с плавающей точкой
- Числа с дробной частью
- Записываются с точкой: `3.14`, `0.5`, `-2.718`
- Могут быть в экспоненциальной форме: `1e6` (1 × 10⁶ = 1000000)
- Занимают 8 байт (64 бита)
- Имеют ограниченную точность (~15-17 значащих цифр)

**Важно:** Деление `/` всегда возвращает `float`, даже если результат целое число!

**Примеры:**

```python
# int — целые числа
a = 10
b = -5
c = 0
print(type(a))  # <class 'int'>

# float — дробные числа
x = 3.14
y = -0.5
z = 2.0  # Это float, даже если нет дробной части!
print(type(x))  # <class 'float'>

# Экспоненциальная запись
big_number = 1e6  # 1000000.0
small_number = 1e-3  # 0.001
print(type(big_number))  # <class 'float'>

# Операции с int
print(10 + 5)   # 15 (int)
print(10 - 3)   # 7 (int)
print(10 * 2)   # 20 (int)
print(10 // 3)  # 3 (int — целочисленное деление)
print(10 % 3)   # 1 (int — остаток)
print(2 ** 3)   # 8 (int — степень)

# Операции с float
print(10.5 + 2.3)  # 12.8 (float)
print(10.0 - 3.0)  # 7.0 (float)
print(3.14 * 2)    # 6.28 (float)

# Деление всегда возвращает float!
print(10 / 2)   # 5.0 (не 5!)
print(9 / 3)    # 3.0 (не 3!)
print(type(10 / 2))  # <class 'float'>

# Смешанные операции — результат float
print(10 + 2.5)    # 12.5 (float)
print(5 * 1.5)     # 7.5 (float)
print(type(10 + 2.5))  # <class 'float'>

# Преобразование типов
num_str = "42"
num_int = int(num_str)     # Строка → int
num_float = float(num_str)  # Строка → float

print(int(3.14))    # 3 (отбрасывает дробную часть)
print(float(5))     # 5.0
print(int(9.99))    # 9 (не округляет, а отбрасывает!)

# Проблема точности float
print(0.1 + 0.2)  # 0.30000000000000004 (не 0.3!)
# Это особенность хранения чисел в памяти
```

## `4.3` Функции `min()`, `max()`, `abs()`
### `min()` — минимальное значение
Возвращает наименьшее из переданных значений или элементов последовательности.

### `max()` — максимальное значение
Возвращает наибольшее из переданных значений или элементов последовательности.

### `abs()` — модуль числа (абсолютное значение)
Возвращает число без знака (всегда положительное или ноль).

**Примеры:**

```python
# min() — минимум из нескольких чисел
print(min(5, 2, 8, 1))  # 1
print(min(10, 20))      # 10
print(min(-5, -10, 0))  # -10

# max() — максимум из нескольких чисел
print(max(5, 2, 8, 1))  # 8
print(max(10, 20))      # 20
print(max(-5, -10, 0))  # 0

# abs() — модуль числа
print(abs(5))      # 5
print(abs(-5))     # 5
print(abs(0))      # 0
print(abs(-3.14))  # 3.14

# Практические примеры
a = int(input("Первое число: "))
b = int(input("Второе число: "))
c = int(input("Третье число: "))

print("Минимум:", min(a, b, c))
print("Максимум:", max(a, b, c))

# Разница между двумя числами (всегда положительная)
x = 10
y = 25
difference = abs(x - y)
print(f"Разница: {difference}")  # 15

# Расстояние от нуля
temperature = -15
distance_from_zero = abs(temperature)
print(f"Температура отличается от нуля на {distance_from_zero}°")
```

## `4.4` Функция `round`
`round()` — округляет число с плавающей точкой до указанного количества знаков после запятой.

**Синтаксис:**
```python
round(число, количество_знаков)
```
- Если не указать количество знаков — округлит до целого
- Использует "математическое округление" (до ближайшего чётного при .5)

**Важно:** `round()` возвращает `float`, если указано количество знаков, и `int`, если нет.

**Примеры:**

```python
# Округление до целого
print(round(3.14))    # 3
print(round(3.7))     # 4
print(round(3.5))     # 4 (округление до ближайшего чётного)
print(round(4.5))     # 4 (тоже до чётного!)
print(round(-2.7))    # -3

# Округление до N знаков после запятой
print(round(3.14159, 2))   # 3.14
print(round(3.14159, 3))   # 3.142
print(round(3.14159, 0))   # 3.0 (вернёт float!)

# Округление до десятков, сотен
print(round(1234, -1))  # 1230 (до десятков)
print(round(1234, -2))  # 1200 (до сотен)
print(round(1567, -2))  # 1600

# Практические примеры
price = 19.99876
print(f"Цена: {round(price, 2)} руб")  # Цена: 20.0 руб

pi = 3.141592653589793
print(round(pi, 4))  # 3.1416

# Среднее значение
total = 100
count = 3
average = total / count
print(f"Среднее: {round(average, 2)}")  # Среднее: 33.33
```

## `4.5` Строковый тип данных
**Строка (str)** — последовательность символов, заключённая в кавычки. Строки **неизменяемы** — нельзя изменить отдельный символ, можно только создать новую строку.

**Способы создания строк:**
- Одинарные кавычки: `'текст'`
- Двойные кавычки: `"текст"`
- Тройные кавычки: `'''текст'''` или `"""текст"""` (для многострочных)

**Особенности:**
- Можно использовать любые кавычки, но стиль должен быть единообразным
- Тройные кавычки сохраняют переносы строк
- Экранирование специальных символов: `\n` (новая строка), `\t` (табуляция), `\\` (обратный слэш), `\'` и `\"`

**Операции со строками:**
- `+` — конкатенация (склеивание)
- `*` — повторение
- Индексация: `s[0]` — первый символ, `s[-1]` — последний
- Срезы: `s[1:4]` — символы с 1 по 3 (4 не включается)

**Примеры:**

```python
# Создание строк
name1 = "Иван"
name2 = 'Пётр'
quote = "Он сказал: 'Привет!'"  # Можно смешивать кавычки
multiline = """Это
многострочный
текст"""

# Конкатенация (склеивание)
first_name = "Иван"
last_name = "Иванов"
full_name = first_name + " " + last_name
print(full_name)  # Иван Иванов

greeting = "Привет, " + "мир!"
print(greeting)  # Привет, мир!

# Повторение
print("=" * 20)  # ====================
print("Ха" * 3)  # ХаХаХа

# Индексация (нумерация с 0)
text = "Python"
print(text[0])   # P (первый символ)
print(text[1])   # y
print(text[-1])  # n (последний символ)
print(text[-2])  # o (предпоследний)

# Срезы [начало:конец]
text = "Hello, World!"
print(text[0:5])   # Hello
print(text[7:12])  # World
print(text[:5])    # Hello (с начала до 5)
print(text[7:])    # World! (с 7 до конца)
print(text[-6:])   # World! (последние 6 символов)

# Специальные символы
print("Строка 1\nСтрока 2")  # Перенос строки
# Строка 1
# Строка 2

print("Имя:\tИван")  # Табуляция
# Имя:    Иван

print("Путь: C:\\Users\\file.txt")  # Экранирование \
# Путь: C:\Users\file.txt

# Строки неизменяемы!
text = "Python"
# text[0] = "J"  # Ошибка! TypeError

# Но можно создать новую строку
text = "J" + text[1:]
print(text)  # Jython

# f-строки (форматирование)
name = "Иван"
age = 25
print(f"Меня зовут {name}, мне {age} лет")
# Меня зовут Иван, мне 25 лет

# Методы строк
text = "python"
print(text.upper())      # PYTHON
print(text.capitalize()) # Python
print(text.replace("p", "j"))  # jython
```

## `4.6` Функции `len()`, `in` для строк
### `len()` — длина строки
Возвращает количество символов в строке (включая пробелы и знаки препинания).

### `in` — проверка вхождения
Оператор `in` проверяет, содержится ли подстрока в строке. Возвращает `True` или `False`.  
`not in` — проверяет отсутствие подстроки.

**Примеры:**

```python
# len() — длина строки
text = "Python"
print(len(text))  # 6

message = "Привет, мир!"
print(len(message))  # 12 (пробелы и знаки считаются)

empty = ""
print(len(empty))  # 0

# Практическое применение len()
password = input("Введите пароль: ")
if len(password) < 8:
    print("Пароль слишком короткий")
else:
    print("Пароль принят")

# in — проверка вхождения подстроки
text = "Python — отличный язык программирования"

print("Python" in text)  # True
print("Java" in text)    # False
print("отличный" in text)  # True
print("плохой" in text)  # False

# not in — проверка отсутствия
print("Java" not in text)  # True
print("Python" not in text)  # False

# Использование в условиях
email = input("Email: ")

if "@" in email and "." in email:
    print("Email корректен")
else:
    print("Некорректный email")

# Проверка на запрещённые слова
comment = input("Комментарий: ")
banned_words = ["плохо", "ужасно", "спам"]

contains_banned = False
for word in banned_words:
    if word in comment:
        contains_banned = True
        break

if contains_banned:
    print("Комментарий содержит запрещённые слова")
else:
    print("Комментарий принят")

# Проверка символа в строке
char = input("Введите символ: ")
vowels = "аеёиоуыэюяАЕЁИОУЫЭЮЯ"

if char in vowels:
    print("Это гласная буква")
else:
    print("Это не гласная")

# Регистр важен!
text = "Python"
print("python" in text)  # False (разный регистр)
print("Python" in text)  # True

# Чтобы игнорировать регистр
text_lower = text.lower()
print("python" in text_lower)  # True
```

**Итог:**
- `len()` — универсальная функция для получения длины строки (и других последовательностей)
- `in` — удобный способ проверить наличие подстроки без сложных условий
- Оба часто используются вместе для валидации пользовательского ввода

## `4.7` (`*`) `bool` & `None`
### **Тип `bool` (булев тип)**

`bool` — это логический тип данных с двумя значениями: `True` и `False`.

```python
is_active = True
is_deleted = False

print(type(is_active))  # <class 'bool'>

# bool() преобразует значения
print(bool(1))       # True
print(bool(0))       # False
print(bool("text"))  # True
print(bool(""))      # False
print(bool([1, 2]))  # True
print(bool([]))      # False
```

**Ложные значения (Falsy):** `False`, `None`, `0`, `""`, `[]`, `()`, `{}`. Всё остальное — истина.

```python
items = []
if not items:
    print("Список пуст")  # Выведет: Список пуст
```

### **Тип `None` (отсутствие значения)**

`None` — специальный объект, обозначающий отсутствие значения.

```python
result = None
print(type(result))  # <class 'NoneType'>

# Функции без return возвращают None
def greet():
    print("Привет")

print(greet())  # None

# Проверка на None — используй is/is not
value = None
if value is None:  # Правильно
    print("Значение не задано")  # Выведет: Значение не задано
```

**Отличия `None` от `False`:**

```python
print(None == False)   # False — разные объекты
print(bool(None))      # False — но приводится к False
print(None is False)   # False — разные типы

# Оба ложные в условиях, но проверяются по-разному
if not None:
    print("None — ложь")  # Выведет

value = None
if value is None:  # Для None используй is
    print("Это None")  # Выведет: Это None
```

----

# `5` Строки
## `5.1` (`*`) Индексы

`Индекс` — это числовое значение, обозначающее позицию символа в строке. В Python индексы начинаются с `0` для первого символа.

### **Положительные индексы**

Отсчитываются с начала строки, начиная с `0`.

```python
s = "Python"
print(s[0])  # 'P' (первый символ)
print(s[1])  # 'y' (второй символ)
print(s[5])  # 'n' (шестой символ)

# Обращение к несуществующему индексу вызовет ошибку
# print(s[10])  # IndexError: string index out of range

# Длина строки
print(len(s))  # 6
print(s[len(s) - 1])  # 'n' (последний символ через длину)
```

### **Отрицательные индексы**

Отсчитываются с конца строки: `-1` — последний символ, `-2` — предпоследний и так далее.

```python
s = "Python"
print(s[-1])  # 'n' (последний символ)
print(s[-2])  # 'o' (предпоследний)
print(s[-6])  # 'P' (первый символ через отрицательный индекс)

# Соответствие положительных и отрицательных индексов
# s = "Python"
#     P  y  t  h  o  n
#     0  1  2  3  4  5   (положительные)
#    -6 -5 -4 -3 -2 -1   (отрицательные)
```

### **Практические примеры**

```python
text = "Hello, World!"

# Получение первого и последнего символа
first = text[0]
last = text[-1]
print(f"Первый: {first}, Последний: {last}")  # Первый: H, Последний: !

# Проверка символа на позиции
email = "user@example.com"
if email[0] == '@':
    print("Email не может начинаться с @")
else:
    print("Email корректен")  # Выведет: Email корректен

# Получение расширения файла
filename = "document.pdf"
extension = filename[-3:]  # Последние 3 символа (используя срез)
print(extension)  # 'pdf'
```

## `5.2` (`*`) Срезы. Срезы с одним/двумя/тремя параметрами `[x:y:z]` 
`Срез` (slice) позволяет извлечь подстроку, указав диапазон индексов. Синтаксис: `[start:stop:step]`.

- `start` — начальный индекс (включительно), по умолчанию `0`
- `stop` — конечный индекс (не включается!), по умолчанию конец строки
- `step` — шаг, по умолчанию `1`

### **Срезы с двумя параметрами `[start:stop]`**

```python
s = "Python Programming"

# От индекса 0 до 6 (не включая 6)
print(s[0:6])   # 'Python'
print(s[:6])    # 'Python' (start=0 по умолчанию)

# От индекса 7 до конца
print(s[7:])    # 'Programming'

# От 7 до 18
print(s[7:18])  # 'Programming'

# Средняя часть
print(s[3:9])   # 'hon Pr'

# Пустая строка (start >= stop)
print(s[5:5])   # ''
print(s[5:3])   # ''
```

### **Срезы с одним параметром `[:stop]` или `[start:]`**

```python
s = "Python"

# От начала до индекса 3
print(s[:3])    # 'Pyt'

# От индекса 2 до конца
print(s[2:])    # 'thon'

# Вся строка
print(s[:])     # 'Python'
```

### **Срезы с тремя параметрами `[start:stop:step]`**

Параметр `step` определяет шаг выбора символов.

```python
s = "Python Programming"

# Каждый второй символ
print(s[::2])   # 'Pto rgamn'

# Каждый третий символ
print(s[::3])   # 'Ph ormn'

# От 0 до 12 с шагом 2
print(s[0:12:2])  # 'Pto rg'

# От 7 до конца с шагом 2
print(s[7::2])    # 'Pormig'

# Пропуск первых и последних символов, шаг 2
print(s[1:-1:2])  # 'yhno rgmin'
```

### **Практические примеры**

```python
# Извлечение доменного имени из email
email = "user@example.com"
at_index = email.index('@')
domain = email[at_index + 1:]
print(domain)  # 'example.com'

# Получение первых N символов
text = "Hello, World!"
preview = text[:5]
print(preview)  # 'Hello'

# Удаление первого и последнего символа
s = '"quoted text"'
unquoted = s[1:-1]
print(unquoted)  # 'quoted text'

# Каждое второе слово (через split и срез)
sentence = "one two three four five six"
words = sentence.split()
every_second = words[::2]
print(every_second)  # ['one', 'three', 'five']

# Копирование строки
original = "Python"
copy = original[:]
print(copy)  # 'Python'
```

## `5.3` Методы строк:  
**Методы** — это функции, которые принадлежат определённому типу данных и вызываются через точку: `строка.метод()`. Строковые методы возвращают новую строку, не изменяя оригинал (строки неизменяемы!).

**Синтаксис:**
```python
результат = строка.метод()
```

### `capitalize()` — первая буква заглавная

**Теория:**
Преобразует первый символ строки в заглавную букву, остальные — в строчные.

**Примеры:**
```python
text = "python"
print(text.capitalize())  # Python

text = "PYTHON"
print(text.capitalize())  # Python

text = "привет мир"
print(text.capitalize())  # Привет мир (только первая буква)

# Практическое применение
name = input("Ваше имя: ").capitalize()
print(f"Привет, {name}!")
# Ввод: иВаН → Привет, Иван!
```

### `title()` — каждое слово с заглавной буквы

**Теория:**
Преобразует первую букву каждого слова в заглавную, остальные — в строчные. Слова разделяются пробелами и знаками препинания.

**Примеры:**
```python
text = "python programming"
print(text.title())  # Python Programming

text = "война и мир"
print(text.title())  # Война И Мир

text = "hello, world!"
print(text.title())  # Hello, World!

# Практическое применение
book = "унесённые ветром"
print(book.title())  # Унесённые Ветром

full_name = input("ФИО: ").title()
print(f"Добро пожаловать, {full_name}")
# Ввод: иван иванов → Добро пожаловать, Иван Иванов
```


### `lower()` — все буквы строчные

**Теория:**
Преобразует все буквы в строчные (нижний регистр).

**Примеры:**
```python
text = "PYTHON"
print(text.lower())  # python

text = "Hello, World!"
print(text.lower())  # hello, world!

# Практическое применение — сравнение без учёта регистра
password = input("Пароль: ")
if password.lower() == "secret":
    print("Доступ разрешён")

# Проверка команды
command = input("Команда: ").lower()
if command == "start":
    print("Запуск программы")
elif command == "stop":
    print("Остановка программы")
```


### `upper()` — все буквы заглавные

**Теория:**
Преобразует все буквы в заглавные (верхний регистр).

**Примеры:**
```python
text = "python"
print(text.upper())  # PYTHON

text = "Hello, World!"
print(text.upper())  # HELLO, WORLD!

# Практическое применение
code = input("Промокод: ").upper()
if code == "SALE2024":
    print("Скидка 20%!")

# Выделение важного текста
print("=" * 30)
print("ВНИМАНИЕ!".upper())
print("=" * 30)
```


### `startswith()` — проверка начала строки

**Теория:**
Проверяет, начинается ли строка с указанной подстроки. Возвращает `True` или `False`.

**Синтаксис:**
```python
строка.startswith(подстрока)
```

**Примеры:**
```python
text = "Python — отличный язык"
print(text.startswith("Python"))  # True
print(text.startswith("Java"))    # False

# Регистр важен!
print(text.startswith("python"))  # False

# Практическое применение — проверка префикса
phone = input("Телефон: ")
if phone.startswith("+7") or phone.startswith("8"):
    print("Российский номер")
else:
    print("Иностранный номер")

# Проверка начала email
email = input("Email: ")
if email.startswith("admin"):
    print("Административный аккаунт")

# Проверка протокола
url = "https://example.com"
if url.startswith("https://"):
    print("Безопасное соединение")
elif url.startswith("http://"):
    print("Небезопасное соединение")

# Проверка нескольких вариантов (кортеж)
text = "Hello, world!"
print(text.startswith(("Hi", "Hello")))  # True
```


### `strip()` — удаление пробелов

**Теория:**
Удаляет пробелы (и другие пробельные символы: `\n`, `\t`) с начала и конца строки. Не затрагивает пробелы внутри строки.

**Варианты:**
- `strip()` — с обоих концов
- `lstrip()` — только слева (left)
- `rstrip()` — только справа (right)

**Примеры:**
```python
text = "  Python  "
print(text.strip())  # "Python" (без кавычек в выводе)
print(len(text))          # 10
print(len(text.strip()))  # 6

# Пробелы внутри не удаляются
text = "  Hello World  "
print(text.strip())  # "Hello World"

# Удаление других символов
text = "...Python..."
print(text.strip("."))  # "Python"

text = "###Hello###"
print(text.strip("#"))  # "Hello"

# lstrip() — только слева
text = "  Python  "
print(text.lstrip())  # "Python  "

# rstrip() — только справа
text = "  Python  "
print(text.rstrip())  # "  Python"

# Практическое применение — очистка ввода
name = input("Ваше имя: ").strip()
# Если пользователь ввёл "  Иван  " → сохранится "Иван"

# Удаление переносов строк
text = "Hello\n"
print(text.strip())  # "Hello"

# Цепочка методов
name = "  иВаН  "
clean_name = name.strip().capitalize()
print(clean_name)  # "Иван"
```


### `isalpha()` — только буквы?

**Теория:**
Проверяет, состоит ли строка **только из букв** (без цифр, пробелов, знаков препинания). Возвращает `True` или `False`.

**Важно:** Пустая строка возвращает `False`.

**Примеры:**
```python
print("Python".isalpha())     # True
print("Python3".isalpha())    # False (есть цифра)
print("Hello World".isalpha()) # False (есть пробел)
print("Привет".isalpha())     # True (работает с кириллицей)
print("".isalpha())           # False (пустая строка)
print("!@#".isalpha())        # False (знаки препинания)

# Практическое применение — валидация имени
name = input("Ваше имя: ")
if name.isalpha():
    print("Имя принято")
else:
    print("Имя должно содержать только буквы")

# Проверка логина (только буквы, без цифр)
login = input("Логин (только буквы): ")
if login.isalpha():
    print("Логин корректен")
else:
    print("Используйте только буквы")
```


### `isdigit()` — только цифры?

**Теория:**
Проверяет, состоит ли строка **только из цифр**. Возвращает `True` или `False`.

**Важно:** Пустая строка возвращает `False`. Знак минус `-` не считается частью цифры.

**Примеры:**
```python
print("12345".isdigit())   # True
print("123.45".isdigit())  # False (есть точка)
print("123 456".isdigit()) # False (есть пробел)
print("-123".isdigit())    # False (есть минус)
print("Python".isdigit())  # False (буквы)
print("".isdigit())        # False (пустая строка)

# Практическое применение — проверка перед int()
age_input = input("Ваш возраст: ")
if age_input.isdigit():
    age = int(age_input)
    print(f"Вам {age} лет")
else:
    print("Введите число!")

# Проверка индекса
index = input("Введите индекс: ")
if index.isdigit() and len(index) == 6:
    print("Корректный почтовый индекс")
else:
    print("Индекс должен состоять из 6 цифр")

# Проверка пин-кода
pin = input("Пин-код (4 цифры): ")
if pin.isdigit() and len(pin) == 4:
    print("Пин-код принят")
else:
    print("Пин-код должен быть из 4 цифр")
```


### `islower()` — все буквы строчные?

**Теория:**
Проверяет, все ли буквы в строке находятся в нижнем регистре. Цифры и символы игнорируются.

**Важно:** Возвращает `False`, если в строке нет ни одной буквы.

**Примеры:**
```python
print("python".islower())      # True
print("Python".islower())      # False (есть заглавная P)
print("python3".islower())     # True (цифры игнорируются)
print("hello world".islower()) # True (пробелы игнорируются)
print("123".islower())         # False (нет букв)
print("".islower())            # False (пустая строка)

# Практическое применение
password = input("Пароль (только строчные буквы): ")
if password.islower() and password.isalpha():
    print("Пароль принят")
else:
    print("Используйте только строчные буквы")

# Проверка формата
code = "abc123"
if code[:3].islower() and code[3:].isdigit():
    print("Формат кода корректен: 3 строчные буквы + 3 цифры")
```


### `isupper()` — все буквы заглавные?

**Теория:**
Проверяет, все ли буквы в строке находятся в верхнем регистре. Цифры и символы игнорируются.

**Важно:** Возвращает `False`, если в строке нет ни одной буквы.

**Примеры:**
```python
print("PYTHON".isupper())      # True
print("Python".isupper())      # False (есть строчные)
print("PYTHON3".isupper())     # True (цифры игнорируются)
print("HELLO WORLD".isupper()) # True (пробелы игнорируются)
print("123".isupper())         # False (нет букв)
print("".isupper())            # False (пустая строка)

# Практическое применение — проверка кода
code = input("Введите код: ")
if code.isupper() and len(code) == 4:
    print("Код принят")
else:
    print("Код должен состоять из 4 заглавных букв")

# Проверка аббревиатуры
abbr = input("Аббревиатура: ")
if abbr.isupper() and abbr.isalpha():
    print("Корректная аббревиатура")
else:
    print("Аббревиатура должна быть из заглавных букв")

# Проверка формата
text = "ABC-123"
parts = text.split("-")
if parts[0].isupper() and parts[1].isdigit():
    print("Формат корректен: ABC-123")
```


**Комбинирование методов:**

```python
# Цепочка методов
text = "  PYTHON programming  "
result = text.strip().lower().capitalize()
print(result)  # "Python programming"

# Проверка и преобразование
username = input("Username: ").strip().lower()
if username.isalpha() and 3 <= len(username) <= 15:
    print("Username принят")
else:
    print("Username: 3-15 букв")

# Валидация email (базовая)
email = input("Email: ").strip().lower()
if "@" in email and "." in email and not email.startswith("@"):
    print("Email корректен")
else:
    print("Некорректный email")

# Проверка пароля
password = input("Пароль: ")
has_upper = any(c.isupper() for c in password)
has_lower = any(c.islower() for c in password)
has_digit = any(c.isdigit() for c in password)

if has_upper and has_lower and has_digit and len(password) >= 8:
    print("Пароль надёжный")
else:
    print("Пароль должен содержать: заглавные, строчные буквы, цифры, минимум 8 символов")
```

**Итог:**
- Строковые методы не изменяют оригинальную строку, а возвращают новую
- Можно объединять методы в цепочки: `text.strip().lower()`
- `is*()` методы возвращают `True`/`False` и удобны для валидации
- Методы регистра (`upper()`, `lower()`) полезны для сравнения без учёта регистра

## `5.4` (`*`) Отрицательные срезы  
Отрицательные индексы в срезах позволяют работать с концом строки без вычисления длины. Особенно полезны для реверса строки и извлечения данных с конца.

### **Отрицательные границы среза**

```python
s = "Hello, Python!"

# Последние 6 символов
print(s[-6:])      # 'Python!'

# С 4-го символа с конца до предпоследнего
print(s[-4:-1])    # 'tho'

# Все символы кроме последних 3
print(s[:-3])      # 'Hello, Pyth'

# Все символы кроме первых 7
print(s[7:])       # 'Python!'

# С -10 по -3
print(s[-10:-3])   # ', Pytho'

# Комбинирование положительных и отрицательных
print(s[2:-2])     # 'llo, Python'
```

### **Отрицательный шаг (реверс)**

При отрицательном `step` строка читается справа налево.

```python
s = "Python"

# Реверс строки
print(s[::-1])     # 'nohtyP'

# Каждый второй символ с конца
print(s[::-2])     # 'nhy'

# От конца до начала с шагом 3
print(s[::-3])     # 'nt'

# Реверс подстроки
text = "Hello, World!"
print(text[7:12][::-1])  # 'dlroW'
# Или в одном срезе (сложнее читается):
print(text[11:6:-1])     # 'dlroW'
```

### **Сложные срезы с отрицательными значениями**

При отрицательном шаге `start` должен быть **больше** `stop` (справа от него).

```python
s = "Python Programming"

# От индекса 10 до 5 (справа налево)
print(s[10:5:-1])   # 'mmargor' (неправильное направление)

# От -5 до -10 (справа налево)
print(s[-5:-10:-1]) # 'mim'

# От конца до индекса 7 (справа налево)
print(s[:7:-1])     # 'gnimmargorP'

# От индекса 10 до начала (справа налево)
print(s[10::-1])    # 'rP nohtyP'

# Весь текст в обратном порядке
print(s[::-1])      # 'gnimmargorP nohtyP'
```

### **Практические примеры с отрицательными срезами**

```python
# Проверка палиндрома
word = "radar"
if word == word[::-1]:
    print(f"{word} — палиндром")  # Выведет: radar — палиндром

# Удаление расширения файла
filename = "document.pdf"
name_without_ext = filename[:-4]  # Убираем последние 4 символа
print(name_without_ext)  # 'document'

# Получение последних N символов
text = "1234567890"
last_three = text[-3:]
print(last_three)  # '890'

# Извлечение кода страны из телефона
phone = "+1-555-1234"
country_code = phone[1:phone.index('-')]  # С индекса 1 до первого '-'
print(country_code)  # '1'

# Реверс каждого слова в предложении
sentence = "Hello World Python"
words = sentence.split()
reversed_words = [word[::-1] for word in words]
result = ' '.join(reversed_words)
print(result)  # 'olleH dlroW nohtyP'

# Получение домена верхнего уровня
url = "https://www.example.com"
tld = url[url.rfind('.') + 1:]  # После последней точки
print(tld)  # 'com'

# Удаление первого и последнего символа
quoted = "'Hello'"
unquoted = quoted[1:-1]
print(unquoted)  # 'Hello'

# Проверка, заканчивается ли строка на определённую подстроку
text = "example.txt"
if text[-4:] == ".txt":
    print("Это текстовый файл")  # Выведет: Это текстовый файл
```

### **Визуализация индексов для сложных срезов**

```python
s = "Python"
# Индексы:
#     P   y   t   h   o   n
#     0   1   2   3   4   5   (положительные)
#    -6  -5  -4  -3  -2  -1   (отрицательные)

# Примеры:
print(s[1:4])     # 'yth' (от 1 до 4, не включая 4)
print(s[-5:-2])   # 'yth' (то же самое через отрицательные)
print(s[::2])     # 'Pto' (каждый второй, шаг 2)
print(s[::-1])    # 'nohtyP' (реверс, шаг -1)
print(s[-1::-1])  # 'nohtyP' (от конца к началу)
print(s[:-4:-1])  # 'noh' (от конца до -4, не включая -4, справа налево)
```

**Ключевые моменты:**

- Отрицательные индексы удобны для работы с концом строки
- `[::-1]` — стандартный способ реверса строки
- При отрицательном шаге `start` должен быть правее `stop`
- Срезы никогда не вызывают `IndexError` — выходящие за границы индексы игнорируются
- Срезы создают **новую строку**, не изменяя оригинал (строки неизменяемы)

## `5.5` Конкатенация и другие математические операции
Со строками можно выполнять некоторые операции, похожие на математические, но с особым смыслом:

- **Конкатенация (`+`)** — склеивание строк
- **Повторение (`*`)** — многократное дублирование строки
- **Сравнение (`==`, `!=`, `<`, `>`)** — лексикографическое сравнение

**Важно:** Нельзя напрямую складывать строки и числа — нужно преобразование типов!

### Конкатенация (`+`) — склеивание строк

**Теория:**
Оператор `+` соединяет (склеивает) строки в одну. Работает только со строками!

**Примеры:**

```python
# Базовая конкатенация
first = "Hello"
second = "World"
result = first + second
print(result)  # HelloWorld

# Добавление пробела
result = first + " " + second
print(result)  # Hello World

# Конкатенация нескольких строк
greeting = "Привет" + ", " + "Иван" + "!"
print(greeting)  # Привет, Иван!

# Составление предложения
name = "Анна"
age = "25"
message = "Меня зовут " + name + ", мне " + age + " лет"
print(message)  # Меня зовут Анна, мне 25 лет

# ❌ Ошибка — нельзя складывать строку и число!
age_number = 25
# result = "Мне " + age_number + " лет"  # TypeError!

# ✅ Правильно — преобразуем число в строку
age_number = 25
result = "Мне " + str(age_number) + " лет"
print(result)  # Мне 25 лет

# Практические примеры
first_name = input("Имя: ")
last_name = input("Фамилия: ")
full_name = first_name + " " + last_name
print("Полное имя:", full_name)

# Создание пути к файлу
folder = "documents"
filename = "report.txt"
path = folder + "/" + filename
print(path)  # documents/report.txt

# Составление URL
domain = "example.com"
protocol = "https://"
url = protocol + domain
print(url)  # https://example.com

# Конкатенация с переносом строки
line1 = "Первая строка"
line2 = "Вторая строка"
text = line1 + "\n" + line2
print(text)
# Первая строка
# Вторая строка
```

### Повторение (`*`) — дублирование строки

**Теория:**
Оператор `*` повторяет строку указанное количество раз. Можно писать `строка * число` или `число * строка`.

**Примеры:**

```python
# Базовое повторение
print("Ha" * 3)  # HaHaHa
print("=" * 20)  # ====================
print("*" * 10)  # **********

# Можно менять местами
print(5 * "Hi")  # HiHiHiHiHi

# Создание разделителей
separator = "-" * 40
print(separator)
print("Заголовок")
print(separator)
# ----------------------------------------
# Заголовок
# ----------------------------------------

# Создание паттернов
pattern = "AB" * 5
print(pattern)  # ABABABABAB

# Отступы и форматирование
indent = " " * 4
print(indent + "Текст с отступом")
#     Текст с отступом

# Пустая строка при умножении на 0
print("Hello" * 0)  # (пустая строка)

# Отрицательные числа дают пустую строку
print("Hello" * -5)  # (пустая строка)

# Практические примеры
# Прогресс-бар
progress = 30  # 30%
bar = "█" * (progress // 5) + "░" * (20 - progress // 5)
print(f"Загрузка: [{bar}] {progress}%")
# Загрузка: [██████░░░░░░░░░░░░░░] 30%

# Создание таблицы
width = 50
print("+" + "-" * (width - 2) + "+")
print("|" + " " * (width - 2) + "|")
print("|" + "Заголовок".center(width - 2) + "|")
print("|" + " " * (width - 2) + "|")
print("+" + "-" * (width - 2) + "+")

# Визуализация рейтинга
rating = 4  # из 5
stars = "★" * rating + "☆" * (5 - rating)
print(f"Рейтинг: {stars}")  # Рейтинг: ★★★★☆

# Генерация строк с переменной длиной
n = int(input("Количество символов: "))
line = "#" * n
print(line)
```

### Сравнение строк

**Теория:**
Строки можно сравнивать операторами `==`, `!=`, `<`, `>`, `<=`, `>=`. Сравнение происходит **лексикографически** (по алфавиту), основываясь на Unicode-кодах символов.

**Правила:**
- Цифры < заглавные латинские буквы < строчные латинские буквы < кириллица
- Сравнение идёт посимвольно слева направо
- Регистр важен: `"A" < "a"` (заглавная меньше строчной)

**Примеры:**

```python
# Равенство
print("Python" == "Python")  # True
print("Python" == "python")  # False (регистр важен!)
print("Hello" != "World")    # True

# Сравнение по алфавиту
print("apple" < "banana")   # True
print("cat" > "dog")        # False
print("abc" < "abd")        # True (сравнение идёт посимвольно)

# Первый символ определяет результат
print("a" < "b")     # True
print("apple" < "b") # True (a < b)

# Длина не важна, важен порядок символов
print("z" > "aaaa")  # True (z идёт после a)

# Регистр
print("A" < "a")     # True (заглавные идут раньше строчных в Unicode)
print("Apple" < "apple")  # True

# Цифры идут раньше букв
print("1" < "a")     # True
print("123" < "abc") # True

# Пробелы
print("a" < "a ")    # True (пробел добавляет символ)
print(" " < "a")     # True (пробел идёт раньше букв)

# Практические примеры
# Проверка пароля
password = input("Пароль: ")
if password == "secret123":
    print("Доступ разрешён")
else:
    print("Неверный пароль")

# Сравнение без учёта регистра
word1 = "Python"
word2 = "python"
if word1.lower() == word2.lower():
    print("Слова одинаковые")  # ✅

# Проверка диапазона
letter = input("Введите букву: ")
if "a" <= letter <= "z":
    print("Строчная латинская буква")
elif "A" <= letter <= "Z":
    print("Заглавная латинская буква")

# Сортировка (позже в курсе)
names = ["Яна", "Анна", "Борис"]
names.sort()
print(names)  # ['Анна', 'Борис', 'Яна']

# Проверка порядка
name1 = "Алиса"
name2 = "Борис"
if name1 < name2:
    print(f"{name1} идёт раньше в алфавитном порядке")
```

### Комбинирование операций

**Примеры:**

```python
# Конкатенация и повторение
separator = "=" * 20
title = "Заголовок"
header = separator + "\n" + title + "\n" + separator
print(header)
# ====================
# Заголовок
# ====================

# Создание таблицы
row_separator = "+" + "-" * 10 + "+" + "-" * 15 + "+"
print(row_separator)
print("| Имя      | Возраст       |")
print(row_separator)
print("| Иван     | 25            |")
print(row_separator)

# Форматирование вывода
name = "Python"
version = "3.11"
stars = "*" * 30
message = stars + "\n" + name + " " + version + "\n" + stars
print(message)
# ******************************
# Python 3.11
# ******************************

# Объединение с условиями
score = 85
if score >= 90:
    grade = "A"
elif score >= 80:
    grade = "B"
else:
    grade = "C"

result = "Оценка: " + grade + " (" + str(score) + " баллов)"
print(result)  # Оценка: B (85 баллов)

# Создание шаблона
template = "=" * 50 + "\n"
template += "Имя: {name}\n"
template += "Возраст: {age}\n"
template += "=" * 50
# Позже можно использовать с .format() или f-строками
```

### Важные замечания

```python
# ❌ Частые ошибки

# 1. Сложение строки и числа
age = 25
# print("Мне " + age + " лет")  # TypeError!
print("Мне " + str(age) + " лет")  # ✅

# 2. Умножение строки на float
# print("Ha" * 2.5)  # TypeError!
print("Ha" * int(2.5))  # ✅ HaHa

# 3. Неправильное сравнение
print("10" > "9")   # False! (сравнение строк, не чисел)
print(10 > 9)       # True (сравнение чисел)
print(int("10") > int("9"))  # True ✅

# 4. Изменяемость
text = "Hello"
# text[0] = "J"  # TypeError! Строки неизменяемы
text = "J" + text[1:]  # ✅ Создаём новую строку

# ✅ Лучшие практики

# Используйте f-строки вместо конкатенации (удобнее)
name = "Иван"
age = 25
# Старый способ
message1 = "Меня зовут " + name + ", мне " + str(age) + " лет"
# Новый способ (лучше!)
message2 = f"Меня зовут {name}, мне {age} лет"

# Используйте join() для множественной конкатенации
words = ["Python", "is", "awesome"]
# Плохо (неэффективно)
sentence = words[0] + " " + words[1] + " " + words[2]
# Хорошо
sentence = " ".join(words)  # Python is awesome
```

**Итог:**
- `+` — склеивает строки (конкатенация)
- `*` — повторяет строку N раз
- Сравнение строк — лексикографическое (по алфавиту)
- Нельзя напрямую комбинировать строки и числа — нужно `str()`
- Для сложного форматирования лучше использовать f-строки

## `5.6` (`*`) Форматирование:  
### `format()`  
Метод `format()` вставляет значения в строку по местам-заполнителям, указанным в фигурных скобках `{}`. Можно использовать позиционные или именованные аргументы, указывая внутри скобок номера или имена: 
```python
"Hello, {}!".format("Alice")  # Hello, Alice!
"{1}, {0}".format('first', 'second')  # second, first
"{name} is {age}".format(name="Bob", age=25)  # Bob is 25
```
Форматирование внутри фигурных скобок позволяет задавать выравнивание, ширину, точность и другие параметры:
```python
"{:>10}".format("cat")    # "       cat" (выравнивание по правому краю, ширина 10)
"{:.3}".format("caterpillar")  # "cat" (обрезка до 3 символов)
"{:0^9}".format(123)      # "000123000" (выравнивание с заполнением нулями)
```

### `f-строки` 
`F-строки` появились в Python 3.6 и позволяют вставлять выражения прямо в строку с префиксом f:
```python
name = "Alice"
age = 30
print(f"Hello, {name}! You are {age} years old.")  # Hello, Alice! You are 30 years old.
```
Также внутри фигурных скобок можно использовать форматирование:
```python
print(f"{123:0>9}")  # '000000123' (выравнивание по правому краю с заполнением нулями)
print(f"{123:.2f}")   # '123.00' (формат с двумя десятичными знаками)
```

## `5.7` (`**`) Как строки хранятся в памяти компьютера. Команды `ord()`, `chr()`
Компьютер работает только с числами (битами и байтами). Каждый символ (буква, цифра, знак) имеет свой числовой код. Эта система кодирования называется **Unicode**.

**Unicode** — универсальная таблица соответствия символов и чисел:
- `A` → 65
- `a` → 97
- `0` → 48
- `А` (кириллица) → 1040
- `😀` (эмодзи) → 128512

**Функции для работы с кодами:**
- `ord(символ)` — возвращает Unicode-код символа (число)
- `chr(код)` — возвращает символ по его коду

**Примеры:**

```python
# ord() — символ → код
print(ord("A"))    # 65
print(ord("a"))    # 97
print(ord("0"))    # 48
print(ord("А"))    # 1040 (кириллица)
print(ord(" "))    # 32 (пробел)
print(ord("!"))    # 33
print(ord("😀"))   # 128512

# chr() — код → символ
print(chr(65))     # A
print(chr(97))     # a
print(chr(1040))   # А
print(chr(128512)) # 😀

# Почему заглавные буквы "меньше" строчных?
print(ord("A"), ord("a"))  # 65 97
print("A" < "a")           # True (65 < 97)

# Практическое применение — шифр Цезаря (сдвиг букв)
letter = "A"
shift = 3
new_code = ord(letter) + shift
encrypted = chr(new_code)
print(f"{letter} → {encrypted}")  # A → D

# Проверка типа символа
char = "5"
if ord("0") <= ord(char) <= ord("9"):
    print("Это цифра")

# Генерация последовательности символов
for i in range(65, 91):  # A-Z
    print(chr(i), end=" ")
# A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

# Расстояние между символами
print(ord("z") - ord("a"))  # 25 (26 букв: 0-25)
```

## `5.8` (`**`) Кодировки
[Смотрим, как устроены кодировки](https://www.youtube.com/watch?v=4MFcmreAUhs)

**Кодировка** — это способ преобразования символов в байты (и обратно) для хранения и передачи данных.

**Основные кодировки:**

1. **ASCII** (American Standard Code for Information Interchange)
   - Самая старая, 128 символов (0-127)
   - Только английские буквы, цифры, базовые знаки
   - 1 символ = 1 байт

2. **UTF-8** (Unicode Transformation Format - 8 bit)
   - Современный стандарт, поддерживает все языки мира
   - Совместима с ASCII (первые 128 символов)
   - Переменная длина: 1-4 байта на символ
   - **Стандарт в Python 3**

3. **Windows-1251** (CP1251)
   - Устаревшая, для кириллицы в Windows
   - 1 символ = 1 байт
   - Может вызывать проблемы с кодировкой

**Важно:** В Python 3 все строки по умолчанию в Unicode (UTF-8). Проблемы с кодировками обычно возникают при чтении/записи файлов.

**Примеры:**

```python
# Строка в Python 3 — это Unicode
text = "Привет, мир!"
print(type(text))  # <class 'str'>

# Преобразование строки в байты (encode)
text = "Hello"
bytes_utf8 = text.encode("utf-8")
print(bytes_utf8)  # b'Hello'
print(type(bytes_utf8))  # <class 'bytes'>

# Кириллица в разных кодировках
text = "Привет"
print(text.encode("utf-8"))       # b'\xd0\x9f\xd1\x80\xd0\xb8\xd0\xb2\xd0\xb5\xd1\x82'
print(text.encode("windows-1251")) # b'\xcf\xf0\xe8\xe2\xe5\xf2'

# Преобразование байтов в строку (decode)
bytes_data = b'Hello'
text = bytes_data.decode("utf-8")
print(text)  # Hello

# Проблема с неправильной кодировкой
text = "Привет"
wrong_bytes = text.encode("utf-8")
try:
    # Пытаемся декодировать UTF-8 как Windows-1251
    wrong_text = wrong_bytes.decode("windows-1251")
    print(wrong_text)  # Ð?Ñ?ивеÑ? (кракозябры!)
except:
    print("Ошибка декодирования")

# Размер в байтах
text_en = "Hello"  # 5 символов
text_ru = "Привет"  # 6 символов

print(len(text_en.encode("utf-8")))  # 5 байт (ASCII)
print(len(text_ru.encode("utf-8")))  # 12 байт (по 2 байта на символ кириллицы)

# Работа с файлами (правильная кодировка)
# Запись файла
with open("file.txt", "w", encoding="utf-8") as f:
    f.write("Привет, мир!")

# Чтение файла
with open("file.txt", "r", encoding="utf-8") as f:
    content = f.read()
    print(content)  # Привет, мир!

# ❌ Если не указать кодировку — могут быть проблемы
# (на Windows по умолчанию cp1251, на Linux/Mac — utf-8)
```

**Практические советы:**

1. **Всегда используйте UTF-8** для файлов и баз данных
2. При открытии файлов явно указывайте `encoding="utf-8"`
3. Если видите кракозябры — проблема в кодировке
4. В Python 3 строки по умолчанию Unicode — это хорошо!

**Частые проблемы:**

```python
# Проблема: файл создан в Windows-1251, читаем как UTF-8
# Решение: указать правильную кодировку
with open("old_file.txt", "r", encoding="windows-1251") as f:
    content = f.read()

# Проблема: нельзя декодировать байты
bytes_data = b'\xff\xfe'
try:
    text = bytes_data.decode("utf-8")
except UnicodeDecodeError:
    print("Неверная кодировка!")
    # Попробовать другую кодировку или игнорировать ошибки
    text = bytes_data.decode("utf-8", errors="ignore")
```

**Итог:**
- Компьютер хранит символы как числа (Unicode-коды)
- `ord()` и `chr()` — конвертация между символами и кодами
- UTF-8 — современный стандарт, используйте его везде
- При работе с файлами всегда указывайте `encoding="utf-8"`

----

# `6` Циклы
[Циклы в Python](https://youtu.be/vMD6-jzgDvI?si=NClQpvFFZSddk-ae)

## `6.1` For loop
### `6.1.1` Как написать for loop в `Python`?
**Цикл `for`** — конструкция для многократного выполнения блока кода. В Python цикл `for` перебирает элементы последовательности (строка, список, диапазон чисел и т.д.).

**Структура:**
```python
for переменная in последовательность:
    # код, который повторяется
    # переменная принимает значения из последовательности
```

**Как работает:**
1. Берётся первый элемент из последовательности
2. Значение присваивается переменной
3. Выполняется блок кода с отступом
4. Берётся следующий элемент
5. Повторяется до конца последовательности

**Примеры:**

```python
# Пример 1: Перебор чисел
for i in range(5):  # 0, 1, 2, 3, 4
    print(i)
# 0
# 1
# 2
# 3
# 4

# Пример 2: Перебор строки (посимвольно)
for letter in "Python":
    print(letter)
# P
# y
# t
# h
# o
# n

# Пример 3: Перебор списка
fruits = ["яблоко", "банан", "апельсин"]
for fruit in fruits:
    print(fruit)
# яблоко
# банан
# апельсин

# Пример 4: Использование переменной цикла
for i in range(1, 6):  # 1, 2, 3, 4, 5
    print(f"Число: {i}, квадрат: {i**2}")
# Число: 1, квадрат: 1
# Число: 2, квадрат: 4
# Число: 3, квадрат: 9
# Число: 4, квадрат: 16
# Число: 5, квадрат: 25

# Пример 5: Накопление суммы
total = 0
for i in range(1, 11):  # 1 до 10
    total += i
print(f"Сумма чисел от 1 до 10: {total}")  # 55

# Пример 6: Подсчёт символов
text = "Hello, World!"
count = 0
for char in text:
    if char == "o":
        count += 1
print(f"Букв 'o': {count}")  # 2

# Пример 7: Таблица умножения
number = 5
for i in range(1, 11):
    print(f"{number} × {i} = {number * i}")

# Пример 8: Вложенные циклы
for i in range(1, 4):
    for j in range(1, 4):
        print(f"i={i}, j={j}")
# i=1, j=1
# i=1, j=2
# i=1, j=3
# i=2, j=1
# ...

# Пример 9: Условия внутри цикла
for i in range(1, 11):
    if i % 2 == 0:
        print(f"{i} — чётное")
    else:
        print(f"{i} — нечётное")
```

### `6.1.2` Функция `range`. `Range` с несколькими параметрами и отрицательным шагом генерации
`range()` — встроенная функция, которая генерирует последовательность целых чисел. Используется в циклах для повторения кода N раз.

**Варианты использования:**
1. `range(stop)` — от 0 до stop-1
2. `range(start, stop)` — от start до stop-1
3. `range(start, stop, step)` — от start до stop-1 с шагом step

**Важно:**
- Конечное значение (`stop`) **не включается**
- По умолчанию начинается с 0
- По умолчанию шаг = 1
- Шаг может быть отрицательным (для обратного отсчёта)

**Примеры:**

```python
# 1. range(stop) — от 0 до stop-1
for i in range(5):
    print(i, end=" ")  # 0 1 2 3 4
print()

# 2. range(start, stop) — от start до stop-1
for i in range(3, 8):
    print(i, end=" ")  # 3 4 5 6 7
print()

# 3. range(start, stop, step) — с шагом
for i in range(0, 10, 2):  # Чётные от 0 до 9
    print(i, end=" ")  # 0 2 4 6 8
print()

for i in range(1, 10, 2):  # Нечётные от 1 до 9
    print(i, end=" ")  # 1 3 5 7 9
print()

# Отрицательный шаг — обратный отсчёт
for i in range(10, 0, -1):  # От 10 до 1
    print(i, end=" ")  # 10 9 8 7 6 5 4 3 2 1
print()

for i in range(5, -1, -1):  # От 5 до 0
    print(i, end=" ")  # 5 4 3 2 1 0
print()

# Обратный отсчёт с шагом -2
for i in range(20, 0, -2):
    print(i, end=" ")  # 20 18 16 14 12 10 8 6 4 2
print()

# Пустой диапазон
for i in range(5, 5):
    print(i)  # Ничего не выведется

for i in range(5, 2):  # start > stop при положительном шаге
    print(i)  # Ничего не выведется

# Преобразование range в список (для просмотра)
print(list(range(5)))           # [0, 1, 2, 3, 4]
print(list(range(2, 8)))        # [2, 3, 4, 5, 6, 7]
print(list(range(0, 10, 3)))    # [0, 3, 6, 9]
print(list(range(10, 0, -2)))   # [10, 8, 6, 4, 2]

# Практические примеры

# Обратный отсчёт
print("Запуск ракеты:")
for i in range(10, 0, -1):
    print(i)
print("Пуск!")

# Таблица степеней двойки
for i in range(0, 11):
    print(f"2^{i} = {2**i}")

# Печать чисел кратных 5 от 0 до 50
for i in range(0, 51, 5):
    print(i, end=" ")  # 0 5 10 15 20 25 30 35 40 45 50
print()

# Итерация по индексам строки
text = "Python"
for i in range(len(text)):
    print(f"Индекс {i}: {text[i]}")
# Индекс 0: P
# Индекс 1: y
# Индекс 2: t
# Индекс 3: h
# Индекс 4: o
# Индекс 5: n

# Шаг больше диапазона
for i in range(0, 10, 100):
    print(i)  # 0 (только одна итерация)

# Дробный шаг (нельзя!)
# for i in range(0, 10, 0.5):  # TypeError!
# Решение — умножить на 10 и делить внутри цикла
for i in range(0, 100, 5):
    print(i / 10, end=" ")  # 0.0 0.5 1.0 1.5 ... 9.5
print()
```

### `6.1.3` `_` в цикле for
Символ `_` (подчёркивание) используется как имя переменной цикла, когда само значение не важно — нужно только количество повторений. Это **соглашение**, говорящее "эта переменная не используется".

**Когда использовать:**
- Нужно повторить действие N раз
- Значение счётчика не используется в коде
- Делает код понятнее — сразу видно, что переменная игнорируется

**Примеры:**

```python
# Повторить 5 раз (без использования переменной)
for _ in range(5):
    print("Привет!")
# Привет!
# Привет!
# Привет!
# Привет!
# Привет!

# Вместо:
for i in range(5):
    print("Привет!")  # i не используется — лучше написать _

# Ввод нескольких чисел
numbers = []
for _ in range(3):
    num = int(input("Введите число: "))
    numbers.append(num)
print(numbers)

# Рисование паттернов
for _ in range(10):
    print("*" * 20)

# Генерация случайных чисел
import random
for _ in range(5):
    print(random.randint(1, 100))

# Повторение вопроса
attempts = 3
for _ in range(attempts):
    password = input("Введите пароль: ")
    if password == "secret":
        print("Доступ разрешён")
        break
else:
    print("Превышено количество попыток")

# Множественный ввод
print("Введите 5 имён:")
names = []
for _ in range(5):
    name = input()
    names.append(name)

# Когда _ НЕ нужен (используется переменная)
for i in range(5):
    print(f"Итерация {i}")  # i используется — не заменяем на _

for i in range(1, 6):
    print(f"Квадрат {i}: {i**2}")  # i используется

# Вложенные циклы с _
for _ in range(3):
    for _ in range(5):
        print("*", end="")
    print()  # Переход на новую строку
# *****
# *****
# *****
```

### `6.1.4` Концепция `флага` (сигнала)
**Флаг (flag)** — это переменная (обычно логическая), которая хранит состояние или сигнализирует о наступлении события. Используется для отслеживания условий внутри цикла.

**Типичные применения:**
- Проверка выполнения условия хотя бы раз
- Поиск элемента в последовательности
- Контроль состояния программы
- Выход из цикла при определённом условии

**Паттерн:**
1. Установить флаг в начальное значение (обычно `False`)
2. Изменить флаг при наступлении события
3. Проверить значение флага после цикла

**Примеры:**

```python
# Пример 1: Поиск элемента
number = int(input("Введите число: "))
found = False  # Флаг "найдено"

for i in range(1, 11):
    if i == number:
        found = True
        break

if found:
    print("Число найдено в диапазоне 1-10")
else:
    print("Число не найдено")

# Пример 2: Проверка условия для всех элементов
numbers = [2, 4, 6, 8, 10]
all_even = True  # Флаг "все чётные"

for num in numbers:
    if num % 2 != 0:
        all_even = False
        break

if all_even:
    print("Все числа чётные")
else:
    print("Есть нечётные числа")

# Пример 3: Проверка наличия хотя бы одного элемента
text = "Hello123"
has_digit = False  # Флаг "есть цифра"

for char in text:
    if char.isdigit():
        has_digit = True
        break

if has_digit:
    print("Строка содержит цифры")
else:
    print("Нет цифр")

# Пример 4: Валидация пароля
password = input("Пароль: ")
has_upper = False
has_lower = False
has_digit = False

for char in password:
    if char.isupper():
        has_upper = True
    if char.islower():
        has_lower = True
    if char.isdigit():
        has_digit = True

# Проверка всех флагов
if has_upper and has_lower and has_digit and len(password) >= 8:
    print("Пароль надёжный")
else:
    print("Пароль должен содержать:")
    if not has_upper:
        print("- заглавные буквы")
    if not has_lower:
        print("- строчные буквы")
    if not has_digit:
        print("- цифры")
    if len(password) < 8:
        print("- минимум 8 символов")

# Пример 5: Игра "Угадай число"
import random
secret = random.randint(1, 10)
guessed = False  # Флаг "угадал"

for attempt in range(3):
    guess = int(input(f"Попытка {attempt + 1}: "))
    if guess == secret:
        print("Поздравляю! Вы угадали!")
        guessed = True
        break
    elif guess < secret:
        print("Больше")
    else:
        print("Меньше")

if not guessed:
    print(f"Вы проиграли. Было загадано: {secret}")

# Пример 6: Поиск простого числа
number = int(input("Проверить число на простоту: "))
is_prime = True  # Флаг "простое число"

if number < 2:
    is_prime = False
else:
    for i in range(2, number):
        if number % i == 0:
            is_prime = False
            break

if is_prime:
    print(f"{number} — простое число")
else:
    print(f"{number} — не простое число")

# Пример 7: Множественные флаги
text = "Python 3.11!"
has_letters = False
has_numbers = False
has_special = False

for char in text:
    if char.isalpha():
        has_letters = True
    elif char.isdigit():
        has_numbers = True
    elif not char.isspace():
        has_special = True

print(f"Буквы: {has_letters}")
print(f"Цифры: {has_numbers}")
print(f"Спецсимволы: {has_special}")

# Пример 8: Контроль состояния
students = ["Анна", "Борис", "Вера", "Глеб"]
target = "Вера"
position_found = False
position = 0

for i, student in enumerate(students):
    if student == target:
        position = i
        position_found = True
        break

if position_found:
    print(f"{target} найден(а) на позиции {position}")
else:
    print(f"{target} не найден(а)")

# Без флага можно использовать else у цикла (продвинутое):
for i, student in enumerate(students):
    if student == target:
        print(f"{target} найден(а) на позиции {i}")
        break
else:  # Выполнится, если break не сработал
    print(f"{target} не найден(а)")
```

**Итог:**
- `for` перебирает элементы последовательности
- `range()` генерирует числа: `range(stop)`, `range(start, stop)`, `range(start, stop, step)`
- `_` используется, когда переменная цикла не нужна
- Флаг — переменная для отслеживания события в цикле

## `6.2` While loop
### `6.2.1` Как написать while loop в `Python`?
**Цикл `while`** — конструкция для повторения кода, пока условие истинно (`True`). В отличие от `for`, который перебирает элементы, `while` работает на основе условия.

**Структура:**
```python
while условие:
    # код, который повторяется
    # пока условие True
```

**Как работает:**
1. Проверяется условие
2. Если `True` — выполняется блок кода
3. Снова проверяется условие
4. Повторяется, пока условие не станет `False`
5. Если условие сразу `False` — блок не выполнится ни разу

**Важно:** Нужно обеспечить изменение условия внутри цикла, иначе получится бесконечный цикл!

**Примеры:**

```python
# Пример 1: Простой счётчик
i = 0
while i < 5:
    print(i)
    i += 1  # Обязательно изменяем i!
# 0
# 1
# 2
# 3
# 4
```

```python
# Пример 2: Обратный отсчёт
count = 5
while count > 0:
    print(count)
    count -= 1
print("Пуск!")
# 5
# 4
# 3
# 2
# 1
# Пуск!
```

```python
# Пример 3: Накопление суммы
total = 0
i = 1
while i <= 10:
    total += i
    i += 1
print(f"Сумма чисел от 1 до 10: {total}")  # 55
```

```python
# Пример 4: Ввод до корректного значения
age = -1
while age < 0:
    age = int(input("Введите возраст (положительное число): "))
    if age < 0:
        print("Возраст не может быть отрицательным")
print(f"Ваш возраст: {age}")

# Пример 5: Игра "Угадай число"
import random
secret = random.randint(1, 10)
guess = 0

while guess != secret:
    guess = int(input("Угадайте число от 1 до 10: "))
    if guess < secret:
        print("Больше!")
    elif guess > secret:
        print("Меньше!")

print("Правильно! Вы угадали!")
```

```python
# Пример 6: Меню программы
choice = ""
while choice != "выход":
    print("\nМеню:")
    print("1. Показать информацию")
    print("2. Настройки")
    print("Введите 'выход' для завершения")
    
    choice = input("Ваш выбор: ").lower()
    
    if choice == "1":
        print("Информация отображена")
    elif choice == "2":
        print("Настройки открыты")
    elif choice == "выход":
        print("До свидания!")
    else:
        print("Неверный выбор")
```

```python
# Пример 7: Валидация ввода
password = ""
while len(password) < 8:
    password = input("Пароль (минимум 8 символов): ")
    if len(password) < 8:
        print(f"Слишком короткий! Введено {len(password)} символов")
print("Пароль принят")
```

```python
# Пример 8: Сумма чисел до отрицательного
total = 0
number = 0

print("Вводите положительные числа. Отрицательное число завершит ввод.")
while number >= 0:
    number = int(input("Число: "))
    if number >= 0:
        total += number

print(f"Сумма: {total}")
```

```python
# Пример 9: Факториал
n = int(input("Факториал числа: "))
factorial = 1
i = 1

while i <= n:
    factorial *= i
    i += 1

print(f"{n}! = {factorial}")
```

```python
# Пример 10: Деление пополам
number = 100
count = 0

while number > 1:
    number = number // 2
    count += 1
    print(f"Шаг {count}: {number}")

print(f"Понадобилось {count} делений")
```

```python
# Пример 11: Поиск цифр в числе
number = int(input("Введите число: "))
digit_count = 0

# Работаем с копией
temp = abs(number)  # Убираем знак
while temp > 0:
    temp = temp // 10
    digit_count += 1

if number == 0:
    digit_count = 1

print(f"Количество цифр: {digit_count}")
```

```python
# Пример 12: Условие с несколькими переменными
balance = 100
attempts = 3

while balance > 0 and attempts > 0:
    withdraw = int(input(f"Баланс: {balance}. Сколько снять? "))
    
    if withdraw <= balance:
        balance -= withdraw
        print(f"Выдано {withdraw}. Остаток: {balance}")
    else:
        attempts -= 1
        print(f"Недостаточно средств. Попыток осталось: {attempts}")

if balance == 0:
    print("Баланс исчерпан")
if attempts == 0:
    print("Превышено количество попыток")
```

**Сравнение while и for:**

```python
# Одинаковый результат разными способами

# for — когда знаем количество итераций
for i in range(5):
    print(i)

# while — то же самое
i = 0
while i < 5:
    print(i)
    i += 1

# for удобнее для перебора
for num in [1, 2, 3, 4, 5]:
    print(num)

# while нужен для условных повторений
password = ""
while password != "secret":
    password = input("Пароль: ")
```

### `6.2.2` Бесконечные циклы
**Бесконечный цикл** — это цикл, условие которого никогда не становится `False`. Цикл выполняется бесконечно, пока программа не будет принудительно остановлена.

**Когда возникает:**
- Условие всегда истинно: `while True:`
- Забыли изменить переменную условия
- Логическая ошибка в условии

**Когда используется намеренно:**
- Серверы и программы, которые должны работать постоянно
- Игровые циклы
- Меню с выходом по команде
- Обработка событий

**Как остановить:**
- `break` — выход из цикла программно
- `Ctrl + C` — принудительная остановка в терминале

**Примеры:**

```python
# ❌ Случайные бесконечные циклы (ошибки)

# Забыли изменить переменную
i = 0
while i < 5:
    print(i)
    # Забыли i += 1 — бесконечный цикл!

# Неправильное условие
count = 10
while count > 0:
    print(count)
    count += 1  # Увеличиваем вместо уменьшения!

# Условие никогда не меняется
x = 5
while x != 10:
    print(x)
    # x не изменяется — бесконечный цикл!
```

```python
# ✅ Намеренные бесконечные циклы (с выходом)

# Пример 1: while True с break
while True:
    command = input("Команда (или 'выход'): ")
    if command == "выход":
        break
    print(f"Выполнена команда: {command}")
print("Программа завершена")
```

```python
# Пример 2: Калькулятор с бесконечным циклом
while True:
    print("\nКалькулятор")
    print("Введите 'q' для выхода")
    
    first = input("Первое число: ")
    if first == "q":
        break
    
    second = input("Второе число: ")
    if second == "q":
        break
    
    operation = input("Операция (+, -, *, /): ")
    if operation == "q":
        break
    
    first = float(first)
    second = float(second)
    
    if operation == "+":
        print(f"Результат: {first + second}")
    elif operation == "-":
        print(f"Результат: {first - second}")
    elif operation == "*":
        print(f"Результат: {first * second}")
    elif operation == "/":
        if second != 0:
            print(f"Результат: {first / second}")
        else:
            print("Деление на ноль!")
```

```python
# Пример 3: Игра с повторениями
while True:
    print("\n--- Новая игра ---")
    
    # Игровая логика
    import random
    secret = random.randint(1, 10)
    attempts = 0
    
    while True:
        guess = int(input("Угадайте число (1-10): "))
        attempts += 1
        
        if guess == secret:
            print(f"Угадали за {attempts} попыток!")
            break
        elif guess < secret:
            print("Больше")
        else:
            print("Меньше")
    
    again = input("Играть ещё? (да/нет): ")
    if again.lower() != "да":
        break

print("Спасибо за игру!")
```

```python
# Пример 4: Сервер (упрощённо)
print("Сервер запущен. Ctrl+C для остановки")
request_count = 0

while True:
    # Симуляция обработки запроса
    request_count += 1
    print(f"Обработан запрос #{request_count}")
    
    # В реальности здесь ожидание запроса
    import time
    time.sleep(1)  # Задержка 1 секунда
    
    # Условие остановки для примера
    if request_count >= 10:
        print("Достигнут лимит запросов")
        break
```

```python
# Пример 5: Чат-бот
print("Чат-бот запущен. Напишите 'пока' для выхода.")

while True:
    message = input("Вы: ")
    
    if message.lower() == "пока":
        print("Бот: До встречи!")
        break
    elif "привет" in message.lower():
        print("Бот: Здравствуйте!")
    elif "как дела" in message.lower():
        print("Бот: Отлично, спасибо!")
    else:
        print("Бот: Интересно...")
```

```python
# Пример 6: Меню с множественным выбором
while True:
    print("\n=== Главное меню ===")
    print("1. Новая игра")
    print("2. Загрузить")
    print("3. Настройки")
    print("4. Выход")
    
    choice = input("Выберите пункт: ")
    
    if choice == "1":
        print("Новая игра начата")
    elif choice == "2":
        print("Игра загружена")
    elif choice == "3":
        print("Настройки открыты")
    elif choice == "4":
        print("Выход из программы")
        break
    else:
        print("Неверный выбор!")
```

```python
# Пример 7: Обработка ошибок ввода
while True:
    try:
        age = int(input("Введите возраст: "))
        if age < 0:
            print("Возраст не может быть отрицательным")
            continue
        if age > 150:
            print("Введите реальный возраст")
            continue
        print(f"Возраст принят: {age}")
        break
    except ValueError:
        print("Введите число!")
```

```python
# Пример 8: Счётчик с условием выхода
counter = 0
while True:
    counter += 1
    print(f"Итерация {counter}")
    
    if counter >= 10:
        print("Достигнут лимит итераций")
        break
    
    if counter % 3 == 0:
        print("Кратно 3!")
```

```python
# Пример 9: Накопление данных
numbers = []
print("Вводите числа. Введите 0 для завершения.")

while True:
    num = int(input("Число: "))
    if num == 0:
        break
    numbers.append(num)

if numbers:
    print(f"Введено чисел: {len(numbers)}")
    print(f"Сумма: {sum(numbers)}")
    print(f"Среднее: {sum(numbers) / len(numbers)}")
else:
    print("Числа не были введены")
```

**Опасности бесконечных циклов:**

```python
# ❌ Зависание программы
# while True:
#     print("Бесконечно...")
# Программа зависнет, придётся закрывать принудительно

# ✅ Всегда добавляйте условие выхода
max_iterations = 1000
count = 0

while True:
    count += 1
    # ... код ...
    
    if count > max_iterations:
        print("Превышен лимит итераций!")
        break
```

**Итог:**
- `while` повторяет код, пока условие `True`
- Обязательно изменяйте переменные условия, иначе зависнет
- `while True:` с `break` — стандартный паттерн для бесконечных циклов с выходом
- Используйте для меню, игр, серверов, валидации ввода

### `6.2.3` (`*`) Операторы: `break`, `continue`, `else`. Кейсы применения
#### **Оператор `break` — досрочный выход из цикла**

`break` прерывает цикл и переходит к коду после него. Полезен, когда нужно остановить цикл при выполнении условия.

```python
# Базовый пример
for i in range(10):
    if i == 5:
        break
    print(i)
# Выведет: 0 1 2 3 4

# Поиск элемента в списке
users = ["Alice", "Bob", "Charlie", "David"]
search = "Charlie"

for user in users:
    if user == search:
        print(f"Найден: {user}")
        break
# Выведет: Найден: Charlie

# Бесконечный цикл с break
while True:
    command = input("Введите команду (exit для выхода): ")
    if command == "exit":
        break
    print(f"Выполняю: {command}")
```

#### **Оператор `continue` — пропуск текущей итерации**

`continue` пропускает оставшийся код в текущей итерации и переходит к следующей. Удобно для игнорирования определённых условий.

```python
# Базовый пример
for i in range(5):
    if i == 3:
        continue
    print(i)
# Выведет: 0 1 2 4

# Пропуск чётных чисел
for num in range(10):
    if num % 2 == 0:
        continue
    print(num)
# Выведет: 1 3 5 7 9

# Фильтрация данных
prices = [100, -50, 200, 0, 150]
for price in prices:
    if price <= 0:
        continue
    discount = price * 0.1
    print(f"Цена: {price}, скидка: {discount}")
# Выведет только положительные цены со скидками
```

#### **Блок `else` с циклами — выполнение при нормальном завершении**

`else` после цикла выполняется, только если цикл завершился **без `break`**.

```python
# Базовый пример
for i in range(3):
    if i == 5:
        break
else:
    print("Цикл выполнен до конца")
# Выведет: Цикл выполнен до конца (break не сработал)

# Поиск с проверкой результата
numbers = [1, 3, 5, 7, 9]
target = 4

for num in numbers:
    if num == target:
        print(f"Число {target} найдено")
        break
else:
    print(f"Число {target} не найдено")
# Выведет: Число 4 не найдено

# Проверка простого числа
n = 17
for i in range(2, n):
    if n % i == 0:
        print(f"{n} не является простым числом")
        break
else:
    print(f"{n} — простое число")
# Выведет: 17 — простое число
```

**Кейсы применения:**

- **`break`:** поиск элемента (выход при первом совпадении), досрочный выход при ошибке, выход из бесконечных циклов
- **`continue`:** фильтрация данных (пропуск невалидных значений), уменьшение вложенности кода, пропуск ненужных итераций
- **`else` с циклом:** проверка результата поиска (найден/не найден), валидация данных, выполнение действий при полном прохождении цикла


## `6.3` Вложенные циклы
### `6.3.1` Что такое вложенные циклы?
**Вложенные циклы** — это циклы внутри других циклов. Внешний цикл выполняет одну итерацию, а внутренний за это время выполняет все свои итерации полностью.

**Структура:**
```python
for переменная1 in последовательность1:
    # Внешний цикл
    for переменная2 in последовательность2:
        # Внутренний цикл
        # Этот код выполнится множество раз
```

**Как работает:**
1. Внешний цикл начинает первую итерацию
2. Внутренний цикл выполняет ВСЕ свои итерации
3. Внешний цикл переходит ко второй итерации
4. Внутренний цикл снова выполняет ВСЕ свои итерации
5. И так далее

**Количество итераций:** Если внешний цикл выполняется N раз, а внутренний M раз, то общее количество итераций = N × M.

**Примеры:**

```python
# Пример 1: Базовый вложенный цикл
for i in range(3):  # Внешний: 3 итерации
    for j in range(2):  # Внутренний: 2 итерации
        print(f"i={i}, j={j}")

# Вывод:
# i=0, j=0
# i=0, j=1
# i=1, j=0
# i=1, j=1
# i=2, j=0
# i=2, j=1
# Всего: 3 × 2 = 6 итераций
```

```python
# Пример 2: Таблица умножения
for i in range(1, 6):  # Числа 1-5
    for j in range(1, 6):  # Числа 1-5
        print(f"{i} × {j} = {i * j}")
    print()  # Пустая строка после каждого числа
```

```python
# Пример 3: Печать прямоугольника из звёздочек
rows = 4
cols = 6

for i in range(rows):
    for j in range(cols):
        print("*", end="")
    print()  # Переход на новую строку

# Вывод:
# ******
# ******
# ******
# ******
```

```python
# Пример 4: Треугольник
n = 5
for i in range(1, n + 1):  # Строки
    for j in range(i):  # Количество звёздочек = номер строки
        print("*", end="")
    print()

# Вывод:
# *
# **
# ***
# ****
# *****
```

```python
# Пример 5: Таблица умножения (красиво)
print("Таблица умножения:")
print("-" * 40)

for i in range(1, 11):
    for j in range(1, 11):
        print(f"{i * j:4}", end="")  # :4 — ширина 4 символа
    print()
```

```python
# Пример 6: Перебор элементов двумерного списка (матрицы)
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

print("Элементы матрицы:")
for row in matrix:  # Перебираем строки
    for element in row:  # Перебираем элементы в строке
        print(element, end=" ")
    print()

# Вывод:
# 1 2 3
# 4 5 6
# 7 8 9
```

```python
# Пример 7: Поиск в двумерном списке
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

target = 5
found = False

for i in range(len(matrix)):
    for j in range(len(matrix[i])):
        if matrix[i][j] == target:
            print(f"Найдено: {target} на позиции [{i}][{j}]")
            found = True
            break
    if found:
        break
```

**Важные моменты:**

```python
# Следите за производительностью!
# O(n²) — квадратичная сложность
for i in range(1000):
    for j in range(1000):
        pass  # 1,000,000 итераций!

# Используйте осознанно
# Не всегда нужны вложенные циклы, иногда достаточно одного

# Именование переменных
# i, j, k — стандартные имена для вложенных циклов
# Для ясности можно использовать row, col или более описательные имена
```

**Итог:**
- Вложенные циклы — это циклы внутри циклов
- Общее количество итераций = произведение итераций всех циклов
- Внутренний цикл полностью выполняется на каждой итерации внешнего
- Используются для работы с таблицами, матрицами, комбинациями, паттернами
- Будьте осторожны с производительностью при большом количестве итераций

### `6.3.2` (`*`) Как работают операторы `break`, `continue`, `else` во вложенных циклах
#### **Оператор `break` во вложенных циклах**

`break` прерывает **только тот цикл, в котором он вызван**. Внешний цикл продолжает работать.

```python
# break прерывает только внутренний цикл
for i in range(3):
    print(f"Внешний цикл: i={i}")
    for j in range(3):
        if j == 1:
            break  # Выходит только из внутреннего цикла
        print(f"  Внутренний цикл: j={j}")
# Выведет:
# Внешний цикл: i=0
#   Внутренний цикл: j=0
# Внешний цикл: i=1
#   Внутренний цикл: j=0
# Внешний цикл: i=2
#   Внутренний цикл: j=0
```

**Выход из всех циклов сразу — использование флага:**

```python
# Флаг для выхода из всех циклов
found = False
for i in range(3):
    for j in range(3):
        if i == 1 and j == 1:
            found = True
            break  # Выход из внутреннего
    if found:
        break  # Выход из внешнего
    print(f"i={i} завершён")
# Выведет только: i=0 завершён
```

**Альтернатива — использование функции и return:**

```python
def find_in_matrix(matrix, target):
    for i, row in enumerate(matrix):
        for j, value in enumerate(row):
            if value == target:
                return (i, j)  # Выход из всех циклов сразу
    return None

matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
result = find_in_matrix(matrix, 5)
print(result)  # (1, 1)
```

#### **Оператор `continue` во вложенных циклах**

`continue` действует **только на текущий цикл** — пропускает остаток текущей итерации и переходит к следующей.

```python
# continue во внутреннем цикле
for i in range(3):
    for j in range(3):
        if j == 1:
            continue  # Пропускает только j=1 во внутреннем цикле
        print(f"i={i}, j={j}")
# Выведет:
# i=0, j=0
# i=0, j=2
# i=1, j=0
# i=1, j=2
# i=2, j=0
# i=2, j=2

# continue во внешнем цикле
for i in range(3):
    if i == 1:
        continue  # Пропускает всю итерацию при i=1
    for j in range(2):
        print(f"i={i}, j={j}")
# Выведет:
# i=0, j=0
# i=0, j=1
# i=2, j=0
# i=2, j=1
```

#### **Блок `else` во вложенных циклах**

`else` выполняется, только если цикл завершился **без `break`**. Каждый цикл имеет свой собственный `else`.

```python
# else для внутреннего цикла
for i in range(2):
    for j in range(3):
        if j == 5:  # Условие не выполнится
            break
    else:
        print(f"Внутренний цикл i={i} завершён без break")
# Выведет:
# Внутренний цикл i=0 завершён без break
# Внутренний цикл i=1 завершён без break

# break во внутреннем цикле отменяет его else
for i in range(2):
    for j in range(3):
        if j == 1:
            break  # else внутреннего цикла не выполнится
    else:
        print(f"Внутренний цикл i={i} завершён")
# Ничего не выведет (break сработал в обеих итерациях)

# Комбинация else для обоих циклов
for i in range(2):
    for j in range(2):
        print(f"i={i}, j={j}")
    else:
        print(f"  Внутренний цикл для i={i} завершён")
else:
    print("Внешний цикл завершён")
# Выведет:
# i=0, j=0
# i=0, j=1
#   Внутренний цикл для i=0 завершён
# i=1, j=0
# i=1, j=1
#   Внутренний цикл для i=1 завершён
# Внешний цикл завершён
```

**Практический пример — поиск в двумерном массиве:**

```python
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
target = 5
found = False

for i, row in enumerate(matrix):
    for j, value in enumerate(row):
        if value == target:
            print(f"Найдено {target} на позиции ({i}, {j})")
            found = True
            break
    if found:
        break
else:
    print(f"Значение {target} не найдено")
# Выведет: Найдено 5 на позиции (1, 1)
```

**Ключевые моменты:**

- `break` и `continue` влияют только на тот цикл, где они вызваны
- Для выхода из всех циклов используйте флаг или функцию с `return`
- `else` у каждого цикла работает независимо
- `else` не выполняется, если сработал `break` в соответствующем цикле

----

# `7` Типы данных 2 (Списки)
## `7.1` Что такое список? Функция `list()`. Изменяемость списков.
**Список (list)** — упорядоченная изменяемая коллекция элементов. Может хранить данные любых типов: числа, строки, другие списки и т.д.

**Создание списка:**
```python
# Пустой список
my_list = []
# Список с элементами
numbers = [1, 2, 3, 4, 5]
# Смешанные типы
mixed = [1, "текст", 3.14, True]
```

**На что похож в других языках:**
- **Java, C#** — `ArrayList` (динамический массив)
- **C++** — `std::vector`
- **JavaScript** — `Array`
- **PHP** — `array` (индексированный массив)

**Функция `list()`:**
Преобразует другие последовательности (строки, кортежи, range) в список.

**Изменяемость:**
Списки **изменяемы** — можно добавлять, удалять, изменять элементы после создания.

**Примеры:**

```python
# Создание списков
empty_list = []
numbers = [1, 2, 3, 4, 5]
fruits = ["яблоко", "банан", "апельсин"]
mixed = [1, "два", 3.0, True, [5, 6]]

print(numbers)  # [1, 2, 3, 4, 5]
print(type(numbers))  # <class 'list'>
```

```python
# Функция list() — преобразование в список
text = "Python"
letters = list(text)
print(letters)  # ['P', 'y', 't', 'h', 'o', 'n']

numbers_range = list(range(5))
print(numbers_range)  # [0, 1, 2, 3, 4]

tuple_data = (1, 2, 3)
list_data = list(tuple_data)
print(list_data)  # [1, 2, 3]
```

```python
# Изменяемость списков
numbers = [1, 2, 3]
print(numbers)  # [1, 2, 3]

# Изменение элемента
numbers[0] = 10
print(numbers)  # [10, 2, 3]

# Добавление элемента
numbers.append(4)
print(numbers)  # [10, 2, 3, 4]

# Удаление элемента
numbers.remove(2)
print(numbers)  # [10, 3, 4]
```

```python
# Сравнение с неизменяемыми строками
# Строки — неизменяемы
text = "Hello"
# text[0] = "J"  # TypeError! Нельзя изменить

# Списки — изменяемы
letters = ["H", "e", "l", "l", "o"]
letters[0] = "J"
print(letters)  # ['J', 'e', 'l', 'l', 'o']
```

```python
# Вложенные списки (списки внутри списков)
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]
print(matrix[0])  # [1, 2, 3]
print(matrix[1][1])  # 5
```

## `7.2` Функции `len()`, `in` для списков
### `len()` — длина списка
Возвращает количество элементов в списке.

### `in` — проверка наличия элемента
Проверяет, содержится ли элемент в списке. Возвращает `True` или `False`.

**Примеры:**

```python
# len() — длина списка
numbers = [1, 2, 3, 4, 5]
print(len(numbers))  # 5

fruits = ["яблоко", "банан"]
print(len(fruits))  # 2

empty = []
print(len(empty))  # 0

nested = [[1, 2], [3, 4], [5, 6]]
print(len(nested))  # 3 (три списка внутри)
```

```python
# in — проверка наличия элемента
numbers = [1, 2, 3, 4, 5]

print(3 in numbers)  # True
print(10 in numbers)  # False

fruits = ["яблоко", "банан", "апельсин"]
print("банан" in fruits)  # True
print("груша" in fruits)  # False
```

```python
# not in — проверка отсутствия
numbers = [1, 2, 3, 4, 5]

print(10 not in numbers)  # True
print(3 not in numbers)  # False
```

```python
# Использование в условиях
shopping_list = ["молоко", "хлеб", "яйца"]
item = input("Что купить? ")

if item in shopping_list:
    print(f"{item} уже в списке")
else:
    shopping_list.append(item)
    print(f"{item} добавлен в список")
```

```python
# Подсчёт элементов
numbers = [1, 2, 3, 2, 4, 2, 5]
count = 0

for num in numbers:
    if num == 2:
        count += 1

print(f"Число 2 встречается {count} раз")  # 3 раза
```

```python
# Проверка нескольких условий
allowed_users = ["admin", "user1", "user2"]
username = input("Имя пользователя: ")

if username in allowed_users:
    print("Доступ разрешён")
else:
    print("Доступ запрещён")
```

## `7.3` Индексы
**Индекс** — порядковый номер элемента в списке. Нумерация начинается с 0.

**Особенности:**
- Положительные индексы: 0, 1, 2, ... (слева направо)
- Отрицательные индексы: -1, -2, -3, ... (справа налево)
- `-1` — последний элемент
- Выход за границы списка вызывает `IndexError`

**Примеры:**

```python
# Положительные индексы
fruits = ["яблоко", "банан", "апельсин", "груша", "киви"]
#         0         1         2           3        4

print(fruits[0])  # яблоко (первый)
print(fruits[1])  # банан
print(fruits[4])  # киви (последний)
```

```python
# Отрицательные индексы
fruits = ["яблоко", "банан", "апельсин", "груша", "киви"]
#         -5        -4       -3          -2       -1

print(fruits[-1])  # киви (последний)
print(fruits[-2])  # груша (предпоследний)
print(fruits[-5])  # яблоко (первый)
```

```python
# Изменение элементов по индексу
numbers = [1, 2, 3, 4, 5]
numbers[0] = 10
print(numbers)  # [10, 2, 3, 4, 5]

numbers[-1] = 50
print(numbers)  # [10, 2, 3, 4, 50]
```

```python
# Ошибка при выходе за границы
numbers = [1, 2, 3]
# print(numbers[10])  # IndexError: list index out of range
# print(numbers[-10])  # IndexError: list index out of range
```

```python
# Безопасный доступ с проверкой
numbers = [1, 2, 3]
index = 5

if 0 <= index < len(numbers):
    print(numbers[index])
else:
    print("Индекс вне диапазона")
```

```python
# Доступ к вложенным спискам
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

print(matrix[0])     # [1, 2, 3] — первая строка
print(matrix[1][2])  # 6 — вторая строка, третий элемент
print(matrix[-1][-1])  # 9 — последняя строка, последний элемент
```

```python
# Получение первого и последнего элемента
numbers = [10, 20, 30, 40, 50]

first = numbers[0]
last = numbers[-1]

print(f"Первый: {first}, Последний: {last}")  # Первый: 10, Последний: 50
```

```python
# Изменение среднего элемента
numbers = [1, 2, 3, 4, 5]
middle_index = len(numbers) // 2
numbers[middle_index] = 100

print(numbers)  # [1, 2, 100, 4, 5]
```

## `7.4` Slices
**Срезы (slices)** — способ получить подсписок (часть списка).

**Синтаксис:**
```python
список[start:stop:step]
```
- `start` — начальный индекс (включительно)
- `stop` — конечный индекс (не включительно)
- `step` — шаг (по умолчанию 1)

**Особенности:**
- Если параметр опущен, используется значение по умолчанию
- Отрицательные индексы работают
- Выход за границы не вызывает ошибку (вернёт пустой список или часть)

**Примеры:**

```python
# Базовые срезы
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

print(numbers[2:5])   # [2, 3, 4] — с 2 по 4 (5 не включается)
print(numbers[0:3])   # [0, 1, 2] — первые 3 элемента
print(numbers[5:10])  # [5, 6, 7, 8, 9] — с 5 до конца
```

```python
# Опущенные параметры
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

print(numbers[:5])    # [0, 1, 2, 3, 4] — с начала до 5
print(numbers[5:])    # [5, 6, 7, 8, 9] — с 5 до конца
print(numbers[:])     # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] — весь список (копия)
```

```python
# Срезы с шагом
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

print(numbers[::2])    # [0, 2, 4, 6, 8] — каждый второй
print(numbers[1::2])   # [1, 3, 5, 7, 9] — каждый второй, начиная с 1
print(numbers[::3])    # [0, 3, 6, 9] — каждый третий
```

```python
# Отрицательные индексы в срезах
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

print(numbers[-5:])     # [5, 6, 7, 8, 9] — последние 5
print(numbers[:-3])     # [0, 1, 2, 3, 4, 5, 6] — все кроме последних 3
print(numbers[-7:-2])   # [3, 4, 5, 6, 7] — с -7 до -2
```

```python
# Отрицательный шаг (разворот)
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

print(numbers[::-1])   # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] — развернуть список
print(numbers[::-2])   # [9, 7, 5, 3, 1] — каждый второй с конца
print(numbers[7:2:-1]) # [7, 6, 5, 4, 3] — с 7 до 3 в обратном порядке
```

```python
# Практические примеры

# Первая половина списка
numbers = [1, 2, 3, 4, 5, 6, 7, 8]
first_half = numbers[:len(numbers)//2]
print(first_half)  # [1, 2, 3, 4]

# Вторая половина списка
second_half = numbers[len(numbers)//2:]
print(second_half)  # [5, 6, 7, 8]

# Каждый третий элемент
every_third = numbers[::3]
print(every_third)  # [1, 4, 7]
```

```python
# Удаление элементов через срезы
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# Удалить первые 3 элемента
numbers = numbers[3:]
print(numbers)  # [3, 4, 5, 6, 7, 8, 9]

# Удалить последние 2 элемента
numbers = numbers[:-2]
print(numbers)  # [3, 4, 5, 6, 7]
```

```python
# Замена части списка через срез
numbers = [0, 1, 2, 3, 4, 5]
numbers[1:4] = [10, 20, 30]
print(numbers)  # [0, 10, 20, 30, 4, 5]

# Можно заменить на меньшее количество элементов
numbers[2:5] = [100]
print(numbers)  # [0, 10, 100, 5]
```

```python
# Копирование списка
original = [1, 2, 3, 4, 5]
copy = original[:]  # Срез создаёт копию

copy[0] = 100
print(original)  # [1, 2, 3, 4, 5] — не изменился
print(copy)      # [100, 2, 3, 4, 5]
```

```python
# Пустые срезы
numbers = [1, 2, 3, 4, 5]

print(numbers[10:20])  # [] — выход за границы даёт пустой список
print(numbers[3:1])    # [] — start > stop
print(numbers[5:])     # [] — начало за пределами списка
```

## `7.5` Функции `sum()`, `min()`, `max()`

### `sum()` — сумма элементов
Возвращает сумму всех элементов списка (работает только с числами).

### `min()` — минимальный элемент
Возвращает наименьший элемент списка.

### `max()` — максимальный элемент
Возвращает наибольший элемент списка.

**Примеры:**

```python
# sum() — сумма элементов
numbers = [1, 2, 3, 4, 5]
print(sum(numbers))  # 15

prices = [100, 250, 75, 320]
total = sum(prices)
print(f"Итого: {total} руб")  # Итого: 745 руб

# Пустой список
print(sum([]))  # 0
```

```python
# sum() с начальным значением
numbers = [1, 2, 3, 4, 5]
print(sum(numbers, 10))  # 25 (15 + 10)

# Добавление к существующей сумме
existing_total = 100
new_items = [50, 25, 75]
updated_total = existing_total + sum(new_items)
print(updated_total)  # 250
```

```python
# min() — минимальный элемент
numbers = [5, 2, 8, 1, 9]
print(min(numbers))  # 1

temperatures = [-5, 3, -10, 0, 7]
print(min(temperatures))  # -10

# min() со строками (лексикографически)
words = ["яблоко", "банан", "апельсин"]
print(min(words))  # апельсин (по алфавиту)
```

```python
# max() — максимальный элемент
numbers = [5, 2, 8, 1, 9]
print(max(numbers))  # 9

scores = [85, 92, 78, 95, 88]
highest_score = max(scores)
print(f"Лучший результат: {highest_score}")  # 95
```

```python
# Комбинированное использование
numbers = [12, 45, 7, 23, 56, 89, 34]

print(f"Сумма: {sum(numbers)}")        # 266
print(f"Минимум: {min(numbers)}")      # 7
print(f"Максимум: {max(numbers)}")     # 89
print(f"Среднее: {sum(numbers) / len(numbers):.2f}")  # 38.00
```

```python
# Практический пример — анализ оценок
grades = [85, 90, 78, 92, 88, 95, 82]

total = sum(grades)
average = total / len(grades)
highest = max(grades)
lowest = min(grades)

print(f"Всего оценок: {len(grades)}")
print(f"Средний балл: {average:.2f}")
print(f"Лучшая оценка: {highest}")
print(f"Худшая оценка: {lowest}")
print(f"Разница: {highest - lowest}")
```

```python
# Ошибки — пустой список
# print(min([]))  # ValueError: min() arg is an empty sequence
# print(max([]))  # ValueError: max() arg is an empty sequence

# Безопасная проверка
numbers = []
if numbers:
    print(f"Минимум: {min(numbers)}")
else:
    print("Список пуст")
```

```python
# min() и max() с несколькими аргументами
print(min(5, 2, 8, 1, 9))  # 1
print(max(5, 2, 8, 1, 9))  # 9

# Сравнение трёх чисел
a, b, c = 10, 25, 15
print(f"Наименьшее: {min(a, b, c)}")  # 10
print(f"Наибольшее: {max(a, b, c)}")  # 25
```

## `7.6` Конкатенация и другие математические операции
### Конкатенация (`+`) — склеивание списков
Объединяет два списка в один новый список.

### Повторение (`*`) — дублирование списка
Повторяет список указанное количество раз.

### Сравнение списков
Списки можно сравнивать операторами `==`, `!=`, `<`, `>` (лексикографически).

**Примеры:**

```python
# Конкатенация списков
list1 = [1, 2, 3]
list2 = [4, 5, 6]
combined = list1 + list2
print(combined)  # [1, 2, 3, 4, 5, 6]

# Исходные списки не изменяются
print(list1)  # [1, 2, 3]
print(list2)  # [4, 5, 6]
```

```python
# Объединение нескольких списков
fruits = ["яблоко", "банан"]
vegetables = ["морковь", "капуста"]
berries = ["клубника", "малина"]

all_food = fruits + vegetables + berries
print(all_food)
# ['яблоко', 'банан', 'морковь', 'капуста', 'клубника', 'малина']
```

```python
# Добавление элемента через конкатенацию
numbers = [1, 2, 3]
numbers = numbers + [4]
print(numbers)  # [1, 2, 3, 4]

# Добавление в начало
numbers = [0] + numbers
print(numbers)  # [0, 1, 2, 3, 4]
```

```python
# Повторение списка
zeros = [0] * 5
print(zeros)  # [0, 0, 0, 0, 0]

pattern = [1, 2] * 3
print(pattern)  # [1, 2, 1, 2, 1, 2]

# Создание начального списка
grid = [[0] * 3] * 2  # Осторожно! Создаёт ссылки на один список
print(grid)  # [[0, 0, 0], [0, 0, 0]]
```

```python
# Пустой список при умножении на 0
numbers = [1, 2, 3] * 0
print(numbers)  # []

# Отрицательные числа тоже дают пустой список
numbers = [1, 2, 3] * -5
print(numbers)  # []
```

```python
# Сравнение списков — равенство
list1 = [1, 2, 3]
list2 = [1, 2, 3]
list3 = [1, 2, 4]

print(list1 == list2)  # True (одинаковые элементы)
print(list1 == list3)  # False
print(list1 != list3)  # True
```

```python
# Лексикографическое сравнение
print([1, 2, 3] < [1, 2, 4])   # True (3 < 4)
print([1, 2] < [1, 2, 3])      # True (короче)
print([2, 1] > [1, 2, 3])      # True (2 > 1 на первой позиции)

words1 = ["apple", "banana"]
words2 = ["apple", "cherry"]
print(words1 < words2)  # True ("banana" < "cherry")
```

```python
# Практические примеры

# Объединение данных из разных источников
morning_tasks = ["Завтрак", "Душ", "Зарядка"]
evening_tasks = ["Ужин", "Чтение", "Сон"]
all_tasks = morning_tasks + evening_tasks

print("План на день:")
for i, task in enumerate(all_tasks, 1):
    print(f"{i}. {task}")
```

```python
# Создание шахматной доски
row_black = ["□", "■"] * 4
row_white = ["■", "□"] * 4
board = [row_black, row_white] * 4

for row in board:
    print(" ".join(row))
```

```python
# Проверка, является ли список палиндромом
numbers = [1, 2, 3, 2, 1]
if numbers == numbers[::-1]:
    print("Палиндром")
else:
    print("Не палиндром")
```

```python
# Создание диапазона с повторяющимися элементами
sequence = list(range(1, 4)) * 2
print(sequence)  # [1, 2, 3, 1, 2, 3]
```

```python
# Нельзя складывать списки с другими типами!
# numbers = [1, 2, 3]
# result = numbers + 4  # TypeError!

# Правильно:
numbers = [1, 2, 3]
result = numbers + [4]
print(result)  # [1, 2, 3, 4]
```

## `7.7` Методы списков (можно посмотреть все, но укажу, которые точно надо знать):  
Методы — это функции, которые принадлежат объекту списка и вызываются через точку: `список.метод()`.

### `append()` — добавление элемента в конец

```python
# Добавление одного элемента в конец
numbers = [1, 2, 3]
numbers.append(4)
print(numbers)  # [1, 2, 3, 4]

numbers.append(5)
print(numbers)  # [1, 2, 3, 4, 5]
```

```python
# Добавление разных типов
mixed = [1, "два"]
mixed.append(3.0)
mixed.append(True)
mixed.append([5, 6])  # Добавляет список как один элемент
print(mixed)  # [1, 'два', 3.0, True, [5, 6]]
```

### `extend()` — добавление нескольких элементов

```python
# Добавление элементов из другого списка
numbers = [1, 2, 3]
numbers.extend([4, 5, 6])
print(numbers)  # [1, 2, 3, 4, 5, 6]
```

```python
# Объединение нескольких списков
list1 = [1, 2]
list2 = [3, 4]
list3 = [5, 6]

list1.extend(list2)
list1.extend(list3)
print(list1)  # [1, 2, 3, 4, 5, 6]
```

### Оператор `del` — удаление по индексу

```python
# Удаление элемента по индексу
numbers = [1, 2, 3, 4, 5]
del numbers[2]  # Удалить элемент с индексом 2
print(numbers)  # [1, 2, 4, 5]
```

```python
# Удаление первого и последнего элемента
numbers = [10, 20, 30, 40, 50]
del numbers[0]   # Удалить первый
del numbers[-1]  # Удалить последний
print(numbers)  # [20, 30, 40]
```

### `remove()` — удаление первого вхождения значения

```python
# Удаление элемента по значению
fruits = ["яблоко", "банан", "апельсин", "банан"]
fruits.remove("банан")  # Удаляет первое вхождение
print(fruits)  # ['яблоко', 'апельсин', 'банан']
```

```python
# Если элемента нет — ошибка
numbers = [1, 2, 3, 4, 5]
# numbers.remove(10)  # ValueError: 10 not in list

# Безопасное удаление с проверкой
if 10 in numbers:
    numbers.remove(10)
else:
    print("Элемент не найден")
```

```python
# Удаление всех вхождений через цикл
numbers = [1, 2, 3, 2, 4, 2, 5]
while 2 in numbers:
    numbers.remove(2)
print(numbers)  # [1, 3, 4, 5]
```

### `pop()` — удаление и возврат элемента

```python
# pop() без аргумента — удаляет последний элемент
numbers = [1, 2, 3, 4, 5]
last = numbers.pop()
print(last)     # 5
print(numbers)  # [1, 2, 3, 4]
```

```python
# pop() с индексом — удаляет элемент по индексу
numbers = [10, 20, 30, 40, 50]
element = numbers.pop(2)  # Удалить элемент с индексом 2
print(element)  # 30
print(numbers)  # [10, 20, 40, 50]
```

```python
# Удаление первого элемента
numbers = [1, 2, 3, 4, 5]
first = numbers.pop(0)
print(first)    # 1
print(numbers)  # [2, 3, 4, 5]
```

### `reverse()` — разворот списка

```python
# Разворот списка на месте
numbers = [1, 2, 3, 4, 5]
numbers.reverse()
print(numbers)  # [5, 4, 3, 2, 1]
```

```python
# reverse() изменяет исходный список
original = [1, 2, 3]
original.reverse()
print(original)  # [3, 2, 1] — изменился!

# Если нужно сохранить оригинал — используйте срез
original = [1, 2, 3]
reversed_copy = original[::-1]
print(original)       # [1, 2, 3] — не изменился
print(reversed_copy)  # [3, 2, 1]
```

```python
# Разворот строк в списке
words = ["привет", "мир", "python"]
words.reverse()
print(words)  # ['python', 'мир', 'привет']
```

### `copy()` — копирование списка

```python
# Создание копии списка
original = [1, 2, 3, 4, 5]
copy = original.copy()

copy[0] = 100
print(original)  # [1, 2, 3, 4, 5] — не изменился
print(copy)      # [100, 2, 3, 4, 5]
```

```python
# Без copy() — создаётся ссылка, а не копия
original = [1, 2, 3]
reference = original  # Это НЕ копия!

reference[0] = 100
print(original)   # [100, 2, 3] — изменился!
print(reference)  # [100, 2, 3]
```

```python
# Альтернативные способы копирования
original = [1, 2, 3, 4, 5]

# Через срез
copy1 = original[:]

# Через list()
copy2 = list(original)

# Через copy()
copy3 = original.copy()

# Все три способа создают независимые копии
```

```python
# Внимание! copy() делает поверхностную копию
original = [[1, 2], [3, 4]]
copy = original.copy()

copy[0][0] = 100  # Изменяем вложенный список
print(original)  # [[100, 2], [3, 4]] — тоже изменился!
print(copy)      # [[100, 2], [3, 4]]

# Для вложенных структур нужен deepcopy
import copy as cp
deep = cp.deepcopy(original)
```

### `clear()` — очистка списка

```python
# Удаление всех элементов
numbers = [1, 2, 3, 4, 5]
numbers.clear()
print(numbers)  # []
```

```python
# clear() vs присваивание нового списка
list1 = [1, 2, 3]
list1.clear()  # Очищает список
print(list1)   # []

list2 = [1, 2, 3]
list2 = []  # Создаёт новый пустой список
print(list2)  # []
```

```python
# Очистка в цикле
todos = ["Задача 1", "Задача 2", "Задача 3"]

while todos:
    print(f"Осталось задач: {len(todos)}")
    print(f"Текущая задача: {todos[0]}")
    input("Нажмите Enter для завершения задачи...")
    todos.pop(0)
    
print("Все задачи выполнены!")
todos.clear()  # На всякий случай
```

### `sort()` — сортировка списка

```python
# Сортировка по возрастанию
numbers = [5, 2, 8, 1, 9, 3]
numbers.sort()
print(numbers)  # [1, 2, 3, 5, 8, 9]
```

```python
# Сортировка по убыванию
numbers = [5, 2, 8, 1, 9, 3]
numbers.sort(reverse=True)
print(numbers)  # [9, 8, 5, 3, 2, 1]
```

```python
# Сортировка строк (по алфавиту)
fruits = ["банан", "яблоко", "апельсин", "груша"]
fruits.sort()
print(fruits)  # ['апельсин', 'банан', 'груша', 'яблоко']
```

```python
# sort() изменяет исходный список
original = [3, 1, 4, 1, 5]
original.sort()
print(original)  # [1, 1, 3, 4, 5] — изменился!

# Если нужно сохранить оригинал — используйте sorted()
original = [3, 1, 4, 1, 5]
sorted_copy = sorted(original)
print(original)      # [3, 1, 4, 1, 5] — не изменился
print(sorted_copy)   # [1, 1, 3, 4, 5]
```

```python
# Сортировка по длине строк
words = ["python", "код", "программирование", "язык"]
words.sort(key=len)
print(words)  # ['код', 'язык', 'python', 'программирование']
```

```python
# Сортировка по нескольким критериям
students = [
    ("Анна", 85),
    ("Борис", 92),
    ("Вера", 85),
    ("Глеб", 78)
]

# Сортировка по оценке
students.sort(key=lambda x: x[1])
print(students)
# [('Глеб', 78), ('Анна', 85), ('Вера', 85), ('Борис', 92)]
```

```python
# Сортировка с игнорированием регистра
words = ["Python", "java", "C++", "ruby"]
words.sort(key=str.lower)
print(words)  # ['C++', 'java', 'Python', 'ruby']
```

```python
# Практический пример — сортировка оценок
grades = [78, 92, 85, 67, 95, 88, 73]

print("Исходные оценки:", grades)

grades.sort()
print("По возрастанию:", grades)

grades.sort(reverse=True)
print("По убыванию:", grades)

print(f"Лучшая оценка: {grades[0]}")
print(f"Худшая оценка: {grades[-1]}")
```

```python
# Нельзя сортировать смешанные типы!
# mixed = [1, "два", 3]
# mixed.sort()  # TypeError: '<' not supported between instances of 'str' and 'int'
```

## `7.8` Уметь перебирать списки через for
Цикл `for` позволяет перебрать все элементы списка по очереди. Это самый распространённый способ работы со списками.

**Варианты перебора:**
1. По элементам: `for element in list:`
2. По индексам: `for i in range(len(list)):`
3. С индексами и элементами: `for i, element in enumerate(list):`

**Примеры:**

```python
# Базовый перебор по элементам
fruits = ["яблоко", "банан", "апельсин"]

for fruit in fruits:
    print(fruit)
# яблоко
# банан
# апельсин
```

```python
# Перебор чисел
numbers = [1, 2, 3, 4, 5]
total = 0

for num in numbers:
    total += num

print(f"Сумма: {total}")  # Сумма: 15
```

```python
# Перебор с условиями
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

print("Чётные числа:")
for num in numbers:
    if num % 2 == 0:
        print(num, end=" ")
# Чётные числа: 2 4 6 8 10
```

```python
# Изменение элементов при переборе по индексам
numbers = [1, 2, 3, 4, 5]

for i in range(len(numbers)):
    numbers[i] = numbers[i] * 2

print(numbers)  # [2, 4, 6, 8, 10]
```

```python
# enumerate() — перебор с индексами и элементами
fruits = ["яблоко", "банан", "апельсин"]

for index, fruit in enumerate(fruits):
    print(f"{index}: {fruit}")
# 0: яблоко
# 1: банан
# 2: апельсин
```

```python
# enumerate() с начальным индексом
tasks = ["Завтрак", "Работа", "Обед", "Спорт"]

print("План на день:")
for num, task in enumerate(tasks, start=1):
    print(f"{num}. {task}")
# 1. Завтрак
# 2. Работа
# 3. Обед
# 4. Спорт
```

```python
# Поиск элемента в списке
numbers = [10, 20, 30, 40, 50]
target = 30
found = False

for num in numbers:
    if num == target:
        found = True
        break

if found:
    print(f"Число {target} найдено")
else:
    print(f"Число {target} не найдено")
```

```python
# Подсчёт элементов с условием
grades = [85, 92, 78, 95, 88, 73, 90]
excellent_count = 0

for grade in grades:
    if grade >= 90:
        excellent_count += 1

print(f"Отличных оценок: {excellent_count}")  # 3
```

```python
# Создание нового списка на основе существующего
numbers = [1, 2, 3, 4, 5]
squares = []

for num in numbers:
    squares.append(num ** 2)

print(squares)  # [1, 4, 9, 16, 25]
```

```python
# Фильтрация списка
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
even_numbers = []

for num in numbers:
    if num % 2 == 0:
        even_numbers.append(num)

print(even_numbers)  # [2, 4, 6, 8, 10]
```

```python
# Перебор вложенных списков
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

print("Элементы матрицы:")
for row in matrix:
    for element in row:
        print(element, end=" ")
    print()
# 1 2 3
# 4 5 6
# 7 8 9
```

```python
# Поиск максимального элемента вручную
numbers = [23, 45, 12, 67, 34, 89, 15]
max_num = numbers[0]  # Предполагаем, что первый — максимальный

for num in numbers:
    if num > max_num:
        max_num = num

print(f"Максимум: {max_num}")  # 89
```

```python
# Подсчёт вхождений элемента
numbers = [1, 2, 3, 2, 4, 2, 5, 2]
target = 2
count = 0

for num in numbers:
    if num == target:
        count += 1

print(f"Число {target} встречается {count} раз")  # 4 раза
```

```python
# Перебор с несколькими действиями
shopping_list = ["молоко", "хлеб", "яйца", "сыр"]
prices = [80, 40, 120, 250]

total = 0
print("Чек:")
for i in range(len(shopping_list)):
    item = shopping_list[i]
    price = prices[i]
    print(f"{item}: {price} руб")
    total += price

print(f"Итого: {total} руб")
```

```python
# Перебор двух списков одновременно с zip()
names = ["Анна", "Борис", "Вера"]
ages = [25, 30, 28]

for name, age in zip(names, ages):
    print(f"{name}: {age} лет")
# Анна: 25 лет
# Борис: 30 лет
# Вера: 28 лет
```

```python
# Изменение списка во время перебора (осторожно!)
numbers = [1, 2, 3, 4, 5]

# ❌ Неправильно — не модифицируйте список во время перебора по элементам
# for num in numbers:
#     if num % 2 == 0:
#         numbers.remove(num)  # Может пропустить элементы!

# ✅ Правильно — используйте копию или перебор по индексам в обратном порядке
for i in range(len(numbers) - 1, -1, -1):
    if numbers[i] % 2 == 0:
        numbers.pop(i)

print(numbers)  # [1, 3, 5]
```

```python
# Перебор с накоплением результата
words = ["python", "java", "ruby", "go"]
long_words = []

for word in words:
    if len(word) > 4:
        long_words.append(word)

print(long_words)  # ['python']
```

**Итог:**
- Перебор по элементам: `for element in list:` — самый простой и распространённый
- Перебор по индексам: `for i in range(len(list)):` — когда нужно изменять элементы
- `enumerate()`: `for i, element in enumerate(list):` — когда нужны и индекс, и элемент
- `zip()`: `for x, y in zip(list1, list2):` — для перебора нескольких списков одновременно
- Будьте осторожны при изменении списка во время перебора!






























## `7.9` (`*`) Распаковка списков

Распаковка списков позволяет одновременно присвоить элементы списка нескольким переменным. Это упрощает работу с данными и делает код более читаемым.

### **Базовая распаковка**

Количество переменных должно совпадать с количеством элементов.

```python
colors = ["red", "green", "blue"]
first, second, third = colors
print(first, second, third)  # red green blue

# С кортежами работает так же
point = (10, 20)
x, y = point
print(x, y)  # 10 20

# Ошибка при несовпадении количества
numbers = [1, 2, 3]
a, b = numbers  # ValueError: too many values to unpack
```

### **Распаковка с оператором `*` (звёздочка)**

Оператор `*` собирает несколько элементов в список.

```python
# Первый, последний и всё между ними
numbers = [1, 2, 3, 4, 5]
first, *middle, last = numbers
print(first)   # 1
print(middle)  # [2, 3, 4]
print(last)    # 5

# Только первый и остальные
head, *tail = numbers
print(head)  # 1
print(tail)  # [2, 3, 4, 5]

# Только последний и остальные
*init, last = numbers
print(init)  # [1, 2, 3, 4]
print(last)  # 5

# Игнорирование средних элементов
first, *_, last = numbers
print(first)  # 1
print(last)   # 5
# _ показывает, что средние элементы нас не интересуют
```

### **Распаковка при объединении списков**

```python
list1 = [1, 2]
list2 = [3, 4]
list3 = [5, 6]

# Объединение списков
merged = [*list1, *list2]
print(merged)  # [1, 2, 3, 4]

# Добавление элементов в начало и конец
extended = [0, *list1, *list2, 7]
print(extended)  # [0, 1, 2, 3, 4, 7]

# Объединение нескольких списков
all_lists = [*list1, *list2, *list3]
print(all_lists)  # [1, 2, 3, 4, 5, 6]
```

### **Распаковка в функциях**

```python
# Передача элементов списка как аргументов
def calculate(a, b, c):
    return a + b + c

values = [10, 20, 30]
result = calculate(*values)  # Эквивалентно calculate(10, 20, 30)
print(result)  # 60

# Создание копии списка
original = [1, 2, 3]
copy = [*original]
print(copy)  # [1, 2, 3]
print(copy is original)  # False (это другой объект)
```

### **Практические примеры**

```python
# Обмен значений без временной переменной
a, b = 10, 20
a, b = b, a
print(a, b)  # 20 10

# Работа с файлами CSV
data = "Иван,Петров,30"
first_name, last_name, age = data.split(',')
print(first_name)  # Иван
print(age)         # 30

# Распаковка вложенных структур
users = [("Alice", 25), ("Bob", 30), ("Charlie", 35)]
for name, age in users:
    print(f"{name} — {age} лет")
# Выведет:
# Alice — 25 лет
# Bob — 30 лет
# Charlie — 35 лет

# Пропуск ненужных значений
coordinates = (10, 20, 30, 40)
x, y, *_ = coordinates
print(x, y)  # 10 20
```


## `7.10` (*) Методы `split()`, `join()`
Эти методы используются для преобразования строк в списки и обратно.

### **Метод `split()` — разбиение строки на список**
Разбивает строку на подстроки по разделителю. Без аргумента разбивает по пробелам.

```python
# Разбиение по запятой
text = "яблоко,банан,апельсин"
fruits = text.split(',')
print(fruits)  # ['яблоко', 'банан', 'апельсин']

# Разбиение по точке с запятой
text = "раз,два;три.четыре"
parts = text.split(';')
print(parts)  # ['раз,два', 'три.четыре']

# Разбиение по пробелам (по умолчанию)
text = "один два три"
words = text.split()
print(words)  # ['один', 'два', 'три']

# Несколько пробелов обрабатываются как один
text = "один    два     три"
words = text.split()
print(words)  # ['один', 'два', 'три']

# Ограничение количества разбиений
text = "a,b,c,d,e"
result = text.split(',', 2)  # Разбить максимум 2 раза
print(result)  # ['a', 'b', 'c,d,e']
```

### **Метод `join()` — объединение списка в строку**

Объединяет элементы списка в строку, вставляя между ними разделитель.

```python
# Объединение через запятую и пробел
words = ['яблоко', 'банан', 'апельсин']
result = ", ".join(words)
print(result)  # "яблоко, банан, апельсин"

# Объединение через дефис
chars = list("Python")
result = "-".join(chars)
print(result)  # "P-y-t-h-o-n"

# Объединение с переносом строки
lines = ['строка 1', 'строка 2', 'строка 3']
text = "\n".join(lines)
print(text)
# Выведет:
# строка 1
# строка 2
# строка 3

# Объединение без разделителя
letters = ['H', 'e', 'l', 'l', 'o']
word = "".join(letters)
print(word)  # "Hello"
```

### **Практические комбинации `split()` и `join()`**

```python
# Очистка строки от лишних пробелов
text = "  много    пробелов   здесь  "
cleaned = " ".join(text.split())
print(cleaned)  # "много пробелов здесь"

# Замена разделителя
csv_data = "яблоко,банан,апельсин"
tsv_data = "\t".join(csv_data.split(','))
print(tsv_data)  # "яблоко	банан	апельсин"

# Работа с путями файлов
path_parts = ['home', 'user', 'documents', 'file.txt']
path = "/".join(path_parts)
print(path)  # "home/user/documents/file.txt"

# Парсинг CSV-подобных данных
data = "Иван,Петров,30,Москва"
fields = data.split(',')
name, surname, age, city = fields
print(f"{name} {surname}, {age} лет, {city}")
# Выведет: Иван Петров, 30 лет, Москва

# Создание строки из чисел
numbers = [1, 2, 3, 4, 5]
# join работает только со строками!
result = ", ".join(str(n) for n in numbers)
print(result)  # "1, 2, 3, 4, 5"

# Разбиение по нескольким разделителям (через replace)
text = "один,два;три.четыре"
normalized = text.replace(',', ' ').replace(';', ' ').replace('.', ' ')
words = normalized.split()
print(words)  # ['один', 'два', 'три', 'четыре']
```

### **Важные моменты**

```python
# split() возвращает список строк
text = "1,2,3"
numbers = text.split(',')
print(type(numbers[0]))  # <class 'str'> (не int!)

# join() работает только со строками
numbers = [1, 2, 3]
# result = ",".join(numbers)  # TypeError!
result = ",".join(map(str, numbers))  # Правильно
print(result)  # "1,2,3"

# Пустая строка между разделителями
text = "a,,b"
parts = text.split(',')
print(parts)  # ['a', '', 'b'] (пустая строка сохраняется)

# Разделитель не удаляется полностью
text = "a,b,c,"
parts = text.split(',')
print(parts)  # ['a', 'b', 'c', ''] (последний элемент пустой)
```

**Кейсы применения:**

- **`split()`:** парсинг CSV/TSV, разбиение строк по словам, обработка пользовательского ввода, работа с путями
- **`join()`:** формирование строк из списков, создание CSV, объединение строк с разделителем, форматирование вывода


## `7.11` (*) Списочные выражения (list comprehensions)
`List comprehension` — это компактный и читаемый способ создания списков на основе существующих итерируемых объектов. Позволяет заменить циклы `for` одной строкой кода.

### **Базовый синтаксис**

```python
# Общая структура: [выражение for элемент in итерируемый_объект]

# Простое создание списка
nums = [n for n in range(1, 6)]
print(nums)  # [1, 2, 3, 4, 5]

# Эквивалент через обычный цикл:
nums = []
for n in range(1, 6):
    nums.append(n)
```

### **Преобразование элементов**

```python
# Возведение в квадрат
nums = [1, 2, 3, 4, 5]
squares = [n * n for n in nums]
print(squares)  # [1, 4, 9, 16, 25]

# Преобразование в строки
numbers = [1, 2, 3]
strings = [str(n) for n in numbers]
print(strings)  # ['1', '2', '3']

# Применение методов
words = ["hello", "world", "python"]
uppercase = [word.upper() for word in words]
print(uppercase)  # ['HELLO', 'WORLD', 'PYTHON']

# Вычисления с несколькими операциями
prices = [100, 200, 300]
with_tax = [price * 1.2 for price in prices]
print(with_tax)  # [120.0, 240.0, 360.0]
```

### **Фильтрация с условием `if`**

```python
# Только нечётные числа
nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]
odd = [n for n in nums if n % 2 == 1]
print(odd)  # [1, 3, 5, 7, 9]

# Квадраты только нечётных чисел
odd_squares = [n * n for n in nums if n % 2 == 1]
print(odd_squares)  # [1, 9, 25, 49, 81]

# Фильтрация строк
words = ["apple", "banana", "kiwi", "strawberry"]
short_words = [w for w in words if len(w) <= 5]
print(short_words)  # ['apple', 'kiwi']

# Несколько условий
numbers = range(1, 21)
result = [n for n in numbers if n % 2 == 0 if n > 10]
print(result)  # [12, 14, 16, 18, 20]
```

### **Условное выражение `if-else`**

```python
# Разная логика для чётных и нечётных
result = ["чётное" if x % 2 == 0 else "нечётное" for x in range(5)]
print(result)  # ['чётное', 'нечётное', 'чётное', 'нечётное', 'чётное']

# Преобразование значений
numbers = [1, -2, 3, -4, 5]
absolute = [n if n >= 0 else -n for n in numbers]
print(absolute)  # [1, 2, 3, 4, 5]

# Замена None
values = [10, None, 20, None, 30]
cleaned = [v if v is not None else 0 for v in values]
print(cleaned)  # [10, 0, 20, 0, 30]
```

### **Вложенные циклы**

```python
# Создание всех пар
pairs = [(x, y) for x in [1, 2, 3] for y in ['a', 'b']]
print(pairs)  # [(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b'), (3, 'a'), (3, 'b')]

# Матрица (список списков)
matrix = [[x for x in range(1, 4)] for y in range(3)]
print(matrix)  # [[1, 2, 3], [1, 2, 3], [1, 2, 3]]

# Таблица умножения
table = [[i * j for j in range(1, 4)] for i in range(1, 4)]
print(table)  # [[1, 2, 3], [2, 4, 6], [3, 6, 9]]

# Развёртывание вложенного списка (flatten)
nested = [[1, 2], [3, 4], [5, 6]]
flat = [item for sublist in nested for item in sublist]
print(flat)  # [1, 2, 3, 4, 5, 6]

# С условием во вложенном цикле
result = [(x, y) for x in range(3) for y in range(3) if x != y]
print(result)  # [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1)]
```

### **Практические примеры**

```python
# Извлечение значений из словарей
users = [
    {"name": "Alice", "age": 25},
    {"name": "Bob", "age": 30},
    {"name": "Charlie", "age": 35}
]
names = [user["name"] for user in users]
print(names)  # ['Alice', 'Bob', 'Charlie']

# Фильтрация и преобразование
adults = [user["name"] for user in users if user["age"] >= 30]
print(adults)  # ['Bob', 'Charlie']

# Обработка файла (построчно)
lines = ["  line 1  ", "line 2", "  line 3  "]
cleaned = [line.strip() for line in lines if line.strip()]
print(cleaned)  # ['line 1', 'line 2', 'line 3']

# Создание множества уникальных значений
numbers = [1, 2, 2, 3, 3, 3, 4]
unique = list({n for n in numbers})  # Set comprehension
print(unique)  # [1, 2, 3, 4]
```

### **Сравнение с обычным циклом**

```python
# List comprehension (одна строка)
squares = [x**2 for x in range(10) if x % 2 == 0]

# Эквивалент через цикл (4 строки)
squares = []
for x in range(10):
    if x % 2 == 0:
        squares.append(x**2)

print(squares)  # [0, 4, 16, 36, 64]
```

**Когда использовать:**
- Простые преобразования и фильтрация данных
- Создание новых списков на основе существующих
- Когда логика помещается в одну строку и остаётся читаемой

**Когда НЕ использовать:**
- Сложная логика, которую трудно читать в одну строку
- Когда нужны побочные эффекты (лучше использовать обычный цикл)
- Глубоко вложенные comprehensions (более 2 уровней)

## `7.12` Вложенные списки
**Вложенные списки** — это списки, содержащие другие списки в качестве элементов. Часто используются для представления двумерных структур: матриц, таблиц, игровых полей, координатных сеток.

**Структура:**
```python
matrix = [
    [элемент00, элемент01, элемент02],  # строка 0
    [элемент10, элемент11, элемент12],  # строка 1
    [элемент20, элемент21, элемент22]   # строка 2
]
```

**Доступ к элементам:**
- `matrix[i]` — получить строку с индексом i
- `matrix[i][j]` — получить элемент в строке i, столбце j

**Примеры:**

```python
# Создание вложенного списка (матрицы 3×3)
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

print(matrix)
# [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
```

```python
# Доступ к элементам
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

print(matrix[0])      # [1, 2, 3] — первая строка
print(matrix[1][2])   # 6 — вторая строка, третий элемент
print(matrix[-1][-1]) # 9 — последняя строка, последний элемент
```

```python
# Изменение элементов
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

matrix[0][0] = 100
matrix[1][1] = 200
print(matrix)
# [[100, 2, 3], [4, 200, 6], [7, 8, 9]]
```

```python
# Создание матрицы с одинаковыми значениями
# ❌ Неправильно — создаёт ссылки на один список!
rows = 3
cols = 3
matrix = [[0] * cols] * rows
matrix[0][0] = 1
print(matrix)
# [[1, 0, 0], [1, 0, 0], [1, 0, 0]] — изменились все строки!

# ✅ Правильно — используем list comprehension
matrix = [[0] * cols for _ in range(rows)]
matrix[0][0] = 1
print(matrix)
# [[1, 0, 0], [0, 0, 0], [0, 0, 0]] — изменилась только первая строка
```

```python
# Перебор всех элементов (вложенные циклы)
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

print("Все элементы:")
for row in matrix:
    for element in row:
        print(element, end=" ")
    print()
# 1 2 3
# 4 5 6
# 7 8 9
```

```python
# Перебор с индексами
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

for i in range(len(matrix)):
    for j in range(len(matrix[i])):
        print(f"[{i}][{j}] = {matrix[i][j]}")
# [0][0] = 1
# [0][1] = 2
# [0][2] = 3
# ...
```

```python
# Сумма всех элементов матрицы
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

total = 0
for row in matrix:
    for element in row:
        total += element

print(f"Сумма: {total}")  # 45

# Или через list comprehension
total = sum(sum(row) for row in matrix)
print(f"Сумма: {total}")  # 45
```

```python
# Транспонирование матрицы (строки ↔ столбцы)
matrix = [
    [1, 2, 3],
    [4, 5, 6]
]

# С циклами
transposed = []
for j in range(len(matrix[0])):  # Перебираем столбцы
    row = []
    for i in range(len(matrix)):  # Перебираем строки
        row.append(matrix[i][j])
    transposed.append(row)

print(transposed)
# [[1, 4], [2, 5], [3, 6]]

# С list comprehension
transposed = [[matrix[i][j] for i in range(len(matrix))] for j in range(len(matrix[0]))]
print(transposed)
# [[1, 4], [2, 5], [3, 6]]
```

```python
# Игровое поле (крестики-нолики)
board = [
    [" ", " ", " "],
    [" ", " ", " "],
    [" ", " ", " "]
]

# Сделать ход
board[0][0] = "X"
board[1][1] = "O"
board[0][2] = "X"

# Вывести поле
for row in board:
    print("|".join(row))
    print("-" * 5)
# X| |X
# -----
#  |O| 
# -----
#  | | 
```

```python
# Таблица учеников с оценками
students = [
    ["Анна", 85, 90, 78],
    ["Борис", 92, 88, 95],
    ["Вера", 78, 85, 82]
]

print("Имя      | Оценки")
print("-" * 25)
for student in students:
    name = student[0]
    grades = student[1:]
    avg = sum(grades) / len(grades)
    print(f"{name:8} | {grades} → Средний: {avg:.1f}")
# Имя      | Оценки
# -------------------------
# Анна     | [85, 90, 78] → Средний: 84.3
# Борис    | [92, 88, 95] → Средний: 91.7
# Вера     | [78, 85, 82] → Средний: 81.7
```

```python
# Поиск элемента в матрице
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

target = 5
found = False

for i in range(len(matrix)):
    for j in range(len(matrix[i])):
        if matrix[i][j] == target:
            print(f"Найдено: {target} на позиции [{i}][{j}]")
            found = True
            break
    if found:
        break
```

```python
# Создание таблицы умножения
size = 5
table = [[i * j for j in range(1, size + 1)] for i in range(1, size + 1)]

for row in table:
    print(" ".join(f"{num:3}" for num in row))
#   1   2   3   4   5
#   2   4   6   8  10
#   3   6   9  12  15
#   4   8  12  16  20
#   5  10  15  20  25
```

```python
# Матрица координат
coords = [
    [(x, y) for x in range(3)]
    for y in range(3)
]

for row in coords:
    print(row)
# [(0, 0), (1, 0), (2, 0)]
# [(0, 1), (1, 1), (2, 1)]
# [(0, 2), (1, 2), (2, 2)]
```

```python
# Поиск максимума в каждой строке
matrix = [
    [10, 45, 23],
    [67, 12, 89],
    [34, 78, 56]
]

for i, row in enumerate(matrix):
    max_val = max(row)
    print(f"Строка {i}: максимум = {max_val}")
# Строка 0: максимум = 45
# Строка 1: максимум = 89
# Строка 2: максимум = 78
```

```python
# Проверка диагоналей (квадратная матрица)
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

# Главная диагональ
main_diagonal = [matrix[i][i] for i in range(len(matrix))]
print(f"Главная диагональ: {main_diagonal}")  # [1, 5, 9]

# Побочная диагональ
n = len(matrix)
side_diagonal = [matrix[i][n - 1 - i] for i in range(n)]
print(f"Побочная диагональ: {side_diagonal}")  # [3, 5, 7]
```

```python
# Фильтрация элементов матрицы
matrix = [
    [10, 5, 23],
    [8, 15, 3],
    [20, 12, 18]
]

# Найти все элементы > 10
large_elements = [element for row in matrix for element in row if element > 10]
print(large_elements)  # [23, 15, 20, 12, 18]
```

```python
# Практический пример — расписание
schedule = [
    ["Понедельник", "Математика", "Физика", "История"],
    ["Вторник", "Литература", "Химия", "Английский"],
    ["Среда", "Биология", "География", "Физкультура"]
]

print("Расписание:")
for day in schedule:
    day_name = day[0]
    subjects = ", ".join(day[1:])
    print(f"{day_name}: {subjects}")
# Понедельник: Математика, Физика, История
# Вторник: Литература, Химия, Английский
# Среда: Биология, География, Физкультура
```

```python
# Три уровня вложенности (куб 2×2×2)
cube = [
    [[1, 2], [3, 4]],
    [[5, 6], [7, 8]]
]

print(cube[0][1][0])  # 3
# [0] — первый слой
# [1] — вторая строка в слое
# [0] — первый элемент в строке
```

**Итог:**
- Вложенные списки — списки внутри списков
- Доступ через двойную индексацию: `matrix[row][col]`
- Для создания используйте list comprehension: `[[0] * cols for _ in range(rows)]`
- Перебор через вложенные циклы или двойной list comprehension
- Применение: матрицы, таблицы, игровые поля, координаты, расписания

## `7.13` (*) Сортировка: `sorted()` и параметр `key`

Функция `sorted()` создаёт **новый** отсортированный список из любого итерируемого объекта, не изменяя оригинал. Параметр `key` позволяет задать критерий сортировки.

### **Базовая сортировка**

```python
# Числа по возрастанию (по умолчанию)
numbers = [5, 2, 8, 1, 9]
result = sorted(numbers)
print(result)  # [1, 2, 5, 8, 9]
print(numbers)  # [5, 2, 8, 1, 9] (оригинал не изменился)

# Строки по алфавиту
words = ["banana", "apple", "cherry"]
result = sorted(words)
print(result)  # ['apple', 'banana', 'cherry']

# В обратном порядке
result = sorted(numbers, reverse=True)
print(result)  # [9, 8, 5, 2, 1]

# Сортировка строки (возвращает список символов)
text = "python"
result = sorted(text)
print(result)  # ['h', 'n', 'o', 'p', 't', 'y']
print(''.join(sorted(text)))  # 'hnopty'
```

### **Параметр `key` — функция для вычисления критерия**

`key` принимает функцию, которая применяется к каждому элементу для определения значения сортировки.

```python
# Сортировка строк по длине
words = ["apple", "pie", "banana", "kiwi"]
result = sorted(words, key=len)
print(result)  # ['pie', 'kiwi', 'apple', 'banana']

# Сортировка без учёта регистра
words = ["Banana", "apple", "Cherry", "date"]
result = sorted(words, key=str.lower)
print(result)  # ['apple', 'Banana', 'Cherry', 'date']

# Сортировка чисел по абсолютному значению
numbers = [-5, 2, -8, 1, 9, -3]
result = sorted(numbers, key=abs)
print(result)  # [1, 2, -3, -5, -8, 9]

# Сортировка по последнему символу
words = ["hello", "world", "python", "code"]
result = sorted(words, key=lambda x: x[-1])
print(result)  # ['code', 'hello', 'python', 'world']
```

### **Сортировка кортежей и списков**

```python
# По умолчанию — по первому элементу
pairs = [(3, 'three'), (1, 'one'), (2, 'two')]
result = sorted(pairs)
print(result)  # [(1, 'one'), (2, 'two'), (3, 'three')]

# По второму элементу
result = sorted(pairs, key=lambda x: x[1])
print(result)  # [(1, 'one'), (3, 'three'), (2, 'two')]

# Сортировка по нескольким критериям (кортеж в key)
students = [
    ('Alice', 85, 20),
    ('Bob', 92, 19),
    ('Charlie', 85, 21),
    ('David', 92, 18)
]
# Сначала по оценке (убывание), потом по возрасту (возрастание)
result = sorted(students, key=lambda x: (-x[1], x[2]))
print(result)
# [('David', 92, 18), ('Bob', 92, 19), ('Alice', 85, 20), ('Charlie', 85, 21)]
```

### **Сортировка объектов**

```python
class Student:
    def __init__(self, name, grade, age):
        self.name = name
        self.grade = grade
        self.age = age
    
    def __repr__(self):
        return f"Student({self.name}, {self.grade}, {self.age})"

students = [
    Student('Alice', 85, 20),
    Student('Bob', 92, 19),
    Student('Charlie', 78, 21)
]

# По оценке
by_grade = sorted(students, key=lambda s: s.grade)
print(by_grade)
# [Student(Charlie, 78, 21), Student(Alice, 85, 20), Student(Bob, 92, 19)]

# По имени
by_name = sorted(students, key=lambda s: s.name)
print(by_name)
# [Student(Alice, 85, 20), Student(Bob, 92, 19), Student(Charlie, 78, 21)]

# По оценке (убывание), затем по имени (возрастание)
result = sorted(students, key=lambda s: (-s.grade, s.name))
print(result)
# [Student(Bob, 92, 19), Student(Alice, 85, 20), Student(Charlie, 78, 21)]
```

### **Сложные случаи сортировки**

```python
# Сортировка словаря по значениям
scores = {'Alice': 85, 'Bob': 92, 'Charlie': 78}
sorted_items = sorted(scores.items(), key=lambda x: x[1], reverse=True)
print(sorted_items)  # [('Bob', 92), ('Alice', 85), ('Charlie', 78)]

# Преобразование обратно в словарь (с Python 3.7+ порядок сохраняется)
sorted_dict = dict(sorted_items)
print(sorted_dict)  # {'Bob': 92, 'Alice': 85, 'Charlie': 78}

# Сортировка строк по количеству гласных
def count_vowels(word):
    return sum(1 for char in word.lower() if char in 'aeiou')

words = ["hello", "world", "python", "code"]
result = sorted(words, key=count_vowels)
print(result)  # ['world', 'python', 'code', 'hello']

# Естественная сортировка (числа в строках)
import re

def natural_key(text):
    return [int(c) if c.isdigit() else c.lower() for c in re.split('(\d+)', text)]

files = ['file1.txt', 'file10.txt', 'file2.txt', 'file20.txt']
result = sorted(files, key=natural_key)
print(result)  # ['file1.txt', 'file2.txt', 'file10.txt', 'file20.txt']
```

### **`sorted()` vs `list.sort()`**

```python
# sorted() — создаёт новый список
numbers = [3, 1, 2]
new_list = sorted(numbers)
print(numbers)   # [3, 1, 2] (не изменился)
print(new_list)  # [1, 2, 3]

# list.sort() — изменяет на месте, возвращает None
numbers = [3, 1, 2]
result = numbers.sort()
print(numbers)  # [1, 2, 3] (изменился)
print(result)   # None

# sort() также поддерживает key и reverse
numbers = [3, 1, 2]
numbers.sort(reverse=True)
print(numbers)  # [3, 2, 1]
```

### **Стабильная сортировка**

Python использует **стабильную** сортировку — элементы с одинаковыми ключами сохраняют исходный порядок.

```python
students = [
    ('Alice', 85),
    ('Bob', 85),
    ('Charlie', 85)
]
# Все имеют одинаковую оценку
result = sorted(students, key=lambda x: x[1])
print(result)
# [('Alice', 85), ('Bob', 85), ('Charlie', 85)]
# Порядок сохранился, как в исходном списке
```

**Когда использовать:**
- `sorted()` — когда нужен новый список или сортировка любого итерируемого объекта
- `list.sort()` — когда нужно отсортировать существующий список и сэкономить память
- `key` — для любой нестандартной сортировки (по атрибутам, длине, сложным критериям)
- `reverse=True` — для обратного порядка

----

# `8` Функции 1
## `8.1` Что такое функциональное программирование?
**Функциональное программирование (ФП)** — это парадигма программирования, в которой вычисления рассматриваются как применение и композицию функций. Программа строится из функций, которые принимают данные и возвращают результат, не изменяя внешнее состояние.

**Основные принципы ФП:**
1. **Функции — первоклассные объекты** — их можно передавать как аргументы, возвращать из других функций, присваивать переменным
2. **Чистые функции (pure functions)** — результат зависит только от входных данных, нет побочных эффектов (не изменяют глобальные переменные, файлы, базы данных)
3. **Неизменяемость данных (immutability)** — данные не изменяются после создания, создаются новые
4. **Отсутствие состояния** — функции не зависят от внешнего контекста
5. **Декларативность** — описываем "что делать", а не "как делать"

**Python и ФП:**
Python — **мультипарадигменный язык**. Он поддерживает:
- Императивное программирование (последовательность команд)
- Объектно-ориентированное программирование (классы, объекты)
- Функциональное программирование (функции высшего порядка, lambda, map, filter, reduce)

Python не является чисто функциональным языком (как Haskell или Lisp), но активно использует идеи ФП.

**Примеры концепций ФП в Python:**

```python
# Чистая функция — результат зависит только от входных данных
def add(a, b):
    return a + b

print(add(2, 3))  # 5 — всегда одинаковый результат для одинаковых аргументов
```

```python
# Нечистая функция — зависит от внешнего состояния
total = 0

def add_to_total(value):
    global total
    total += value  # Изменяет глобальное состояние — побочный эффект!
    return total
```

```python
# Неизменяемость — создаём новые данные вместо изменения старых
numbers = [1, 2, 3]

# Императивный стиль (изменяем список)
numbers.append(4)

# Функциональный стиль (создаём новый список)
new_numbers = numbers + [4]
```

**Зачем изучать ФП:**
- Код становится более предсказуемым и тестируемым
- Легче избежать ошибок, связанных с изменяемым состоянием
- Проще распараллеливать вычисления
- Код более выразительный и лаконичный

## `8.2` Что такое функция? Как объявить функцию в Python?
**Функция** — это именованный блок кода, который выполняет определённую задачу. Функция может принимать данные (параметры), обрабатывать их и возвращать результат.

**Зачем нужны функции:**
1. **Переиспользование кода** — пишем один раз, используем много раз
2. **Структурирование программы** — разделяем сложную задачу на простые части
3. **Читаемость** — код с функциями понятнее
4. **Тестирование** — легче проверить отдельную функцию
5. **Абстракция** — скрываем детали реализации
6. **Избежание дублирования** — принцип DRY (Don't Repeat Yourself)

**Синтаксис объявления функции:**
```python
def имя_функции(параметры):
    """Документация функции (опционально)"""
    # тело функции
    # код, который выполняется при вызове
    return результат  # опционально
```

**Компоненты функции:**
- `def` — ключевое слово для объявления функции
- `имя_функции` — идентификатор функции (правила как для переменных)
- `параметры` — входные данные (могут отсутствовать)
- `docstring` — строка документации (необязательна, но рекомендуется)
- `тело функции` — код с отступом (обязательно минимум одна строка)
- `return` — возврат результата (опционально)

**Вызов функции:**
```python
результат = имя_функции(аргументы)
```

**Примеры:**

```python
# Простейшая функция без параметров и без return
def greet():
    print("Привет, мир!")

# Вызов функции
greet()  # Привет, мир!
```

```python
# Функция с параметром
def greet_person(name):
    print(f"Привет, {name}!")

greet_person("Анна")   # Привет, Анна!
greet_person("Борис")  # Привет, Борис!
```

```python
# Функция с return
def add(a, b):
    result = a + b
    return result

sum_result = add(5, 3)
print(sum_result)  # 8
```

```python
# Функция с несколькими параметрами
def calculate_rectangle_area(width, height):
    area = width * height
    return area

area = calculate_rectangle_area(5, 10)
print(f"Площадь: {area}")  # Площадь: 50
```

```python
# Функция с docstring (документацией)
def multiply(a, b):
    """
    Умножает два числа.
    
    Параметры:
        a (int/float): первое число
        b (int/float): второе число
    
    Возвращает:
        int/float: произведение a и b
    """
    return a * b

result = multiply(4, 7)
print(result)  # 28

# Просмотр документации
print(multiply.__doc__)
```

```python
# Функция может вызывать другие функции
def square(x):
    return x * x

def sum_of_squares(a, b):
    return square(a) + square(b)

result = sum_of_squares(3, 4)
print(result)  # 9 + 16 = 25
```

**Правила именования функций:**
- Используйте `snake_case` (слова через подчёркивание)
- Имя должно быть глаголом или глагольной фразой (функция что-то **делает**)
- Имя должно описывать действие функции

```python
# ✅ Хорошие имена
def calculate_total():
    pass

def get_user_age():
    pass

def is_valid_email():
    pass

def send_notification():
    pass

# ❌ Плохие имена
def calc():  # Слишком короткое, неясное
    pass

def data():  # Существительное, непонятно что делает
    pass

def func1():  # Бессмысленное имя
    pass
```

**Порядок выполнения:**

```python
print("1. Начало программы")

def my_function():
    print("3. Внутри функции")

print("2. Функция объявлена, но ещё не вызвана")

my_function()  # Вызов функции

print("4. После вызова функции")

# Вывод:
# 1. Начало программы
# 2. Функция объявлена, но ещё не вызвана
# 3. Внутри функции
# 4. После вызова функции
```

**Важно:**
- Функцию нужно **объявить** перед тем, как её **вызвать**
- Код внутри функции выполняется только при вызове
- Функция может быть вызвана многократно

## `8.3` Функции с и без параметров
Функции могут принимать **параметры (аргументы)** — входные данные для обработки. Параметры указываются в скобках при объявлении функции.

**Типы функций:**
1. **Без параметров** — функция не принимает данные извне
2. **С одним параметром** — принимает одно значение
3. **С несколькими параметрами** — принимает несколько значений

### Функции без параметров

**Когда использовать:**
- Функция выполняет фиксированное действие
- Данные берутся изнутри функции или из внешних источников
- Функция не зависит от входных данных

```python
# Функция без параметров
def print_header():
    print("=" * 40)
    print("      Добро пожаловать!")
    print("=" * 40)

print_header()
# ========================================
#       Добро пожаловать!
# ========================================
```

```python
# Функция с вводом внутри
def ask_name():
    name = input("Как вас зовут? ")
    print(f"Привет, {name}!")

ask_name()
```

```python
# Функция, возвращающая константу
def get_pi():
    return 3.141592653589793

pi = get_pi()
print(pi)  # 3.141592653589793
```

### Функции с одним параметром

**Когда использовать:**
- Функция обрабатывает одно значение
- Нужна гибкость — одна и та же функция с разными данными

```python
# Функция с одним параметром
def greet(name):
    print(f"Привет, {name}!")

greet("Анна")   # Привет, Анна!
greet("Борис")  # Привет, Борис!
```

```python
# Функция с return и одним параметром
def square(x):
    return x ** 2

print(square(5))   # 25
print(square(10))  # 100
```

```python
# Преобразование данных
def to_uppercase(text):
    return text.upper()

result = to_uppercase("python")
print(result)  # PYTHON
```

### Функции с несколькими параметрами

**Когда использовать:**
- Функция обрабатывает несколько связанных значений
- Нужны разные данные для вычисления результата

```python
# Функция с двумя параметрами
def add(a, b):
    return a + b

result = add(5, 3)
print(result)  # 8
```

```python
# Функция с тремя параметрами
def calculate_average(a, b, c):
    total = a + b + c
    average = total / 3
    return average

avg = calculate_average(80, 90, 85)
print(f"Средний балл: {avg}")  # Средний балл: 85.0
```

```python
# Функция с разными типами параметров
def create_greeting(name, age, city):
    return f"Меня зовут {name}, мне {age} лет, живу в {city}"

message = create_greeting("Иван", 25, "Москва")
print(message)  # Меня зовут Иван, мне 25 лет, живу в Москва
```

**Порядок параметров важен:**

```python
def introduce(name, age):
    print(f"{name} — {age} лет")

introduce("Анна", 25)  # Анна — 25 лет
introduce(25, "Анна")  # 25 — Анна лет (неправильно!)
```

**Сравнение:**

```python
# Без параметров — жёстко заданное поведение
def print_hello():
    print("Hello!")

print_hello()  # Всегда выводит "Hello!"

# С параметром — гибкое поведение
def print_message(message):
    print(message)

print_message("Hello!")    # Hello!
print_message("Привет!")   # Привет!
print_message("Bonjour!")  # Bonjour!
```

**Практические примеры:**

```python
# Без параметров — информационная функция
def show_menu():
    print("1. Новая игра")
    print("2. Загрузить")
    print("3. Выход")

show_menu()
```

```python
# С параметрами — универсальная функция
def calculate_discount(price, discount_percent):
    discount_amount = price * discount_percent / 100
    final_price = price - discount_amount
    return final_price

price1 = calculate_discount(1000, 10)  # 900.0
price2 = calculate_discount(500, 20)   # 400.0
```

## `8.4` Разница аргумента и параметра
**Параметры** и **аргументы** — это близкие, но разные понятия:

- **Параметр (parameter)** — переменная в определении функции. Это "шаблон" того, что функция ожидает получить.
- **Аргумент (argument)** — конкретное значение, которое передаётся функции при вызове.

**Простыми словами:**
- **Параметр** — это "заготовка" (переменная в объявлении функции)
- **Аргумент** — это "наполнение" (реальное значение при вызове)

**Аналогия:**
Представьте функцию как форму для печенья:
- **Параметр** — форма (абстрактный шаблон)
- **Аргумент** — тесто, которое вы кладёте в форму (конкретные данные)

**Пример:**

```python
# Объявление функции
def greet(name):  # name — это ПАРАМЕТР
    print(f"Привет, {name}!")

# Вызов функции
greet("Анна")  # "Анна" — это АРГУМЕНТ
greet("Борис")  # "Борис" — это АРГУМЕНТ
```

**Визуальное объяснение:**

```python
def add(a, b):  # a и b — ПАРАМЕТРЫ (placeholders)
    return a + b

result = add(5, 3)  # 5 и 3 — АРГУМЕНТЫ (actual values)
#            ↑  ↑
#            |  |
#     аргументы передаются в параметры
```

**Типы аргументов:**

### 1. Позиционные аргументы
Передаются в том же порядке, что и параметры.

```python
def introduce(name, age, city):
    print(f"{name}, {age} лет, {city}")

introduce("Анна", 25, "Москва")
# "Анна" → name
# 25 → age
# "Москва" → city
```

### 2. Именованные аргументы (keyword arguments)
Указываются с именем параметра, порядок не важен.

```python
def introduce(name, age, city):
    print(f"{name}, {age} лет, {city}")

# Порядок может быть любым
introduce(city="Москва", name="Анна", age=25)
introduce(age=30, name="Борис", city="Санкт-Петербург")
```

### 3. Смешанные аргументы
Сначала позиционные, потом именованные.

```python
def introduce(name, age, city):
    print(f"{name}, {age} лет, {city}")

# Сначала позиционные, затем именованные
introduce("Анна", 25, city="Москва")
introduce("Борис", age=30, city="Казань")

# ❌ Ошибка — именованные должны быть после позиционных
# introduce(name="Анна", 25, "Москва")  # SyntaxError
```

**Параметры по умолчанию (default parameters):**

```python
# Параметр с значением по умолчанию
def greet(name, greeting="Привет"):
    print(f"{greeting}, {name}!")

greet("Анна")           # Привет, Анна! (используется значение по умолчанию)
greet("Борис", "Здравствуйте")  # Здравствуйте, Борис!
```

```python
# Несколько параметров по умолчанию
def create_user(name, age=18, country="Россия"):
    print(f"Пользователь: {name}, {age} лет, {country}")

create_user("Анна")                      # Возраст 18, Россия
create_user("Борис", 25)                 # Возраст 25, Россия
create_user("Вера", 30, "Украина")       # Возраст 30, Украина
create_user("Глеб", country="Казахстан") # Возраст 18, Казахстан
```

**Важные правила:**

```python
# ✅ Правильно — параметры по умолчанию в конце
def func(a, b, c=10):
    pass

# ❌ Ошибка — обязательный параметр после параметра по умолчанию
# def func(a, b=5, c):  # SyntaxError
#     pass
```

**Практический пример:**

```python
def calculate_price(base_price, tax=0.2, discount=0):
    """
    Вычисляет финальную цену с учётом налога и скидки.
    
    Параметры:
        base_price (float): базовая цена
        tax (float): налог в процентах (по умолчанию 20%)
        discount (float): скидка в процентах (по умолчанию 0%)
    """
    price_with_tax = base_price * (1 + tax)
    final_price = price_with_tax * (1 - discount)
    return final_price

# Разные способы вызова
print(calculate_price(1000))                    # 1200.0 (только базовая цена)
print(calculate_price(1000, 0.1))               # 1100.0 (налог 10%)
print(calculate_price(1000, 0.2, 0.1))          # 1080.0 (налог 20%, скидка 10%)
print(calculate_price(1000, discount=0.15))     # 1020.0 (налог по умолчанию, скидка 15%)
```

**Итог:**
- **Параметр** — переменная в определении функции (шаблон)
- **Аргумент** — значение при вызове функции (данные)
- **Позиционные аргументы** — порядок важен
- **Именованные аргументы** — порядок не важен
- **Параметры по умолчанию** — необязательные значения

## `8.5` Разные виды `return`
`return` — оператор для возврата результата из функции. После выполнения `return` функция **немедленно завершается**, и управление возвращается в место вызова.

**Основные концепции:**
1. `return` может возвращать значение любого типа
2. `return` без значения возвращает `None`
3. Функция без `return` тоже возвращает `None`
4. `return` прерывает выполнение функции
5. Можно вернуть несколько значений (кортеж)

### 1. Return с значением

```python
# Возврат числа
def get_age():
    return 25

age = get_age()
print(age)  # 25
print(type(age))  # <class 'int'>
```

```python
# Возврат результата вычисления
def add(a, b):
    return a + b

result = add(10, 5)
print(result)  # 15
```

```python
# Возврат строки
def get_greeting():
    return "Привет, мир!"

message = get_greeting()
print(message)  # Привет, мир!
```

### 2. Return без значения (возврат None)

```python
# return без значения
def say_hello():
    print("Привет!")
    return  # Явный выход из функции

result = say_hello()
print(result)  # None
```

```python
# Функция без return — неявно возвращает None
def print_message():
    print("Сообщение")

result = print_message()
print(result)  # None
```

### 3. Return прерывает функцию

```python
# Код после return не выполняется
def example():
    print("До return")
    return 42
    print("После return")  # Это никогда не выполнится!

result = example()
# Вывод:
# До return
```

```python
# Досрочный выход из функции
def check_age(age):
    if age < 18:
        return "Несовершеннолетний"  # Выход из функции
    return "Совершеннолетний"

print(check_age(15))  # Несовершеннолетний
print(check_age(25))  # Совершеннолетний
```

```python
# Множественные return для разных условий
def get_grade(score):
    if score >= 90:
        return "Отлично"
    elif score >= 70:
        return "Хорошо"
    elif score >= 50:
        return "Удовлетворительно"
    else:
        return "Неудовлетворительно"

print(get_grade(95))  # Отлично
print(get_grade(65))  # Удовлетворительно
```

### 4. Return нескольких значений

```python
# Возврат нескольких значений (кортеж)
def get_user_info():
    name = "Анна"
    age = 25
    city = "Москва"
    return name, age, city  # Возвращает кортеж

# Распаковка значений
user_name, user_age, user_city = get_user_info()
print(user_name)  # Анна
print(user_age)   # 25
print(user_city)  # Москва

# Или получить кортеж целиком
info = get_user_info()
print(info)  # ('Анна', 25, 'Москва')
print(type(info))  # <class 'tuple'>
```

```python
# Возврат результата нескольких вычислений
def calculate(a, b):
    sum_result = a + b
    diff_result = a - b
    product_result = a * b
    return sum_result, diff_result, product_result

s, d, p = calculate(10, 5)
print(f"Сумма: {s}, Разность: {d}, Произведение: {p}")
# Сумма: 15, Разность: 5, Произведение: 50
```

### 5. Return различных типов данных

```python
# Возврат списка
def get_numbers():
    return [1, 2, 3, 4, 5]

numbers = get_numbers()
print(numbers)  # [1, 2, 3, 4, 5]
```

```python
# Возврат словаря
def get_person():
    return {
        "name": "Анна",
        "age": 25,
        "city": "Москва"
    }

person = get_person()
print(person["name"])  # Анна
```

```python
# Возврат булева значения
def is_even(number):
    return number % 2 == 0

print(is_even(4))  # True
print(is_even(7))  # False
```

### 6. Return в циклах

```python
# Return прерывает не только функцию, но и цикл внутри неё
def find_first_even(numbers):
    for num in numbers:
        if num % 2 == 0:
            return num  # Выход из цикла и функции
    return None  # Если чётное не найдено

result = find_first_even([1, 3, 5, 8, 10, 12])
print(result)  # 8 (первое чётное)

result = find_first_even([1, 3, 5, 7])
print(result)  # None
```

```python
# Поиск элемента в списке
def find_index(lst, target):
    for i in range(len(lst)):
        if lst[i] == target:
            return i  # Возврат индекса при нахождении
    return -1  # Элемент не найден

numbers = [10, 20, 30, 40, 50]
print(find_index(numbers, 30))  # 2
print(find_index(numbers, 100))  # -1
```

### 7. Return выражений

```python
# Можно возвращать результат выражения напрямую
def is_adult(age):
    return age >= 18  # Возвращает True или False

print(is_adult(25))  # True
print(is_adult(15))  # False
```

```python
# Возврат результата вызова другой функции
def square(x):
    return x ** 2

def sum_of_squares(a, b):
    return square(a) + square(b)  # Возврат результата вычисления

print(sum_of_squares(3, 4))  # 25
```

**Важные замечания:**

```python
# ❌ Частая ошибка — print вместо return
def add_wrong(a, b):
    print(a + b)  # Печатает, но НЕ возвращает!

result = add_wrong(5, 3)  # Выведет 8
print(result)  # None (функция ничего не вернула)

# ✅ Правильно — return
def add_correct(a, b):
    return a + b

result = add_correct(5, 3)
print(result)  # 8
```

```python
# Return можно использовать с условными выражениями (тернарный оператор)
def get_status(age):
    return "Взрослый" if age >= 18 else "Ребёнок"

print(get_status(20))  # Взрослый
print(get_status(10))  # Ребёнок
```

**Итог:**
- `return` возвращает результат из функции
- `return` без значения или отсутствие `return` возвращает `None`
- `return` немедленно завершает функцию
- Можно вернуть несколько значений (кортеж)
- Можно возвращать любые типы данных
- `return` работает в циклах, досрочно завершая функцию

----

# `9` Типы данных 3
## `9.1` Кортежи
### `9.1.1` Что такое кортежи?  
### `9.1.2` В чем их плюсы и минусы? Их свойства. Отличие от списков  
### `9.1.3` Функции `len()`, `in` для кортежей и другие по типу `sum()`  
### `9.1.4` Методы кортежей:  
- `index()`  
- `count()`  
- `join()`
### `9.1.5` Распаковка кортежей  

## `9.2` Множества
### `9.2.1` Что такое множества? Свойства множеств  
### `9.2.2` Функции `len()`, `in` для множеств и другие по типу `sum()`  
### `9.2.3` Методы множеств (можно посмотреть все, но укажу, который точно надо знать):  
- `add()`  
- `remove()`  
- `discard()`  
- `pop()`  
- `clear()`  
- методы и операторы для операций между множествами  
- `issubset()`  
- `issuperset()`

### `9.2.3` (`*`) Генераторы множеств (`set comprehensions`)

`Set comprehension` — это компактный способ создания множества на основе итерируемого объекта с фильтрацией и преобразованием элементов. Синтаксис похож на list comprehension, но используются **фигурные скобки** `{}`.

### **Синтаксис**

```python
{expression for item in iterable if condition}
```

### **Базовые примеры**

```python
# Создание множества из квадратов чисел
numbers = [1, 2, 3, 4, 5]
squares = {x**2 for x in numbers}
print(squares)  # {1, 4, 9, 16, 25}

# Автоматическое удаление дубликатов
numbers = [1, 2, 2, 3, 3, 3, 4]
unique = {x for x in numbers}
print(unique)  # {1, 2, 3, 4}

# Преобразование в верхний регистр
words = ["hello", "world", "python", "hello"]
uppercase = {word.upper() for word in words}
print(uppercase)  # {'HELLO', 'WORLD', 'PYTHON'}
```

### **Фильтрация с условием**

```python
# Только чётные числа
numbers = [13, 21, 14, 24, 53, 62]
even_numbers = {num for num in numbers if num % 2 == 0}
print(even_numbers)  # {24, 62, 14} (порядок может отличаться)

# Только длинные слова
words = ["cat", "elephant", "dog", "giraffe", "ant"]
long_words = {word for word in words if len(word) > 3}
print(long_words)  # {'elephant', 'giraffe'}

# Положительные числа из смешанного списка
numbers = [-5, 3, -2, 8, 0, -1, 7]
positive = {n for n in numbers if n > 0}
print(positive)  # {8, 3, 7}
```

### **Преобразование элементов**

```python
# Длины уникальных слов
words = ["hello", "world", "hi", "python"]
lengths = {len(word) for word in words}
print(lengths)  # {2, 5, 6}

# Первые буквы слов
sentence = "the quick brown fox jumps over the lazy dog"
first_letters = {word[0] for word in sentence.split()}
print(first_letters)  # {'b', 'd', 'f', 'j', 'l', 'o', 'q', 't'}

# Абсолютные значения
numbers = [-5, 3, -3, 5, -7, 7]
absolutes = {abs(n) for n in numbers}
print(absolutes)  # {3, 5, 7}
```

### **Извлечение уникальных значений из сложных структур**

```python
# Уникальные возрасты из списка словарей
users = [
    {"name": "Alice", "age": 25},
    {"name": "Bob", "age": 30},
    {"name": "Charlie", "age": 25},
    {"name": "David", "age": 35}
]
ages = {user["age"] for user in users}
print(ages)  # {25, 30, 35}

# Уникальные расширения файлов
files = ["doc.txt", "image.png", "script.py", "data.txt", "photo.png"]
extensions = {file.split('.')[-1] for file in files}
print(extensions)  # {'txt', 'png', 'py'}

# Уникальные символы в строке
text = "hello world"
chars = {char for char in text if char != ' '}
print(chars)  # {'h', 'e', 'l', 'o', 'w', 'r', 'd'}
```

### **Вложенные циклы в set comprehension**

```python
# Уникальные произведения пар чисел
numbers1 = [2, 3]
numbers2 = [4, 5]
products = {x * y for x in numbers1 for y in numbers2}
print(products)  # {8, 10, 12, 15}

# Уникальные координаты сетки (без дубликатов)
grid = {(x, y) for x in range(3) for y in range(3) if x != y}
print(grid)  # {(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1)}
```

### **Практические примеры**

```python
# Поиск уникальных слов в тексте (без учёта регистра)
text = "Hello world hello Python python World"
unique_words = {word.lower() for word in text.split()}
print(unique_words)  # {'hello', 'world', 'python'}

# Извлечение доменов из списка email'ов
emails = ["user1@gmail.com", "user2@yahoo.com", "user3@gmail.com"]
domains = {email.split('@')[1] for email in emails}
print(domains)  # {'gmail.com', 'yahoo.com'}

# Уникальные цифры в числе
number = 1122334455
digits = {int(d) for d in str(number)}
print(digits)  # {1, 2, 3, 4, 5}

# Фильтрация валидных email (простая проверка)
emails = ["user@example.com", "invalid", "test@test.org", "bad@"]
valid = {email for email in emails if '@' in email and '.' in email.split('@')[-1]}
print(valid)  # {'user@example.com', 'test@test.org'}
```

### **Сравнение с list comprehension**

```python
numbers = [1, 2, 2, 3, 3, 3]

# List comprehension — сохраняет дубликаты
list_result = [x for x in numbers]
print(list_result)  # [1, 2, 2, 3, 3, 3]

# Set comprehension — удаляет дубликаты
set_result = {x for x in numbers}
print(set_result)  # {1, 2, 3}

# Преобразование set обратно в list
unique_list = list(set_result)
print(unique_list)  # [1, 2, 3] (или другой порядок)
```

**Когда использовать:**
- Нужны только уникальные элементы
- Порядок элементов не важен
- Требуется быстрая проверка принадлежности элемента
- Извлечение уникальных значений из данных

**Особенности:**
- Автоматически удаляет дубликаты
- Элементы неупорядочены (порядок не гарантируется)
- Элементы должны быть хешируемыми (нельзя добавить списки или словари)
- Быстрее list comprehension для проверки наличия элемента

### `9.2.4` (`**`) `frozenset`
`frozenset` — это неизменяемый (immutable) аналог множества (`set`). Как и множество, он хранит уникальные элементы, но после создания его нельзя изменить (добавлять или удалять элементы).

Основные особенности:
- Можно использовать как ключи в словарях или элементы других множеств (т.к. хешируем).
- Создаётся из итерируемого объекта: `frozenset(iterable)`.

```python
s = frozenset([1, 2, 2, 3])
print(s)  # frozenset({1, 2, 3})

# Попытка изменить вызовет ошибку:
# s.add(4)  # AttributeError: 'frozenset' object has no attribute 'add'
```


### **frozenset как элемент множества**

```python
# Множество множеств (только с frozenset)
set_of_sets = {
    frozenset([1, 2]),
    frozenset([3, 4]),
    frozenset([1, 2])  # Дубликат, будет удалён
}
print(set_of_sets)  # {frozenset({1, 2}), frozenset({3, 4})}

# Нельзя добавить обычный set
# set_of_sets.add({5, 6})  # TypeError: unhashable type: 'set'
```

### **Практические примеры**

```python
# Хранение неизменяемых групп пользователей
user_groups = {
    'alice': frozenset(['admin', 'editor']),
    'bob': frozenset(['viewer']),
    'charlie': frozenset(['admin', 'viewer', 'editor'])
}

# Проверка прав доступа
if 'admin' in user_groups['alice']:
    print("Alice имеет права администратора")  # Выведет

# Поиск пользователей с определёнными правами
admin_users = [user for user, groups in user_groups.items() if 'admin' in groups]
print(admin_users)  # ['alice', 'charlie']

# Граф связей (неизменяемые рёбра)
graph = {
    frozenset(['A', 'B']): 5,  # Ребро A-B с весом 5
    frozenset(['B', 'C']): 3,
    frozenset(['A', 'C']): 7
}

# Поиск веса ребра
edge = frozenset(['A', 'B'])
print(graph[edge])  # 5

# Кеширование результатов для наборов параметров
cache = {}

def calculate(params):
    frozen_params = frozenset(params.items())
    if frozen_params not in cache:
        # Сложные вычисления
        result = sum(params.values()) * 2
        cache[frozen_params] = result
    return cache[frozen_params]

print(calculate({'a': 1, 'b': 2}))  # 6
print(calculate({'a': 1, 'b': 2}))  # 6 (из кеша)
```

### **Преобразование между set и frozenset**

```python
# set → frozenset
s = {1, 2, 3}
fs = frozenset(s)
print(fs)  # frozenset({1, 2, 3})

# frozenset → set
fs = frozenset([4, 5, 6])
s = set(fs)
s.add(7)
print(s)  # {4, 5, 6, 7}

# frozenset остался неизменным
print(fs)  # frozenset({4, 5, 6})
```

**Когда использовать frozenset:**
- Нужно неизменяемое множество (для гарантии целостности данных)
- Множество должно быть ключом словаря
- Множество должно быть элементом другого множества
- Требуется хешируемая коллекция уникальных элементов
- Передача данных, которые нельзя случайно изменить

**Ключевые особенности:**
- Неизменяемый (immutable) — нельзя добавлять/удалять элементы
- Хешируемый (hashable) — можно использовать как ключ или в множестве
- Поддерживает все операции чтения множеств
- Создаётся один раз и не меняется
- Немного быстрее обычного `set` в некоторых операциях из-за неизменяемости

[Видео про frozenset](https://www.youtube.com/watch?v=YatGF3voZH8)


## `9.3` Словари
### `9.3.1` (`*`) Что такое словари? Свойства словарей 
[Видео про dict](https://youtu.be/MZZSMaEAC2g?si=YvGzIOcgZDZGICoG)

Словарь (`dict`) — это изменяемая коллекция, которая хранит данные в виде пар **ключ-значение**. Каждому уникальному ключу соответствует одно значение.

```python
# Создание словаря
person = {
    'name': 'Alice',
    'age': 30,
    'city': 'Moscow'
}

# Доступ к значению по ключу
print(person['name'])  # 'Alice'

# Добавление/изменение элемента
person['email'] = 'alice@example.com'  # Добавление
person['age'] = 31                      # Изменение

print(person)
# {'name': 'Alice', 'age': 31, 'city': 'Moscow', 'email': 'alice@example.com'}
```

**Основные свойства словарей:**

1. **Неупорядоченность** (до Python 3.7) / **Сохранение порядка вставки** (с Python 3.7+)
2. **Ключи уникальны** — дублирующиеся ключи перезаписываются
3. **Ключи должны быть неизменяемыми** (hashable) — строки, числа, кортежи
4. **Значения могут быть любыми** — включая другие словари, списки, объекты
5. **Быстрый доступ по ключу — O(1)** — не нужно перебирать элементы!

```python
# Ключи уникальны — дубликат перезаписывается
data = {'a': 1, 'b': 2, 'a': 3}
print(data)  # {'a': 3, 'b': 2}

# Значения могут повторяться
scores = {'Alice': 100, 'Bob': 85, 'Charlie': 100}
print(scores)  # {'Alice': 100, 'Bob': 85, 'Charlie': 100}

# Значения могут быть любого типа
mixed = {
    'name': 'Alice',
    'scores': [85, 90, 95],
    'active': True,
    'address': {'city': 'Moscow', 'street': 'Main St'}
}
```

**Главное преимущество — мгновенный поиск по ключу:**

```python
# Список — нужно перебирать все элементы (медленно для больших данных)
users_list = [
    ('alice', 'Alice'),
    ('bob', 'Bob'),
    ('charlie', 'Charlie')
    # ... 10000 элементов
]
# Чтобы найти пользователя, нужно перебрать весь список
for username, name in users_list:
    if username == 'charlie':
        print(name)  # Долго!

# Словарь — мгновенный доступ по ключу (быстро!)
users_dict = {
    'alice': 'Alice',
    'bob': 'Bob',
    'charlie': 'Charlie'
    # ... 10000 элементов
}
# Прямой доступ без перебора
print(users_dict['charlie'])  # Мгновенно!
```

### `9.3.2` Что может быть ключом словаря, а что нет?  
### `9.3.3` Функции `len()`, `in` для словарей и другие по типу `sum()`  
### `9.3.4` Методы словарей (можно посмотреть все, но укажу, который точно надо знать):  
- получение элемента из словаря  
- удаление элемента из словаря
- `keys()`  
- `values()`  
- `items()`  
- `get()`  
- `update()`  
- `setdefault()`  
- `pop()`  
- `clear()`  
- `copy()`

### `9.3.5` Уметь перебирать словари через for  
### `9.3.6` Вложенные словари  
### `9.3.7` (`*`) Генераторы словарей или `dict comprehensions`
Dict comprehension — это компактный способ создания словаря на основе итерируемого объекта с возможностью преобразования и фильтрации.

**Синтаксис:**
```python
{ключ: значение for элемент in итерируемый_объект if условие}
```

**Пример 1: Создание словаря из списка**

```python
# Создать словарь: число → квадрат числа
numbers = [1, 2, 3, 4, 5]
squares = {num: num**2 for num in numbers}
print(squares)  # {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}

# С фильтрацией — только чётные числа
even_squares = {num: num**2 for num in numbers if num % 2 == 0}
print(even_squares)  # {2: 4, 4: 16}
```

**Пример 2: Преобразование данных**

```python
# Список имён → словарь: имя → длина имени
names = ['Alice', 'Bob', 'Charlie']
name_lengths = {name: len(name) for name in names}
print(name_lengths)  # {'Alice': 5, 'Bob': 3, 'Charlie': 7}

# Инвертирование словаря (ключи ↔ значения)
original = {'a': 1, 'b': 2, 'c': 3}
inverted = {value: key for key, value in original.items()}
print(inverted)  # {1: 'a', 2: 'b', 3: 'c'}
```

Dict comprehension создаёт словарь за одну строку, избегая циклов и временных переменных.

### `9.3.8` (`*`) Что такое коллекции и последовательности?
### **Коллекции (Collections)**

Коллекции — это структуры данных для хранения групп объектов. В Python основные типы коллекций: списки (`list`), кортежи (`tuple`), множества (`set`), словари (`dict`).

```python
# Основные коллекции
fruits_list = ['apple', 'banana', 'cherry']      # Список
coordinates = (10, 20, 30)                       # Кортеж
unique_numbers = {1, 2, 3, 4, 5}                # Множество
person = {'name': 'Alice', 'age': 30}           # Словарь

# Общие операции для всех коллекций
print(len(fruits_list))          # 3 (длина)
print('apple' in fruits_list)    # True (проверка вхождения)
for item in fruits_list:         # Итерация
    print(item)
```

### **Последовательности (Sequences)**

Последовательности — это **упорядоченные** коллекции, где элементы имеют позицию (индекс) и доступны по этой позиции. К ним относятся: списки, кортежи, строки, range.

```python
# Последовательности поддерживают индексацию и срезы
numbers = [10, 20, 30, 40, 50]   # Список — последовательность
text = "Python"                   # Строка — последовательность

# Индексация
print(numbers[0])      # 10 (первый элемент)
print(text[-1])        # 'n' (последний элемент)

# Срезы
print(numbers[1:4])    # [20, 30, 40]
print(text[:3])        # 'Pyt'

# НЕ последовательности — нет индексов
unique_set = {10, 20, 30}        # Множество
# print(unique_set[0])           # TypeError! У множества нет индексов

person_dict = {'name': 'Bob'}    # Словарь
# print(person_dict[0])          # KeyError! У словаря доступ по ключу, не по индексу
```

**Главное отличие:**

- **Последовательности** = коллекции с **порядком** и **индексами** (список, кортеж, строка)
- **Остальные коллекции** = нет гарантированного порядка или доступа по индексу (множество, словарь)

```python
# Порядок важен в последовательностях
list1 = [1, 2, 3]
list2 = [3, 2, 1]
print(list1 == list2)  # False (разный порядок)

# Порядок не важен в множествах
set1 = {1, 2, 3}
set2 = {3, 2, 1}
print(set1 == set2)    # True (важны только элементы)
```

**Все коллекции в Python итерируемы** (их можно перебрать в цикле), но только последовательности поддерживают индексацию и срезы.

----

# `10` (`*`) Управление памятью
[Must Have Video](https://youtu.be/8GpI0PAGniA?si=GVxdfcmtYRZfeJzv)

## `10.1` Устройство памяти в общем
[Как устроена память?](https://www.youtube.com/watch?v=Wh22_O8jXVQ)

## `10.2` Устройства памяти в Python
[Как устроена память в Python?](https://www.youtube.com/watch?v=1CHLo4bY7P4)

## `10.3` Переменные в Python. Как работают ссылки в Python  
В Python **переменные — это ссылки (указатели) на объекты в памяти**, а не сами данные. Переменная хранит адрес объекта, а не его значение.

```python
# Переменная — это ссылка на объект
x = 42
# x не содержит число 42, а указывает на объект со значением 42 в памяти

y = x
# y теперь указывает на тот же объект, что и x

print(id(x))  # Например: 140234567890
print(id(y))  # 140234567890 (тот же адрес!)
print(x is y) # True (обе переменные указывают на один объект)
```

**Поведение с неизменяемыми объектами:**

```python
a = 10
b = a          # b указывает на тот же объект
print(a is b)  # True

a = 20         # a теперь указывает на новый объект (10 → 20)
print(a is b)  # False (a и b указывают на разные объекты)
print(a)       # 20
print(b)       # 10 (не изменилась!)
```

**Поведение с изменяемыми объектами:**

```python
list1 = [1, 2, 3]
list2 = list1          # list2 указывает на тот же список
print(list1 is list2)  # True (одна и та же ссылка)

list1.append(4)        # Изменяем список через list1
print(list1)           # [1, 2, 3, 4]
print(list2)           # [1, 2, 3, 4] (тоже изменился!)

# Чтобы создать независимую копию:
list3 = list1.copy()   # или list3 = list1[:]
list3.append(5)
print(list1)           # [1, 2, 3, 4] (не изменился)
print(list3)           # [1, 2, 3, 4, 5]
```

**Передача аргументов в функции:**

```python
# Неизменяемые объекты
def change_number(x):
    x = 100        # Создаётся новый объект, исходный не меняется

num = 10
change_number(num)
print(num)         # 10 (не изменилось)

# Изменяемые объекты
def change_list(lst):
    lst.append(4)  # Изменяется тот же объект

my_list = [1, 2, 3]
change_list(my_list)
print(my_list)     # [1, 2, 3, 4] (изменилось!)
```

**Ключевые моменты:**

- Переменная = ссылка (указатель) на объект в памяти
- Присваивание `a = b` копирует ссылку, а не объект
- Неизменяемые объекты безопасны — изменение создаёт новый объект
- Изменяемые объекты — изменение влияет на все ссылки
- Используйте `copy()` или `deepcopy()` для создания независимых копий

## `10.4` Изменяемые и неизменяемые типы данных. `copy()` & `deepcopy()`
В Python все типы данных делятся на две категории по возможности изменения после создания:

- **Неизменяемые (immutable)** — после создания объект нельзя изменить. Любая «модификация» создаёт новый объект.
- **Изменяемые (mutable)** — объект можно изменять на месте без создания нового.

### **Неизменяемые типы (Immutable)**

**Основные неизменяемые типы:** `int`, `float`, `str`, `tuple`, `bool`, `frozenset`, `bytes`

```python
# Числа (int, float)
x = 10
print(id(x))    # Адрес 1
x = x + 5       # Создаётся НОВЫЙ объект со значением 15
print(id(x))    # Адрес 2 (другой объект!)

# Строки (str)
text = "hello"
print(id(text))       # Адрес 1
text = text + " world"  # Создаётся НОВАЯ строка
print(id(text))       # Адрес 2 (другой объект!)

# При попытке изменить символ — ошибка
s = "Python"
# s[0] = 'J'  # TypeError: 'str' object does not support item assignment

# Кортежи (tuple)
coords = (10, 20)
print(id(coords))     # Адрес 1
# coords[0] = 15      # TypeError: 'tuple' object does not support item assignment
coords = (15, 20)     # Создаётся НОВЫЙ кортеж
print(id(coords))     # Адрес 2 (другой объект!)
```

**Что происходит при "изменении":**

```python
# Каждая операция создаёт новый объект
x = 5
print(id(x))     # Адрес A

x = x + 1        # x = 6 — это НОВЫЙ объект
print(id(x))     # Адрес B (изменился!)

x += 1           # x = 7 — снова НОВЫЙ объект
print(id(x))     # Адрес C (изменился!)

# Строки работают так же
name = "Alice"
print(id(name))        # Адрес 1
name = name.upper()    # Создаётся новая строка "ALICE"
print(id(name))        # Адрес 2 (изменился!)
```

**Почему это важно — передача в функцию:**

```python
def modify_number(n):
    print(f"До изменения внутри функции: {id(n)}")
    n = n + 10  # Создаётся НОВЫЙ объект
    print(f"После изменения внутри функции: {id(n)}")
    return n

x = 5
print(f"До вызова функции: {id(x)}")
result = modify_number(x)
print(f"После вызова функции: {id(x)}")
print(f"x = {x}")  # 5 (не изменился!)
print(f"result = {result}")  # 15

# Вывод:
# До вызова функции: адрес A
# До изменения внутри функции: адрес A (та же ссылка)
# После изменения внутри функции: адрес B (новый объект!)
# После вызова функции: адрес A (x не изменился)
```


### **Изменяемые типы (Mutable)**

**Основные изменяемые типы:** `list`, `dict`, `set`, `bytearray`

```python
# Списки (list)
numbers = [1, 2, 3]
print(id(numbers))      # Адрес 1
numbers.append(4)       # Изменяем на месте
print(id(numbers))      # Адрес 1 (тот же объект!)
numbers[0] = 100        # Изменяем элемент
print(id(numbers))      # Адрес 1 (всё ещё тот же!)

# Словари (dict)
person = {'name': 'Alice', 'age': 30}
print(id(person))       # Адрес 1
person['city'] = 'Moscow'  # Добавляем ключ
print(id(person))       # Адрес 1 (тот же объект!)
person['age'] = 31      # Изменяем значение
print(id(person))       # Адрес 1 (тот же объект!)

# Множества (set)
tags = {'python', 'coding'}
print(id(tags))         # Адрес 1
tags.add('tutorial')    # Добавляем элемент
print(id(tags))         # Адрес 1 (тот же объект!)
```

**Опасность изменяемых объектов — общие ссылки:**

```python
# Две переменные указывают на ОДИН список
list1 = [1, 2, 3]
list2 = list1          # Копируется ссылка, НЕ объект!

print(list1 is list2)  # True (один и тот же объект)
print(id(list1))       # Адрес A
print(id(list2))       # Адрес A (тот же!)

# Изменение через одну переменную влияет на другую
list1.append(4)
print(list1)           # [1, 2, 3, 4]
print(list2)           # [1, 2, 3, 4] (тоже изменился!)

# Изменение через list2
list2[0] = 100
print(list1)           # [100, 2, 3, 4] (изменился!)
print(list2)           # [100, 2, 3, 4]
```

**Как создать независимую копию:**

```python
# Способ 1: метод copy()
original = [1, 2, 3]
copy1 = original.copy()
copy1.append(4)
print(original)  # [1, 2, 3] (не изменился)
print(copy1)     # [1, 2, 3, 4]

# Способ 2: срез [:]
copy2 = original[:]
copy2.append(5)
print(original)  # [1, 2, 3] (не изменился)
print(copy2)     # [1, 2, 3, 5]

# Способ 3: list()
copy3 = list(original)
copy3.append(6)
print(original)  # [1, 2, 3] (не изменился)
print(copy3)     # [1, 2, 3, 6]
```

**Передача в функцию — изменяемые объекты:**

```python
def modify_list(lst):
    lst.append(4)  # Изменяет ОРИГИНАЛЬНЫЙ список!
    print(f"Внутри функции: {lst}")

my_list = [1, 2, 3]
print(f"До вызова: {my_list}")
modify_list(my_list)
print(f"После вызова: {my_list}")  # [1, 2, 3, 4] (изменился!)

# Вывод:
# До вызова: [1, 2, 3]
# Внутри функции: [1, 2, 3, 4]
# После вызова: [1, 2, 3, 4]
```

**Как защититься от изменения:**

```python
def modify_list_safe(lst):
    local_copy = lst.copy()  # Создаём локальную копию
    local_copy.append(4)
    return local_copy

my_list = [1, 2, 3]
result = modify_list_safe(my_list)
print(my_list)  # [1, 2, 3] (не изменился!)
print(result)   # [1, 2, 3, 4]
```

### **Поверхностное и глубокое копирование: `copy()` vs `deepcopy()`**

Когда внутри списка есть другие изменяемые объекты (списки, словари), обычное копирование создаёт **поверхностную копию** — копируется только внешний уровень, а вложенные объекты остаются общими.

#### **Поверхностное копирование (shallow copy) — `.copy()`**

```python
# Проблема с вложенными списками
original = [[1, 2], [3, 4]]
shallow = original.copy()

print(id(original))       # Адрес A
print(id(shallow))        # Адрес B (разные объекты)
print(id(original[0]))    # Адрес C
print(id(shallow[0]))     # Адрес C (ОДИН И ТОТ ЖЕ вложенный список!)

# Изменяем вложенный список
shallow[0].append(999)

print(original)  # [[1, 2, 999], [3, 4]] (изменился!)
print(shallow)   # [[1, 2, 999], [3, 4]]

# Почему? Визуализация:
# original -> [список1, список2]
#               ↓        ↓
# shallow  -> [список1, список2]  # Те же самые вложенные списки!
```

**Когда `.copy()` работает нормально:**

```python
# С простыми элементами (неизменяемыми)
numbers = [1, 2, 3]
copy_num = numbers.copy()
copy_num[0] = 999
print(numbers)   # [1, 2, 3] (не изменился)
print(copy_num)  # [999, 2, 3]

# Работает, потому что числа неизменяемы — присваивание создаёт новый объект
```

#### **Глубокое копирование (deep copy) — `copy.deepcopy()`**

```python
import copy

# Глубокое копирование рекурсивно копирует ВСЕ уровни
original = [[1, 2], [3, 4]]
deep = copy.deepcopy(original)

print(id(original))       # Адрес A
print(id(deep))           # Адрес B (разные объекты)
print(id(original[0]))    # Адрес C
print(id(deep[0]))        # Адрес D (РАЗНЫЕ вложенные списки!)

# Изменяем вложенный список
deep[0].append(999)

print(original)  # [[1, 2], [3, 4]] (НЕ изменился!)
print(deep)      # [[1, 2, 999], [3, 4]]

# Визуализация:
# original -> [список1_orig, список2_orig]
# deep     -> [список1_copy, список2_copy]  # Полностью независимые копии!
```

**Сложный пример со словарями:**

```python
import copy

# Вложенные структуры
original = {
    'user': 'Alice',
    'scores': [85, 90, 95],
    'settings': {'theme': 'dark', 'notifications': True}
}

# Поверхностная копия
shallow = original.copy()
shallow['scores'].append(100)          # Изменяем список
shallow['settings']['theme'] = 'light' # Изменяем словарь

print(original['scores'])    # [85, 90, 95, 100] (изменился!)
print(original['settings'])  # {'theme': 'light', ...} (изменился!)

# Глубокая копия
deep = copy.deepcopy(original)
deep['scores'].append(200)
deep['settings']['theme'] = 'blue'

print(original['scores'])    # [85, 90, 95, 100] (НЕ изменился)
print(original['settings'])  # {'theme': 'light', ...} (НЕ изменился)
```

**Когда использовать что:**

```python
# copy() — для простых одноуровневых структур
simple_list = [1, 2, 3, 4]
simple_copy = simple_list.copy()  # Достаточно

# deepcopy() — для вложенных структур
nested_list = [[1, 2], [3, 4], {'a': [5, 6]}]
nested_copy = copy.deepcopy(nested_list)  # Необходимо!

# Проверка: есть ли вложенные изменяемые объекты?
data = [1, 'text', (1, 2), 3.14]  # Только неизменяемые элементы
safe_copy = data.copy()  # copy() достаточно

data2 = [1, [2, 3], {'key': 'value'}]  # Есть вложенные изменяемые
safe_copy2 = copy.deepcopy(data2)  # Нужен deepcopy()
```

**Визуальное сравнение:**

```python
import copy

original = [[1, 2], [3, 4]]

# Присваивание (=) — общая ссылка
ref = original
ref[0].append(999)
print(original)  # [[1, 2, 999], [3, 4]] — изменился!

# Поверхностная копия (.copy()) — копируется только первый уровень
original = [[1, 2], [3, 4]]
shallow = original.copy()
shallow[0].append(999)
print(original)  # [[1, 2, 999], [3, 4]] — изменился!

# Глубокая копия (deepcopy()) — полностью независимая копия
original = [[1, 2], [3, 4]]
deep = copy.deepcopy(original)
deep[0].append(999)
print(original)  # [[1, 2], [3, 4]] — НЕ изменился!
```


### **Сравнительная таблица**

| Операция | Неизменяемые | Изменяемые |
|----------|--------------|------------|
| Изменение значения | Создаётся новый объект | Объект меняется на месте |
| `id()` после изменения | Меняется | Не меняется |
| Безопасность при передаче | Безопасно | Может измениться |
| Можно использовать как ключ словаря | Да | Нет |
| Копирование `=` | Безопасно | Опасно (общая ссылка) |
| `.copy()` | Не нужно | Копирует 1 уровень |
| `deepcopy()` | Не нужно | Копирует все уровни |


### **Практические примеры**

```python
# Пример 1: Дефолтные аргументы функции (частая ошибка!)
def add_item(item, lst=[]):  # ОПАСНО! [] создаётся ОДИН раз
    lst.append(item)
    return lst

print(add_item(1))  # [1]
print(add_item(2))  # [1, 2] (Ожидали [2]!)
print(add_item(3))  # [1, 2, 3] (Ожидали [3]!)

# Правильно:
def add_item_safe(item, lst=None):
    if lst is None:
        lst = []  # Создаём новый список при каждом вызове
    lst.append(item)
    return lst

print(add_item_safe(1))  # [1]
print(add_item_safe(2))  # [2]
print(add_item_safe(3))  # [3]

# Пример 2: Кеширование неизменяемых объектов
a = 257
b = 257
print(a is b)  # False (большие числа — разные объекты)

x = 5
y = 5
print(x is y)  # True (маленькие числа кешируются Python!)

s1 = "hello"
s2 = "hello"
print(s1 is s2)  # True (строки тоже кешируются)

# Пример 3: Изменяемые объекты в кортеже
t = ([1, 2], [3, 4])
# t[0] = [5, 6]  # TypeError (кортеж неизменяем)
t[0].append(999)  # Но список внутри можно изменить!
print(t)  # ([1, 2, 999], [3, 4])
```

**Ключевые правила:**

1. **Неизменяемые типы безопасны** — изменение создаёт новый объект, оригинал не трогается
2. **Изменяемые типы опасны** — изменение влияет на все ссылки
3. **При присваивании `a = b`** копируется ссылка, а не объект
4. **`.copy()` — поверхностное копирование** — копирует только первый уровень (быстрее)
5. **`deepcopy()` — глубокое копирование** — копирует все вложенные уровни (медленнее, но безопаснее)
6. **Остерегайтесь изменяемых дефолтных аргументов** в функциях
7. **Только неизменяемые типы** можно использовать как ключи словаря или элементы множества


## `10.5` Garbage collector. Слабые и сильные ссылки
[How it works?](https://youtu.be/3Kqal7QaCCM?si=0_M82_NFF5eECt7f)

### **Garbage Collector (Сборщик мусора)**

Garbage Collector (GC) — это механизм автоматического управления памятью в Python. Он отслеживает объекты и удаляет те, которые больше не используются, освобождая память.

**Как работает — подсчёт ссылок:**

Python считает, сколько переменных ссылается на каждый объект. Когда счётчик становится равным нулю, объект удаляется.

```python
# Создаём список — счётчик ссылок = 1
x = [1, 2, 3]

# Создаём ещё одну ссылку — счётчик = 2
y = x

# Удаляем одну ссылку — счётчик = 1
del x

# Удаляем последнюю ссылку — счётчик = 0
del y
# Объект [1, 2, 3] автоматически удалён из памяти

# Можно посмотреть счётчик ссылок
import sys
data = [1, 2, 3]
print(sys.getrefcount(data))  # Покажет количество ссылок
```

**Проблема циклических ссылок:**

Когда объекты ссылаются друг на друга, подсчёт ссылок не работает. Python GC обнаруживает и удаляет такие циклы автоматически.

```python
# Циклическая ссылка
list1 = []
list2 = []
list1.append(list2)  # list1 → list2
list2.append(list1)  # list2 → list1

del list1, list2
# GC автоматически обнаружит и удалит этот цикл

# Принудительный запуск сборки мусора
import gc
gc.collect()  # Удаляет недостижимые объекты
```

---

### **Сильные ссылки**

**Сильная ссылка** — обычная ссылка на объект. Пока есть хотя бы одна сильная ссылка, объект остаётся в памяти.

```python
data = {'name': 'Alice'}
backup = data  # Две сильные ссылки на один объект

del data  # Удалили одну ссылку
print(backup)  # {'name': 'Alice'} — объект всё ещё существует

del backup  # Удалили последнюю ссылку
# Теперь объект удалён из памяти
```

---

### **Слабые ссылки**

**Слабая ссылка** — ссылка, которая **не препятствует удалению объекта**. Если остались только слабые ссылки, GC может удалить объект.

```python
import weakref

# Создаём объект
data = [1, 2, 3, 4, 5]

# Создаём слабую ссылку
weak_ref = weakref.ref(data)

# Доступ через слабую ссылку (вызываем как функцию)
print(weak_ref())  # [1, 2, 3, 4, 5]

# Удаляем сильную ссылку
del data

# Объект удалён, слабая ссылка больше не работает
print(weak_ref())  # None
```

**Зачем нужны слабые ссылки — пример с кешем:**

```python
import weakref

# Обычный словарь — объекты никогда не удаляются (утечка памяти!)
cache = {}
big_data = [i for i in range(1000000)]
cache['key'] = big_data
del big_data
# Объект всё ещё в памяти через cache!

# Словарь со слабыми ссылками — объекты удаляются автоматически
cache_weak = weakref.WeakValueDictionary()
big_data2 = [i for i in range(1000000)]
cache_weak['key'] = big_data2
print('key' in cache_weak)  # True

del big_data2
# Объект удалён, память освобождена
print('key' in cache_weak)  # False
```

**Ограничения:**

Слабые ссылки работают не со всеми типами. Нельзя создать слабую ссылку на числа и строки.

```python
import weakref

# Работает
weak1 = weakref.ref([1, 2, 3])  # OK
weak2 = weakref.ref({'a': 1})   # OK

# Не работает
# weak3 = weakref.ref(42)      # TypeError
# weak4 = weakref.ref("text")  # TypeError
```

---

**Ключевые моменты:**

- **GC автоматически удаляет неиспользуемые объекты** — не нужно освобождать память вручную
- **Подсчёт ссылок** — когда счётчик = 0, объект удаляется
- **Сильная ссылка** — обычная ссылка, объект живёт пока она есть
- **Слабая ссылка** — не мешает удалению объекта, возвращает `None` после удаления
- **Используйте слабые ссылки** для кешей и временных данных, чтобы избежать утечек памяти

----

# `11` (`*`) Функции 2
## `11.1` Встроенные функции `type()`, `sorted()`, `reversed()`, `isinstance()`, `callable()`, `hasattr()`, `hash()`
### **`type()` — определение типа объекта**

```python
print(type(42))           # <class 'int'>
print(type("hello"))      # <class 'str'>
print(type([1, 2, 3]))    # <class 'list'>

# Сравнение типов
x = 10
if type(x) == int:
    print("x — это число")
```

### **`sorted()` — сортировка (создаёт новый список)**

```python
numbers = [5, 2, 8, 1, 9]
print(sorted(numbers))                    # [1, 2, 5, 8, 9]
print(sorted(numbers, reverse=True))      # [9, 8, 5, 2, 1]

# Сортировка по ключу
students = [("Alice", 85), ("Bob", 92)]
print(sorted(students, key=lambda x: x[1]))  # [('Alice', 85), ('Bob', 92)]
```

### **`reversed()` — реверс последовательности (возвращает итератор)**

```python
numbers = [1, 2, 3, 4, 5]
print(list(reversed(numbers)))  # [5, 4, 3, 2, 1]

# Со строками
print(''.join(reversed("Python")))  # nohtyP
```

### **`isinstance()` — проверка типа объекта**

```python
x = 42
print(isinstance(x, int))              # True
print(isinstance(x, str))              # False
print(isinstance(x, (int, float)))     # True (проверка нескольких типов)

# Использование
def process(data):
    if isinstance(data, str):
        return data.upper()
    elif isinstance(data, int):
        return data * 2

print(process("hello"))  # HELLO
print(process(5))        # 10
```

### **`callable()` — проверка, можно ли вызвать объект**

```python
def greet():
    return "Hello"

print(callable(greet))     # True (функция)
print(callable(42))        # False (число)
print(callable([1, 2]))    # False (список)

# Безопасный вызов
callback = lambda x: x * 2
if callable(callback):
    print(callback(5))  # 10
```

### **`hasattr()` — проверка наличия атрибута**

```python
text = "hello"
print(hasattr(text, 'upper'))   # True
print(hasattr(text, 'append'))  # False

class Person:
    def __init__(self, name):
        self.name = name

person = Person("Alice")
print(hasattr(person, 'name'))  # True
print(hasattr(person, 'age'))   # False
```

### **`hash()` — получение хеш-значения**

```python
# Работает с неизменяемыми объектами
print(hash(42))         # 42
print(hash("hello"))    # Число
print(hash((1, 2, 3)))  # Число

# Изменяемые объекты не хешируемы
try:
    hash([1, 2, 3])  # TypeError
except TypeError:
    print("Списки не хешируемы")

# Проверка, можно ли использовать как ключ словаря
def can_be_key(obj):
    try:
        hash(obj)
        return True
    except TypeError:
        return False

print(can_be_key("text"))   # True
print(can_be_key([1, 2]))   # False
```

**Когда использовать:**
- `type()` — узнать тип (лучше использовать `isinstance()` для проверок)
- `sorted()` — создать новый отсортированный список
- `reversed()` — итерация в обратном порядке
- `isinstance()` — проверка типа (работает с наследованием)
- `callable()` — проверка перед вызовом функции
- `hasattr()` — безопасная проверка атрибутов
- `hash()` — проверка хешируемости объекта

## `11.2` Позиционные и именованные аргументы
При вызове функции можно передавать аргументы двумя способами: по позиции (порядок важен) или по имени (порядок не важен).

### **Позиционные аргументы**

Аргументы передаются в том порядке, в котором определены параметры функции.

```python
def greet(name, age):
    print(f"Привет, {name}! Тебе {age} лет.")

# Порядок важен!
greet("Alice", 25)  # Привет, Alice! Тебе 25 лет.
greet(25, "Alice")  # Привет, 25! Тебе Alice лет. (неправильно!)
```

### **Именованные аргументы (keyword arguments)**

Аргументы передаются с указанием имени параметра. Порядок не важен.

```python
def greet(name, age):
    print(f"Привет, {name}! Тебе {age} лет.")

# Порядок не важен
greet(name="Alice", age=25)  # Привет, Alice! Тебе 25 лет.
greet(age=25, name="Alice")  # Привет, Alice! Тебе 25 лет. (тот же результат)
```

### **Комбинирование**

Можно комбинировать оба способа, но позиционные должны идти **перед** именованными.

```python
def create_user(username, email, age, city):
    print(f"{username}, {email}, {age}, {city}")

# Сначала позиционные, потом именованные
create_user("alice", "alice@mail.com", age=25, city="Moscow")
# alice, alice@mail.com, 25, Moscow

# Ошибка: именованный аргумент перед позиционным
# create_user(username="alice", "alice@mail.com", 25, "Moscow")  # SyntaxError
```

### **Практические примеры**

```python
# Позиционные — короче, но менее понятно
def calculate(a, b, operation):
    if operation == "add":
        return a + b
    elif operation == "multiply":
        return a * b

result = calculate(5, 10, "add")  # Что значит "add"? Неочевидно
print(result)  # 15

# Именованные — длиннее, но понятнее
result = calculate(a=5, b=10, operation="add")  # Понятно, что делаем
print(result)  # 15

# Для функций с множеством параметров именованные аргументы улучшают читаемость
def send_email(to, subject, body, cc=None, bcc=None, attachments=None):
    print(f"To: {to}, Subject: {subject}")

# Непонятно
send_email("user@mail.com", "Hello", "Text", None, None, ["file.pdf"])

# Понятно
send_email(
    to="user@mail.com",
    subject="Hello",
    body="Text",
    attachments=["file.pdf"]
)
```

## `11.3` Аргументы по умолчанию
Параметры функции могут иметь значения по умолчанию. Если аргумент не передан, используется значение по умолчанию.

### **Базовое использование**

```python
def greet(name, greeting="Привет"):
    print(f"{greeting}, {name}!")

greet("Alice")              # Привет, Alice! (используется умолчание)
greet("Bob", "Здравствуй")  # Здравствуй, Bob! (передано значение)
```

### **Параметры по умолчанию должны идти после обязательных**

```python
# Правильно: обязательные → по умолчанию
def create_user(username, age=18, city="Moscow"):
    print(f"{username}, {age}, {city}")

create_user("Alice")                    # Alice, 18, Moscow
create_user("Bob", 25)                  # Bob, 25, Moscow
create_user("Charlie", city="SPb")      # Charlie, 18, SPb

# Неправильно: параметр по умолчанию перед обязательным
# def wrong(age=18, username):  # SyntaxError
#     pass
```

### **Множественные параметры по умолчанию**

```python
def configure_server(host="localhost", port=8080, debug=False):
    print(f"Server: {host}:{port}, Debug: {debug}")

configure_server()                              # Server: localhost:8080, Debug: False
configure_server("192.168.1.1")                 # Server: 192.168.1.1:8080, Debug: False
configure_server(port=3000)                     # Server: localhost:3000, Debug: False
configure_server("0.0.0.0", debug=True)         # Server: 0.0.0.0:8080, Debug: True
configure_server(debug=True, port=5000)         # Server: localhost:5000, Debug: True
```

### **ВАЖНО: изменяемые объекты как значения по умолчанию (частая ошибка!)**

```python
# ОПАСНО! Список создаётся ОДИН раз при определении функции
def add_item(item, items=[]):  
    items.append(item)
    return items

print(add_item(1))  # [1]
print(add_item(2))  # [1, 2] (Ожидали [2]!)
print(add_item(3))  # [1, 2, 3] (Ожидали [3]!)

# ПРАВИЛЬНО: используйте None
def add_item_correct(item, items=None):
    if items is None:
        items = []  # Создаём новый список каждый раз
    items.append(item)
    return items

print(add_item_correct(1))  # [1]
print(add_item_correct(2))  # [2]
print(add_item_correct(3))  # [3]
```

### **Практические примеры**

```python
# Функция для форматирования имени
def format_name(first, last, middle=None):
    if middle:
        return f"{first} {middle} {last}"
    return f"{first} {last}"

print(format_name("John", "Doe"))              # John Doe
print(format_name("John", "Doe", "Smith"))     # John Smith Doe

# Функция с настройками по умолчанию
def download_file(url, timeout=30, retries=3, verify_ssl=True):
    print(f"Скачиваю {url}")
    print(f"Timeout: {timeout}s, Retries: {retries}, SSL: {verify_ssl}")

download_file("https://example.com/file.zip")
# Скачиваю https://example.com/file.zip
# Timeout: 30s, Retries: 3, SSL: True

download_file("https://example.com/file.zip", timeout=60, verify_ssl=False)
# Скачиваю https://example.com/file.zip
# Timeout: 60s, Retries: 3, SSL: False

# Расчёт скидки
def calculate_price(base_price, discount=0, tax=0.2):
    price_after_discount = base_price * (1 - discount)
    final_price = price_after_discount * (1 + tax)
    return final_price

print(calculate_price(100))                # 120.0 (без скидки)
print(calculate_price(100, discount=0.1))  # 108.0 (со скидкой 10%)
print(calculate_price(100, 0.2, 0.15))     # 92.0 (скидка 20%, налог 15%)
```

**Ключевые правила:**
- **Позиционные аргументы** — передаются по порядку
- **Именованные аргументы** — передаются по имени, порядок не важен
- **Позиционные должны идти перед именованными** при вызове
- **Параметры по умолчанию должны идти после обязательных** при определении
- **НЕ используйте изменяемые объекты** (списки, словари) как значения по умолчанию — используйте `None`

## `11.4` Функции высшего порядка
`Функции высшего порядка (Higher-Order Functions)` — это функции, которые принимают другие функции как аргументы или возвращают функции как результат. В Python функции являются объектами первого класса, поэтому их можно передавать и возвращать как обычные переменные.

### **Функции как аргументы**

```python
def apply_operation(x, y, operation):
    """Применяет функцию operation к x и y"""
    return operation(x, y)

def add(a, b):
    return a + b

def multiply(a, b):
    return a * b

# Передаём функции как аргументы
print(apply_operation(5, 3, add))       # 8
print(apply_operation(5, 3, multiply))  # 15
```

### **Функции как возвращаемое значение**

```python
def create_multiplier(factor):
    """Возвращает функцию, которая умножает на factor"""
    def multiplier(x):
        return x * factor
    return multiplier

# Создаём разные функции-умножители
double = create_multiplier(2)
triple = create_multiplier(3)

print(double(5))   # 10
print(triple(5))   # 15
```

### **Практический пример**

```python
def process_list(numbers, transformer):
    """Применяет функцию transformer к каждому элементу"""
    result = []
    for num in numbers:
        result.append(transformer(num))
    return result

def square(x):
    return x ** 2

numbers = [1, 2, 3, 4, 5]
print(process_list(numbers, square))  # [1, 4, 9, 16, 25]
print(process_list(numbers, abs))     # [1, 2, 3, 4, 5]
```

## `11.5` `lambda` функции
`lambda` — это анонимная (безымянная) функция, которая определяется в одну строку. Используется для простых операций, где не нужно полноценное определение функции.

**Синтаксис:** `lambda аргументы: выражение`

### **Базовое использование**

```python
# Обычная функция
def square(x):
    return x ** 2

# То же самое через lambda
square_lambda = lambda x: x ** 2

print(square(5))         # 25
print(square_lambda(5))  # 25

# Lambda с несколькими аргументами
add = lambda a, b: a + b
print(add(3, 7))  # 10

# Lambda без аргументов
get_pi = lambda: 3.14159
print(get_pi())  # 3.14159
```

### **Lambda в функциях высшего порядка**

```python
# Сортировка по длине строки
words = ["apple", "pie", "banana", "kiwi"]
sorted_words = sorted(words, key=lambda w: len(w))
print(sorted_words)  # ['pie', 'kiwi', 'apple', 'banana']

# Сортировка кортежей по второму элементу
students = [("Alice", 85), ("Bob", 92), ("Charlie", 78)]
sorted_students = sorted(students, key=lambda x: x[1])
print(sorted_students)  # [('Charlie', 78), ('Alice', 85), ('Bob', 92)]

# Фильтрация чётных чисел
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
evens = list(filter(lambda x: x % 2 == 0, numbers))
print(evens)  # [2, 4, 6, 8, 10]
```

### **Ограничения lambda**

```python
# Lambda — только одно выражение, нельзя использовать:
# - несколько строк
# - операторы (if, for, while как операторы)
# - присваивания

# Можно: тернарный оператор
absolute = lambda x: x if x >= 0 else -x
print(absolute(-5))  # 5

# Нельзя: несколько строк
# lambda x: 
#     result = x * 2  # SyntaxError
#     return result
```

### **Когда использовать lambda**

```python
# Хорошо: короткие одноразовые функции
numbers = [1, 2, 3, 4, 5]
doubled = list(map(lambda x: x * 2, numbers))
print(doubled)  # [2, 4, 6, 8, 10]

# Плохо: сложная логика (лучше обычная функция)
# result = filter(lambda x: x > 0 and x < 100 and x % 2 == 0 and x % 3 != 0, numbers)

# Лучше:
def is_valid(x):
    return x > 0 and x < 100 and x % 2 == 0 and x % 3 != 0

result = filter(is_valid, numbers)
```

## `11.6` `map()`, `filter()`, `reduce()`. Кейсы их применения
### **`map()` — применение функции к каждому элементу**

```python
# Синтаксис: map(function, iterable)

numbers = [1, 2, 3, 4, 5]

# Возведение в квадрат
squared = list(map(lambda x: x ** 2, numbers))
print(squared)  # [1, 4, 9, 16, 25]

# Преобразование в строки
strings = list(map(str, numbers))
print(strings)  # ['1', '2', '3', '4', '5']

# Работа со строками
words = ["hello", "world", "python"]
uppercase = list(map(str.upper, words))
print(uppercase)  # ['HELLO', 'WORLD', 'PYTHON']

# map() с несколькими последовательностями
a = [1, 2, 3]
b = [10, 20, 30]
sums = list(map(lambda x, y: x + y, a, b))
print(sums)  # [11, 22, 33]
```

**Кейсы применения `map()`:**
- Преобразование типов данных
- Применение операций ко всем элементам
- Извлечение атрибутов из объектов

```python
# Практический пример: обработка цен
prices = [100, 200, 150, 300]
with_tax = list(map(lambda p: p * 1.2, prices))
print(with_tax)  # [120.0, 240.0, 180.0, 360.0]

# Извлечение имён
users = [
    {"name": "Alice", "age": 25},
    {"name": "Bob", "age": 30}
]
names = list(map(lambda u: u["name"], users))
print(names)  # ['Alice', 'Bob']
```

### **`filter()` — фильтрация элементов**

```python
# Синтаксис: filter(function, iterable)
# Оставляет только элементы, для которых function вернула True

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Только чётные
evens = list(filter(lambda x: x % 2 == 0, numbers))
print(evens)  # [2, 4, 6, 8, 10]

# Только положительные
values = [-5, 3, -2, 8, 0, -1, 7]
positives = list(filter(lambda x: x > 0, values))
print(positives)  # [3, 8, 7]

# Фильтрация строк
words = ["apple", "banana", "kiwi", "strawberry"]
short = list(filter(lambda w: len(w) <= 5, words))
print(short)  # ['apple', 'kiwi']
```

**Кейсы применения `filter()`:**
- Отбор элементов по условию
- Удаление невалидных данных
- Поиск подходящих элементов

```python
# Практический пример: валидация email
emails = ["user@mail.com", "invalid", "test@test.org", "bad@"]
valid = list(filter(lambda e: '@' in e and '.' in e.split('@')[-1], emails))
print(valid)  # ['user@mail.com', 'test@test.org']

# Фильтрация взрослых пользователей
users = [
    {"name": "Alice", "age": 25},
    {"name": "Bob", "age": 17},
    {"name": "Charlie", "age": 30}
]
adults = list(filter(lambda u: u["age"] >= 18, users))
print(adults)  # [{'name': 'Alice', 'age': 25}, {'name': 'Charlie', 'age': 30}]
```

### **`reduce()` — свёртка последовательности в одно значение**

```python
from functools import reduce

# Синтаксис: reduce(function, iterable, initial_value)
# Применяет function последовательно: result = f(f(f(a, b), c), d)

numbers = [1, 2, 3, 4, 5]

# Сумма всех элементов
total = reduce(lambda acc, x: acc + x, numbers)
print(total)  # 15

# То же самое с начальным значением
total = reduce(lambda acc, x: acc + x, numbers, 0)
print(total)  # 15

# Произведение всех элементов
product = reduce(lambda acc, x: acc * x, numbers)
print(product)  # 120

# Поиск максимума
maximum = reduce(lambda acc, x: acc if acc > x else x, numbers)
print(maximum)  # 5
```

**Кейсы применения `reduce()`:**
- Вычисление общей суммы, произведения
- Поиск минимума/максимума
- Объединение данных в одну структуру

```python
from functools import reduce

# Практический пример: подсчёт общей корзины
cart = [
    {"item": "Apple", "price": 50},
    {"item": "Banana", "price": 30},
    {"item": "Orange", "price": 40}
]
total_price = reduce(lambda acc, item: acc + item["price"], cart, 0)
print(total_price)  # 120

# Слияние словарей
dicts = [{"a": 1}, {"b": 2}, {"c": 3}]
merged = reduce(lambda acc, d: {**acc, **d}, dicts, {})
print(merged)  # {'a': 1, 'b': 2, 'c': 3}

# Построение строки
words = ["Hello", "World", "Python"]
sentence = reduce(lambda acc, word: acc + " " + word, words)
print(sentence)  # Hello World Python
```

### **Комбинирование map, filter, reduce**

```python
from functools import reduce

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Задача: сумма квадратов чётных чисел
result = reduce(
    lambda acc, x: acc + x,
    map(lambda x: x ** 2,
        filter(lambda x: x % 2 == 0, numbers)
    ),
    0
)
print(result)  # 220 (2²+4²+6²+8²+10² = 4+16+36+64+100)

# Более читаемый вариант
evens = filter(lambda x: x % 2 == 0, numbers)
squared = map(lambda x: x ** 2, evens)
total = reduce(lambda acc, x: acc + x, squared, 0)
print(total)  # 220
```

## `11.7` `any()`, `all()`, `zip()`, `enumerate()`  
### **`any()` — проверка наличия хотя бы одного `True`**

```python
# Возвращает True, если хотя бы один элемент True

# С булевыми значениями
print(any([False, False, True]))   # True
print(any([False, False, False]))  # False
print(any([True, True, True]))     # True

# С числами (0 = False, остальное = True)
print(any([0, 0, 0]))      # False
print(any([0, 0, 5]))      # True
print(any([1, 2, 3]))      # True

# С пустыми коллекциями
print(any([]))             # False
print(any([0]))            # False

# Практическое использование
numbers = [2, 4, 6, 8, 9]
has_odd = any(n % 2 != 0 for n in numbers)
print(has_odd)  # True (есть 9)

# Проверка наличия слова в списке
words = ["apple", "banana", "cherry"]
has_long_word = any(len(word) > 6 for word in words)
print(has_long_word)  # False
```

### **`all()` — проверка, что все элементы `True`**

```python
# Возвращает True, если ВСЕ элементы True

# С булевыми значениями
print(all([True, True, True]))    # True
print(all([True, False, True]))   # False
print(all([False, False, False])) # False

# С числами
print(all([1, 2, 3]))      # True (все ненулевые)
print(all([1, 0, 3]))      # False (есть 0)

# С пустыми коллекциями
print(all([]))             # True (пустая последовательность)

# Практическое использование
numbers = [2, 4, 6, 8, 10]
all_even = all(n % 2 == 0 for n in numbers)
print(all_even)  # True

# Валидация данных
ages = [18, 25, 30, 17]
all_adults = all(age >= 18 for age in ages)
print(all_adults)  # False (есть 17)

# Проверка, что все строки не пустые
strings = ["hello", "world", "python"]
all_non_empty = all(len(s) > 0 for s in strings)
print(all_non_empty)  # True
```

### **`zip()` — объединение нескольких последовательностей**

```python
# Объединяет элементы из нескольких последовательностей в кортежи

# Базовое использование
names = ["Alice", "Bob", "Charlie"]
ages = [25, 30, 35]

for name, age in zip(names, ages):
    print(f"{name} — {age} лет")
# Alice — 25 лет
# Bob — 30 лет
# Charlie — 35 лет

# Преобразование в список кортежей
pairs = list(zip(names, ages))
print(pairs)  # [('Alice', 25), ('Bob', 30), ('Charlie', 35)]

# Три и более последовательности
cities = ["Moscow", "SPb", "Kazan"]
combined = list(zip(names, ages, cities))
print(combined)  # [('Alice', 25, 'Moscow'), ('Bob', 30, 'SPb'), ('Charlie', 35, 'Kazan')]

# Разная длина — обрезается по минимальной
a = [1, 2, 3, 4, 5]
b = ['a', 'b', 'c']
result = list(zip(a, b))
print(result)  # [(1, 'a'), (2, 'b'), (3, 'c')]
```

**Практические примеры `zip()`:**

```python
# Создание словаря
keys = ["name", "age", "city"]
values = ["Alice", 25, "Moscow"]
user = dict(zip(keys, values))
print(user)  # {'name': 'Alice', 'age': 25, 'city': 'Moscow'}

# Распаковка (unzip)
pairs = [(1, 'a'), (2, 'b'), (3, 'c')]
numbers, letters = zip(*pairs)
print(numbers)  # (1, 2, 3)
print(letters)  # ('a', 'b', 'c')

# Параллельная обработка списков
prices = [100, 200, 150]
quantities = [2, 1, 3]
totals = [p * q for p, q in zip(prices, quantities)]
print(totals)  # [200, 200, 450]
```

### **`enumerate()` — получение индекса и элемента**

```python
# Возвращает кортежи (индекс, элемент)

# Базовое использование
fruits = ["apple", "banana", "cherry"]

for index, fruit in enumerate(fruits):
    print(f"{index}: {fruit}")
# 0: apple
# 1: banana
# 2: cherry

# Преобразование в список
indexed = list(enumerate(fruits))
print(indexed)  # [(0, 'apple'), (1, 'banana'), (2, 'cherry')]

# Начать с другого индекса
for index, fruit in enumerate(fruits, start=1):
    print(f"{index}. {fruit}")
# 1. apple
# 2. banana
# 3. cherry
```

**Практические примеры `enumerate()`:**

```python
# Поиск индекса элемента
words = ["hello", "world", "python"]
for i, word in enumerate(words):
    if word == "python":
        print(f"Найдено на позиции {i}")  # Найдено на позиции 2

# Изменение элементов по индексу
numbers = [10, 20, 30, 40]
for i, num in enumerate(numbers):
    numbers[i] = num * 2
print(numbers)  # [20, 40, 60, 80]

# Нумерованный список
tasks = ["Купить молоко", "Написать код", "Почитать книгу"]
for i, task in enumerate(tasks, start=1):
    print(f"{i}. {task}")
# 1. Купить молоко
# 2. Написать код
# 3. Почитать книгу

# Создание словаря с индексами
items = ["apple", "banana", "cherry"]
indexed_dict = {i: item for i, item in enumerate(items)}
print(indexed_dict)  # {0: 'apple', 1: 'banana', 2: 'cherry'}
```

**Когда использовать:**
- `any()` — проверка существования хотя бы одного подходящего элемента
- `all()` — проверка, что все элементы удовлетворяют условию
- `zip()` — параллельная обработка нескольких списков, создание пар/троек
- `enumerate()` — когда нужен и индекс, и значение элемента


# `12` Работа с файлами
### `12.0.1` Потоковый ввод и вывод данных  

## `12.1` TXT
[Базовая работа с файлами](https://www.youtube.com/watch?v=t-xQAhLNYSs)

### `12.1.1` (`*`) Что такое контекстный менеджер?
[Контекстный менеджер](https://www.youtube.com/watch?v=ycVlsU_c4Mg)

`Контекстный менеджер` — это механизм в Python, который автоматически выполняет определённые действия до и после блока кода. Используется с ключевым словом `with` и гарантирует, что ресурсы будут корректно освобождены даже при возникновении ошибок.

**Зачем нужен:**
- Автоматически закрывает файлы
- Освобождает ресурсы (соединения, блокировки)
- Выполняет cleanup-код даже при ошибках
- Делает код короче и безопаснее

**Без контекстного менеджера (плохо):**

```python
# Открываем файл вручную
file = open('data.txt', 'r')

try:
    content = file.read()
    print(content)
finally:
    file.close()  # ОБЯЗАТЕЛЬНО нужно закрыть!
    # Если забыть — утечка ресурсов

# Проблемы:
# 1. Легко забыть закрыть файл
# 2. Много кода для простой операции
# 3. Нужно помнить про try-finally
```

**С контекстным менеджером (хорошо):**

```python
# Контекстный менеджер автоматически закроет файл
with open('data.txt', 'r') as file:
    content = file.read()
    print(content)
# Файл автоматически закрыт здесь, даже если была ошибка!

# Преимущества:
# 1. Короче и понятнее
# 2. Файл всегда закроется
# 3. Работает даже при ошибках
```

**Как это работает:**

```python
# 1. При входе в блок with — открывается файл
# 2. Выполняется код внутри блока
# 3. При выходе из блока — файл закрывается автоматически

with open('data.txt', 'r') as file:  # ← Открытие (вход)
    content = file.read()             # ← Работа с файлом
    print(content)
# ← Автоматическое закрытие (выход)

# Даже если произошла ошибка
with open('data.txt', 'r') as file:
    content = file.read()
    raise ValueError("Ошибка!")  # Ошибка!
    # Файл всё равно будет закрыт
```

**Практические примеры:**

**Работа с файлами:**

```python
# Чтение файла
with open('input.txt', 'r', encoding='utf-8') as f:
    data = f.read()
    print(data)
# Файл закрыт

# Запись в файл
with open('output.txt', 'w', encoding='utf-8') as f:
    f.write("Hello, World!")
# Файл закрыт и сохранён

# Работа с несколькими файлами
with open('input.txt', 'r') as f_in, open('output.txt', 'w') as f_out:
    content = f_in.read()
    f_out.write(content.upper())
# Оба файла закрыты
```

**Сравнение с ручным управлением:**

```python
# БЕЗ контекстного менеджера — опасно!
f = open('data.txt', 'w')
f.write("some data")
# Если программа упадёт здесь, файл не закроется!
# Данные могут не сохраниться!
f.close()

# С контекстным менеджером — безопасно
with open('data.txt', 'w') as f:
    f.write("some data")
    # Даже если ошибка здесь, файл сохранится и закроется
# Файл гарантированно закрыт и сохранён
```

**Что происходит за кулисами:**

```python
# Когда мы пишем:
with open('file.txt', 'r') as f:
    content = f.read()

# Python делает примерно это:
f = open('file.txt', 'r')
try:
    content = f.read()
finally:
    f.close()  # Всегда выполнится

# Но контекстный менеджер делает это автоматически!
```

**Создание простого контекстного менеджера:**

```python
from contextlib import contextmanager

@contextmanager
def timer():
    """Измеряет время выполнения кода"""
    import time
    start = time.time()
    print("Таймер запущен")
    
    try:
        yield  # Здесь выполняется код внутри with
    finally:
        elapsed = time.time() - start
        print(f"Время выполнения: {elapsed:.2f} сек")

# Использование
with timer():
    # Код, время выполнения которого измеряем
    total = sum(range(1000000))
    print(f"Сумма: {total}")

# Вывод:
# Таймер запущен
# Сумма: 499999500000
# Время выполнения: 0.05 сек
```

**Другие примеры контекстных менеджеров:**

```python
# Временное изменение директории
import os
from contextlib import contextmanager

@contextmanager
def change_dir(path):
    """Временно меняет директорию"""
    original = os.getcwd()
    os.chdir(path)
    print(f"Перешли в {path}")
    
    try:
        yield
    finally:
        os.chdir(original)
        print(f"Вернулись в {original}")

# Использование
print(f"Начальная директория: {os.getcwd()}")
with change_dir('/tmp'):
    print(f"Внутри with: {os.getcwd()}")
print(f"После with: {os.getcwd()}")

# Вывод:
# Начальная директория: /home/user
# Перешли в /tmp
# Внутри with: /tmp
# Вернулись в /home/user
# После with: /home/user
```

**Ключевые моменты:**
- **`with`** — ключевое слово для использования контекстного менеджера
- **Автоматическое освобождение ресурсов** — не нужно вручную закрывать файлы
- **Безопасность** — ресурсы освобождаются даже при ошибках
- **Читаемость** — код короче и понятнее
- **Основное применение** — работа с файлами, но можно использовать для любых ресурсов

**Когда использовать:**
- Работа с файлами (всегда!)
- Работа с БД соединениями
- Блокировки в многопоточности
- Временные изменения состояния
- Любые ресурсы, требующие cleanup

### `12.1.2` Какие есть функции и методы для работы с TXT в Python?  

## `12.2` (`*`) JSON
[Видео про JSON](https://www.youtube.com/watch?v=-51jxlQaxyA)

### `12.2.1` Что такое JSON? Для чего он нужен?
`JSON (JavaScript Object Notation)` — это текстовый формат для хранения и передачи структурированных данных. Он легко читается человеком и компьютером, поэтому широко используется для обмена данными между приложениями.

**Основные характеристики:**
- Текстовый формат (строка)
- Язык-независимый (работает везде)
- Простая и понятная структура
- Поддерживает вложенность

**Пример JSON:**

```json
{
  "name": "Alice",
  "age": 25,
  "city": "Moscow",
  "skills": ["Python", "JavaScript", "SQL"],
  "active": true,
  "address": {
    "street": "Main St",
    "building": 10
  }
}
```

**Для чего нужен JSON:**
- **API и веб-сервисы** — обмен данными между клиентом и сервером
- **Конфигурационные файлы** — хранение настроек приложений
- **Хранение данных** — сохранение структурированной информации
- **Логирование** — структурированные логи
- **Передача данных** — между разными языками программирования

**Где используется:**
```python
# REST API
# GET /api/users/123
# Response: {"id": 123, "name": "Alice", "email": "alice@mail.com"}

# Конфигурация
# config.json: {"debug": true, "port": 8080, "database": "localhost"}

# Сохранение данных
# data.json: [{"product": "Laptop", "price": 1000}, {"product": "Mouse", "price": 20}]
```

### `12.2.2` Какие есть функции и методы для работы с JSON в Python?
Python имеет встроенный модуль `json` для работы с JSON-данными.

**Основные функции:**
**`json.dumps()` — сериализация Python → JSON (строка)**

```python
import json

# Python объект → JSON строка
data = {
    "name": "Alice",
    "age": 25,
    "skills": ["Python", "SQL"]
}

json_string = json.dumps(data)
print(json_string)  # {"name": "Alice", "age": 25, "skills": ["Python", "SQL"]}
print(type(json_string))  # <class 'str'>

# С форматированием (pretty print)
json_formatted = json.dumps(data, indent=4)
print(json_formatted)
# {
#     "name": "Alice",
#     "age": 25,
#     "skills": [
#         "Python",
#         "SQL"
#     ]
# }

# Сортировка ключей
json_sorted = json.dumps(data, indent=2, sort_keys=True)
print(json_sorted)
# {
#   "age": 25,
#   "name": "Alice",
#   "skills": [
#     "Python",
#     "SQL"
#   ]
# }
```

**`json.loads()` — десериализация JSON (строка) → Python**

```python
import json

# JSON строка → Python объект
json_string = '{"name": "Bob", "age": 30, "active": true}'
data = json.loads(json_string)

print(data)  # {'name': 'Bob', 'age': 30, 'active': True}
print(type(data))  # <class 'dict'>
print(data["name"])  # Bob

# С вложенными структурами
json_complex = '''
{
    "user": "Alice",
    "scores": [85, 90, 95],
    "settings": {
        "theme": "dark",
        "notifications": true
    }
}
'''
parsed = json.loads(json_complex)
print(parsed["scores"])  # [85, 90, 95]
print(parsed["settings"]["theme"])  # dark
```

**`json.dump()` — запись в файл**

```python
import json

# Запись Python объекта в JSON файл
data = {
    "products": [
        {"name": "Laptop", "price": 1000},
        {"name": "Mouse", "price": 20}
    ]
}

# Сохранение в файл
with open('data.json', 'w', encoding='utf-8') as file:
    json.dump(data, file, indent=4, ensure_ascii=False)

# Файл data.json:
# {
#     "products": [
#         {
#             "name": "Laptop",
#             "price": 1000
#         },
#         {
#             "name": "Mouse",
#             "price": 20
#         }
#     ]
# }
```

**`json.load()` — чтение из файла**

```python
import json

# Чтение JSON из файла
with open('data.json', 'r', encoding='utf-8') as file:
    data = json.load(file)

print(data)  # {'products': [{'name': 'Laptop', 'price': 1000}, ...]}
print(data["products"][0]["name"])  # Laptop
```

**Параметры функций:**

```python
import json

data = {"name": "Анна", "city": "Москва"}

# indent — отступы для читаемости
json.dumps(data, indent=2)

# sort_keys — сортировка ключей
json.dumps(data, sort_keys=True)

# ensure_ascii — кириллица и спецсимволы
json.dumps(data, ensure_ascii=False)  # {"name": "Анна", ...}
json.dumps(data, ensure_ascii=True)   # {"name": "\u0410\u043d\u043d\u0430", ...}

# separators — разделители
json.dumps(data, separators=(',', ':'))  # Компактный вывод без пробелов
# {"name":"Анна","city":"Москва"}
```

**Обработка ошибок:**

```python
import json

# Невалидный JSON
invalid_json = '{"name": "Alice", "age": 25'  # Отсутствует }

try:
    data = json.loads(invalid_json)
except json.JSONDecodeError as e:
    print(f"Ошибка парсинга JSON: {e}")
    # Ошибка парсинга JSON: Expecting ',' delimiter: line 1 column 29 (char 28)

# Проверка валидности JSON
def is_valid_json(json_string):
    try:
        json.loads(json_string)
        return True
    except json.JSONDecodeError:
        return False

print(is_valid_json('{"name": "Alice"}'))  # True
print(is_valid_json('{"name": Alice}'))    # False (нет кавычек)
```

### `12.2.3` Как происходит конвертация типов данных при сериализации?
При преобразовании Python ↔ JSON типы данных автоматически конвертируются.

**Таблица соответствия типов:**

| Python | JSON | Обратно в Python |
|--------|------|------------------|
| `dict` | `object` | `dict` |
| `list`, `tuple` | `array` | `list` |
| `str` | `string` | `str` |
| `int`, `float` | `number` | `int`, `float` |
| `True` | `true` | `True` |
| `False` | `false` | `False` |
| `None` | `null` | `None` |

**Примеры конвертации:**

```python
import json

# Python → JSON
data = {
    "name": "Alice",           # str → string
    "age": 25,                 # int → number
    "height": 1.65,            # float → number
    "active": True,            # bool → true/false
    "address": None,           # None → null
    "skills": ["Python", "SQL"], # list → array
    "scores": (85, 90, 95),    # tuple → array
    "metadata": {"key": "value"} # dict → object
}

json_str = json.dumps(data, indent=2)
print(json_str)
# {
#   "name": "Alice",
#   "age": 25,
#   "height": 1.65,
#   "active": true,
#   "address": null,
#   "skills": ["Python", "SQL"],
#   "scores": [85, 90, 95],
#   "metadata": {"key": "value"}
# }

# JSON → Python
parsed = json.loads(json_str)
print(type(parsed["skills"]))   # <class 'list'> (был list)
print(type(parsed["scores"]))   # <class 'list'> (был tuple, стал list!)
print(parsed["address"])        # None (был null)
print(parsed["active"])         # True (был true)
```

**Важные моменты конвертации:**
**1. Кортежи становятся списками**

```python
import json

data = {"numbers": (1, 2, 3)}  # tuple
json_str = json.dumps(data)
parsed = json.loads(json_str)

print(type(parsed["numbers"]))  # <class 'list'> (потерялся тип tuple!)
print(parsed["numbers"])        # [1, 2, 3]
```

 **2. Множества не поддерживаются**

```python
import json

data = {"tags": {"python", "coding"}}  # set

try:
    json.dumps(data)
except TypeError as e:
    print(f"Ошибка: {e}")
    # Ошибка: Object of type set is not JSON serializable

# Решение: конвертировать в list
data_fixed = {"tags": list(data["tags"])}
print(json.dumps(data_fixed))  # {"tags": ["python", "coding"]}
```

**3. Пользовательские объекты не поддерживаются**

```python
import json

class User:
    def __init__(self, name, age):
        self.name = name
        self.age = age

user = User("Alice", 25)

try:
    json.dumps(user)
except TypeError as e:
    print(f"Ошибка: {e}")
    # Ошибка: Object of type User is not JSON serializable

# Решение 1: конвертировать в словарь вручную
user_dict = {"name": user.name, "age": user.age}
print(json.dumps(user_dict))  # {"name": "Alice", "age": 25}

# Решение 2: использовать __dict__
print(json.dumps(user.__dict__))  # {"name": "Alice", "age": 25}

# Решение 3: кастомный encoder
class UserEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, User):
            return {"name": obj.name, "age": obj.age}
        return super().default(obj)

print(json.dumps(user, cls=UserEncoder))  # {"name": "Alice", "age": 25}
```

**4. Специальные числа**

```python
import json

# Infinity и NaN не поддерживаются по умолчанию
data = {"value": float('inf')}

try:
    json.dumps(data)
except ValueError as e:
    print(f"Ошибка: {e}")
    # Ошибка: Out of range float values are not JSON compliant

# Разрешить специальные значения
json_str = json.dumps(data, allow_nan=True)
print(json_str)  # {"value": Infinity}
```

**Практические примеры:**

```python
import json

# Работа с API
response_data = {
    "status": "success",
    "users": [
        {"id": 1, "name": "Alice", "active": True},
        {"id": 2, "name": "Bob", "active": False}
    ],
    "total": 2
}

# Отправка данных
json_response = json.dumps(response_data)
print(json_response)

# Получение данных
parsed_response = json.loads(json_response)
for user in parsed_response["users"]:
    if user["active"]:
        print(f"Активный пользователь: {user['name']}")

# Сохранение конфигурации
config = {
    "debug": True,
    "port": 8080,
    "database": {
        "host": "localhost",
        "name": "mydb"
    }
}

with open('config.json', 'w') as f:
    json.dump(config, f, indent=4)

# Чтение конфигурации
with open('config.json', 'r') as f:
    loaded_config = json.load(f)
    print(f"Порт: {loaded_config['port']}")
    print(f"БД: {loaded_config['database']['host']}")
```

**Ключевые моменты:**
- `json.dumps()` / `json.loads()` — работа со строками
- `json.dump()` / `json.load()` — работа с файлами
- JSON поддерживает: dict, list, str, int, float, bool, None
- JSON НЕ поддерживает: set, tuple (конвертируется в list), пользовательские объекты
- Используйте `indent` для читаемости, `ensure_ascii=False` для кириллицы


## `12.3` CSV
[Видео про CSV](https://www.youtube.com/watch?v=q5uM4VKywbA)

### `12.3.1` Что такое CSV? Для чего он нужен?  
### `12.3.2` Какие есть функции и методы для работы с CSV в Python?  

----

# `13` Работа с датой и временем
## `13.1` Посмотреть модуль `datetime` и различные типы данных в нем: `date`, `time`, etc.  
## `13.2` На дате можно изучить `repr()` и посмотреть разницу с `str()`  
## `13.3` `strftime()`, `strptime()`, `isoformat()`, `fromisoformat()`, `combine()`, `now()`  
## `13.4` Что такое начало эпохи?  
## `13.5` Что такое `timedelta` и зачем оно нужно?  
## `13.6` Посмотреть, что такое временные зоны и как с ними работать  

----

# `14` (`*`) Обработка исключений
[Видео про исключения](https://youtu.be/89wpfOAgrCk?si=b7ERcnzmtdMD_MuR)

## `14.1` Типы ошибок. Основные исключения в Python и их иерархия
### **Типы ошибок**
В Python существует три основных типа ошибок:

**1. Синтаксические ошибки (Syntax Errors)**
- Возникают при нарушении синтаксиса языка
- Код не запустится до исправления

```python
# SyntaxError
if True
    print("Hello")  # Забыли двоеточие
```

**2. Ошибки выполнения (Runtime Errors / Exceptions)**
- Возникают во время выполнения программы
- Синтаксически корректный код, но что-то пошло не так

```python
# ZeroDivisionError
result = 10 / 0

# FileNotFoundError
with open("несуществующий_файл.txt") as f:
    data = f.read()
```

**3. Логические ошибки (Logical Errors)**
- Программа работает без ошибок, но результат неверный
- Самые сложные для обнаружения

```python
# Хотели найти среднее, но забыли разделить
def average(numbers):
    return sum(numbers)  # Должно быть sum(numbers) / len(numbers)
```

### **Иерархия исключений в Python**
Все исключения в Python наследуются от базового класса `BaseException`:

```
BaseException
├── SystemExit
├── KeyboardInterrupt
├── GeneratorExit
└── Exception
    ├── StopIteration
    ├── ArithmeticError
    │   ├── ZeroDivisionError
    │   ├── OverflowError
    │   └── FloatingPointError
    ├── AttributeError
    ├── EOFError
    ├── ImportError
    │   └── ModuleNotFoundError
    ├── LookupError
    │   ├── IndexError
    │   └── KeyError
    ├── NameError
    ├── OSError
    │   ├── FileNotFoundError
    │   ├── PermissionError
    │   └── ConnectionError
    ├── RuntimeError
    │   └── RecursionError
    ├── TypeError
    ├── ValueError
    └── ...
```

### **Основные исключения**
| Исключение | Описание | Пример |
|------------|----------|---------|
| `Exception` | Базовый класс для большинства исключений | - |
| `ValueError` | Неправильное значение | `int("abc")` |
| `TypeError` | Неправильный тип данных | `"5" + 5` |
| `KeyError` | Ключ не найден в словаре | `d = {}; d["key"]` |
| `IndexError` | Индекс вне диапазона | `[1, 2][5]` |
| `AttributeError` | Атрибут не найден | `"text".nonexistent()` |
| `FileNotFoundError` | Файл не найден | `open("nope.txt")` |
| `ZeroDivisionError` | Деление на ноль | `1 / 0` |
| `ImportError` | Ошибка импорта | `import fake_module` |
| `NameError` | Переменная не определена | `print(x)` |

**Примеры:**
```python
# ValueError
age = int("двадцать")  # ValueError: invalid literal for int()

# TypeError
result = "Hello" + 5  # TypeError: can only concatenate str to str

# KeyError
user = {"name": "Alice"}
print(user["age"])  # KeyError: 'age'

# IndexError
numbers = [1, 2, 3]
print(numbers[10])  # IndexError: list index out of range

# AttributeError
text = "Python"
text.append("!")  # AttributeError: 'str' object has no attribute 'append'

# ZeroDivisionError
result = 100 / 0  # ZeroDivisionError: division by zero
```

## `14.2` `try-except`
Конструкция `try-except` позволяет перехватывать и обрабатывать исключения, чтобы программа не завершалась аварийно.

**Синтаксис:**
```python
try:
    # Код, который может вызвать ошибку
    risky_code()
except ExceptionType:
    # Код, который выполнится при ошибке
    handle_error()
```

### **Базовое использование**
**Пример 1: Обработка одного исключения**

```python
try:
    number = int(input("Введите число: "))
    result = 100 / number
    print(f"Результат: {result}")
except ZeroDivisionError:
    print("Ошибка: нельзя делить на ноль!")

# Ввод: 0
# Вывод: Ошибка: нельзя делить на ноль!
```

**Пример 2: Обработка нескольких исключений**

```python
try:
    number = int(input("Введите число: "))
    result = 100 / number
    print(f"Результат: {result}")
except ZeroDivisionError:
    print("Ошибка: деление на ноль!")
except ValueError:
    print("Ошибка: введите корректное число!")

# Ввод: "abc"
# Вывод: Ошибка: введите корректное число!
```

**Пример 3: Несколько исключений в одном блоке**

```python
try:
    data = {"name": "Alice"}
    print(data["age"])
except (KeyError, IndexError, TypeError) as e:
    print(f"Ошибка доступа к данным: {e}")

# Вывод: Ошибка доступа к данным: 'age'
```

### **Получение информации об ошибке**

```python
try:
    result = 10 / 0
except ZeroDivisionError as error:
    print(f"Произошла ошибка: {error}")
    print(f"Тип ошибки: {type(error).__name__}")

# Вывод:
# Произошла ошибка: division by zero
# Тип ошибки: ZeroDivisionError
```

### **Перехват всех исключений**
**⚠️ Не рекомендуется использовать без крайней необходимости!**

```python
try:
    risky_operation()
except Exception as e:
    print(f"Что-то пошло не так: {e}")

# Лучше ловить конкретные исключения
```

**Почему это плохо:**
- Скрывает неожиданные ошибки
- Усложняет отладку
- Может перехватить системные исключения

### **Практический пример: безопасное чтение файла**

```python
def read_file(filename):
    try:
        with open(filename, 'r', encoding='utf-8') as f:
            return f.read()
    except FileNotFoundError:
        print(f"Файл '{filename}' не найден")
        return None
    except PermissionError:
        print(f"Нет прав для чтения файла '{filename}'")
        return None
    except Exception as e:
        print(f"Неожиданная ошибка: {e}")
        return None

content = read_file("data.txt")
if content:
    print(content)
```

## `14.3` `else` & `finally` в `try-except`
### **Блок `else`**
Выполняется **только если** в блоке `try` не возникло исключений.

**Синтаксис:**
```python
try:
    # Код, который может вызвать ошибку
    risky_code()
except ExceptionType:
    # Обработка ошибки
    handle_error()
else:
    # Выполняется, если ошибок не было
    success_code()
```

**Пример:**
```python
try:
    number = int(input("Введите число: "))
    result = 100 / number
except (ValueError, ZeroDivisionError) as e:
    print(f"Ошибка: {e}")
else:
    print(f"Успешно! Результат: {result}")

# Ввод: 5
# Вывод: Успешно! Результат: 20.0

# Ввод: 0
# Вывод: Ошибка: division by zero
```

### **Блок `finally`**
Выполняется **всегда**, независимо от того, была ошибка или нет. Используется для очистки ресурсов (закрытие файлов, соединений и т.д.).

**Синтаксис:**
```python
try:
    risky_code()
except ExceptionType:
    handle_error()
finally:
    # Выполняется ВСЕГДА
    cleanup()
```

**Пример 1: Гарантированное закрытие файла**

```python
file = None
try:
    file = open("data.txt", "r")
    data = file.read()
    print(data)
except FileNotFoundError:
    print("Файл не найден")
finally:
    if file:
        file.close()
        print("Файл закрыт")

# Файл будет закрыт в любом случае
```

**Пример 2: Логирование попыток**

```python
def divide(a, b):
    try:
        result = a / b
    except ZeroDivisionError:
        print("Ошибка: деление на ноль")
        return None
    else:
        print(f"Деление успешно: {result}")
        return result
    finally:
        print("Операция завершена")

divide(10, 2)
# Вывод:
# Деление успешно: 5.0
# Операция завершена

divide(10, 0)
# Вывод:
# Ошибка: деление на ноль
# Операция завершена
```

### **Полная структура `try-except-else-finally`**
```python
try:
    # Основной код
    file = open("data.txt", "r")
    data = file.read()
    number = int(data)
except FileNotFoundError:
    # Если файл не найден
    print("Файл не существует")
except ValueError:
    # Если содержимое не число
    print("Файл содержит не число")
else:
    # Если ошибок не было
    print(f"Число успешно прочитано: {number}")
finally:
    # Выполняется всегда
    print("Попытка чтения завершена")
    if 'file' in locals() and file:
        file.close()
```

**Порядок выполнения:**
1. `try` — выполняется основной код
2. `except` — если возникла ошибка
3. `else` — если ошибок не было
4. `finally` — выполняется всегда в конце

## `14.4` Оператор `raise`
Оператор `raise` используется для **явного вызова исключения**.

**Синтаксис:**
```python
raise ExceptionType("Сообщение об ошибке")
```

### **Базовое использование**
**Пример 1: Вызов стандартного исключения**

```python
def set_age(age):
    if age < 0:
        raise ValueError("Возраст не может быть отрицательным")
    if age > 150:
        raise ValueError("Возраст слишком большой")
    print(f"Возраст установлен: {age}")

set_age(25)   # Возраст установлен: 25
set_age(-5)   # ValueError: Возраст не может быть отрицательным
```

**Пример 2: Проверка типов**

```python
def calculate_discount(price, discount):
    if not isinstance(price, (int, float)):
        raise TypeError("Цена должна быть числом")
    if not isinstance(discount, (int, float)):
        raise TypeError("Скидка должна быть числом")
    if discount < 0 or discount > 100:
        raise ValueError("Скидка должна быть от 0 до 100")
    
    return price * (1 - discount / 100)

print(calculate_discount(1000, 20))  # 800.0
print(calculate_discount("1000", 20))  # TypeError: Цена должна быть числом
```

### **Повторный вызов исключения**
Можно перехватить исключение, обработать его и вызвать снова:

```python
def process_data(data):
    try:
        result = int(data) / 0
    except ZeroDivisionError as e:
        print("Логирование: произошла ошибка деления на ноль")
        raise  # Повторно вызываем то же исключение

try:
    process_data("10")
except ZeroDivisionError:
    print("Обработка ошибки на верхнем уровне")

# Вывод:
# Логирование: произошла ошибка деления на ноль
# Обработка ошибки на верхнем уровне
```

### **Вызов исключения из другого исключения**
```python
try:
    result = int("abc")
except ValueError as e:
    raise RuntimeError("Не удалось обработать данные") from e

# RuntimeError: Не удалось обработать данные
# (связано с ValueError: invalid literal for int() with base 10: 'abc')
```

## `14.5` Кастомные ошибки  
Можно создавать собственные классы исключений для специфичных ошибок в вашем приложении.

**Базовый синтаксис:**
```python
class MyCustomError(Exception):
    pass
```

### **Простая кастомная ошибка**
**Пример 1:**

```python
class NegativeNumberError(Exception):
    """Исключение для отрицательных чисел"""
    pass

def square_root(number):
    if number < 0:
        raise NegativeNumberError("Нельзя извлечь корень из отрицательного числа")
    return number ** 0.5

try:
    print(square_root(16))  # 4.0
    print(square_root(-9))  # NegativeNumberError
except NegativeNumberError as e:
    print(f"Ошибка: {e}")
```

### **Кастомная ошибка с дополнительными данными**
**Пример 2:**

```python
class InsufficientFundsError(Exception):
    """Исключение при недостатке средств"""
    
    def __init__(self, balance, amount):
        self.balance = balance
        self.amount = amount
        self.shortage = amount - balance
        message = f"Недостаточно средств. Баланс: {balance}, требуется: {amount}"
        super().__init__(message)

class BankAccount:
    def __init__(self, balance):
        self.balance = balance
    
    def withdraw(self, amount):
        if amount > self.balance:
            raise InsufficientFundsError(self.balance, amount)
        self.balance -= amount
        return self.balance

# Использование
account = BankAccount(1000)

try:
    account.withdraw(500)   # OK
    print(f"Баланс: {account.balance}")
    account.withdraw(800)   # Ошибка
except InsufficientFundsError as e:
    print(e)
    print(f"Не хватает: {e.shortage} рублей")

# Вывод:
# Баланс: 500
# Недостаточно средств. Баланс: 500, требуется: 800
# Не хватает: 300 рублей
```

### **Иерархия кастомных исключений**
**Пример 3:**

```python
class ValidationError(Exception):
    """Базовое исключение для валидации"""
    pass

class EmailValidationError(ValidationError):
    """Ошибка валидации email"""
    pass

class PasswordValidationError(ValidationError):
    """Ошибка валидации пароля"""
    pass

def validate_email(email):
    if "@" not in email:
        raise EmailValidationError("Email должен содержать символ @")

def validate_password(password):
    if len(password) < 8:
        raise PasswordValidationError("Пароль должен быть не менее 8 символов")

def register_user(email, password):
    try:
        validate_email(email)
        validate_password(password)
        print("Пользователь зарегистрирован")
    except ValidationError as e:
        print(f"Ошибка валидации: {e}")

register_user("user.com", "12345")
# Вывод: Ошибка валидации: Email должен содержать символ @

register_user("user@mail.com", "12345")
# Вывод: Ошибка валидации: Пароль должен быть не менее 8 символов

register_user("user@mail.com", "strongpass123")
# Вывод: Пользователь зарегистрирован
```

### **Практический пример: API клиент**

```python
class APIError(Exception):
    """Базовая ошибка API"""
    pass

class ConnectionError(APIError):
    """Ошибка соединения"""
    pass

class AuthenticationError(APIError):
    """Ошибка аутентификации"""
    pass

class RateLimitError(APIError):
    """Превышен лимит запросов"""
    
    def __init__(self, retry_after):
        self.retry_after = retry_after
        super().__init__(f"Лимит превышен. Повторите через {retry_after} секунд")

def make_api_request(endpoint, token):
    # Симуляция API запроса
    if not token:
        raise AuthenticationError("Токен не предоставлен")
    
    if endpoint == "/rate_limited":
        raise RateLimitError(retry_after=60)
    
    return {"status": "success", "data": "..."}

# Использование
try:
    response = make_api_request("/users", token="abc123")
    print(response)
except AuthenticationError as e:
    print(f"Ошибка аутентификации: {e}")
except RateLimitError as e:
    print(f"Лимит запросов: {e}")
    print(f"Ожидание: {e.retry_after} сек")
except APIError as e:
    print(f"Ошибка API: {e}")
```

**Когда создавать кастомные исключения:**
- Для бизнес-логики приложения
- Когда стандартные исключения недостаточно информативны
- Для создания иерархии ошибок в больших проектах
- Когда нужно передавать дополнительные данные об ошибке

----

# `15` Рекурсия
## `15.1` Что такое рекурсия?  
## `15.2` Какие задачи решает рекурсия?  

----

# `16` Функции 3
## `16.1` Вложенные функции
## `16.2` (`*`) Замыкание. Зачем оно нужно?
**Замыкание** (closure) — это функция, которая определена внутри другой функции и хранит «замкнутые» значения переменных из внешней области видимости, даже после завершения работы внешней функции. То есть она "запоминает" своё окружение и может использовать переменные внешней функции, когда уже вне её контекста.

**Зачем нужны замыкания:**
- Для создания _фабричных функций_ с сохранением внутренних параметров (вместо глобальных переменных).
- Для инкапсуляции данных, когда не хочется использовать классы и нужно скрыть внутреннюю логику или состояние.
- Для генерации функций с "запомненным" состоянием или параметром.

```python
def make_multiplier(n):
    def multiplier(x):
        return x * n
    return multiplier

double = make_multiplier(2)
triple = make_multiplier(3)

print(double(4))  # 8
print(triple(4))  # 12
```
Здесь `multiplier` — замыкание: оно "помнит" значение `n` из внешней функции.

```python
def counter():
    count = 0
    def inc():
        nonlocal count
        count += 1
        return count
    return inc

count1 = counter()
print(count1())  # 1
print(count1())  # 2
```


## `16.3` (`*`) Паттерн Фабрика
`Паттерн Фабрика` — это способ централизованного создания объектов или значений, когда точный тип или параметры неизвестны заранее. В Python, без использования классов, он часто реализуется как функция, которая принимает параметры и возвращает нужное значение (например, другую функцию или структуру).

### Зачем нужен
- Чтобы упростить создание разных вариантов объектов или функций.
- Чтобы скрыть логику создания внутри одной функции.
- Чтобы избежать повторения кода.

### Пример простой фабрики без классов
```python
def animal_factory(animal_type):
    if animal_type == "dog":
        return "Гав-гав"
    elif animal_type == "cat":
        return "Мяу"
    else:
        return "Неизвестный звук"

print(animal_factory("dog"))  # Гав-гав
print(animal_factory("cat"))  # Мяу
```


## `16.4` (`*`) Локальные и глобальные переменные. Область видимости. Правило `LEGB`
В Python **локальные переменные** объявляются внутри функций и доступны только в этих функциях. **Глобальные переменные** находятся вне всех функций и доступны во всей программе. Если объявить переменную внутри функции с тем же именем, что и глобальная — внутри функции будет использоваться локальная версия, а глобальная вне функции.

**Область видимости** — определяет, где переменная "видна" и доступна для использования. Локальные переменные исчезают после завершения функции, глобальные — сохраняются на протяжении исполнения всей программы.

### LEGB правило поиска переменных
Python ищет переменные по цепочке областей видимости:
- **L**ocal (Локальная): внутри текущей функции или метода
- **E**nclosing (Вложенная): в родительских (внешних) функциях, если используется вложенность
- **G**lobal (Глобальная): на уровне всего модуля (файла)
- **B**uilt-in (Встроенная): специальные переменные и функции Python (например, `print`, `len`)

**Глобальная переменная:**
```python
x = "глобальная переменная"

def show():
    print(x)  # доступ к глобальной переменной
show()
print(x)      # доступ вне функции
```

**Локальная переменная:**
```python
def foo():
    y = "локальная переменная"
    print(y)
foo()
# print(y)  # Ошибка, вне функции переменная недоступна
```

**LEGB - вложенные функции:**
```python
def outer():
    a = "enclosing"
    def inner():
        print(a)  # ищет переменную во внешней функции (Enclosing)
    inner()
outer()
```

**Изменение глобальной переменной внутри функции:**
```python
global_var = 10

def update():
    global global_var
    global_var = 20  # изменится глобальная переменная
update()
print(global_var)    # 20
```

----

# `17` (`*`) Декораторы
[Видео про декораторы](https://youtu.be/VnuDMPQSMjs?si=waVjxvA83EmMDevm)

## `17.1` Что такое декоратор? Как написать свой декоратор?
### **Что такое декоратор?**
**Декоратор** — это функция, которая принимает другую функцию и расширяет её поведение без изменения исходного кода. Это паттерн проектирования, который позволяет "обернуть" функцию дополнительной логикой.

**Основные характеристики:**
- Декоратор — это функция высшего порядка (принимает функцию, возвращает функцию)
- Используется синтаксис `@decorator_name` перед определением функции
- Позволяет переиспользовать код
- Не изменяет исходную функцию

**Для чего нужны декораторы:**
- Логирование вызовов функций
- Измерение времени выполнения
- Проверка прав доступа
- Кэширование результатов
- Валидация входных данных
- Обработка ошибок

### **Базовый пример**
**Без декоратора:**

```python
def say_hello():
    print("Hello!")

def add_greeting(func):
    def wrapper():
        print("--- Начало ---")
        func()
        print("--- Конец ---")
    return wrapper

say_hello = add_greeting(say_hello)
say_hello()

# Вывод:
# --- Начало ---
# Hello!
# --- Конец ---
```

**С декоратором (синтаксический сахар):**
```python
def add_greeting(func):
    def wrapper():
        print("--- Начало ---")
        func()
        print("--- Конец ---")
    return wrapper

@add_greeting
def say_hello():
    print("Hello!")

say_hello()

# Вывод:
# --- Начало ---
# Hello!
# --- Конец ---
```

**`@add_greeting`** эквивалентно **`say_hello = add_greeting(say_hello)`**

### **Как написать свой декоратор**
**Шаблон декоратора:**

```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        # Код ДО вызова функции
        result = func(*args, **kwargs)
        # Код ПОСЛЕ вызова функции
        return result
    return wrapper
```

### **Пример 1: Декоратор для логирования**

```python
def logger(func):
    def wrapper(*args, **kwargs):
        print(f"Вызов функции: {func.__name__}")
        print(f"Аргументы: args={args}, kwargs={kwargs}")
        result = func(*args, **kwargs)
        print(f"Результат: {result}")
        return result
    return wrapper

@logger
def add(a, b):
    return a + b

@logger
def greet(name, greeting="Привет"):
    return f"{greeting}, {name}!"

add(5, 3)
# Вывод:
# Вызов функции: add
# Аргументы: args=(5, 3), kwargs={}
# Результат: 8

greet("Алиса", greeting="Здравствуй")
# Вывод:
# Вызов функции: greet
# Аргументы: args=('Алиса',), kwargs={'greeting': 'Здравствуй'}
# Результат: Здравствуй, Алиса!
```

### **Пример 2: Декоратор для измерения времени выполнения**

```python
import time

def timer(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"Функция {func.__name__} выполнилась за {end - start:.4f} секунд")
        return result
    return wrapper

@timer
def slow_function():
    time.sleep(2)
    return "Готово"

@timer
def calculate_sum(n):
    return sum(range(n))

slow_function()
# Вывод: Функция slow_function выполнилась за 2.0021 секунд

calculate_sum(1000000)
# Вывод: Функция calculate_sum выполнилась за 0.0234 секунд
```

### **Пример 3: Декоратор для проверки типов**

```python
def validate_positive(func):
    def wrapper(number):
        if number <= 0:
            raise ValueError("Число должно быть положительным")
        return func(number)
    return wrapper

@validate_positive
def calculate_square_root(n):
    return n ** 0.5

print(calculate_square_root(16))  # 4.0
print(calculate_square_root(-4))  # ValueError: Число должно быть положительным
```

### **Множественные декораторы**
Можно применять несколько декораторов к одной функции:

```python
@decorator1
@decorator2
@decorator3
def my_function():
    pass

# Эквивалентно:
# my_function = decorator1(decorator2(decorator3(my_function)))
```

**Пример:**

```python
def uppercase(func):
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        return result.upper()
    return wrapper

def add_exclamation(func):
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        return result + "!!!"
    return wrapper

@uppercase
@add_exclamation
def greet(name):
    return f"hello, {name}"

print(greet("Alice"))
# Вывод: HELLO, ALICE!!!

# Порядок выполнения:
# 1. greet("Alice") → "hello, Alice"
# 2. add_exclamation → "hello, Alice!!!"
# 3. uppercase → "HELLO, ALICE!!!"
```

## `17.2` (`**`) Есть ли что-то похожее в других языках?
Да, декораторы или похожие паттерны существуют во многих языках программирования. Концепция "обёртывания" функций является универсальной.

### **Java — Аннотации**
В Java используются **аннотации** — специальные метки, которые добавляют метаданные к коду. Они помечаются символом `@` перед именем класса, метода или поля.

**Примеры использования:**
- `@Override` — указывает, что метод переопределяет метод родительского класса
- `@Deprecated` — помечает устаревший код, который не рекомендуется использовать
- `@Autowired` — в Spring Framework автоматически внедряет зависимости
- `@GetMapping` — в Spring определяет HTTP GET endpoint для веб-сервиса

**Особенности:**
- Используются для метаданных, а не для модификации поведения
- Обрабатываются во время компиляции или выполнения программы
- Широко применяются в фреймворках (Spring, Hibernate, JUnit)
- Не изменяют логику напрямую, а указывают как должен работать фреймворк

### **C# — Атрибуты**
В C# есть **атрибуты** — аналог Java-аннотаций. Они записываются в квадратных скобках перед объявлением класса, метода или свойства.

**Примеры использования:**
- `[Obsolete]` — помечает устаревший код с предупреждением для разработчика
- `[HttpGet]` — в ASP.NET определяет HTTP GET метод для API
- `[Route]` — задаёт URL маршрут для контроллера
- `[Serializable]` — указывает, что объект можно сериализовать

**Особенности:**
- Похожи на Java-аннотации по назначению и синтаксису
- Используются для метаданных и рефлексии
- Применяются к классам, методам, свойствам, параметрам
- Фреймворки читают эти атрибуты через рефлексию для настройки поведения

### **TypeScript/JavaScript — Декораторы**
**TypeScript** поддерживает **декораторы** как экспериментальную функцию — это самая близкая к Python реализация. Используется синтаксис `@decorator` перед объявлением класса или метода.

**JavaScript** не имеет встроенного синтаксиса для декораторов, но широко использует **функции высшего порядка** — функции, которые принимают другие функции и возвращают новые с изменённым поведением. Это тот же принцип, что и в Python, но без синтаксического сахара `@`.

**Особенности TypeScript:**
- Экспериментальная функция, требует включения в конфигурации
- Синтаксис максимально похож на Python
- Используется для модификации классов и методов

**Особенности JavaScript:**
- Функции высшего порядка — основной способ обёртывания функций
- Нет специального синтаксиса, используется обычный вызов функций
- Широко применяется в React (Higher-Order Components)

### **Ruby — Методы-модификаторы**
В Ruby нет специального синтаксиса для декораторов, но есть мощное **метапрограммирование** и возможность изменять классы во время выполнения.

**Техника "monkey patching":**
- Можно переопределить любой метод в любом классе
- Используется `alias_method` для сохранения оригинального метода
- Затем переопределяется метод с вызовом оригинального внутри

**Особенности:**
- Очень гибкий подход, но может быть опасным
- Изменения видны глобально во всей программе
- Нет явного синтаксиса для декорирования
- Используется метапрограммирование и динамическая природа языка

### **PHP — Атрибуты**
Начиная с **PHP 8**, появились **атрибуты** — механизм похожий на Java-аннотации. Используется синтаксис `#[AttributeName]` перед функцией или классом.

**Примеры использования:**
- `#[Route]` — определяет маршрут для контроллера
- `#[Deprecated]` — помечает устаревший код
- Используется в современных фреймворках (Symfony, Laravel)

**Особенности:**
- Добавлены только в PHP 8 (2020 год)
- Похожи на Java-аннотации и C#-атрибуты
- Используются для метаданных, обрабатываются через рефлексию

### **Go — Функции высшего порядка**
В Go **нет встроенных декораторов** и специального синтаксиса для них. Но язык поддерживает функции как значения первого класса, что позволяет использовать **функции высшего порядка**.

**Подход:**
- Создаётся функция, которая принимает другую функцию
- Возвращается новая функция с расширенным поведением
- Нужно явно присваивать результат переменной

**Особенности:**
- Нет синтаксического сахара `@decorator`
- Более многословный подход
- Явное управление обёртыванием функций
- Типизация усложняет создание универсальных декораторов

### **Сравнительная таблица**
| Язык | Синтаксис | Название | Особенности |
|------|-----------|----------|-------------|
| **Python** | `@decorator` | Декораторы | Полноценные, модифицируют поведение во время выполнения |
| **Java** | `@Annotation` | Аннотации | Метаданные, обрабатываются компилятором/runtime |
| **C#** | `[Attribute]` | Атрибуты | Метаданные, используются через рефлексию |
| **TypeScript** | `@decorator` | Декораторы | Экспериментальная функция, похожа на Python |
| **JavaScript** | Функции высшего порядка | - | Нет синтаксического сахара |
| **Ruby** | `alias_method` | - | Monkey patching, метапрограммирование |
| **PHP** | `#[Attribute]` | Атрибуты | С PHP 8, похожи на Java |
| **Go** | Функции высшего порядка | - | Нет встроенного синтаксиса |


**Вывод:** 
Python-декораторы наиболее близки к TypeScript-декораторам по синтаксису и функциональности. Оба языка используют символ `@` и позволяют модифицировать поведение функций напрямую.

Java и C# используют похожую концепцию, но их аннотации/атрибуты больше предназначены для метаданных, которые затем обрабатываются фреймворками, а не для прямого изменения логики.

JavaScript и Go используют функции высшего порядка без специального синтаксиса — это более явный, но менее удобный подход.

Ruby идёт своим путём через метапрограммирование и динамическое изменение классов.

## `17.3` Атрибуты `__name__` & `__doc__`
Когда функция оборачивается декоратором, она теряет свои метаданные: имя, строку документации и другие атрибуты. Это может создать проблемы при отладке и использовании инструментов рефлексии.

### **Проблема потери метаданных**

```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        """Это wrapper функция"""
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def greet(name):
    """Приветствует пользователя по имени"""
    return f"Hello, {name}!"

print(greet.__name__)  # wrapper (не greet!)
print(greet.__doc__)   # Это wrapper функция (не оригинальная документация!)
```

**Что произошло:**
- `greet.__name__` показывает `"wrapper"` вместо `"greet"`
- `greet.__doc__` показывает документацию wrapper'а, а не оригинальной функции
- Теряется информация об оригинальной функции

### **Атрибуты функций**
Основные атрибуты функций в Python:

| Атрибут | Описание | Пример |
|---------|----------|---------|
| `__name__` | Имя функции | `"greet"` |
| `__doc__` | Строка документации | `"Приветствует пользователя"` |
| `__module__` | Модуль, где определена функция | `"__main__"` |
| `__qualname__` | Квалифицированное имя | `"MyClass.method"` |
| `__annotations__` | Аннотации типов | `{"name": str, "return": str}` |

**Пример:**
```python
def calculate_area(width: float, height: float) -> float:
    """
    Вычисляет площадь прямоугольника.
    
    Args:
        width: ширина
        height: высота
    
    Returns:
        Площадь прямоугольника
    """
    return width * height

print(calculate_area.__name__)        # calculate_area
print(calculate_area.__doc__)         # Вычисляет площадь...
print(calculate_area.__module__)      # __main__
print(calculate_area.__annotations__) # {'width': <class 'float'>, ...}
```

### **Ручное сохранение метаданных**
Можно вручную копировать атрибуты из оригинальной функции:

```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    
    # Вручную копируем метаданные
    wrapper.__name__ = func.__name__
    wrapper.__doc__ = func.__doc__
    wrapper.__module__ = func.__module__
    wrapper.__annotations__ = func.__annotations__
    
    return wrapper

@my_decorator
def greet(name: str) -> str:
    """Приветствует пользователя"""
    return f"Hello, {name}!"

print(greet.__name__)  # greet
print(greet.__doc__)   # Приветствует пользователя
```

**Проблема:** Это неудобно и легко забыть скопировать все необходимые атрибуты.


## `17.4` `@functools.wraps` - что такое и зачем?
`functools.wraps` — это декоратор для декораторов, который автоматически копирует метаданные из оригинальной функции в wrapper-функцию.

**Зачем нужен:**
- Сохраняет `__name__`, `__doc__`, `__module__` и другие атрибуты
- Упрощает написание декораторов
- Облегчает отладку
- Корректно работает с инструментами документации

### **Синтаксис**
```python
from functools import wraps

def my_decorator(func):
    @wraps(func)  # ← Сохраняет метаданные оригинальной функции
    def wrapper(*args, **kwargs):
        # Дополнительная логика
        return func(*args, **kwargs)
    return wrapper
```

### **Пример: Без `@wraps` vs С `@wraps`**
**Без `@wraps`:**

```python
def logger(func):
    def wrapper(*args, **kwargs):
        """Wrapper функция для логирования"""
        print(f"Вызов: {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

@logger
def add(a, b):
    """Складывает два числа"""
    return a + b

print(add.__name__)  # wrapper
print(add.__doc__)   # Wrapper функция для логирования
help(add)
# Help on function wrapper in module __main__:
# wrapper(*args, **kwargs)
#     Wrapper функция для логирования
```

**С `@wraps`:**

```python
from functools import wraps

def logger(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        """Wrapper функция для логирования"""
        print(f"Вызов: {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

@logger
def add(a, b):
    """Складывает два числа"""
    return a + b

print(add.__name__)  # add
print(add.__doc__)   # Складывает два числа
help(add)
# Help on function add in module __main__:
# add(a, b)
#     Складывает два числа
```

### **Практические примеры**
**Пример 1: Декоратор с `@wraps`**

```python
from functools import wraps
import time

def timer(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} выполнилась за {end - start:.4f}s")
        return result
    return wrapper

@timer
def calculate_fibonacci(n: int) -> int:
    """Вычисляет n-ое число Фибоначчи"""
    if n <= 1:
        return n
    return calculate_fibonacci(n - 1) + calculate_fibonacci(n - 2)

# Метаданные сохранены
print(calculate_fibonacci.__name__)  # calculate_fibonacci
print(calculate_fibonacci.__doc__)   # Вычисляет n-ое число Фибоначчи

calculate_fibonacci(10)
# calculate_fibonacci выполнилась за 0.0003s
```

**Пример 2: Декоратор для кэширования**

```python
from functools import wraps

def cache(func):
    cached_results = {}
    
    @wraps(func)
    def wrapper(*args):
        if args not in cached_results:
            cached_results[args] = func(*args)
            print(f"Вычислено: {func.__name__}{args}")
        else:
            print(f"Из кэша: {func.__name__}{args}")
        return cached_results[args]
    
    return wrapper

@cache
def expensive_computation(x, y):
    """Выполняет сложное вычисление"""
    return x ** y

print(expensive_computation.__name__)  # expensive_computation (не wrapper!)

print(expensive_computation(2, 10))  # Вычислено: expensive_computation(2, 10)
print(expensive_computation(2, 10))  # Из кэша: expensive_computation(2, 10)
print(expensive_computation(3, 5))   # Вычислено: expensive_computation(3, 5)
```

### **Какие атрибуты копирует `@wraps`**
`functools.wraps` копирует следующие атрибуты:
- `__module__` — имя модуля
- `__name__` — имя функции
- `__qualname__` — квалифицированное имя
- `__annotations__` — аннотации типов
- `__doc__` — строка документации
- `__dict__` — словарь атрибутов функции

**Вывод:** Всегда используйте `@functools.wraps` при написании декораторов!


## `17.5` Параметризованный декоратор
**Параметризованный декоратор** — это декоратор, который принимает аргументы. Это позволяет настраивать поведение декоратора.

### **Структура параметризованного декоратора**

```python
def decorator_with_params(param1, param2):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # Используем param1, param2
            return func(*args, **kwargs)
        return wrapper
    return decorator
```

**Три уровня функций:**
1. **Внешняя функция** — принимает параметры декоратора
2. **Средняя функция** — принимает декорируемую функцию
3. **Внутренняя функция (wrapper)** — выполняет саму логику

### **Пример 1: Декоратор с параметром количества повторов**

```python
from functools import wraps

def repeat(times):
    """Повторяет выполнение функции заданное количество раз"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for _ in range(times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(times=3)
def greet(name):
    print(f"Hello, {name}!")

greet("Alice")
# Вывод:
# Hello, Alice!
# Hello, Alice!
# Hello, Alice!

@repeat(times=5)
def show_number(n):
    print(n)

show_number(42)
# Вывод: 42 (5 раз)
```

### **Пример 2: Декоратор с проверкой прав доступа**

```python
from functools import wraps

def requires_permission(permission):
    """Проверяет наличие прав доступа"""
    def decorator(func):
        @wraps(func)
        def wrapper(user, *args, **kwargs):
            if permission not in user.get("permissions", []):
                raise PermissionError(f"Требуется право: {permission}")
            return func(user, *args, **kwargs)
        return wrapper
    return decorator

@requires_permission("admin")
def delete_user(user, user_id):
    print(f"Пользователь {user_id} удалён")

@requires_permission("read")
def view_data(user):
    print("Просмотр данных")

# Использование
admin_user = {"name": "Alice", "permissions": ["admin", "read", "write"]}
regular_user = {"name": "Bob", "permissions": ["read"]}

delete_user(admin_user, 123)  # ✓ Пользователь 123 удалён
delete_user(regular_user, 123)  # ✗ PermissionError: Требуется право: admin

view_data(regular_user)  # ✓ Просмотр данных
```

### **Пример 3: Декоратор для повторных попыток**

```python
from functools import wraps
import time
import random

def retry(max_attempts=3, delay=1):
    """Повторяет выполнение функции при ошибке"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            attempts = 0
            while attempts < max_attempts:
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    attempts += 1
                    if attempts >= max_attempts:
                        raise
                    print(f"Попытка {attempts} неудачна. Повтор через {delay}s...")
                    time.sleep(delay)
        return wrapper
    return decorator

@retry(max_attempts=5, delay=2)
def unstable_api_call():
    """Симуляция нестабильного API"""
    if random.random() < 0.7:  # 70% вероятность ошибки
        raise ConnectionError("API недоступен")
    return "Успех!"

result = unstable_api_call()
print(result)
# Попытка 1 неудачна. Повтор через 2s...
# Попытка 2 неудачна. Повтор через 2s...
# Успех!
```

### **Пример 4: Декоратор для валидации типов**

```python
from functools import wraps

def validate_types(**expected_types):
    """Проверяет типы аргументов функции"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # Проверяем kwargs
            for arg_name, arg_value in kwargs.items():
                if arg_name in expected_types:
                    expected_type = expected_types[arg_name]
                    if not isinstance(arg_value, expected_type):
                        raise TypeError(
                            f"Аргумент '{arg_name}' должен быть {expected_type.__name__}, "
                            f"получен {type(arg_value).__name__}"
                        )
            return func(*args, **kwargs)
        return wrapper
    return decorator

@validate_types(name=str, age=int, salary=float)
def create_user(name, age, salary):
    print(f"Создан пользователь: {name}, {age} лет, зарплата {salary}")

create_user(name="Alice", age=30, salary=50000.0)  # ✓ OK
create_user(name="Bob", age="25", salary=60000.0)  # ✗ TypeError
```

### **Пример 5: Декоратор для логирования с уровнем детализации**

```python
from functools import wraps
import logging

def log(level="INFO"):
    """Логирует вызов функции с заданным уровнем"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            logger = logging.getLogger(func.__module__)
            log_message = f"Вызов {func.__name__} с args={args}, kwargs={kwargs}"
            
            if level == "DEBUG":
                logger.debug(log_message)
            elif level == "INFO":
                logger.info(log_message)
            elif level == "WARNING":
                logger.warning(log_message)
            elif level == "ERROR":
                logger.error(log_message)
            
            result = func(*args, **kwargs)
            logger.info(f"{func.__name__} вернула: {result}")
            return result
        return wrapper
    return decorator

logging.basicConfig(level=logging.DEBUG)

@log(level="DEBUG")
def add(a, b):
    return a + b

@log(level="WARNING")
def divide(a, b):
    return a / b

add(5, 3)
divide(10, 2)
```

### **Универсальный шаблон**

```python
from functools import wraps

def my_decorator(param1=default1, param2=default2):
    """Описание декоратора"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # Логика ДО вызова функции
            # Можно использовать param1, param2
            
            result = func(*args, **kwargs)
            
            # Логика ПОСЛЕ вызова функции
            
            return result
        return wrapper
    return decorator

@my_decorator(param1=value1, param2=value2)
def my_function():
    pass
```

**Когда использовать параметризованные декораторы:**
- Когда нужна гибкая настройка поведения
- Для переиспользуемых декораторов с разными параметрами
- Когда один декоратор должен работать по-разному в разных случаях

----

# `18` (`*`) Итераторы
[Видосик про Итераторы](https://www.youtube.com/watch?v=Lnk-Xhje27Q)

## `18.1` Что такое итераторы? Зачем они нужны? В чем их профит?
**Что такое итератор?**

`Итератор` — это специальный объект в Python, который умеет выдавать элементы по одному, когда вы их запрашиваете. 

Представьте: у вас есть коробка с 1000 шариков. Есть два способа с ними работать:
- **Способ 1 (список):** Высыпать все 1000 шариков на стол сразу — они занимают много места
- **Способ 2 (итератор):** Брать по одному шарику из коробки, когда нужно — место почти не занимает

**Как это работает технически:**

Когда вы пишете цикл `for`, Python за кулисами делает примерно следующее:

```python
# Когда вы пишете:
for item in [1, 2, 3]:
    print(item)

# Python на самом деле делает что-то вроде:
items = [1, 2, 3]
iterator = iter(items)  # Создает итератор из списка

try:
    while True:
        item = next(iterator)  # Берет следующий элемент
        print(item)
except StopIteration:  # Когда элементы закончились
    pass  # Выходит из цикла
```

**Две главные функции для работы с итераторами:**
- `iter(объект)` — создает итератор из объекта
- `next(итератор)` — берет следующий элемент из итератора

**Пример 1: Ручная работа с итератором**
```python
# У нас есть список
numbers = [10, 20, 30]

# Создаем из него итератор
my_iterator = iter(numbers)

# Берем элементы по одному вручную
print(next(my_iterator))  # 10
print(next(my_iterator))  # 20
print(next(my_iterator))  # 30

# Если попытаться взять еще один — ошибка
# print(next(my_iterator))  # StopIteration — элементы кончились!
```

**Пример 2: Итератор со строкой**
```python
text = "привет"
text_iterator = iter(text)

print(next(text_iterator))  # 'п'
print(next(text_iterator))  # 'р'
print(next(text_iterator))  # 'и'
print(next(text_iterator))  # 'в'
print(next(text_iterator))  # 'е'
print(next(text_iterator))  # 'т'
```

**Зачем нужны итераторы:**

1. **Экономия памяти** — не нужно хранить все данные в памяти одновременно
   ```python
   # Список — все 1 миллион чисел в памяти
   big_list = list(range(1000000))  # Занимает ~8 МБ памяти
   
   # Итератор — хранит только "где мы сейчас находимся"
   big_iterator = iter(range(1000000))  # Занимает ~100 байт
   ```

2. **Работа с данными, которые не помещаются в память**
   ```python
   # Огромный файл на 10 ГБ
   with open('huge_file.txt') as f:
       for line in f:  # f — это итератор!
           print(line)  # Читает по одной строке, а не весь файл
   ```

3. **Ленивые вычисления** — элемент вычисляется только когда нужен
   ```python
   # Не вычисляет все квадраты сразу, а только по запросу
   squares = (x**2 for x in range(1000000))
   print(next(squares))  # 0 — вычислил только первый
   print(next(squares))  # 1 — вычислил только второй
   ```

**Профит (выгода):**
- **Память:** Обработка миллиарда чисел требует не гигабайты, а килобайты памяти
- **Скорость запуска:** Программа начинает работать сразу, не дожидаясь загрузки всех данных
- **Гибкость:** Можно работать с потоками данных (сеть, файлы, датчики) в реальном времени


## `18.2` Генераторы
**Что такое генератор?**
`Генератор` — это функция, которая умеет "останавливаться" и "продолжаться".

Обычная функция:
- Выполняется от начала до конца
- `return` возвращает результат и функция завершается

Функция-генератор:
- Может останавливаться на `yield` и возвращать значение
- При следующем вызове продолжает работу с места остановки
- `yield` значит "вернуть значение, но не забывать, где остановились"

**Как создать генератор:**

Просто напишите функцию и используйте `yield` вместо `return`.

**Пример 1: Простейший генератор**
```python
def my_first_generator():
    print("Начали работу")
    yield 1  # Остановка 1: вернуть 1
    print("Продолжили работу")
    yield 2  # Остановка 2: вернуть 2
    print("Почти закончили")
    yield 3  # Остановка 3: вернуть 3
    print("Всё, закончили")

# Создаем генератор (функция еще не выполнилась!)
gen = my_first_generator()

print(next(gen))  
# Напечатает: Начали работу
#             1

print(next(gen))
# Напечатает: Продолжили работу
#             2

print(next(gen))
# Напечатает: Почти закончили
#             3

# print(next(gen))
# Напечатает: Всё, закончили
# StopIteration — элементы закончились
```

**Обратите внимание:** Строки `print` выполняются только когда доходит до них очередь!

**Пример 2: Генератор счетчика**
```python
def count_up_to(max_number):
    """Генератор, который считает от 1 до max_number"""
    current = 1
    while current <= max_number:
        yield current  # Вернуть текущее число
        current += 1   # Увеличить счетчик

# Использование в цикле
for number in count_up_to(5):
    print(number)  # 1, 2, 3, 4, 5

# Или вручную
counter = count_up_to(3)
print(next(counter))  # 1
print(next(counter))  # 2
print(next(counter))  # 3
```

**Пример 3: Генератор четных чисел**
```python
def even_numbers(up_to):
    """Генерирует четные числа от 0 до up_to"""
    number = 0
    while number <= up_to:
        yield number
        number += 2

for num in even_numbers(10):
    print(num, end=' ')  # 0 2 4 6 8 10
```

**Генераторные выражения (короткая запись):**

Есть короткий способ создать генератор — похоже на создание списка, но с круглыми скобками:

```python
# Создание списка (все элементы сразу в памяти)
squares_list = [x**2 for x in range(10)]
print(squares_list)  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# Генераторное выражение (элементы создаются по запросу)
squares_gen = (x**2 for x in range(10))
print(squares_gen)  # <generator object> — не список!

# Берем элементы
print(next(squares_gen))  # 0
print(next(squares_gen))  # 1
print(next(squares_gen))  # 4

# Или в цикле
for square in (x**2 for x in range(5)):
    print(square, end=' ')  # 0 1 4 9 16
```

**Пример 4: Практическая задача — чтение большого файла**

```python
def read_numbers_from_file(filename):
    """Читает числа из файла по одному"""
    with open(filename, 'r') as file:
        for line in file:
            # Каждую строку превращаем в число и отдаем
            yield int(line.strip())

# Файл может быть огромным, но в памяти только одно число!
for number in read_numbers_from_file('numbers.txt'):
    if number > 100:
        print(f"Нашли большое число: {number}")
```

**Ключевые моменты:**

- Генератор — это функция с `yield`
- `yield` работает как "пауза" в функции
- Генератор помнит свое состояние между вызовами
- Генератор создается сразу, но код начинает выполняться только при первом `next()`


## `18.3` В чем разница генераторов от итераторов?  
**Главное правило:** `Генератор` — это всегда `итератор`, но `итератор` — не всегда `генератор`.

Это как сказать: "Любая собака — это животное, но не любое животное — это собака"

**Что такое итератор (в общем смысле):**

Итератор — это любой объект, который умеет:
1. Выдавать элементы по одному через `next()`
2. Сообщать когда элементы закончились (через ошибку `StopIteration`)

**Что такое генератор:**

Генератор — это **способ создать** итератор с помощью функции с `yield`. Это как конструктор для создания итератора.

**Итераторами являются:**
- Генераторы (функции с `yield`)
- Файлы
- `range()`
- Строки, списки, кортежи (после `iter()`)
- Много других встроенных объектов

**Сравнение на примере:**

```python
# ИТЕРАТОР ИЗ СПИСКА
my_list = [1, 2, 3]
list_iterator = iter(my_list)  # Превратили список в итератор

print(next(list_iterator))  # 1
print(next(list_iterator))  # 2

# ГЕНЕРАТОР (это тоже итератор!)
def my_generator():
    yield 1
    yield 2
    yield 3

gen = my_generator()  # Создали генератор

print(next(gen))  # 1
print(next(gen))  # 2

# Оба работают через next() — оба итераторы!
# Но создали мы их по-разному
```

**Основные различия:**

| **Аспект** | **Обычный итератор** | **Генератор** |
|------------|---------------------|---------------|
| **Как создать** | `iter()` от существующего объекта | Функция с `yield` |
| **Сложность** | Простой (берет из готовых данных) | Можем писать любую логику |
| **Код** | Короткий (`iter(список)`) | Пишем функцию |
| **Гибкость** | Ограниченная | Очень гибкая |
| **Когда использовать** | Готовые данные уже есть | Нужно генерировать данные "на лету" |

**Пример: Одна и та же задача разными способами**

Задача: получить числа от 1 до 5

```python
# СПОСОБ 1: Список + итератор
numbers_list = [1, 2, 3, 4, 5]
iterator1 = iter(numbers_list)

for num in iterator1:
    print(num, end=' ')  # 1 2 3 4 5

# СПОСОБ 2: Генератор
def generate_numbers():
    for i in range(1, 6):
        yield i

iterator2 = generate_numbers()

for num in iterator2:
    print(num, end=' ')  # 1 2 3 4 5

# СПОСОБ 3: Генераторное выражение
iterator3 = (i for i in range(1, 6))

for num in iterator3:
    print(num, end=' ')  # 1 2 3 4 5
```

Все три способа дают итератор, но третий (генератор) самый гибкий.

**Когда генератор лучше:**

```python
# Нужно генерировать бесконечную последовательность
def infinite_numbers():
    num = 0
    while True:  # Бесконечный цикл!
        yield num
        num += 1

# Список так сделать невозможно!
# infinite_list = [0, 1, 2, 3, ...]  # Нельзя!

gen = infinite_numbers()
print(next(gen))  # 0
print(next(gen))  # 1
print(next(gen))  # 2
# И так можно бесконечно
```

**Важное отличие — повторное использование:**

```python
# Список можно перебрать много раз
my_list = [1, 2, 3]
for num in my_list:
    print(num, end=' ')  # 1 2 3

for num in my_list:
    print(num, end=' ')  # 1 2 3 — снова работает!

# Генератор "одноразовый"
def my_gen():
    yield 1
    yield 2
    yield 3

gen = my_gen()

for num in gen:
    print(num, end=' ')  # 1 2 3

for num in gen:
    print(num, end=' ')  # Ничего! Генератор "израсходован"

# Нужно создать новый
gen = my_gen()  # Создаем заново
for num in gen:
    print(num, end=' ')  # 1 2 3 — теперь работает
```

**Простое объяснение:**
- **Итератор** — это категория объектов (как "транспорт")
- **Генератор** — это конкретный вид итератора (как "велосипед")
- Все генераторы — итераторы
- Но не все итераторы — генераторы


## `18.4` Когда использовать и кейсы
**Когда использовать итераторы и генераторы:**
### **1. Работа с большими объемами данных**

Если данных много и они не помещаются в память — используйте итераторы/генераторы.

**Кейс: Обработка большого файла**

```python
# ❌ ПЛОХО — весь файл в память (может быть 10 ГБ!)
def process_file_bad(filename):
    with open(filename, 'r', encoding='utf-8') as f:
        all_lines = f.readlines()  # Загрузили ВСЁ в память!
    
    for line in all_lines:
        # обрабатываем строку
        process_line(line)

# ✅ ХОРОШО — по одной строке
def process_file_good(filename):
    with open(filename, 'r', encoding='utf-8') as f:
        for line in f:  # Файл — это итератор!
            # обрабатываем строку
            process_line(line)  # В памяти только одна строка

# ✅ ЕЩЕ ЛУЧШЕ — свой генератор с обработкой
def read_and_clean_lines(filename):
    """Генератор: читает и очищает строки"""
    with open(filename, 'r', encoding='utf-8') as f:
        for line in f:
            cleaned = line.strip()  # Убираем пробелы
            if cleaned:  # Пропускаем пустые
                yield cleaned

# Использование
for line in read_and_clean_lines('big_data.txt'):
    print(line)  # В памяти всегда только одна строка
```

### **2. Цепочки обработки данных (pipeline)**

Когда нужно выполнить несколько операций последовательно.

**Кейс: Обработка чисел из файла**

```python
def read_numbers(filename):
    """Шаг 1: Читаем числа из файла"""
    with open(filename, 'r') as f:
        for line in f:
            yield int(line.strip())

def filter_positive(numbers):
    """Шаг 2: Оставляем только положительные"""
    for num in numbers:
        if num > 0:
            yield num

def square_numbers(numbers):
    """Шаг 3: Возводим в квадрат"""
    for num in numbers:
        yield num ** 2

def limit_results(numbers, max_count):
    """Шаг 4: Берем первые max_count результатов"""
    count = 0
    for num in numbers:
        if count >= max_count:
            break
        yield num
        count += 1

# Строим цепочку (ничего еще не вычислилось!)
step1 = read_numbers('numbers.txt')
step2 = filter_positive(step1)
step3 = square_numbers(step2)
step4 = limit_results(step3, 5)

# Только теперь начинаются вычисления!
for result in step4:
    print(result)

# Можно записать короче:
for result in limit_results(
    square_numbers(
        filter_positive(
            read_numbers('numbers.txt')
        )
    ), 5
):
    print(result)
```

**Преимущество:** Обрабатывается только 5 чисел, хотя в файле может быть миллион!

### **3. Бесконечные последовательности**

Когда нужен бесконечный источник данных.

**Кейс: Бесконечный счетчик**

```python
def counter(start=0, step=1):
    """Бесконечно считает с заданным шагом"""
    current = start
    while True:  # Бесконечный цикл!
        yield current
        current += step

# Берем столько, сколько нужно
c = counter(10, 5)
for _ in range(5):  # Возьмем только 5 значений
    print(next(c))  # 10, 15, 20, 25, 30
```

**Кейс: Генератор случайных данных**

```python
import random

def random_numbers():
    """Бесконечный генератор случайных чисел"""
    while True:
        yield random.randint(1, 100)

# Генерируем пока не найдем число > 95
gen = random_numbers()
for num in gen:
    print(num)
    if num > 95:
        break  # Выходим когда нужно
```

### **4. Ленивые вычисления**

Когда вычисления дорогие и нужны не все результаты.

**Кейс: Поиск простых чисел**

```python
def is_prime(n):
    """Проверка, является ли число простым (медленная операция)"""
    if n < 2:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

def prime_numbers():
    """Генератор простых чисел"""
    num = 2
    while True:
        if is_prime(num):  # Проверка только когда нужно!
            yield num
        num += 1

# Найдем первые 10 простых чисел
primes = prime_numbers()
for _ in range(10):
    print(next(primes), end=' ')  # 2 3 5 7 11 13 17 19 23 29

# Если бы мы делали список, пришлось бы проверить ВСЕ числа заранее!
```

### **5. Экономия памяти при преобразованиях**

**Кейс: Обработка логов**

```python
def parse_log_lines(filename):
    """Парсим строки лога"""
    with open(filename, 'r') as f:
        for line in f:
            # Пример строки: "2025-01-15 ERROR Something went wrong"
            parts = line.strip().split(' ', 2)
            if len(parts) == 3:
                date, level, message = parts
                yield {'date': date, 'level': level, 'message': message}

def filter_errors(log_entries):
    """Оставляем только ошибки"""
    for entry in log_entries:
        if entry['level'] == 'ERROR':
            yield entry

# Обрабатываем только ошибки, остальное не загружаем в память
logs = parse_log_lines('app.log')
errors = filter_errors(logs)

for error in errors:
    print(f"{error['date']}: {error['message']}")
```

### **Когда НЕ нужно использовать итераторы/генераторы:**

1. **Данные помещаются в память** — используйте обычный список
   ```python
   # Если данных мало — список проще
   small_data = [1, 2, 3, 4, 5]
   ```

2. **Нужен доступ по индексу**
   ```python
   # С генератором нельзя:
   # gen[5]  # Ошибка!
   
   # Нужен список:
   data = [1, 2, 3, 4, 5]
   print(data[2])  # 3 — работает
   ```

3. **Нужно узнать длину заранее**
   ```python
   # len(генератор) не работает!
   # Нужен список или кортеж
   ```

4. **Нужно проходить по данным много раз**
   ```python
   # Генератор "одноразовый"
   gen = (x for x in range(5))
   list(gen)  # [0, 1, 2, 3, 4]
   list(gen)  # [] — пустой! Израсходован
   
   # Список можно использовать многократно
   my_list = list(range(5))
   list(my_list)  # [0, 1, 2, 3, 4]
   list(my_list)  # [0, 1, 2, 3, 4] — всё ещё работает
   ```

**Правило большого пальца:**
- Данных мало (< 10000 элементов) → используйте список
- Данных много или они не все нужны → используйте генератор
- Нужна гибкость (доступ по индексу, длина, многократный проход) → список
- Нужна экономия памяти или бесконечность → генератор

----

# `19` (`*`) Type hints
[Большое видео про Type hints](https://www.youtube.com/watch?v=RwH2UzC2rIo)

## `19.1` Что такое и зачем нужны?
### **Что такое Type hints?**

**Type hints (аннотации типов)** — это синтаксис Python для указания ожидаемых типов переменных, параметров функций и возвращаемых значений. Это необязательные подсказки, которые не влияют на выполнение кода, но помогают в разработке.

**Основные характеристики:**
- Добавлены в Python 3.5 (PEP 484)
- Не обязательны — Python остаётся динамически типизированным
- Игнорируются интерпретатором Python
- Проверяются внешними инструментами (mypy, pyright, pyre)

**Синтаксис:**

```python
# Без type hints
def greet(name):
    return f"Hello, {name}!"

# С type hints
def greet(name: str) -> str:
    return f"Hello, {name}!"

# Переменные с аннотациями
age: int = 25
price: float = 99.99
items: list[int] = [1, 2, 3]
```

### **Зачем нужны type hints?**
**1. Улучшение читаемости кода**

Сразу видно, какие типы данных ожидаются:

```python
# Непонятно, что принимает и возвращает
def process(data, config):
    return data

# Понятно с первого взгляда
def process(data: dict, config: dict) -> list:
    return list(data.values())
```

**2. Раннее обнаружение ошибок**

Статические анализаторы находят ошибки до запуска кода:

```python
def add(a: int, b: int) -> int:
    return a + b

result = add(5, "10")  # mypy найдёт ошибку: str вместо int
```

**3. Улучшение автодополнения в IDE**

IDE знают типы и предлагают правильные методы:

```python
def get_user(user_id: int) -> dict:
    return {"name": "Alice", "age": 30}

user = get_user(123)
# IDE знает, что user — dict, и предложит .get(), .keys(), .items()
```

**4. Упрощение рефакторинга**

При изменении типов легко найти все места, где нужны правки:

```python
# Меняем возвращаемый тип с dict на list
def get_users(limit: int) -> list:  # было dict
    return []

# Анализатор покажет все места, где код ожидал dict
```

**5. Самодокументирование кода**

Не нужно читать весь код функции, чтобы понять интерфейс:

```python
def calculate_discount(
    price: float,
    discount_percent: float,
    min_price: float = 0.0
) -> float:
    """Вычисляет цену со скидкой"""
    discounted = price * (1 - discount_percent / 100)
    return max(discounted, min_price)
```

### **Практические примеры**
**Пример 1: Функции с type hints**

```python
def calculate_area(width: float, height: float) -> float:
    return width * height

def find_user(user_id: int) -> dict | None:
    """Возвращает пользователя или None"""
    if user_id in database:
        return database[user_id]
    return None
```

**Пример 2: Класс с type hints**

```python
class User:
    def __init__(self, name: str, age: int) -> None:
        self.name: str = name
        self.age: int = age
    
    def get_info(self) -> str:
        return f"{self.name}, {self.age} лет"
    
    def is_adult(self) -> bool:
        return self.age >= 18
```

**Пример 3: Коллекции с типами**

```python
# Списки, словари, множества
numbers: list[int] = [1, 2, 3, 4, 5]
scores: dict[str, int] = {"Alice": 100, "Bob": 95}
tags: set[str] = {"python", "typing"}
coordinates: tuple[float, float] = (12.5, 45.3)
```

### **Важно: Type hints не выполняются во время работы**

```python
def add(a: int, b: int) -> int:
    return a + b

# Python НЕ проверяет типы во время выполнения
result = add("Hello", "World")  # Код выполнится без ошибок!
print(result)  # HelloWorld

# Но mypy найдёт ошибку при статическом анализе
```

### **Когда использовать type hints**
**✅ Используйте:**
- В публичных API и библиотеках
- В больших проектах и командной разработке
- В сложной бизнес-логике
- При работе с внешними данными

**❌ Не обязательно:**
- В небольших скриптах
- В прототипах и экспериментах
- Когда типы очевидны из контекста


## `19.2` Что такое динамическая типизация?
### **Динамическая vs Статическая типизация**
**Динамическая типизация** — это подход, при котором тип переменной определяется во время выполнения программы, а не при компиляции. Python использует динамическую типизацию.

**Статическая типизация** — это подход, при котором типы переменных проверяются на этапе компиляции. Используется в языках как Java, C++, C#, Go.

### **Характеристики динамической типизации**
**1. Тип определяется во время выполнения**

```python
# Переменная может менять тип
x = 5           # x — int
x = "Hello"     # x теперь str
x = [1, 2, 3]   # x теперь list

# В статически типизированных языках это ошибка компиляции
```

**2. Не нужно объявлять типы**

```python
# Python
name = "Alice"
age = 30

# Java требует явное объявление:
# String name = "Alice";
# int age = 30;
```

**3. Проверка типов во время выполнения**

```python
def divide(a, b):
    return a / b

divide(10, 2)      # ✓ Работает
divide("10", "2")  # ✗ TypeError во время выполнения
```

### **Преимущества динамической типизации**
**1. Быстрое прототипирование**

Не тратим время на объявление типов:

```python
users = []
users.append({"name": "Alice", "age": 30})
users.append({"name": "Bob", "age": 25})

for user in users:
    print(user["name"])
```

**2. Duck Typing ("утиная типизация")**

*"Если это ходит как утка и крякает как утка, то это утка"*
Важно не ЧТО это за объект, а ЧТО он умеет делать:

```python
def print_all(items):
    for item in items:
        print(item)

# Работает с любым итерируемым объектом
print_all([1, 2, 3])      # список
print_all("Hello")        # строка
print_all(range(5))       # range
```

**3. Гибкость кода**

Одна функция работает с разными типами:

```python
def double(value):
    return value * 2

print(double(5))        # 10 (int)
print(double("Hi"))     # HiHi (str)
print(double([1, 2]))   # [1, 2, 1, 2] (list)
```

### **Недостатки динамической типизации**
**1. Ошибки обнаруживаются только во время выполнения**

```python
def calculate(a, b):
    return a + b

# Ошибка проявится только при запуске
result = calculate(5, "10")  # TypeError: unsupported operand type(s)
```

**2. Меньше помощи от IDE**

```python
def process(data):
    # IDE не знает методы data
    return data.method()  # Автодополнение не работает
```

**3. Сложнее рефакторинг**

```python
# Изменили возвращаемый тип
def get_users():
    return []  # было dict, стало list

# Нужно вручную найти все места использования
```

### **Сравнение с статической типизацией**

| Характеристика | Динамическая (Python) | Статическая (Java, C++) |
|----------------|----------------------|------------------------|
| **Проверка типов** | Во время выполнения | При компиляции |
| **Объявление типов** | Не требуется | Обязательно |
| **Скорость разработки** | Быстрая | Медленнее |
| **Гибкость** | Высокая | Ограниченная |
| **Обнаружение ошибок** | Во время работы | До запуска |
| **Рефакторинг** | Сложнее | Проще |

### **Type hints — лучшее из двух миров**
Type hints позволяют получить преимущества статической типизации, сохраняя гибкость динамической:

```python
# Динамическая типизация + статический анализ
def add(a: int, b: int) -> int:
    return a + b

# Python выполнит код в любом случае
result = add("Hello", "World")  # Работает во время выполнения

# Но mypy предупредит об ошибке до запуска
# error: Argument 1 to "add" has incompatible type "str"; expected "int"
```

**Подход Python:**
- Код выполняется как обычно (динамическая типизация)
- Статические анализаторы проверяют типы отдельно (опционально)
- Разработчик выбирает уровень строгости проверки типов

## `19.3` Модуль `typing`
Модуль **`typing`** предоставляет расширенные возможности для аннотации типов, которые выходят за рамки базовых типов Python.

**Зачем нужен:**
- Аннотация сложных структур данных
- Указание нескольких возможных типов
- Определение протоколов и callable-объектов
- Создание типизированных коллекций

### **Базовые типы из `typing`**
**1. `Optional` — значение или None**

Используется, когда функция может вернуть значение или `None`:

```python
from typing import Optional

def find_user(user_id: int) -> Optional[dict]:
    """Возвращает пользователя или None"""
    if user_id in users_db:
        return users_db[user_id]
    return None

# Optional[dict] === dict | None (в Python 3.10+)
```

**2. `Union` — один из нескольких типов**

Когда параметр может быть разных типов:

```python
from typing import Union

def process_id(user_id: Union[int, str]) -> str:
    """Принимает int или str"""
    return str(user_id)

# В Python 3.10+ можно использовать |
def process_id(user_id: int | str) -> str:
    return str(user_id)
```

**3. `Any` — любой тип**

Отключает проверку типов для конкретного значения:

```python
from typing import Any

def print_value(value: Any) -> None:
    """Принимает значение любого типа"""
    print(value)

# Используйте экономно — это отключает проверку типов!
```

### **Продвинутые типы**

**4. `Callable` — функции и методы**

Для аннотации функций как параметров:

```python
from typing import Callable

def execute(
    func: Callable[[int, int], int],
    a: int,
    b: int
) -> int:
    """Выполняет функцию, принимающую два int и возвращающую int"""
    return func(a, b)

def add(x: int, y: int) -> int:
    return x + y

def multiply(x: int, y: int) -> int:
    return x * y

result = execute(add, 5, 3)       # 8
result = execute(multiply, 5, 3)  # 15

# Callable[[arg_types], return_type]
```

**5. `Literal` — конкретные значения**

Ограничивает значения конкретным набором:

```python
from typing import Literal

def set_mode(mode: Literal["read", "write", "append"]) -> None:
    """Принимает только конкретные строки"""
    print(f"Режим: {mode}")

set_mode("read")    # ✓ OK
set_mode("write")   # ✓ OK
set_mode("delete")  # ✗ mypy ошибка

# Полезно для ограничения значений
Status = Literal["pending", "success", "error"]

def update_status(status: Status) -> None:
    print(status)
```

### **Коллекции и последовательности**

**6. `Sequence`, `Iterable`, `Mapping`**

Абстрактные типы для более гибких аннотаций:

```python
from typing import Sequence, Iterable, Mapping

def print_items(items: Sequence[int]) -> None:
    """Принимает любую последовательность: list, tuple, range"""
    for item in items:
        print(item)

print_items([1, 2, 3])        # list
print_items((1, 2, 3))        # tuple
print_items(range(1, 4))      # range

def sum_values(data: Mapping[str, int]) -> int:
    """Принимает любое отображение: dict, OrderedDict и т.д."""
    return sum(data.values())

def process_all(items: Iterable[str]) -> None:
    """Принимает любой итерируемый объект"""
    for item in items:
        print(item.upper())
```

### **Практические примеры**
**Пример 1: API клиент**

```python
from typing import Optional, Literal

HttpMethod = Literal["GET", "POST", "PUT", "DELETE"]

class APIClient:
    def request(
        self,
        method: HttpMethod,
        endpoint: str,
        data: Optional[dict] = None
    ) -> dict:
        """Выполняет HTTP запрос"""
        response = self._send(method, endpoint, data)
        return response.json()
    
    def get(self, endpoint: str) -> dict:
        return self.request("GET", endpoint)
    
    def post(self, endpoint: str, data: dict) -> dict:
        return self.request("POST", endpoint, data)
```

**Пример 2: Callback функции**

```python
from typing import Callable

def process_data(
    data: list[int],
    transformer: Callable[[int], int],
    filter_func: Callable[[int], bool]
) -> list[int]:
    """Применяет трансформацию и фильтрацию к данным"""
    transformed = [transformer(x) for x in data]
    return [x for x in transformed if filter_func(x)]

def double(x: int) -> int:
    return x * 2

def is_even(x: int) -> bool:
    return x % 2 == 0

numbers = [1, 2, 3, 4, 5]
result = process_data(numbers, double, is_even)
print(result)  # [2, 4, 6, 8, 10]
```

### **Таблица: Когда использовать какой тип**

| Ситуация | Тип | Пример |
|----------|-----|--------|
| Значение или None | `Optional[T]` или `T \| None` | `Optional[str]` |
| Несколько типов | `Union[T1, T2]` или `T1 \| T2` | `int \| str` |
| Любой тип | `Any` | `Any` |
| Функция как параметр | `Callable` | `Callable[[int], str]` |
| Конкретные значения | `Literal` | `Literal["read", "write"]` |
| Структура словаря | `TypedDict` | `class User(TypedDict): ...` |
| Duck typing | `Protocol` | `class Drawable(Protocol): ...` |
| Константы | `Final` | `Final[int] = 100` |

## `19.4` (`**`) Generics
[Видео про Generics](https://youtu.be/1vtYHS4V1ok?si=zdz5l8v72ejAKgpJ)

**Generics (обобщённые типы)** — это механизм создания функций и классов, которые работают с разными типами данных, сохраняя при этом информацию о конкретном типе.

**Зачем нужны:**
- Переиспользование кода для разных типов
- Сохранение информации о типах
- Безопасность типов без дублирования кода

### **Проблема без Generics**

```python
# Без generics — теряем информацию о типе
def get_first(items: list) -> object:
    return items[0]

numbers = [1, 2, 3]
first = get_first(numbers)  # first имеет тип object, не int!

# IDE не знает, что first — это int
# result = first + 5  # mypy не может проверить
```

### **TypeVar — переменная типа**
`TypeVar` создаёт переменную типа, которая может принимать любой тип:

```python
from typing import TypeVar

T = TypeVar('T')

def get_first(items: list[T]) -> T:
    """Возвращает первый элемент списка любого типа"""
    return items[0]

# mypy понимает типы!
numbers: list[int] = [1, 2, 3]
first_num: int = get_first(numbers)  # T = int

words: list[str] = ["hello", "world"]
first_word: str = get_first(words)   # T = str
```

**Как это работает:**
- `T` — это "заполнитель" для любого типа
- При вызове функции `T` автоматически заменяется на конкретный тип
- mypy отслеживает, что возвращаемый тип совпадает с типом элементов списка

### **Базовые примеры с TypeVar**
**Пример 1: Функция с одним типом**

```python
from typing import TypeVar

T = TypeVar('T')

def identity(value: T) -> T:
    """Возвращает то же значение, что получила"""
    return value

x: int = identity(5)           # T = int
y: str = identity("hello")     # T = str
z: list = identity([1, 2, 3])  # T = list
```

**Пример 2: Функция с двумя параметрами одного типа**

```python
from typing import TypeVar

T = TypeVar('T')

def swap(a: T, b: T) -> tuple[T, T]:
    """Меняет местами два значения одного типа"""
    return (b, a)

x, y = swap(1, 2)           # T = int, result: tuple[int, int]
a, b = swap("hi", "bye")    # T = str, result: tuple[str, str]

# mypy найдёт ошибку
# swap(1, "text")  # ✗ Разные типы!
```

### **Ограничения для TypeVar**
Можно ограничить `TypeVar` конкретными типами:

```python
from typing import TypeVar

# T может быть только int или float
T = TypeVar('T', int, float)

def add(a: T, b: T) -> T:
    return a + b

add(5, 3)      # ✓ OK, T = int
add(5.5, 2.3)  # ✓ OK, T = float
add("a", "b")  # ✗ Ошибка — str не разрешён
```

**Ограничение базовым классом:**

```python
from typing import TypeVar

# T должен быть числом (int, float или их подклассы)
T = TypeVar('T', bound=int | float)

def double(value: T) -> T:
    return value * 2

double(5)      # ✓ OK
double(3.14)   # ✓ OK
double("hi")   # ✗ Ошибка
```


### **Generic классы**
Создание классов, работающих с любыми типами:

```python
from typing import Generic, TypeVar

T = TypeVar('T')

class Stack(Generic[T]):
    """Стек для элементов любого типа"""
    def __init__(self) -> None:
        self._items: list[T] = []
    
    def push(self, item: T) -> None:
        self._items.append(item)
    
    def pop(self) -> T:
        return self._items.pop()
    
    def is_empty(self) -> bool:
        return len(self._items) == 0

# Стек целых чисел
int_stack: Stack[int] = Stack()
int_stack.push(1)
int_stack.push(2)
value: int = int_stack.pop()  # mypy знает, что value — int

# Стек строк
str_stack: Stack[str] = Stack()
str_stack.push("hello")
str_stack.push("world")
text: str = str_stack.pop()  # mypy знает, что text — str

# mypy найдёт ошибку
# int_stack.push("text")  # ✗ Нельзя добавить str в Stack[int]
```

### **Generic с несколькими параметрами**

```python
from typing import Generic, TypeVar

K = TypeVar('K')  # Key
V = TypeVar('V')  # Value

class Pair(Generic[K, V]):
    """Пара ключ-значение"""
    def __init__(self, key: K, value: V) -> None:
        self.key = key
        self.value = value
    
    def get_key(self) -> K:
        return self.key
    
    def get_value(self) -> V:
        return self.value

# Разные комбинации типов
pair1: Pair[str, int] = Pair("age", 30)
pair2: Pair[int, str] = Pair(1, "Alice")
pair3: Pair[str, list[int]] = Pair("numbers", [1, 2, 3])

key: str = pair1.get_key()    # mypy знает, что key — str
value: int = pair1.get_value()  # mypy знает, что value — int
```

### **Практический пример: Repository pattern**

```python
from typing import Generic, TypeVar, Optional

T = TypeVar('T')

class Repository(Generic[T]):
    """Обобщённый репозиторий для работы с данными"""
    def __init__(self) -> None:
        self._data: dict[int, T] = {}
        self._current_id: int = 0
    
    def add(self, item: T) -> int:
        """Добавляет элемент и возвращает его ID"""
        self._current_id += 1
        self._data[self._current_id] = item
        return self._current_id
    
    def get(self, item_id: int) -> Optional[T]:
        """Получает элемент по ID"""
        return self._data.get(item_id)
    
    def get_all(self) -> list[T]:
        """Возвращает все элементы"""
        return list(self._data.values())

# Используем для разных типов
class User:
    def __init__(self, name: str, age: int) -> None:
        self.name = name
        self.age = age

class Product:
    def __init__(self, title: str, price: float) -> None:
        self.title = title
        self.price = price

# Репозиторий пользователей
user_repo: Repository[User] = Repository()
user_id = user_repo.add(User("Alice", 30))
user = user_repo.get(user_id)  # mypy знает, что user — Optional[User]

# Репозиторий продуктов
product_repo: Repository[Product] = Repository()
product_id = product_repo.add(Product("Laptop", 1000.0))
product = product_repo.get(product_id)  # mypy знает, что product — Optional[Product]
```

### **Когда использовать Generics**

**✅ Используйте Generics когда:**
- Пишете контейнеры или коллекции (Stack, Queue, List)
- Создаёте функции обработки данных, работающие с любыми типами
- Реализуете паттерны (Repository, Factory, Builder)
- Нужна типобезопасность без дублирования кода

**❌ Не нужны Generics когда:**
- Функция всегда работает с конкретным типом
- Тип не важен для логики (используйте `Any`)
- Код простой и не будет переиспользоваться


## `19.5` (`**`) Ковариантность, контрвариантность и инвариантность
Эти понятия описывают, как связаны типы при наследовании и как они могут быть заменены друг другом.

**Простыми словами:**
- **Ковариантность** — можно заменить базовый тип на подтип
- **Контрвариантность** — можно заменить подтип на базовый тип
- **Инвариантность** — нельзя заменять типы вообще

### **Базовая иерархия классов**

```python
class Animal:
    def speak(self) -> str:
        return "Some sound"

class Dog(Animal):
    def speak(self) -> str:
        return "Woof!"

class Cat(Animal):
    def speak(self) -> str:
        return "Meow!"
```

`Dog` и `Cat` — это **подтипы** `Animal`


### **Ковариантность (Covariance)**
**Определение:** Можно использовать более специфичный тип вместо общего.

**Пример с возвращаемым значением:**

```python
from typing import Callable

# Функция возвращает Animal
def get_animal() -> Animal:
    return Animal()

# Функция возвращает Dog (подтип Animal)
def get_dog() -> Dog:
    return Dog()

# ✓ Ковариантность: Dog можно использовать вместо Animal
animal_getter: Callable[[], Animal] = get_dog  # OK!

# Почему это работает?
# Если ожидается Animal, то Dog тоже подходит (Dog IS-A Animal)
```

**Практический пример:**

```python
def process_animals(animals: list[Animal]) -> None:
    for animal in animals:
        print(animal.speak())

# ✗ Это НЕ работает из-за инвариантности list
dogs: list[Dog] = [Dog(), Dog()]
# process_animals(dogs)  # Ошибка mypy!

# ✓ Решение: используйте Sequence (ковариантный тип)
from typing import Sequence

def process_animals_safe(animals: Sequence[Animal]) -> None:
    for animal in animals:
        print(animal.speak())

dogs: list[Dog] = [Dog(), Dog()]
process_animals_safe(dogs)  # ✓ OK!
```

### **Контрвариантность (Contravariance)**
**Определение:** Можно использовать более общий тип вместо специфичного (звучит странно, но это про параметры функций).

**Пример с параметрами функции:**

```python
from typing import Callable

# Функция принимает Animal
def feed_animal(animal: Animal) -> None:
    print(f"Feeding: {animal.speak()}")

# Функция принимает Dog (более специфичный тип)
def feed_dog(dog: Dog) -> None:
    print(f"Feeding dog: {dog.speak()}")

# ✓ Контрвариантность: функция с Animal может использоваться для Dog
dog_feeder: Callable[[Dog], None] = feed_animal  # OK!

# Почему это работает?
# Если функция умеет работать с Animal, она умеет работать и с Dog
```

**Визуализация:**

```
Animal (базовый)
  ↓
Dog (подтип)

Ковариантность (возвращаемое значение):
  Animal ← Dog ✓ (Dog можно вместо Animal)

Контрвариантность (параметры):
  Animal → Dog ✓ (Animal можно вместо Dog)
```

### **Инвариантность (Invariance)**
**Определение:** Тип должен совпадать точно, замены не допускаются.

**Пример:**

```python
# list, dict, set — инвариантные типы

def add_animal(animals: list[Animal]) -> None:
    animals.append(Animal())

dogs: list[Dog] = [Dog(), Dog()]
# add_animal(dogs)  # ✗ Ошибка mypy!

# Почему это ошибка?
# Если бы это работало, мы бы добавили Animal в список Dog!
# dogs = [Dog(), Dog(), Animal()]  # Теперь в списке Dog есть просто Animal!
```

**Проблема с инвариантностью:**

```python
# Если бы list был ковариантным (это НЕ так!)
dogs: list[Dog] = [Dog()]
animals: list[Animal] = dogs  # Представим, что это OK

# Теперь можем добавить Cat в список Dog!
animals.append(Cat())  # Это был бы список Dog, но мы добавили Cat!

# dogs теперь содержит Cat! Это нарушает типобезопасность
```


### **TypeVar с вариантностью**

```python
from typing import TypeVar

# Инвариантный (по умолчанию)
T = TypeVar('T')

# Ковариантный — для возвращаемых значений
T_co = TypeVar('T_co', covariant=True)

# Контрвариантный — для параметров
T_contra = TypeVar('T_contra', contravariant=True)
```

**Пример с ковариантностью:**

```python
from typing import TypeVar, Generic

T_co = TypeVar('T_co', covariant=True)

class Box(Generic[T_co]):
    """Контейнер только для чтения (ковариантный)"""
    def __init__(self, item: T_co) -> None:
        self._item = item
    
    def get(self) -> T_co:
        return self._item

# ✓ Ковариантность работает
dog_box: Box[Dog] = Box(Dog())
animal_box: Box[Animal] = dog_box  # OK! Dog -> Animal
```

**Пример с контрвариантностью:**

```python
from typing import TypeVar, Generic

T_contra = TypeVar('T_contra', contravariant=True)

class Handler(Generic[T_contra]):
    """Обработчик (контрвариантный)"""
    def handle(self, item: T_contra) -> None:
        print(f"Handling: {item}")

# ✓ Контрвариантность работает
animal_handler: Handler[Animal] = Handler()
dog_handler: Handler[Dog] = animal_handler  # OK! Animal -> Dog
```

### **Практическая таблица**

| Вариантность | Когда использовать | Пример | Замена |
|--------------|-------------------|--------|--------|
| **Ковариантность** | Только чтение (возвращаемые значения) | `Sequence[T]`, `Iterable[T]` | `Dog` → `Animal` ✓ |
| **Контрвариантность** | Только запись (параметры функций) | Редко используется | `Animal` → `Dog` ✓ |
| **Инвариантность** | Чтение и запись | `list[T]`, `dict[K,V]` | Замена запрещена ✗ |


### **Практический совет**

**Для 99% случаев запомните:**
1. **Возвращаемые значения** — ковариантны (подтип вместо базового ✓)
2. **Параметры функций** — контрвариантны (базовый вместо подтипа ✓)
3. **Изменяемые коллекции** (`list`, `dict`) — инвариантны (точное совпадение)
4. **Неизменяемые коллекции** (`Sequence`, `Iterable`) — ковариантны

**Когда в сомнениях:**
- Используйте `Sequence[T]` вместо `list[T]` для параметров функций
- Используйте `Iterable[T]` для максимальной гибкости
- Не беспокойтесь о вариантности в простых случаях — mypy подскажет, если что-то не так!


## `19.6` Совместимость с другими версиями
`Type hints` эволюционировали с каждой версией Python, добавляя новые возможности и упрощая синтаксис. Важно понимать, какие фичи доступны в разных версиях.

### **История развития type hints**

| Версия | Год | Основные изменения |
|--------|-----|-------------------|
| **Python 3.5** | 2015 | Первое появление type hints (PEP 484), модуль `typing` |
| **Python 3.6** | 2016 | Аннотации переменных, `typing.NamedTuple` |
| **Python 3.7** | 2018 | `from __future__ import annotations`, улучшения `dataclass` |
| **Python 3.8** | 2019 | `Literal`, `Final`, `TypedDict`, `Protocol` |
| **Python 3.9** | 2020 | Встроенные дженерики (`list[int]` вместо `List[int]`) |
| **Python 3.10** | 2021 | Union types с `|` оператором (`int | str`) |
| **Python 3.11** | 2022 | `Self` тип, улучшения производительности |
| **Python 3.12** | 2023 | Синтаксис для дженериков, улучшенная поддержка типов |


### **Python 3.5-3.8: Старый синтаксис**
**Нужно импортировать типы из `typing`:**

```python
from typing import List, Dict, Set, Tuple, Optional, Union

# Коллекции
numbers: List[int] = [1, 2, 3]
scores: Dict[str, int] = {"Alice": 100}
tags: Set[str] = {"python"}
coords: Tuple[float, float] = (10.5, 20.3)

# Опциональные типы
def find_user(user_id: int) -> Optional[Dict]:
    pass

# Union типы
def process(value: Union[int, str]) -> str:
    return str(value)
```

### **Python 3.9+: Упрощённый синтаксис**
**Можно использовать встроенные типы напрямую:**

```python
# Не нужен импорт из typing!
numbers: list[int] = [1, 2, 3]
scores: dict[str, int] = {"Alice": 100}
tags: set[str] = {"python"}
coords: tuple[float, float] = (10.5, 20.3)

# Optional всё ещё нужен из typing
from typing import Optional
def find_user(user_id: int) -> Optional[dict]:
    pass

# Но Union можно заменить на |
def process(value: int | str) -> str:
    return str(value)
```

### **Python 3.10+: Оператор `|` для Union**
**Новый способ указания нескольких типов:**

```python
# Старый способ (работает везде)
from typing import Union, Optional
def process(value: Union[int, str, float]) -> Union[str, None]:
    pass

# Новый способ (Python 3.10+)
def process(value: int | str | float) -> str | None:
    pass

# Optional[T] теперь можно писать как T | None
def find_user(user_id: int) -> dict | None:
    pass
```

### **Обратная совместимость: `from __future__ import annotations`**
Если нужно использовать новый синтаксис в старых версиях Python:

```python
from __future__ import annotations

# Теперь работает в Python 3.7+
def get_items() -> list[int]:
    return [1, 2, 3]

def process(value: int | str) -> str:
    return str(value)
```

**Как это работает:**
- Аннотации становятся строками и не вычисляются во время импорта
- Позволяет использовать синтаксис из новых версий
- Анализаторы типов всё равно понимают аннотации

**Ограничения:**
- Не работает для `isinstance()` и `issubclass()` проверок
- Добавляет небольшой overhead при использовании рефлексии

### **Таблица совместимости**
| Фича | Python 3.5-3.8 | Python 3.9+ | Python 3.10+ |
|------|---------------|-------------|--------------|
| Базовые аннотации | ✅ | ✅ | ✅ |
| `typing.List[int]` | ✅ | ✅ (устарел) | ✅ (устарел) |
| `list[int]` | ❌ | ✅ | ✅ |
| `Union[int, str]` | ✅ | ✅ | ✅ (устарел) |
| `int \| str` | ❌ | ❌ | ✅ |
| `Optional[int]` | ✅ | ✅ | ✅ |
| `int \| None` | ❌ | ❌ | ✅ |
| `TypedDict` | ✅ (3.8+) | ✅ | ✅ |
| `Protocol` | ✅ (3.8+) | ✅ | ✅
| `Literal` | ✅ (3.8+) | ✅ | ✅ |
| `Final` | ✅ (3.8+) | ✅ | ✅ |
| `Self` | ❌ | ❌ | ✅ (3.11+) |


### **Рекомендации по использованию**
**Если вы пишете для Python 3.9+:**

```python
# ✅ Используйте встроенные типы
numbers: list[int] = [1, 2, 3]
user: dict[str, str] = {"name": "Alice"}

# ✅ Используйте | для Union в Python 3.10+
def process(value: int | str | None) -> str:
    return str(value) if value else ""

# ✅ Optional можно заменить на T | None
def find_item(item_id: int) -> dict | None:
    pass
```

**Если нужна поддержка Python 3.7-3.8:**
```python
from __future__ import annotations
from typing import Optional, Union

# Теперь работает новый синтаксис
def get_users() -> list[dict[str, int]]:
    return [{"age": 30}]

# Но для Union и Optional всё равно нужен typing
def process(value: Union[int, str]) -> Optional[str]:
    pass
```

**Если нужна поддержка Python 3.5-3.6:**
```python
from typing import List, Dict, Optional, Union

# Старый синтаксис
def get_users() -> List[Dict[str, int]]:
    return [{"age": 30}]

def process(value: Union[int, str]) -> Optional[str]:
    pass
```

### **Forward References (Отложенные аннотации)**
Проблема возникает, когда тип ещё не определён:

```python
# ❌ Ошибка: User ещё не определён
class User:
    def get_friend(self) -> User:
        pass

# ✅ Решение 1: Строковая аннотация
class User:
    def get_friend(self) -> "User":
        pass

# ✅ Решение 2: from __future__ import annotations
from __future__ import annotations

class User:
    def get_friend(self) -> User:
        pass
```

**Пример с циклическими зависимостями:**
```python
from __future__ import annotations
from typing import Optional

class TreeNode:
    def __init__(self, value: int) -> None:
        self.value: int = value
        self.left: Optional[TreeNode] = None
        self.right: Optional[TreeNode] = None
    
    def add_left(self, node: TreeNode) -> TreeNode:
        self.left = node
        return self
    
    def add_right(self, node: TreeNode) -> TreeNode:
        self.right = node
        return self
```

### **Проверка типов в runtime**
Type hints **не проверяются** Python во время выполнения, но есть инструменты для runtime-проверки:

**1. Использование `isinstance()` — не работает с типами из `typing`:**

```python
from typing import List

numbers: List[int] = [1, 2, 3]

# ❌ Не работает
isinstance(numbers, List[int])  # TypeError

# ✅ Работает только для базового типа
isinstance(numbers, list)  # True
```

**2. Библиотека `typeguard` для runtime-проверки:**

```python
from typeguard import typechecked

@typechecked
def add(a: int, b: int) -> int:
    return a + b

add(5, 3)      # ✓ OK
add(5, "3")    # ✗ TypeError во время выполнения
```

**3. Библиотека `pydantic` для валидации данных:**

```python
from pydantic import BaseModel

class User(BaseModel):
    name: str
    age: int
    email: str

# ✓ Валидация успешна
user = User(name="Alice", age=30, email="alice@mail.com")

# ✗ ValidationError — age должен быть int
user = User(name="Bob", age="25", email="bob@mail.com")
```

### **Статические анализаторы типов**
Для проверки типов используются внешние инструменты:

**1. mypy — самый популярный**

```bash
# Установка
pip install mypy

# Проверка файла
mypy script.py

# Проверка проекта
mypy .
```

**Пример использования:**

```python
# script.py
def greet(name: str) -> str:
    return f"Hello, {name}!"

result = greet(123)  # Ошибка типа
```

```bash
$ mypy script.py
script.py:4: error: Argument 1 to "greet" has incompatible type "int"; expected "str"
```

**2. pyright — от Microsoft**

```bash
# Установка
pip install pyright

# Проверка
pyright script.py
```

**3. pyre — от Facebook/Meta**

```bash
# Установка
pip install pyre-check

# Проверка
pyre check
```

**4. pytype — от Google**

```bash
# Установка
pip install pytype

# Проверка
pytype script.py
```

### **Настройка mypy**
Создайте файл `mypy.ini` или `pyproject.toml`:

**mypy.ini:**

```ini
[mypy]
python_version = 3.10
warn_return_any = True
warn_unused_configs = True
disallow_untyped_defs = True
disallow_any_generics = True
check_untyped_defs = True
no_implicit_optional = True
warn_redundant_casts = True
warn_unused_ignores = True
warn_no_return = True
strict = False

# Игнорировать определённые модули
[mypy-some_library.*]
ignore_missing_imports = True
```

**pyproject.toml:**

```toml
[tool.mypy]
python_version = "3.10"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
```

### **Игнорирование ошибок типов**
Иногда нужно отключить проверку для конкретной строки:

```python
# Игнорировать ошибку на этой строке
result = some_function()  # type: ignore

# Игнорировать конкретный тип ошибки
result = some_function()  # type: ignore[arg-type]

# Игнорировать весь файл
# mypy: ignore-errors
```

**Когда использовать `type: ignore`:**
- При работе с библиотеками без type hints
- Для legacy кода
- Когда mypy ошибается (редко)
- В тестах с mock-объектами

### **Миграция проекта на type hints**
**Шаг 1: Установите mypy**

```bash
pip install mypy
```

**Шаг 2: Запустите проверку**

```bash
mypy . --ignore-missing-imports
```

**Шаг 3: Добавляйте аннотации постепенно**

Начните с публичных API:

```python
# До
def calculate_discount(price, percent):
    return price * (1 - percent / 100)

# После
def calculate_discount(price: float, percent: float) -> float:
    return price * (1 - percent / 100)
```

**Шаг 4: Используйте `# type: ignore` временно**

Для legacy кода, который сложно типизировать:

```python
def legacy_function(data):  # type: ignore
    # Сложная логика без типов
    pass
```

**Шаг 5: Настройте строгость постепенно**

```ini
# mypy.ini — начните с мягких настроек
[mypy]
warn_return_any = True
warn_unused_configs = True

# Постепенно добавляйте строгость
disallow_untyped_defs = True
strict = True
```

### **Практические примеры совместимости**
**Пример 1: Универсальный код для разных версий**

```python
from __future__ import annotations
from typing import Optional, List, Dict, Union
import sys

# Проверка версии Python
if sys.version_info >= (3, 10):
    # Python 3.10+ — используем | оператор
    def process(value: int | str | None) -> str | None:
        return str(value) if value else None
else:
    # Старые версии — используем Union
    def process(value: Union[int, str, None]) -> Optional[str]:
        return str(value) if value else None
```

**Пример 2: Совместимость с TypedDict**

```python
from typing import TypedDict

# Python 3.8+
class User(TypedDict):
    name: str
    age: int

# Для Python 3.7 используйте альтернативный синтаксис
User = TypedDict('User', {
    'name': str,
    'age': int
})
```

**Пример 3: Совместимость с Protocol**

```python
from typing import Protocol

# Python 3.8+
class Drawable(Protocol):
    def draw(self) -> None: ...

# Для Python 3.7 используйте typing_extensions
try:
    from typing import Protocol
except ImportError:
    from typing_extensions import Protocol

class Drawable(Protocol):
    def draw(self) -> None: ...
```


### **Библиотека `typing_extensions`**
Для использования новых фич в старых версиях Python:

```bash
pip install typing_extensions
```

```python
from typing_extensions import (
    Literal,      # Доступен в 3.8+, но можно использовать в 3.7
    TypedDict,    # Доступен в 3.8+, но можно использовать в 3.7
    Protocol,     # Доступен в 3.8+, но можно использовать в 3.7
    Final,        # Доступен в 3.8+, но можно использовать в 3.7
    Self,         # Доступен в 3.11+, но можно использовать раньше
)

# Теперь работает в Python 3.7
Mode = Literal["read", "write", "append"]

def open_file(filename: str, mode: Mode) -> None:
    pass
```

### **Выводы и best practices**
**✅ Рекомендации:**
1. **Используйте type hints в новом коде** — это улучшает читаемость и помогает найти ошибки
2. **Начинайте с публичного API** — функции, классы, методы, которые используют другие разработчики
3. **Используйте современный синтаксис** — если проект на Python 3.9+, используйте `list[int]` вместо `List[int]`
4. **Проверяйте типы с mypy** — добавьте проверку в CI/CD pipeline
5. **Не переусердствуйте** — не нужно типизировать каждую переменную в скриптах
6. **Используйте `from __future__ import annotations`** — для совместимости и производительности

**❌ Чего избегать:**
1. Не используйте `Any` без необходимости — это отключает проверку типов
2. Не игнорируйте все ошибки mypy — используйте `type: ignore` точечно
3. Не используйте устаревший синтаксис в новых проектах — `List[int]` вместо `list[int]`
4. Не проверяйте типы во runtime без необходимости — это замедляет код

**Итоговая таблица: Какой синтаксис использовать**
| Версия Python | Рекомендуемый синтаксис |
|---------------|------------------------|
| **3.5-3.6** | `from typing import List, Dict`<br>`List[int]`, `Dict[str, int]` |
| **3.7-3.8** | `from __future__ import annotations`<br>`list[int]`, `dict[str, int]` |
| **3.9** | `list[int]`, `dict[str, int]`<br>`Union[int, str]` для множественных типов |
| **3.10+** | `list[int]`, `dict[str, int]`<br>`int \| str` для множественных типов |
| **3.11+** | Современный синтаксис + `Self` для методов классов |



















----



# `20` (`**`) Extra Python  
_P.S: only for flexing on the job interview_  

## `20.1` Модуль `itertools`  
## `20.2` Модуль `functools`  
## `20.3` Регулярные выражения. Модуль `re`  

----

# `21` (`*`) Cache & Hash
[Небольшое видео про Cache в Python](https://youtu.be/IR4dmy0uu4s?si=2v3nxyKQXPan3BY4)
[Как работают словари в Python | Хэш-таблицы](https://www.youtube.com/watch?v=6XS-wzpWs7E)

## `21.1` Что такое кэш?
**Что такое кэш?**

`Кэш` — это способ сохранить результаты работы программы, чтобы не делать одну и ту же работу дважды.

**Аналогия из жизни:**

Представьте, что вы решаете математическую задачу на листочке. Задача сложная, вы потратили 10 минут. Потом друг просит решить такую же задачу. Что вы сделаете?

- **Без кэша:** Решите задачу заново, потратите еще 10 минут
- **С кэшем:** Покажете уже готовое решение с листочка, потратите 5 секунд

Кэш в программировании работает точно так же — сохраняет результаты, чтобы не пересчитывать.

**Как работает кэш:**

1. Программа получает задачу
2. Проверяет: "А я уже решал такую задачу?"
3. Если **да** — берет готовый ответ из кэша (быстро!)
4. Если **нет** — решает задачу, сохраняет ответ в кэш (медленно, но только один раз)

**Пример 1: Медленная функция без кэша**

```python
import time

def slow_function(n):
    """Функция, которая долго работает"""
    print(f"Вычисляю для {n}...")
    time.sleep(2)  # Имитация долгой работы (2 секунды)
    return n * 2

# Вызываем несколько раз
print(slow_function(5))  # Вычисляю для 5... -> 10 (ждем 2 сек)
print(slow_function(5))  # Вычисляю для 5... -> 10 (опять ждем 2 сек!)
print(slow_function(5))  # Вычисляю для 5... -> 10 (и снова 2 сек!)

# Всего 6 секунд на одну и ту же задачу!
```

**Пример 2: Функция с ручным кэшем**

```python
import time

# Создаем "хранилище" для результатов
cache = {}

def slow_function_with_cache(n):
    """Функция с кэшем"""
    # Проверяем: есть ли уже результат?
    if n in cache:
        print(f"Беру из кэша для {n}!")
        return cache[n]  # Возвращаем сохраненный результат
    
    # Если нет — вычисляем
    print(f"Вычисляю для {n}...")
    time.sleep(2)
    result = n * 2
    
    # Сохраняем в кэш
    cache[n] = result
    return result

# Вызываем несколько раз
print(slow_function_with_cache(5))  # Вычисляю для 5... -> 10 (2 сек)
print(slow_function_with_cache(5))  # Беру из кэша для 5! -> 10 (мгновенно!)
print(slow_function_with_cache(5))  # Беру из кэша для 5! -> 10 (мгновенно!)

# Всего 2 секунды вместо 6!

print(cache)  # {5: 10} — результат сохранен
```

**Зачем нужен кэш:**

1. **Ускорение программы** — не делаем одну работу много раз
2. **Экономия ресурсов** — не нагружаем процессор/память лишними вычислениями
3. **Уменьшение нагрузки** — меньше запросов к базам данных, API, файлам

**Где используется кэш:**

- Веб-браузеры (сохраняют картинки с сайтов, чтобы не загружать их снова)
- Процессоры (сохраняют данные из памяти для быстрого доступа)
- Базы данных (сохраняют результаты частых запросов)
- Ваши программы (сохраняют результаты функций)

**Важно понимать:**

Кэш — это **компромисс**:
- ✅ Плюс: программа работает быстрее
- ❌ Минус: используется дополнительная память для хранения результатов


## `21.2` `lru_cache` и мемоизация
**Что такое мемоизация?**

**Мемоизация** — это умное слово для "запоминания результатов функции". Это техника кэширования специально для функций.

Правило мемоизации простое:
- Если функцию вызвали с теми же аргументами — вернуть сохраненный результат
- Если с новыми аргументами — вычислить и сохранить

**Что такое `lru_cache`?**

`lru_cache` — это готовый инструмент в Python для автоматической мемоизации. Это декоратор (специальная "обертка" для функций).

**LRU** означает **Least Recently Used** (наименее недавно использованный) — если кэш переполняется, удаляются самые старые результаты.

**Пример 1: Классическая задача — числа Фибоначчи**

Числа Фибоначчи: 0, 1, 1, 2, 3, 5, 8, 13, 21...
Каждое число = сумма двух предыдущих.

```python
# БЕЗ кэша (медленно!)
def fibonacci_slow(n):
    """Вычисление n-го числа Фибоначчи"""
    if n <= 1:
        return n
    return fibonacci_slow(n - 1) + fibonacci_slow(n - 2)

# Попробуем посчитать
import time

start = time.time()
print(fibonacci_slow(35))  # 9227465
end = time.time()
print(f"Время: {end - start:.2f} секунд")  # ~3-5 секунд!

# Почему медленно? Функция вызывается МИЛЛИОНЫ раз!
# fibonacci_slow(5) вызывает fibonacci_slow(4) и fibonacci_slow(3)
# fibonacci_slow(4) вызывает fibonacci_slow(3) и fibonacci_slow(2)
# fibonacci_slow(3) вычисляется много раз!
```

```python
# С lru_cache (быстро!)
from functools import lru_cache

@lru_cache(maxsize=None)  # maxsize=None — неограниченный размер кэша
def fibonacci_fast(n):
    """То же самое, но с кэшем"""
    if n <= 1:
        return n
    return fibonacci_fast(n - 1) + fibonacci_fast(n - 2)

start = time.time()
print(fibonacci_fast(35))  # 9227465
end = time.time()
print(f"Время: {end - start:.6f} секунд")  # ~0.000030 секунд!

# В 100000 раз быстрее! Каждое число вычисляется только один раз
```

**Как работает `@lru_cache`:**

```python
from functools import lru_cache

@lru_cache(maxsize=128)  # Хранить максимум 128 результатов
def expensive_function(x, y):
    """Дорогая функция (долго работает)"""
    print(f"Вычисляю для x={x}, y={y}")
    # Имитация сложных вычислений
    result = x ** y
    return result

# Первый вызов — вычисляется
print(expensive_function(2, 10))  # Вычисляю для x=2, y=10 -> 1024

# Второй вызов с теми же аргументами — из кэша!
print(expensive_function(2, 10))  # (ничего не печатает) -> 1024

# Третий вызов с другими аргументами — вычисляется
print(expensive_function(3, 5))   # Вычисляю для x=3, y=5 -> 243

# Четвертый — снова из кэша
print(expensive_function(2, 10))  # -> 1024 (мгновенно)
```

**Пример 2: Факториал**

```python
from functools import lru_cache

@lru_cache(maxsize=None)
def factorial(n):
    """Факториал числа n"""
    print(f"Вычисляю факториал {n}")
    if n <= 1:
        return 1
    return n * factorial(n - 1)

print(factorial(5))
# Вычисляю факториал 5
# Вычисляю факториал 4
# Вычисляю факториал 3
# Вычисляю факториал 2
# Вычисляю факториал 1
# -> 120

print(factorial(5))  # (ничего не печатает) -> 120 из кэша!

print(factorial(6))
# Вычисляю факториал 6 (только одно вычисление!)
# factorial(5) уже в кэше
# -> 720
```

**Параметры `lru_cache`:**

```python
from functools import lru_cache

# Кэш на 128 элементов (по умолчанию)
@lru_cache(maxsize=128)
def func1(x):
    return x * 2

# Неограниченный кэш
@lru_cache(maxsize=None)
def func2(x):
    return x * 2

# Без типизации (typed=False по умолчанию)
# func(1) и func(1.0) — одно и то же
@lru_cache(maxsize=128, typed=False)
def func3(x):
    return x * 2

# С типизацией (typed=True)
# func(1) и func(1.0) — разные вызовы
@lru_cache(maxsize=128, typed=True)
def func4(x):
    return x * 2
```

**Управление кэшем:**

```python
from functools import lru_cache

@lru_cache(maxsize=3)
def add(a, b):
    print(f"Вычисляю {a} + {b}")
    return a + b

add(1, 2)  # Вычисляю 1 + 2 -> 3
add(2, 3)  # Вычисляю 2 + 3 -> 5
add(1, 2)  # (из кэша) -> 3

# Посмотреть информацию о кэше
print(add.cache_info())
# CacheInfo(hits=1, misses=2, maxsize=3, currsize=2)
# hits — сколько раз взяли из кэша
# misses — сколько раз вычисляли
# currsize — текущий размер кэша

# Очистить кэш
add.cache_clear()
print(add.cache_info())
# CacheInfo(hits=0, misses=0, maxsize=3, currsize=0)

add(1, 2)  # Вычисляю 1 + 2 -> 3 (снова вычисляет)
```

**Когда использовать `lru_cache`:**

✅ **Используйте когда:**
- Функция вызывается много раз с одинаковыми аргументами
- Функция чистая (всегда возвращает одинаковый результат для одинаковых аргументов)
- Функция выполняется долго (сложные вычисления, обращения к базе данных)

❌ **НЕ используйте когда:**
- Функция возвращает разные результаты для одинаковых аргументов (использует случайность, время)
- Аргументы функции не могут быть хэшированы (списки, словари)
- Функция имеет побочные эффекты (изменяет глобальные переменные, файлы)

**Пример неправильного использования:**

```python
from functools import lru_cache
import random

# ❌ ПЛОХО — результат случайный!
@lru_cache
def get_random():
    return random.randint(1, 100)

print(get_random())  # 42
print(get_random())  # 42 (одно и то же!)
print(get_random())  # 42 (всегда одно и то же!)

# Кэш "заморозил" первое случайное число
```


## `21.3` Методы кэширования
Кроме `lru_cache`, существуют разные способы кэширования в зависимости от задачи.

### **1. Ручной кэш (словарь)**

Самый простой способ — использовать обычный словарь.

**Пример 1: Кэш для функции с одним аргументом**

```python
# Глобальный словарь для хранения результатов
cache = {}

def square(n):
    """Возведение в квадрат с кэшированием"""
    if n in cache:
        print(f"Из кэша: {n}")
        return cache[n]
    
    print(f"Вычисляю: {n}")
    result = n ** 2
    cache[n] = result
    return result

print(square(5))   # Вычисляю: 5 -> 25
print(square(5))   # Из кэша: 5 -> 25
print(square(10))  # Вычисляю: 10 -> 100
print(square(5))   # Из кэша: 5 -> 25
```

**Пример 2: Кэш для функции с несколькими аргументами**

```python
cache = {}

def multiply(a, b):
    """Умножение с кэшированием"""
    # Ключ — кортеж из аргументов
    key = (a, b)
    
    if key in cache:
        print(f"Из кэша: {a} * {b}")
        return cache[key]
    
    print(f"Вычисляю: {a} * {b}")
    result = a * b
    cache[key] = result
    return result

print(multiply(3, 4))   # Вычисляю: 3 * 4 -> 12
print(multiply(3, 4))   # Из кэша: 3 * 4 -> 12
print(multiply(5, 6))   # Вычисляю: 5 * 6 -> 30
```

### **2. Кэш внутри функции (замыкание)**

Можно хранить кэш прямо внутри функции, используя атрибуты функции.

```python
def cached_function(n):
    """Функция со встроенным кэшем"""
    # Проверяем, есть ли атрибут cache у функции
    if not hasattr(cached_function, 'cache'):
        cached_function.cache = {}  # Создаем кэш
    
    # Проверяем кэш
    if n in cached_function.cache:
        print(f"Из кэша: {n}")
        return cached_function.cache[n]
    
    # Вычисляем
    print(f"Вычисляю: {n}")
    result = n ** 3
    cached_function.cache[n] = result
    return result

print(cached_function(2))  # Вычисляю: 2 -> 8
print(cached_function(2))  # Из кэша: 2 -> 8
print(cached_function(3))  # Вычисляю: 3 -> 27

# Можем посмотреть кэш
print(cached_function.cache)  # {2: 8, 3: 27}
```

### **3. Свой декоратор для кэширования**

Можно написать собственный декоратор, который добавляет кэширование к любой функции.

```python
def simple_cache(func):
    """Декоратор для простого кэширования"""
    cache = {}
    
    def wrapper(*args):
        # Используем args (аргументы) как ключ
        if args in cache:
            print(f"Из кэша для {func.__name__}{args}")
            return cache[args]
        
        print(f"Вычисляю {func.__name__}{args}")
        result = func(*args)
        cache[args] = result
        return result
    
    return wrapper

# Применяем декоратор
@simple_cache
def add(a, b):
    return a + b

@simple_cache
def power(base, exp):
    return base ** exp

print(add(2, 3))      # Вычисляю add(2, 3) -> 5
print(add(2, 3))      # Из кэша для add(2, 3) -> 5
print(power(2, 10))   # Вычисляю power(2, 10) -> 1024
print(power(2, 10))   # Из кэша для power(2, 10) -> 1024
```

### **4. cache (новый в Python 3.9+)**

В Python 3.9 появился упрощенный вариант `lru_cache` — просто `cache`.

```python
from functools import cache  # Только Python 3.9+

@cache  # Эквивалентно @lru_cache(maxsize=None)
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

print(fibonacci(100))  # Очень быстро!
```

### **5. Кэш с ограничением по времени (TTL — Time To Live)**

Иногда нужно, чтобы кэш "протухал" через определенное время.

```python
import time

def cache_with_ttl(ttl_seconds):
    """Декоратор с кэшем, который живет ttl_seconds"""
    def decorator(func):
        cache = {}
        
        def wrapper(*args):
            current_time = time.time()
            
            # Проверяем кэш
            if args in cache:
                result, timestamp = cache[args]
                # Если кэш свежий — используем
                if current_time - timestamp < ttl_seconds:
                    print(f"Из кэша (возраст: {current_time - timestamp:.1f}с)")
                    return result
                else:
                    print("Кэш устарел, пересчитываю")
            
            # Вычисляем и сохраняем с временной меткой
            print("Вычисляю")
            result = func(*args)
            cache[args] = (result, current_time)
            return result
        
        return wrapper
    return decorator

@cache_with_ttl(ttl_seconds=3)  # Кэш живет 3 секунды
def get_data(n):
    return n * 2

print(get_data(5))    # Вычисляю -> 10
time.sleep(1)
print(get_data(5))    # Из кэша (возраст: 1.0с) -> 10
time.sleep(3)
print(get_data(5))    # Кэш устарел, пересчитываю -> 10
```

### **6. Кэш на уровне класса**

Если у вас есть класс, можно кэшировать методы.

```python
from functools import lru_cache

class Calculator:
    @lru_cache(maxsize=128)
    def factorial(self, n):
        """Факториал с кэшем"""
        print(f"Вычисляю факториал {n}")
        if n <= 1:
            return 1
        return n * self.factorial(n - 1)

calc = Calculator()
print(calc.factorial(5))   # Вычисления
print(calc.factorial(5))   # Из кэша
print(calc.factorial(6))   # Только одно новое вычисление
```

### **Сравнение методов:**

| Метод | Простота | Гибкость | Когда использовать |
|-------|----------|----------|-------------------|
| Ручной словарь | Легко | Максимальная | Простые случаи, обучение |
| `lru_cache` | Очень легко | Средняя | Большинство случаев |
| `cache` | Очень легко | Низкая | Неограниченный кэш |
| Свой декоратор | Сложнее | Максимальная | Особые требования |
| Кэш с TTL | Средне | Высокая | Данные устаревают |


## `21.4` Что такое хэш?
**Что такое хэш?**

`Хэш (hash)` — это число, которое получается из любых данных по специальной формуле. Это как "отпечаток пальца" для данных.

**Аналогия:**

Представьте библиотеку с миллионом книг. Как быстро найти нужную книгу?

- **Плохой способ:** Смотреть все книги по порядку (медленно!)
- **Хороший способ:** У каждой книги есть номер-код. По этому коду вы сразу знаете, на какой полке искать

Хэш — это и есть такой "номер-код" для любых данных.

**Как работает хэш в Python:**

Python использует функцию `hash()`, которая превращает данные в число.

**Пример 1: Хэши разных типов данных**

```python
# Хэш от числа
print(hash(42))          # 42 (для маленьких чисел часто равен самому числу)
print(hash(1000000))     # 1000000

# Хэш от строки
print(hash("привет"))    # Большое число, например: -2834723987324
print(hash("hello"))     # Другое большое число

# Хэш от кортежа
print(hash((1, 2, 3)))   # Какое-то число

# Важно: одинаковые данные всегда дают одинаковый хэш!
print(hash("test"))      # Например: 394857234
print(hash("test"))      # 394857234 (то же самое!)
```

**Пример 2: Хэш для быстрого поиска**

```python
# Представим, что мы ищем число в списке
numbers = [10, 20, 30, 40, 50, 100, 200, 300]

# Нужно найти 200 — придется проверить много элементов
if 200 in numbers:  # Python проверяет: 10? нет. 20? нет. 30? нет...
    print("Нашли!")

# Теперь с множеством (использует хэши!)
numbers_set = {10, 20, 30, 40, 50, 100, 200, 300}

# Поиск мгновенный! Python вычисляет hash(200) и сразу находит
if 200 in numbers_set:  # Мгновенно!
    print("Нашли!")
```

**Важные свойства хэша:**

1. **Детерминированность** — одинаковые данные всегда дают одинаковый хэш
   ```python
   print(hash("apple"))  # Например: 5873461234
   print(hash("apple"))  # 5873461234 (всегда одинаково!)
   ```

2. **Быстрота вычисления** — хэш считается очень быстро
   ```python
   # Даже для длинной строки хэш считается мгновенно
   long_text = "a" * 1000000  # Миллион символов
   print(hash(long_text))     # Мгновенно!
   ```

3. **Распределенность** — разные данные обычно дают разные хэши
   ```python
   print(hash("cat"))   # 8472634234
   print(hash("dog"))   # 1928475632 (совсем другое число!)
   ```

4. **Необратимость** — по хэшу нельзя восстановить исходные данные
   ```python
   h = hash("password123")
   # По числу h невозможно узнать, что было "password123"
   ```

**Пример 3: Что можно хэшировать, а что нельзя**

```python
# ✅ Можно хэшировать (неизменяемые типы):
print(hash(42))                  # int
print(hash(3.14))                # float
print(hash("text"))              # str
print(hash((1, 2, 3)))           # tuple
print(hash(True))                # bool

# ❌ Нельзя хэшировать (изменяемые типы):
try:
    print(hash([1, 2, 3]))       # list — ошибка!
except TypeError as e:
    print(f"Ошибка: {e}")        # unhashable type: 'list'

try:
    print(hash({"a": 1}))        # dict — ошибка!
except TypeError as e:
    print(f"Ошибка: {e}")        # unhashable type: 'dict'

try:
    print(hash({1, 2, 3}))       # set — ошибка!
except TypeError as e:
    print(f"Ошибка: {e}")        # unhashable type: 'set'
```

**Почему нельзя хэшировать изменяемые типы?**

```python
# Представим, что мы могли бы хэшировать список
my_list = [1, 2, 3]
h1 = hash(my_list)  # Предположим, получили хэш

my_list.append(4)   # Изменили список
h2 = hash(my_list)  # Хэш изменился?

# Если h1 != h2 — проблема! 
# Если использовали h1 как ключ в словаре, как теперь найти этот элемент?
```

**Где используются хэши в Python:**

### **1. Словари (dict)**

Словари используют хэши ключей для быстрого доступа.

```python
# Словарь
phonebook = {
    "Алиса": "123-45-67",
    "Боб": "765-43-21",
    "Вася": "111-22-33"
}

# Когда вы пишете:
print(phonebook["Боб"])

# Python делает:
# 1. Вычисляет hash("Боб")
# 2. По этому хэшу мгновенно находит значение "765-43-21"
# Не нужно проверять "Алиса"? нет, "Боб"? да!
```

### **2. Множества (set)**

Множества используют хэши для проверки уникальности.

```python
# Множество
numbers = {1, 2, 3, 4, 5}

# Добавление элемента
numbers.add(3)  # Python: hash(3) уже есть? Да — не добавляем

# Проверка вхождения
if 3 in numbers:  # hash(3) есть в множестве? Мгновенная проверка!
    print("Есть!")
```

### **3. Кэширование**

```python
from functools import lru_cache

@lru_cache
def slow_function(a, b):
    return a + b

# Python использует hash((a, b)) как ключ в кэше
slow_function(1, 2)  # Вычисляет, сохраняет с ключом hash((1, 2))
slow_function(1, 2)  # hash((1, 2)) уже есть? Да — берем из кэша!
```

**Пример 4: Коллизии хэшей**

Иногда разные объекты могут иметь одинаковый хэш (это редко, но бывает).

```python
# Коллизия — это когда hash(x) == hash(y), но x != y

# У некоторых чисел могут совпадать хэши
# (Python обрабатывает это правильно)

# Пример: создадим искусственную коллизию
class BadHash:
    def __init__(self, value):
        self.value = value
    
    def __hash__(self):
        return 42  # Всегда возвращаем 42!
    
    def __eq__(self, other):
        return self.value == other.value

# Все объекты имеют одинаковый хэш
obj1 = BadHash(1)
obj2 = BadHash(2)
obj3 = BadHash(3)

print(hash(obj1))  # 42
print(hash(obj2))  # 42
print(hash(obj3))  # 42

# Но множество всё равно работает правильно!
s = {obj1, obj2, obj3}
print(len(s))  # 3 — все элементы разные, несмотря на одинаковые хэши
```

**Итого про хэш:**

- Хэш — это "отпечаток пальца" для данных
- Используется для быстрого поиска (словари, множества, кэш)
- Одинаковые данные = одинаковый хэш
- По хэшу нельзя восстановить данные
- Изменяемые типы (списки, словари) нельзя хэшировать


## `21.5` Разница кэша и хэша  
Многие путают кэш и хэш, потому что оба слова похожи. Но это **совершенно разные вещи**!

**Простое объяснение:**

- **Хэш** — это "номер" для данных (как номер паспорта для человека)
- **Кэш** — это "сохраненный результат" работы (как шпаргалка с готовыми ответами)

**Аналогия из жизни:**

Представьте библиотеку:

- **Хэш** — это номер на корешке книги, по которому вы быстро находите нужную полку
- **Кэш** — это список "недавно прочитанных книг", который лежит на вашем столе для быстрого доступа

### **Сравнительная таблица:**

| **Аспект** | **Хэш** | **Кэш** |
|-----------|---------|---------|
| **Что это?** | Число-"отпечаток" данных | Сохраненный результат вычисления |
| **Для чего?** | Быстрый поиск и сравнение | Избежать повторных вычислений |
| **Функция** | `hash(данные)` → число | Сохранить результат функции |
| **Пример** | `hash("apple")` → `5873461234` | `fibonacci(10)` → сохранить результат `55` |
| **Где используется** | Словари, множества, ключи | Ускорение функций, веб-кэш |
| **Изменяется?** | Нет (всегда одинаковый для данных) | Да (можно очистить, обновить) |
| **Память** | Почти не занимает | Может занимать много памяти |

### **Как они связаны?**
Хэш часто используется **внутри** кэша, но это разные концепции:

```python
# Внутри lru_cache:
# 
# def lru_cache_внутренности(func):
#     cache = {}  # Словарь для кэша
#     
#     def wrapper(*args):
#         key = hash(args)  # ХЭШ аргументов как ключ
#         
#         if key in cache:  # Проверка КЭШа
#             return cache[key]  # Возврат из КЭШа
#         
#         result = func(*args)
#         cache[key] = result  # Сохранение в КЭШ
#         return result
#     
#     return wrapper
```

### **Итоговое сравнение в терминах задач:**

**Хэш отвечает на вопрос:** "Как быстро найти/сравнить данные?"
```python
# Быстрый поиск
if "key" in my_dict:  # hash("key") → поиск
    pass
```

**Кэш отвечает на вопрос:** "Как не делать одну работу дважды?"
```python
# Избежать повторных вычислений
@lru_cache
def work(x):
    return x * 2
```

### **Запоминалка:**

- **Хэш** = **H**ow to find? (Как найти?) → номер для поиска
- **Кэш** = **C**ache results (Кэшировать результаты) → сохранять ответы

**Главное:** 
- Хэш помогает **найти** данные быстро
- Кэш помогает **не пересчитывать** данные заново

Они могут работать вместе, но это разные инструменты для разных целей!

----

# `22` (`**`) Типы данных 4  
_P.S: only for flexing on the job interview_  

## `22.1` `Decimal` что такое и для чего нужен?  
## `22.2` `namedtuple` что такое и для чего нужен?  
## `22.3` `defaultdict` что такое и для чего нужен?  
## `22.4` `OrderedDict` что такое и для чего нужен?  
## `22.5` `ChainMap` что такое и для чего нужен?  
## `22.6` `deque` что такое и для чего нужен?  
## `22.7` Можно ещё поизучать модуль `collections`  

----

# `23` Принципы ООП
## `23.1` Парадигмы программирования. Что такое объект в Python?
**Что такое парадигма программирования?**

Парадигма программирования — это **стиль** или **подход** к написанию программ. Это как разные способы решения одной задачи.

**Аналогия:**

Представьте, что вам нужно добраться из точки А в точку Б:
- Можно пойти пешком (одна парадигма)
- Можно поехать на машине (другая парадигма)
- Можно полететь на самолете (третья парадигма)

Цель одна, но способы разные!

### **Основные парадигмы программирования:**

### **1. Процедурное программирование**

Программа — это последовательность команд (процедур), выполняемых одна за другой.

**Пример:**
```python
# Процедурный стиль — функции и данные отдельно

# Данные
balance = 1000

# Функции для работы с данными
def deposit(amount):
    global balance
    balance += amount
    print(f"Пополнение: +{amount}. Баланс: {balance}")

def withdraw(amount):
    global balance
    if balance >= amount:
        balance -= amount
        print(f"Снятие: -{amount}. Баланс: {balance}")
    else:
        print("Недостаточно средств")

# Использование
deposit(500)    # Пополнение: +500. Баланс: 1500
withdraw(200)   # Снятие: -200. Баланс: 1300
```

**Характеристики:**
- Программа = набор функций
- Данные хранятся отдельно от функций
- Функции изменяют данные

### **2. Объектно-ориентированное программирование (ООП)**

Программа — это набор объектов, которые взаимодействуют друг с другом. Данные и функции объединены вместе.

**Пример:**
```python
# ООП стиль — данные и функции вместе

class BankAccount:
    def __init__(self):
        self.balance = 1000
    
    def deposit(self, amount):
        self.balance += amount
        print(f"Пополнение: +{amount}. Баланс: {self.balance}")
    
    def withdraw(self, amount):
        if self.balance >= amount:
            self.balance -= amount
            print(f"Снятие: -{amount}. Баланс: {self.balance}")
        else:
            print("Недостаточно средств")

# Создаем объект
account = BankAccount()

# Используем методы объекта
account.deposit(500)    # Пополнение: +500. Баланс: 1500
account.withdraw(200)   # Снятие: -200. Баланс: 1300
```

**Характеристики:**
- Программа = набор объектов
- Данные и функции объединены в объекты
- Объекты взаимодействуют друг с другом

### **3. Функциональное программирование**

Программа — это набор функций, которые не изменяют данные, а создают новые.

**Пример:**
```python
# Функциональный стиль — функции не изменяют данные

def deposit(balance, amount):
    """Возвращает новый баланс"""
    return balance + amount

def withdraw(balance, amount):
    """Возвращает новый баланс или None"""
    if balance >= amount:
        return balance - amount
    else:
        return None

# Использование
balance = 1000
balance = deposit(balance, 500)     # balance = 1500
balance = withdraw(balance, 200)    # balance = 1300

print(f"Баланс: {balance}")
```

**Характеристики:**
- Функции не изменяют данные, а возвращают новые
- Избегание изменяемого состояния
- Функции как данные

### **Что такое объект в Python?**

**Объект** — это "коробка", в которой хранятся:
1. **Данные** (свойства, характеристики)
2. **Функции** (действия, которые можно совершить)

**Важно:** В Python **всё является объектом**!

**Примеры объектов:**

```python
# Число — это объект!
number = 42
print(type(number))  # <class 'int'>

# У числа есть методы (функции)
print(number.bit_length())  # 6 (количество бит)

# Строка — это объект!
text = "привет"
print(type(text))  # <class 'str'>

# У строки есть методы
print(text.upper())      # ПРИВЕТ
print(text.capitalize()) # Привет

# Список — это объект!
numbers = [1, 2, 3]
print(type(numbers))  # <class 'list'>

# У списка есть методы
numbers.append(4)  # Добавить элемент
numbers.reverse()  # Перевернуть список
print(numbers)     # [4, 3, 2, 1]
```

**Объект = данные + методы**

```python
# Строка "hello"
text = "hello"

# Данные объекта
print(text)        # "hello" — сами данные
print(len(text))   # 5 — длина (данные)

# Методы объекта (функции, привязанные к объекту)
print(text.upper())       # "HELLO"
print(text.replace('l', 'L'))  # "heLLo"
print(text.count('l'))    # 2
```

**Пример: создадим свой простой объект**

```python
# Словарь как простой объект
person = {
    'name': 'Алиса',
    'age': 25,
    'city': 'Москва'
}

# У "объекта" есть данные
print(person['name'])  # Алиса
print(person['age'])   # 25

# Но это еще не полноценный объект ООП
# Функции хранятся отдельно
def introduce(person_dict):
    print(f"Меня зовут {person_dict['name']}, мне {person_dict['age']} лет")

introduce(person)  # Меня зовут Алиса, мне 25 лет
```

В ООП мы объединим данные и функции вместе (об этом в следующих разделах).


## `23.2` Преимущества ООП и недостатки
### **Преимущества ООП:**

**1. Организация кода**

Всё связанное находится в одном месте.

```python
# БЕЗ ООП — всё разбросано
user_name = "Анна"
user_age = 25
user_email = "anna@example.com"

def send_email_to_user(email, message):
    print(f"Отправка на {email}: {message}")

def is_adult(age):
    return age >= 18

# С ООП — всё вместе
class User:
    def __init__(self, name, age, email):
        self.name = name
        self.age = age
        self.email = email
    
    def send_email(self, message):
        print(f"Отправка на {self.email}: {message}")
    
    def is_adult(self):
        return self.age >= 18

user = User("Анна", 25, "anna@example.com")
user.send_email("Привет!")  # Всё логически связано
```

**2. Повторное использование кода (наследование)**

Можно создавать новые классы на основе существующих.

```python
# Базовый функционал
class Animal:
    def __init__(self, name):
        self.name = name
    
    def speak(self):
        pass

# Расширяем функционал
class Dog(Animal):
    def speak(self):
        return f"{self.name} говорит: Гав!"

class Cat(Animal):
    def speak(self):
        return f"{self.name} говорит: Мяу!"

dog = Dog("Бобик")
cat = Cat("Мурка")

print(dog.speak())  # Бобик говорит: Гав!
print(cat.speak())  # Мурка говорит: Мяу!
```

**3. Модульность**

Код разделен на независимые части (объекты).

```python
# Каждый объект — независимая единица
account1 = BankAccount()
account2 = BankAccount()

# Изменение одного не влияет на другой
account1.deposit(100)
account2.deposit(500)

print(account1.balance)  # 1100
print(account2.balance)  # 1500
```

**4. Скрытие сложности (инкапсуляция)**

Пользователь работает с простым интерфейсом, не зная внутренней реализации.

```python
class CoffeeMachine:
    def make_coffee(self, coffee_type):
        self._grind_beans()    # Внутренние детали
        self._heat_water()     # скрыты от пользователя
        self._brew(coffee_type)
        return "☕ Ваш кофе готов!"
    
    def _grind_beans(self):
        # Сложная логика помола
        pass
    
    def _heat_water(self):
        # Сложная логика нагрева
        pass
    
    def _brew(self, coffee_type):
        # Сложная логика заваривания
        pass

# Пользователь не знает, как работает машина внутри
machine = CoffeeMachine()
coffee = machine.make_coffee("эспрессо")  # Просто!
```

**5. Легкость поддержки**

Изменения в одном месте не ломают весь код.

```python
# Изменили класс User
class User:
    def __init__(self, name, age, email):
        self.name = name
        self.age = age
        self.email = email
    
    # Добавили новый метод — старый код продолжает работать
    def get_full_info(self):
        return f"{self.name}, {self.age} лет, {self.email}"
```

**6. Моделирование реального мира**

Объекты похожи на объекты реального мира.

```python
# Реальный мир: машины, двери, двигатели
class Car:
    def __init__(self, brand):
        self.brand = brand
        self.engine = Engine()
        self.doors = [Door(), Door(), Door(), Door()]
    
    def start(self):
        self.engine.start()
        print(f"{self.brand} завелась")

class Engine:
    def start(self):
        print("Двигатель запущен")

class Door:
    def open(self):
        print("Дверь открыта")

# Код похож на реальную машину
car = Car("Toyota")
car.start()
car.doors[0].open()
```

### **Недостатки ООП:**

**1. Избыточность для простых задач**

```python
# Для простой задачи ООП — overkill

# ПРОСТАЯ ЗАДАЧА: сложить два числа

# Процедурный стиль (просто и понятно)
def add(a, b):
    return a + b

print(add(2, 3))  # 5

# ООП стиль (слишком сложно для такой задачи)
class Calculator:
    def add(self, a, b):
        return a + b

calc = Calculator()
print(calc.add(2, 3))  # 5 — зачем столько кода?
```

**2. Сложность для начинающих**

ООП требует понимания абстрактных концепций.

```python
# Новичку сложно понять это с первого раза
class AbstractFactory:
    def create_product(self):
        pass

class ConcreteFactory(AbstractFactory):
    def create_product(self):
        return ConcreteProduct()

# Процедурный код проще для понимания
def create_product():
    return {"type": "product"}
```

**3. Медленнее выполнение**

Вызовы методов объектов медленнее обычных функций.

```python
# Функция (быстрее)
def square(x):
    return x * x

# Метод объекта (медленнее из-за дополнительных операций)
class Math:
    def square(self, x):
        return x * x

# Разница незначительна, но есть
```

**4. Больше памяти**

Объекты хранят больше информации.

```python
# Простые переменные (меньше памяти)
x = 10
y = 20

# Объект (больше памяти — хранит данные + методы + служебную информацию)
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

p = Point(10, 20)
```

**5. Может привести к переусложнению**

Программисты иногда создают слишком сложную архитектуру.

```python
# Простая задача: хранить имя и возраст

# ПЛОХО — переусложнение
class Person:
    def __init__(self, name, age):
        self._personal_info = PersonalInfo(name, age)
    
    def get_name(self):
        return self._personal_info.get_name()

class PersonalInfo:
    def __init__(self, name, age):
        self._name = Name(name)
        self._age = Age(age)
    
    def get_name(self):
        return self._name.get_value()

class Name:
    def __init__(self, value):
        self._value = value
    
    def get_value(self):
        return self._value

# ХОРОШО — просто
person = {"name": "Анна", "age": 25}
print(person["name"])
```

### **Когда использовать ООП:**

✅ **Используйте ООП:**
- Большие проекты с множеством связанных данных
- Когда нужна модульность и переиспользование кода
- При моделировании сложных систем (игры, веб-приложения, GUI)
- Когда работают несколько программистов

❌ **НЕ используйте ООП:**
- Простые скрипты и утилиты
- Математические вычисления
- Обработка данных (лучше функциональный подход)
- Быстрые прототипы


## `23.3` Что такое класс и объект?
**Класс** — это **чертёж** или **шаблон** для создания объектов.

**Объект** — это **конкретный экземпляр** класса.

**Аналогия:**

- **Класс** = чертёж дома (бумажный план)
- **Объект** = настоящий построенный дом

По одному чертежу можно построить много одинаковых домов, но каждый дом будет отдельным объектом.

### **Пример 1: Класс и объекты**

```python
# Класс — чертёж для собаки
class Dog:
    def __init__(self, name, age):
        self.name = name  # Данные
        self.age = age
    
    def bark(self):  # Поведение
        print(f"{self.name} говорит: Гав-гав!")

# Создаем объекты (конкретные собаки) по чертежу
dog1 = Dog("Бобик", 3)
dog2 = Dog("Шарик", 5)
dog3 = Dog("Рекс", 2)

# У каждого объекта свои данные
print(dog1.name)  # Бобик
print(dog2.name)  # Шарик
print(dog3.name)  # Рекс

# Но поведение одинаковое
dog1.bark()  # Бобик говорит: Гав-гав!
dog2.bark()  # Шарик говорит: Гав-гав!
```

### **Структура класса:**

```python
class ClassName:  # Имя класса с большой буквы
    """Описание класса"""
    
    def __init__(self, параметры):  # Конструктор (инициализатор)
        self.свойство1 = значение1
        self.свойство2 = значение2
    
    def метод1(self):  # Методы (функции класса)
        # код метода
        pass
    
    def метод2(self, параметр):
        # код метода
        pass
```

### **Пример 2: Класс "Книга"**

```python
class Book:
    """Класс для представления книги"""
    
    def __init__(self, title, author, pages):
        """Конструктор — вызывается при создании объекта"""
        self.title = title      # Название
        self.author = author    # Автор
        self.pages = pages      # Страницы
        self.current_page = 0   # Текущая страница
    
    def read(self, pages_count):
        """Прочитать несколько страниц"""
        self.current_page += pages_count
        if self.current_page > self.pages:
            self.current_page = self.pages
        print(f"Прочитано до страницы {self.current_page}")
    
    def info(self):
        """Информация о книге"""
        return f"'{self.title}' - {self.author}, {self.pages} стр."

# Создаем объекты (книги)
book1 = Book("Война и мир", "Толстой", 1200)
book2 = Book("Гарри Поттер", "Роулинг", 300)

# У каждой книги свои данные
print(book1.info())  # 'Война и мир' - Толстой, 1200 стр.
print(book2.info())  # 'Гарри Поттер' - Роулинг, 300 стр.

# Читаем книги независимо
book1.read(50)   # Прочитано до страницы 50
book2.read(100)  # Прочитано до страницы 100
book1.read(30)   # Прочитано до страницы 80

print(book1.current_page)  # 80
print(book2.current_page)  # 100
```

### **Что такое `self`?**

`self` — это ссылка на **сам объект**. Через `self` методы получают доступ к данным объекта.

```python
class Counter:
    def __init__(self):
        self.count = 0  # self.count — это "мой счетчик"
    
    def increment(self):
        self.count += 1  # Увеличиваю МОЙ счетчик
        print(f"Счетчик: {self.count}")

# Создаем два независимых счетчика
counter1 = Counter()
counter2 = Counter()

counter1.increment()  # Счетчик: 1
counter1.increment()  # Счетчик: 2

counter2.increment()  # Счетчик: 1

# У каждого объекта свой self.count
print(counter1.count)  # 2
print(counter2.count)  # 1
```

**Почему `self`?**

```python
# Когда вы пишете:
dog1.bark()

# Python преобразует это в:
Dog.bark(dog1)  # Передает dog1 как self

# Поэтому первый параметр всегда self
```

### **Пример 3: Класс "Банковский счёт"**

```python
class BankAccount:
    def __init__(self, owner, balance=0):
        self.owner = owner
        self.balance = balance
    
    def deposit(self, amount):
        """Пополнить счёт"""
        self.balance += amount
        print(f"{self.owner}: +{amount}. Баланс: {self.balance}")
    
    def withdraw(self, amount):
        """Снять деньги"""
        if self.balance >= amount:
            self.balance -= amount
            print(f"{self.owner}: -{amount}. Баланс: {self.balance}")
        else:
            print(f"{self.owner}: Недостаточно средств!")
    
    def get_balance(self):
        """Узнать баланс"""
        return self.balance

# Создаем счета для разных людей
account_anna = BankAccount("Анна", 1000)
account_boris = BankAccount("Борис", 500)

# Каждый работает со своим счётом
account_anna.deposit(200)   # Анна: +200. Баланс: 1200
account_boris.withdraw(100) # Борис: -100. Баланс: 400

print(account_anna.get_balance())  # 1200
print(account_boris.get_balance()) # 400
```

### **Разница класс vs объект:**

```python
# Класс — это тип/шаблон
print(type(Dog))  # <class 'type'>

# Объект — это экземпляр класса
dog = Dog("Бобик", 3)
print(type(dog))  # <class '__main__.Dog'>

# Класс существует в единственном числе
# Объектов может быть сколько угодно
dog1 = Dog("Бобик", 3)
dog2 = Dog("Шарик", 5)
dog3 = Dog("Рекс", 2)
# ... можно создать тысячи собак по одному классу
```

**Запоминалка:**
- **Класс** = форма для печенья
- **Объект** = конкретное печенье, сделанное по этой форме


## `23.4` 4 принципа ООП
Существует **4 основных принципа ООП**, которые делают код лучше:

1. **Абстракция**
2. **Инкапсуляция**
3. **Наследование**
4. **Полиморфизм**

### **1. Абстракция**

**Абстракция** — это **выделение важного и скрытие несущественного**.

Мы показываем пользователю только то, что ему нужно, и скрываем сложные детали.

**Аналогия из жизни:**

Когда вы водите машину:
- Вы используете: руль, педали, коробку передач (простой интерфейс)
- Вы НЕ думаете о: работе двигателя, системе впрыска топлива, электронике (сложные детали)

**Суть абстракции:** Пользователь видит только **что** делает объект, но не **как** он это делает.

### **2. Инкапсуляция**

**Инкапсуляция** — это **объединение данных и методов в одном месте** + **защита данных от прямого доступа**.

Данные объекта должны изменяться только через методы этого объекта.

**Аналогия из жизни:**

Банковский счёт:
- ❌ НЕЛЬЗЯ: прийти в банк и самому дописать нули на счету
- ✅ МОЖНО: попросить банк пополнить счёт через официальную процедуру

**Суть инкапсуляции:** Данные защищены, изменить их можно только через методы, которые проверяют корректность.

### **3. Наследование**

**Наследование** — это создание нового класса на основе существующего.

Новый класс (потомок) получает все свойства и методы родительского класса, и может добавлять свои.

**Аналогия из жизни:**

Дети наследуют черты родителей:
- Ребёнок получает: цвет глаз, группу крови, форму носа от родителей
- Но также имеет свои уникальные черты

**Суть наследования:** Не нужно писать один и тот же код снова — берём готовый класс и расширяем его.

### **4. Полиморфизм**

**Полиморфизм** — это способность использовать объекты разных классов через **единый интерфейс**.

Слово "полиморфизм" означает "много форм". Один и тот же метод может работать по-разному в разных классах.

**Аналогия из жизни:**

Кнопка "Play":
- На магнитофоне — проигрывает кассету
- На DVD-плеере — проигрывает диск
- На телефоне — проигрывает музыку

Одна кнопка, но делает разные вещи в зависимости от устройства!

**Суть полиморфизма:** Пишем код один раз, а он работает с разными типами объектов. Не нужно знать точный тип объекта — главное, чтобы у него был нужный метод.

---

## **Итоги: Четыре принципа ООП**

### **1. Абстракция** — "Скрыть сложность"
- Показываем простой интерфейс
- Скрываем сложную реализацию
- Пример: пульт от телевизора (нажимаем кнопку, не думаем о схемах)

### **2. Инкапсуляция** — "Защитить данные"
- Данные и методы вместе
- Данные изменяются только через методы
- Пример: банковский счёт (нельзя просто дописать нули)

### **3. Наследование** — "Переиспользовать код"
- Создаём новые классы на основе старых
- Потомок получает всё от родителя
- Пример: Dog и Cat наследуют от Animal

### **4. Полиморфизм** — "Много форм одного действия"
- Один метод работает по-разному в разных классах
- Пишем код один раз для всех типов
- Пример: метод `speak()` у разных животных

---

**Как они работают вместе:**

```python
# Абстракция — простой интерфейс
class Animal:  
    def speak(self):
        pass

# Инкапсуляция — данные внутри класса
class Dog(Animal):  # Наследование
    def __init__(self, name):
        self._name = name  # Защищенные данные
    
    def speak(self):  # Полиморфизм
        return f"{self._name} говорит: Гав!"

class Cat(Animal):  # Наследование
    def __init__(self, name):
        self._name = name
    
    def speak(self):  # Полиморфизм
        return f"{self._name} говорит: Мяу!"

# Используем все принципы вместе
animals = [Dog("Бобик"), Cat("Мурка")]

for animal in animals:  # Полиморфизм
    print(animal.speak())  # Абстракция — не знаем детали реализации

# Бобик говорит: Гав!
# Мурка говорит: Мяу!
```

**Зачем нужны эти принципы?**

✅ Код легче читать  
✅ Код легче изменять  
✅ Меньше ошибок  
✅ Можно переиспользовать код  
✅ Легче работать в команде

----

# `24` Атрибуты и методы
## `24.1` Какие кейсы есть вообще, и какие соглашения на использовании в Python (camelCase, snake_case, etc)  
## `24.2` Функция `dir()` — для получения списка атрибутов и методов объекта  
## `24.3` Создание классов и объектов в Python  
## `24.4` Атрибуты класса и объекта (без `__init__`)  
## `24.5` Атрибут `__dict__` — словарь атрибутов объекта  
## `24.6` Встроенные функции для работы с атрибутами:  
- `getattr()` — получить атрибут  
- `setattr()` — установить атрибут  
- `delattr()` — удалить атрибут  
- `hasattr()` — проверить наличие атрибута  
## `24.7` Что такое метод и как его создавать?  

----

# `25` Методы экземпляра класса
## `25.1` Метод `__init__` — конструктор класса
**Теория:**
`__init__` — это специальный метод (конструктор), который автоматически вызывается при создании нового объекта класса. Он нужен для инициализации — задания начальных значений атрибутам объекта. Без `__init__` каждый объект создавался бы "пустым", и пришлось бы вручную добавлять атрибуты после создания.

**Примеры:**

```python
# Пример 1: Простой класс с __init__
class Dog:
    def __init__(self, name, age):
        self.name = name  # Сохраняем имя собаки
        self.age = age    # Сохраняем возраст

# Создаём объекты
dog1 = Dog("Бобик", 3)  # __init__ вызывается автоматически
dog2 = Dog("Рекс", 5)

print(dog1.name)  # Бобик
print(dog2.age)   # 5
```

```python
# Пример 2: __init__ с параметрами по умолчанию
class Book:
    def __init__(self, title, pages=100):
        self.title = title
        self.pages = pages
        self.is_read = False  # Можно задавать значения без параметров

book1 = Book("Война и мир", 1300)
book2 = Book("Рассказ")  # pages будет 100 по умолчанию

print(book2.pages)    # 100
print(book1.is_read)  # False
```

## `25.2` Параметр `self` — что это и зачем нужен
**Теория:**
`self` — это ссылка на конкретный экземпляр класса (объект). Когда вы вызываете метод на объекте, Python автоматически передаёт этот объект первым параметром. `self` позволяет методам обращаться к атрибутам и другим методам именно этого объекта.

**Важно:** имя `self` — это соглашение, технически можно использовать любое имя, но все программисты используют именно `self`.

**Примеры:**

```python
# Пример 1: self даёт доступ к атрибутам объекта
class Counter:
    def __init__(self, start):
        self.value = start  # self.value — атрибут конкретного объекта
    
    def increment(self):
        self.value += 1  # Обращаемся к атрибуту через self

counter1 = Counter(0)
counter2 = Counter(100)

counter1.increment()  # Python автоматически передаёт counter1 как self
counter2.increment()

print(counter1.value)  # 1
print(counter2.value)  # 101 — каждый объект независим!
```

```python
# Пример 2: self для вызова других методов
class Calculator:
    def __init__(self, value):
        self.value = value
    
    def add(self, number):
        self.value += number
    
    def double(self):
        self.add(self.value)  # Вызываем другой метод через self
    
calc = Calculator(5)
calc.double()  # Внутри вызовется self.add(5)
print(calc.value)  # 10
```

**Почему self обязателен:**
Без `self` Python не поймёт, к какому конкретно объекту относятся атрибуты — к `dog1` или `dog2`, к `counter1` или `counter2`. `self` — это способ сказать: "работай с ЭТИМ конкретным объектом".

----

# `26` (`*`) Доступ к атрибутам
## `26.1` Сокрытие данных (инкапсуляция) в Python
**Теория:**
`Инкапсуляция` — это один из принципов ООП, который означает "упаковку" данных и методов внутри класса, а также ограничение прямого доступа к внутренним данным объекта. Идея в том, что внутреннее устройство объекта должно быть скрыто, а взаимодействие с ним происходит через публичные методы.

**Зачем это нужно:**
- **Защита данных** — предотвращение случайного изменения важных атрибутов
- **Контроль** — возможность проверять значения перед записью
- **Гибкость** — можно менять внутреннюю реализацию без изменения внешнего интерфейса
- **Логика** — можно добавить вычисления при получении/установке значений

**Важно:** В Python нет настоящего сокрытия данных, как в Java или C++. Все атрибуты технически доступны. Python следует философии "мы все взрослые люди" — доверие программисту вместо жёстких ограничений.

**Примеры:**

```python
# Пример 1: Проблема без инкапсуляции
class BankAccount:
    def __init__(self, balance):
        self.balance = balance

account = BankAccount(1000)
account.balance = -5000  # Можем установить отрицательный баланс — это плохо!
print(account.balance)  # -5000
```

```python
# Пример 2: Решение с методами (базовая инкапсуляция)
class BankAccount:
    def __init__(self, balance):
        self._balance = balance  # _ указывает: "это внутренний атрибут"
    
    def get_balance(self):
        return self._balance
    
    def deposit(self, amount):
        if amount > 0:
            self._balance += amount
        else:
            print("Сумма должна быть положительной")
    
    def withdraw(self, amount):
        if 0 < amount <= self._balance:
            self._balance -= amount
        else:
            print("Недостаточно средств или неверная сумма")

account = BankAccount(1000)
account.deposit(500)
print(account.get_balance())  # 1500
account.withdraw(2000)  # Недостаточно средств или неверная сумма
# Технически всё ещё можно: account._balance = -5000, но это нарушает соглашение
```


## `26.2` Соглашения между разработчиками по именованию и доступу
**Теория:**
В Python используются соглашения об именовании для обозначения уровня доступа к атрибутам и методам. Это не строгие правила, а договорённость между программистами.

**Три уровня доступа:**

1. **Публичные атрибуты** (`name`) — обычные атрибуты, доступны везде
2. **Защищённые атрибуты** (`_name`) — один символ подчёркивания в начале
3. **Приватные атрибуты** (`__name`) — два символа подчёркивания в начале

**Примеры:**

```python
# Пример 1: Разные уровни доступа
class Person:
    def __init__(self, name, age, passport):
        self.name = name           # Публичный — можно свободно использовать
        self._age = age            # Защищённый — используй осторожно
        self.__passport = passport # Приватный — не трогай снаружи!
    
    def get_info(self):
        return f"{self.name}, {self._age} лет"
    
    def _internal_check(self):
        # Защищённый метод для внутреннего использования
        return self.__passport is not None

person = Person("Иван", 30, "1234567890")

# Публичный доступ — нормально
print(person.name)  # Иван

# Защищённый — работает, но намекает "будь осторожен"
print(person._age)  # 30

# Приватный — вызовет ошибку
print(person.__passport)  # AttributeError!
```

```python
# Пример 2: Name mangling — механизм приватности
class Secret:
    def __init__(self):
        self.__hidden = "секрет"
    
    def reveal(self):
        return self.__hidden

obj = Secret()
# print(obj.__hidden)  # AttributeError

# Но на самом деле атрибут доступен через name mangling:
print(obj._Secret__hidden)  # секрет
# Python переименовал __hidden в _Secret__hidden
```

**Соглашения:**
- `_name` — "Это внутренний атрибут, используй, только если знаешь что делаешь"
- `__name` — "Это точно не для внешнего использования" (name mangling для избежания конфликтов в наследовании)
- `name_` — для избежания конфликтов с ключевыми словами (например, `class_`)
- `__name__` — специальные методы Python (dunder methods)


## `26.3` Геттеры, сеттеры, делитеры — что это и зачем нужны
**Теория:**
Геттеры, сеттеры и делитеры — это специальные методы для управления доступом к атрибутам объекта:

- **Геттер (getter)** — метод для **получения** значения атрибута
- **Сеттер (setter)** — метод для **установки** значения атрибута с валидацией
- **Делитер (deleter)** — метод для **удаления** атрибута

Этот паттерн пришёл из языков вроде Java и C++, где прямой доступ к полям класса считается плохой практикой

**Зачем нужны:**
- Валидация данных при установке
- Вычисления при получении (динамические атрибуты)
- Преобразование и нормализация данных
- Логирование обращений к атрибутам
- Защита от некорректных значений
- Побочные эффекты (например, обновление связанных данных)

**Примеры:**

```python
# Пример 1: Классические геттеры и сеттеры (старый стиль)
class Temperature:
    def __init__(self, celsius):
        self._celsius = celsius
    
    def get_celsius(self):  # Геттер
        return self._celsius
    
    def set_celsius(self, value):  # Сеттер
        if value < -273.15:
            raise ValueError("Температура не может быть ниже абсолютного нуля")
        self._celsius = value
    
    def del_celsius(self):  # Делитер
        print("Удаление температуры")
        del self._celsius

temp = Temperature(25)
print(temp.get_celsius())  # 25
temp.set_celsius(30)
print(temp.get_celsius())  # 30
# temp.set_celsius(-300)  # ValueError!
```

```python
# Пример 2: Геттер с вычислениями
class Rectangle:
    def __init__(self, width, height):
        self._width = width
        self._height = height
    
    def get_area(self):  # Геттер для вычисляемого свойства
        return self._width * self._height
    
    def set_width(self, value):
        if value <= 0:
            raise ValueError("Ширина должна быть положительной")
        self._width = value

rect = Rectangle(5, 10)
print(rect.get_area())  # 50
rect.set_width(8)
print(rect.get_area())  # 80 (автоматически пересчиталось)
```

```python
# Пример 3: Преобразование данных
class Person:
    def __init__(self, name, email):
        self._name = name
        self._email = email
    
    def get_name(self):
        """Возвращаем имя с заглавной буквы"""
        return self._name.title()
    
    def set_name(self, value):
        """Сохраняем имя, убрав лишние пробелы"""
        if not value.strip():
            raise ValueError("Имя не может быть пустым")
        self._name = value.strip()
    
    def get_email(self):
        """Возвращаем email в нижнем регистре"""
        return self._email.lower()

person = Person("  иВаН  ", "Ivan@EXAMPLE.COM")
print(person.get_name())   # Иван
print(person.get_email())  # ivan@example.com
```

```python
# Пример 4: Побочные эффекты — логирование изменений
class BankAccount:
    def __init__(self, balance):
        self._balance = balance
        self._transaction_count = 0
    
    def get_balance(self):
        return self._balance
    
    def set_balance(self, amount):
        if amount < 0:
            raise ValueError("Баланс не может быть отрицательным")
        
        old_balance = self._balance
        self._balance = amount
        self._transaction_count += 1
        print(f"Транзакция #{self._transaction_count}: {old_balance} → {amount}")

account = BankAccount(1000)
account.set_balance(1500)  # Транзакция #1: 1000 → 1500
account.set_balance(1200)  # Транзакция #2: 1500 → 1200
```

**Проблема старого стиля:**
Код выглядит громоздко: `temp.get_celsius()` и `temp.set_celsius(30)` вместо простого `temp.celsius` и `temp.celsius = 30`. Приходится писать много дополнительного кода, и синтаксис становится менее естественным для Python

**Решение — `property`:**
Python предлагает более элегантное решение через `property`, который позволяет использовать синтаксис обычных атрибутов с контролем доступа под капотом. Современный Python почти не использует явные `get_`/`set_` методы — вместо этого применяется декоратор `@property`


## `26.4` Свойство (`property`) — атрибут с управляемым доступом
**Теория:**
`property` — это встроенный класс Python, который превращает методы в атрибуты. Снаружи это выглядит как обычный атрибут (`obj.name`), но при обращении к нему вызываются специальные методы (геттер, сеттер, делитер). Это делает код чище и естественнее — вместо `obj.get_celsius()` пишем просто `obj.celsius`.

**Как это работает:**
Когда вы создаёте `property`, вы связываете имя атрибута с методами:
- При **чтении** атрибута (`print(obj.celsius)`) вызывается геттер
- При **записи** атрибута (`obj.celsius = 30`) вызывается сеттер
- При **удалении** атрибута (`del obj.celsius`) вызывается делитер

**Синтаксис:**
```python
attribute = property(fget=getter, fset=setter, fdel=deleter, doc=docstring)
```
- `fget` — функция-геттер (для чтения)
- `fset` — функция-сеттер (для записи)
- `fdel` — функция-делитер (для удаления)
- `doc` — строка документации (опционально)

Все параметры опциональны — можно создать property только с геттером (read-only).

**Примеры:**

```python
# Пример 1: property с геттером и сеттером
class Temperature:
    def __init__(self, celsius):
        self._celsius = celsius
    
    def get_celsius(self):
        print("Получение температуры")
        return self._celsius
    
    def set_celsius(self, value):
        print("Установка температуры")
        if value < -273.15:
            raise ValueError("Температура не может быть ниже абсолютного нуля")
        self._celsius = value
    
    def del_celsius(self):
        print("Удаление температуры")
        del self._celsius
    
    # Создаём property, связывая его с методами
    celsius = property(get_celsius, set_celsius, del_celsius, "Температура в градусах Цельсия")

temp = Temperature(25)

# Работаем как с обычным атрибутом, но вызываются методы
print(temp.celsius)  # Получение температуры → 25
temp.celsius = 30    # Установка температуры
print(temp.celsius)  # Получение температуры → 30
del temp.celsius     # Удаление температуры

# Можем прочитать документацию
print(Temperature.celsius.__doc__)  # Температура в градусах Цельсия
```

```python
# Пример 2: property только с геттером (read-only атрибут)
class Circle:
    def __init__(self, radius):
        self._radius = radius
    
    def get_area(self):
        return 3.14159 * self._radius ** 2
    
    def get_circumference(self):
        return 2 * 3.14159 * self._radius
    
    # Read-only свойства — только геттер
    area = property(get_area)
    circumference = property(get_circumference)

circle = Circle(5)
print(circle.area)          # 78.53975
print(circle.circumference) # 31.4159

# Нельзя изменить — нет сеттера
try:
    circle.area = 100
except AttributeError as e:
    print(f"Ошибка: {e}")  # can't set attribute
```

```python
# Пример 3: Вычисляемые свойства с преобразованием единиц
class Distance:
    def __init__(self, meters):
        self._meters = meters
    
    def get_meters(self):
        return self._meters
    
    def set_meters(self, value):
        if value < 0:
            raise ValueError("Расстояние не может быть отрицательным")
        self._meters = value
    
    def get_kilometers(self):
        """Автоматическое преобразование в километры"""
        return self._meters / 1000
    
    def set_kilometers(self, value):
        """Устанавливаем через километры, сохраняем в метрах"""
        if value < 0:
            raise ValueError("Расстояние не может быть отрицательным")
        self._meters = value * 1000
    
    def get_miles(self):
        """Автоматическое преобразование в мили"""
        return self._meters / 1609.34
    
    def set_miles(self, value):
        """Устанавливаем через мили, сохраняем в метрах"""
        if value < 0:
            raise ValueError("Расстояние не может быть отрицательным")
        self._meters = value * 1609.34
    
    # Создаём свойства для разных единиц измерения
    meters = property(get_meters, set_meters)
    kilometers = property(get_kilometers, set_kilometers)
    miles = property(get_miles, set_miles)

distance = Distance(5000)  # 5000 метров

print(distance.meters)      # 5000
print(distance.kilometers)  # 5.0
print(distance.miles)       # 3.106855

# Устанавливаем в километрах
distance.kilometers = 10
print(distance.meters)      # 10000.0

# Устанавливаем в милях
distance.miles = 1
print(distance.meters)      # 1609.34
print(distance.kilometers)  # 1.60934
```

```python
# Пример 4: Свойство с делитером и сложной логикой
class User:
    def __init__(self, username, password):
        self._username = username
        self._password = password
        self._is_active = True
    
    def get_password(self):
        """Возвращаем замаскированный пароль"""
        return "*" * len(self._password)
    
    def set_password(self, value):
        """Проверяем сложность пароля"""
        if len(value) < 8:
            raise ValueError("Пароль должен быть минимум 8 символов")
        if not any(c.isdigit() for c in value):
            raise ValueError("Пароль должен содержать цифры")
        if not any(c.isupper() for c in value):
            raise ValueError("Пароль должен содержать заглавные буквы")
        self._password = value
        print("Пароль успешно изменён")
    
    def del_password(self):
        """При удалении пароля деактивируем пользователя"""
        print("Пароль удалён, пользователь деактивирован")
        self._password = None
        self._is_active = False
    
    password = property(get_password, set_password, del_password, "Пароль пользователя")

user = User("ivan", "Secret123")

print(user.password)  # ********* (замаскирован)

user.password = "NewPass456"  # Пароль успешно изменён
print(user.password)          # **********

try:
    user.password = "weak"  # ValueError: Пароль должен быть минимум 8 символов
except ValueError as e:
    print(f"Ошибка: {e}")

del user.password  # Пароль удалён, пользователь деактивирован
print(user._is_active)  # False
```

```python
# Пример 5: Сравнение старого и нового стиля
class Rectangle:
    def __init__(self, width, height):
        self._width = width
        self._height = height
    
    # Геттеры
    def get_width(self):
        return self._width
    
    def get_height(self):
        return self._height
    
    def get_area(self):
        return self._width * self._height
    
    # Сеттеры
    def set_width(self, value):
        if value <= 0:
            raise ValueError("Ширина должна быть положительной")
        self._width = value
    
    def set_height(self, value):
        if value <= 0:
            raise ValueError("Высота должна быть положительной")
        self._height = value
    
    # Превращаем в свойства
    width = property(get_width, set_width)
    height = property(get_height, set_height)
    area = property(get_area)  # read-only

rect = Rectangle(5, 10)

# Старый стиль (если бы не было property):
# rect.set_width(8)
# print(rect.get_area())

# Новый стиль с property:
rect.width = 8       # Естественный синтаксис!
print(rect.area)     # 80
print(rect.height)   # 10

# Валидация работает
try:
    rect.width = -5
except ValueError as e:
    print(f"Ошибка: {e}")  # Ширина должна быть положительной
```

**Преимущества property:**
1. **Естественный синтаксис** — `obj.celsius = 30` вместо `obj.set_celsius(30)`
2. **Обратная совместимость** — можно добавить валидацию к существующему атрибуту без изменения кода, который его использует
3. **Вычисляемые атрибуты** — значение рассчитывается динамически, но выглядит как обычный атрибут
4. **Read-only атрибуты** — легко создать атрибут, который можно только читать
5. **Единообразие** — все атрибуты используют одинаковый синтаксис

**Недостатки старого синтаксиса property:**
Хотя `property()` лучше явных геттеров/сеттеров, код всё ещё выглядит громоздко — приходится писать отдельные функции и связывать их. Есть более элегантное решение — декоратор `@property`, о котором в следующем разделе!


## `26.5` Декоратор `@property` — как работает и зачем
[Видео про @property](https://youtu.be/HkbQ_NaH0Lc?si=ufzyV1HdKl6a48Ov)

**Теория:**
`@property` — это декоратор, который делает то же самое, что и `property()`, но синтаксис гораздо красивее и понятнее. Это современный и рекомендуемый способ создания свойств в Python.

**Как работает:**
1. `@property` над методом делает его геттером
2. `@имя_свойства.setter` создаёт сеттер для этого свойства
3. `@имя_свойства.deleter` создаёт делитер для этого свойства

Все три декоратора работают с одним и тем же именем свойства, связывая соответствующие методы.

**Важно:** Имя метода под декоратором должно совпадать с именем свойства. Сначала определяется геттер с `@property`, затем можно добавить сеттер и делитер.

**Примеры:**

```python
# Пример 1: Базовое использование @property
class Person:
    def __init__(self, name, age):
        self._name = name
        self._age = age
    
    @property
    def name(self):
        """Геттер для имени"""
        return self._name.title()  # Возвращаем с большой буквы
    
    @property
    def age(self):
        """Геттер для возраста"""
        return self._age
    
    @age.setter
    def age(self, value):
        """Сеттер для возраста с валидацией"""
        if not isinstance(value, int):
            raise TypeError("Возраст должен быть целым числом")
        if value < 0 or value > 150:
            raise ValueError("Некорректный возраст")
        self._age = value
    
    @age.deleter
    def age(self):
        """Делитер для возраста"""
        print("Удаление возраста")
        del self._age

person = Person("иван", 30)
print(person.name)  # Иван (автоматически с большой буквы)
print(person.age)   # 30

person.age = 35     # Сработает валидация
print(person.age)   # 35

# person.age = -5   # ValueError: Некорректный возраст
# person.age = "30" # TypeError: Возраст должен быть целым числом

del person.age      # Удаление возраста
```

```python
# Пример 2: Вычисляемые свойства
class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    @property
    def area(self):
        """Площадь вычисляется динамически"""
        return self.width * self.height
    
    @property
    def perimeter(self):
        """Периметр вычисляется динамически"""
        return 2 * (self.width + self.height)

rect = Rectangle(5, 10)
print(rect.area)      # 50
print(rect.perimeter) # 30

rect.width = 8
print(rect.area)      # 80 (автоматически пересчиталось!)
# rect.area = 100     # AttributeError: can't set attribute
```

```python
# Пример 3: Преобразование единиц измерения
class Temperature:
    def __init__(self, celsius):
        self._celsius = celsius
    
    @property
    def celsius(self):
        return self._celsius
    
    @celsius.setter
    def celsius(self, value):
        if value < -273.15:
            raise ValueError("Температура не может быть ниже абсолютного нуля")
        self._celsius = value
    
    @property
    def fahrenheit(self):
        """Автоматическое преобразование в Фаренгейты"""
        return self._celsius * 9/5 + 32
    
    @fahrenheit.setter
    def fahrenheit(self, value):
        """Устанавливаем через Фаренгейты, сохраняем в Цельсиях"""
        self._celsius = (value - 32) * 5/9

temp = Temperature(0)
print(temp.celsius)     # 0
print(temp.fahrenheit)  # 32.0

temp.fahrenheit = 212   # Устанавливаем 212°F
print(temp.celsius)     # 100.0 (автоматически конвертировалось!)
```

```python
# Пример 4: Ленивая инициализация с кэшированием
class DataLoader:
    def __init__(self, filename):
        self.filename = filename
        self._data = None  # Данные ещё не загружены
    
    @property
    def data(self):
        """Загружаем данные только при первом обращении"""
        if self._data is None:
            print(f"Загрузка данных из {self.filename}...")
            # Симуляция загрузки данных
            self._data = f"Содержимое файла {self.filename}"
        return self._data
    
    @data.setter
    def data(self, value):
        """Обновляем кэш"""
        print("Обновление кэшированных данных")
        self._data = value
    
    @data.deleter
    def data(self):
        """Очищаем кэш"""
        print("Очистка кэша")
        self._data = None

loader = DataLoader("data.txt")
print("Объект создан, но данные не загружены")

# Первое обращение — данные загружаются
print(loader.data)  # Загрузка данных из data.txt... → Содержимое файла data.txt

# Второе обращение — используется кэш
print(loader.data)  # Содержимое файла data.txt (без загрузки)

# Очищаем кэш
del loader.data  # Очистка кэша

# Снова загружается при обращении
print(loader.data)  # Загрузка данных из data.txt... → Содержимое файла data.txt
```

```python
# Пример 5: Сложная валидация и связанные свойства
class BankAccount:
    def __init__(self, owner, balance):
        self._owner = owner
        self._balance = balance
        self._transaction_history = []
    
    @property
    def owner(self):
        return self._owner
    
    @owner.setter
    def owner(self, value):
        if not value or not value.strip():
            raise ValueError("Владелец не может быть пустым")
        old_owner = self._owner
        self._owner = value.strip()
        print(f"Владелец счёта изменён: {old_owner} → {self._owner}")
    
    @property
    def balance(self):
        return self._balance
    
    @balance.setter
    def balance(self, value):
        if value < 0:
            raise ValueError("Баланс не может быть отрицательным")
        
        change = value - self._balance
        self._balance = value
        
        # Записываем в историю транзакций
        self._transaction_history.append({
            'new_balance': value,
            'change': change
        })
        print(f"Баланс изменён: {change:+.2f} (новый баланс: {value:.2f})")
    
    @property
    def transaction_history(self):
        """Read-only свойство — нельзя изменить историю напрямую"""
        return self._transaction_history.copy()

account = BankAccount("Иван Иванов", 1000)

print(account.balance)  # 1000

account.balance = 1500  # Баланс изменён: +500.00 (новый баланс: 1500.00)
account.balance = 1200  # Баланс изменён: -300.00 (новый баланс: 1200.00)

print(account.transaction_history)
# [{'new_balance': 1500, 'change': 500}, {'new_balance': 1200, 'change': -300}]

account.owner = "Пётр Петров"  # Владелец счёта изменён: Иван Иванов → Пётр Петров
```

```python
# Пример 6: Сравнение старого синтаксиса property() с @property
class Circle:
    def __init__(self, radius):
        self._radius = radius
    
    # Старый способ с property()
    def get_radius(self):
        return self._radius
    
    def set_radius(self, value):
        if value <= 0:
            raise ValueError("Радиус должен быть положительным")
        self._radius = value
    
    radius_old = property(get_radius, set_radius)
    
    # Новый способ с @property (гораздо чище!)
    @property
    def diameter(self):
        return self._radius * 2
    
    @diameter.setter
    def diameter(self, value):
        if value <= 0:
            raise ValueError("Диаметр должен быть положительным")
        self._radius = value / 2
    
    @property
    def area(self):
        return 3.14159 * self._radius ** 2

circle = Circle(5)

# Оба способа работают одинаково
print(circle.radius_old)  # 5
print(circle.diameter)    # 10
print(circle.area)        # 78.53975

circle.diameter = 20
print(circle.radius_old)  # 10.0
print(circle.area)        # 314.159
```

**Преимущества @property:**
- **Чистый синтаксис** — код выглядит как обычные атрибуты: `obj.value` вместо `obj.get_value()`
- **Читабельность** — все методы для одного свойства находятся рядом
- **Обратная совместимость** — можно добавить валидацию к существующим атрибутам без изменения внешнего API
- **Ленивые вычисления** — значение вычисляется только при обращении
- **Pythonic** — это стандартный и рекомендуемый способ создания свойств в Python

**Когда использовать @property:**
- Нужна валидация при установке значения
- Атрибут должен быть вычисляемым (например, площадь из ширины и высоты)
- Нужно преобразование данных при чтении/записи
- Требуется ленивая инициализация
- Хотите сделать атрибут read-only (только геттер без сеттера)
- Нужно логирование обращений к атрибуту


## `26.6` Декораторы `@classmethod` и `@staticmethod` — что такое `cls` и различия
**Теория:**
Обычные методы работают с экземплярами класса через `self`. Но иногда нужны методы, которые:
- Работают с самим классом, а не с конкретным объектом — `@classmethod`
- Вообще не зависят от класса или объекта — `@staticmethod`

### `@classmethod`
- Первый параметр — `cls` (сам класс, а не объект)
- Может обращаться к атрибутам класса и создавать экземпляры
- Используется для фабричных методов (альтернативных конструкторов)

### `@staticmethod`
- Не получает ни `self`, ни `cls`
- Просто функция внутри класса для логической группировки
- Не может менять состояние класса или объекта

**Примеры:**

```python
# Пример 1: Различия между методами
class MyClass:
    class_variable = "Я переменная класса"
    
    def instance_method(self):
        """Обычный метод — работает с объектом"""
        return f"Вызван из объекта: {self}"
    
    @classmethod
    def class_method(cls):
        """Метод класса — работает с классом"""
        return f"Вызван из класса: {cls.__name__}, переменная: {cls.class_variable}"
    
    @staticmethod
    def static_method():
        """Статический метод — не работает ни с чем"""
        return "Просто функция в классе"

obj = MyClass()

print(obj.instance_method())      # Вызван из объекта: <__main__.MyClass object at ...>
print(obj.class_method())         # Вызван из класса: MyClass, переменная: Я переменная класса
print(MyClass.class_method())     # То же самое — можно вызывать через класс
print(MyClass.static_method())    # Просто функция в классе
```

```python
# Пример 2: @classmethod для альтернативных конструкторов
class Date:
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day
    
    @classmethod
    def from_string(cls, date_string):
        """Создание объекта из строки"""
        year, month, day = map(int, date_string.split('-'))
        return cls(year, month, day)  # cls — это Date (или подкласс)
    
    @classmethod
    def today(cls):
        """Создание объекта с сегодняшней датой"""
        import datetime
        today = datetime.date.today()
        return cls(today.year, today.month, today.day)
    
    def __str__(self):
        return f"{self.year}-{self.month:02d}-{self.day:02d}"

# Разные способы создания объекта
date1 = Date(2025, 10, 9)              # Обычный конструктор
date2 = Date.from_string("2025-10-09") # Через classmethod
date3 = Date.today()                   # Через classmethod

print(date1)  # 2025-10-09
print(date2)  # 2025-10-09
print(date3)  # 2025-10-09
```

```python
# Пример 3: @staticmethod для вспомогательных функций
class StringUtils:
    @staticmethod
    def is_palindrome(text):
        """Проверка, является ли строка палиндромом"""
        cleaned = text.replace(" ", "").lower()
        return cleaned == cleaned[::-1]
    
    @staticmethod
    def count_words(text):
        """Подсчёт слов в строке"""
        return len(text.split())
    
    @staticmethod
    def reverse_words(text):
        """Переворот слов в строке"""
        return ' '.join(text.split()[::-1])

# Можно вызывать без создания объекта
print(StringUtils.is_palindrome("А роза упала на лапу Азора"))  # True
print(StringUtils.count_words("Привет мир"))                    # 2
print(StringUtils.reverse_words("Привет мир"))                  # мир Привет

# Или через объект (но смысла нет)
utils = StringUtils()
print(utils.is_palindrome("level"))  # True
```

```python
# Пример 4: Наследование и @classmethod
class Animal:
    species_count = 0
    
    def __init__(self, name):
        self.name = name
        Animal.species_count += 1
    
    @classmethod
    def get_count(cls):
        return f"Всего {cls.__name__}: {cls.species_count}"
    
    @classmethod
    def create_many(cls, names):
        """Создаёт несколько экземпляров"""
        return [cls(name) for name in names]

class Dog(Animal):
    pass

class Cat(Animal):
    pass

# classmethod работает с правильным классом
dogs = Dog.create_many(["Бобик", "Рекс"])
cats = Cat.create_many(["Мурка"])

print(Dog.get_count())  # Всего Dog: 3
print(Cat.get_count())  # Всего Cat: 3
# species_count общий для всех, но cls.__name__ разный
```

**Когда что использовать:**
- **Обычный метод** — когда нужен доступ к атрибутам объекта
- **@classmethod** — для альтернативных конструкторов, работы с атрибутами класса
- **@staticmethod** — для утилитарных функций, логически связанных с классом


## `26.7` (`**`) Продвинутое: `@singledispatchmethod` — перегрузка методов по типу аргумента
[Видео про @singledispatchmethod](https://www.youtube.com/watch?v=iXORLumN1Lo)

**Теория:**
`@singledispatchmethod` — это декоратор из модуля `functools`, который позволяет создавать методы с разным поведением в зависимости от типа первого аргумента (после `self`). Это называется **перегрузка методов** или **single dispatch**.

**Зачем нужно:**
В Python нет встроенной перегрузки методов, как в Java или C++. Обычно приходится писать множество `if isinstance(...)` проверок. `@singledispatchmethod` делает код чище и понятнее.

**Как работает:**
1. Базовый метод с `@singledispatchmethod` определяет общее поведение
2. Специализированные версии регистрируются через `@метод.register`
3. Python автоматически выбирает нужную версию по типу аргумента

**Примеры:**

```python
# Пример 1: Базовое использование
from functools import singledispatchmethod

class DataProcessor:
    @singledispatchmethod
    def process(self, data):
        """Базовая версия — для неизвестных типов"""
        raise NotImplementedError(f"Не знаю как обработать {type(data)}")
    
    @process.register
    def _(self, data: str):
        """Специальная версия для строк"""
        return f"Обработка строки: {data.upper()}"
    
    @process.register
    def _(self, data: int):
        """Специальная версия для чисел"""
        return f"Обработка числа: {data * 2}"
    
    @process.register
    def _(self, data: list):
        """Специальная версия для списков"""
        return f"Обработка списка из {len(data)} элементов: {sum(data)}"

processor = DataProcessor()

print(processor.process("hello"))      # Обработка строки: HELLO
print(processor.process(42))           # Обработка числа: 84
print(processor.process([1, 2, 3]))    # Обработка списка из 3 элементов: 6
# processor.process(3.14)              # NotImplementedError
```

```python
# Пример 2: Форматирование разных типов данных
from functools import singledispatchmethod
from datetime import datetime

class Formatter:
    @singledispatchmethod
    def format(self, value):
        """По умолчанию — просто str()"""
        return str(value)
    
    @format.register
    def _(self, value: int):
        """Форматирование целых чисел"""
        return f"{value:,}".replace(",", " ")  # 1000000 → 1 000 000
    
    @format.register
    def _(self, value: float):
        """Форматирование дробных чисел"""
        return f"{value:.2f}"  # 3.14159 → 3.14
    
    @format.register
    def _(self, value: bool):
        """Форматирование булевых значений"""
        return "✓" if value else "✗"
    
    @format.register
    def _(self, value: datetime):
        """Форматирование дат"""
        return value.strftime("%d.%m.%Y %H:%M")
    
    @format.register(list)
    @format.register(tuple)
    def _(self, value):
        """Форматирование последовательностей (можно регистрировать несколько типов)"""
        formatted = [self.format(item) for item in value]
        return f"[{', '.join(formatted)}]"

formatter = Formatter()

print(formatter.format(1000000))                    # 1 000 000
print(formatter.format(3.14159))                    # 3.14
print(formatter.format(True))                       # ✓
print(formatter.format(datetime(2025, 10, 9, 14, 30)))  # 09.10.2025 14:30
print(formatter.format([1, 2.5, True]))             # [1, 2.50, ✓]
print(formatter.format((100, 200)))                 # [100, 200]
```

```python
# Пример 3: Сохранение в разные форматы
from functools import singledispatchmethod
import json

class DataSaver:
    def __init__(self, filename):
        self.filename = filename
    
    @singledispatchmethod
    def save(self, data):
        """Базовый метод — ошибка"""
        raise TypeError(f"Не могу сохранить тип {type(data)}")
    
    @save.register
    def _(self, data: dict):
        """Сохранение словаря в JSON"""
        with open(self.filename, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        print(f"Словарь сохранён в JSON: {self.filename}")
    
    @save.register
    def _(self, data: str):
        """Сохранение строки в текстовый файл"""
        with open(self.filename, 'w', encoding='utf-8') as f:
            f.write(data)
        print(f"Строка сохранена в TXT: {self.filename}")
    
    @save.register
    def _(self, data: list):
        """Сохранение списка построчно"""
        with open(self.filename, 'w', encoding='utf-8') as f:
            for item in data:
                f.write(f"{item}\n")
        print(f"Список сохранён построчно: {self.filename}")

# Использование
saver = DataSaver("output.txt")
saver.save({"name": "Иван", "age": 30})  # Словарь сохранён в JSON: output.txt
saver.save("Привет, мир!")               # Строка сохранена в TXT: output.txt
saver.save([1, 2, 3, 4, 5])              # Список сохранён построчно: output.txt
```

**Важные моменты:**
- Dispatch происходит только по **первому** аргументу после `self`
- Типы проверяются через `isinstance()`, работает наследование
- Можно регистрировать один метод для нескольких типов
- Имя метода в `@метод.register` можно опустить (использовать `_`)

**Альтернатива без singledispatchmethod:**
```python
# Без singledispatchmethod пришлось бы писать так:
def process(self, data):
    if isinstance(data, str):
        return f"Обработка строки: {data.upper()}"
    elif isinstance(data, int):
        return f"Обработка числа: {data * 2}"
    elif isinstance(data, list):
        return f"Обработка списка: {sum(data)}"
    else:
        raise NotImplementedError(f"Не знаю как обработать {type(data)}")
# Менее читабельно и сложнее поддерживать
```

----

# `27` (`*`) Магические методы
Что такое магические методы и зачем нужны?
## `27.1` `__init__`, `__new__`, `super()`, `__del__`
## `27.2` `__str__`, `__repr__`
## `27.3` Сравнение объектов
- `__eq__`
- `__ne__`
- `__lt__`
- `__gt__`
- `__le__`
- `__ge__`
## `27.4` Вызываемые объекты
- `__call__`
## `27.5` Работа с атрибутами
- `__getattribute__`
- `__getattr__`
- `__setattr__`
- `__delattr__`
## `27.6` Хэширование
## `27.7` (`**`) Ultra flex
1) Унарные операторы
2) Арифметические операции
3) Преобразование типов

----

# `28` (`*`) Протоколы
## `28.1` Итерируемые объекты и итераторы
## `28.2` Протокол контекстных менеджеров
## `28.3` Дескрипторы
## `28.4` (`**`) Ultra flex
1) Протокол последовательностей
2) Протокол дескрипторов

----

# `29` (`*`) Наследование и Полиморфизм
## `29.1` Наследование
## `29.2` Полиморфизм
## `29.3` Абстрактные классы и протоколы
## `29.4` Generics
## `29.5` Композиция

----

# `30` (`*`) Extra OOP
## `30.1` `__slots__`, `__dict__`
## `30.2` Enum
## `30.3` Миксины
## `30.4` dataclasses

----

# `31` (`*`) Виртуальное окружение
## `31.1` Что такое виртуальное окружение и зачем?
## `31.1` venv
## `31.1` poetry

----

# `32` (`*`) Многопоточность
[Must have video](https://youtu.be/JIp14T9bvvc?si=uHOZNBIKbo7ZTk68)

## `32.1` Что такое многопоточность и зачем она нужна
**Многопоточность (multithreading)** — это способность программы выполнять несколько задач одновременно в рамках одного процесса. Каждая задача выполняется в отдельном **потоке (thread)** — это независимая последовательность инструкций внутри программы.

### **Простая аналогия:**

Представьте ресторан:
- **Без многопоточности:** один официант обслуживает столики по очереди. Пока он принимает заказ у первого стола, второй и третий ждут.
- **С многопоточностью:** несколько официантов работают одновременно. Один принимает заказ, другой приносит еду, третий убирает посуду — всё происходит параллельно.

### **Как работает обычная программа (однопоточная):**

```python
import time

def download_file(file_name):
    print(f"Начинаю загрузку {file_name}")
    time.sleep(2)  # Имитация загрузки файла (2 секунды)
    print(f"Загрузка {file_name} завершена")

# Загружаем файлы по очереди
start = time.time()

download_file("файл1.txt")
download_file("файл2.txt")
download_file("файл3.txt")

end = time.time()
print(f"Общее время: {end - start:.2f} секунд")

# Вывод:
# Начинаю загрузку файл1.txt
# Загрузка файл1.txt завершена
# Начинаю загрузку файл2.txt
# Загрузка файл2.txt завершена
# Начинаю загрузку файл3.txt
# Загрузка файл3.txt завершена
# Общее время: 6.00 секунд (2+2+2)
```

**Проблема:** каждый файл загружается по очереди. Пока первый файл загружается, программа простаивает и ждёт. Общее время = 6 секунд.

### **С многопоточностью:**

```python
import time
import threading

def download_file(file_name):
    print(f"Начинаю загрузку {file_name}")
    time.sleep(2)  # Имитация загрузки
    print(f"Загрузка {file_name} завершена")

# Создаём потоки для загрузки файлов одновременно
start = time.time()

thread1 = threading.Thread(target=download_file, args=("файл1.txt",))
thread2 = threading.Thread(target=download_file, args=("файл2.txt",))
thread3 = threading.Thread(target=download_file, args=("файл3.txt",))

# Запускаем все потоки
thread1.start()
thread2.start()
thread3.start()

# Ждём завершения всех потоков
thread1.join()
thread2.join()
thread3.join()

end = time.time()
print(f"Общее время: {end - start:.2f} секунд")

# Вывод:
# Начинаю загрузку файл1.txt
# Начинаю загрузку файл2.txt
# Начинаю загрузку файл3.txt
# Загрузка файл1.txt завершена
# Загрузка файл2.txt завершена
# Загрузка файл3.txt завершена
# Общее время: 2.00 секунд (все одновременно!)
```

**Результат:** все три файла загружаются параллельно. Общее время = 2 секунды вместо 6!

### **Зачем нужна многопоточность:**

#### **1. Ускорение I/O операций (ввод-вывод)**

Когда программа ждёт внешние операции (чтение файлов, сетевые запросы, работа с БД), процессор простаивает. Потоки позволяют делать другую работу во время ожидания.

```python
import time
import threading

def check_website(url):
    print(f"Проверяю {url}")
    time.sleep(1)  # Имитация HTTP-запроса
    print(f"{url} доступен")

websites = ["site1.com", "site2.com", "site3.com", "site4.com"]

# Без многопоточности — 4 секунды
start = time.time()
for site in websites:
    check_website(site)
print(f"Время без потоков: {time.time() - start:.2f} сек")  # ~4 секунды

# С многопоточностью — 1 секунда
start = time.time()
threads = []
for site in websites:
    thread = threading.Thread(target=check_website, args=(site,))
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()

print(f"Время с потоками: {time.time() - start:.2f} сек")  # ~1 секунда
```

#### **2. Отзывчивость интерфейса**

В GUI-приложениях длительные операции выполняются в отдельном потоке, чтобы интерфейс не зависал.

```python
import threading
import time

def long_operation():
    """Долгая операция (обработка данных, загрузка файла)"""
    print("Начинаю долгую операцию...")
    time.sleep(5)
    print("Операция завершена!")

# Без потоков — интерфейс зависнет на 5 секунд
# long_operation()  # Программа заморожена!

# С потоками — интерфейс работает
thread = threading.Thread(target=long_operation)
thread.start()

# Основной поток может продолжать работу
print("Интерфейс продолжает работать")
print("Пользователь может нажимать кнопки")
# ... интерфейс отзывчив

thread.join()  # Дожидаемся завершения в конце
```

#### **3. Параллельная обработка независимых задач**

```python
import threading
import time

def process_data(data_chunk, result_list, index):
    """Обработка части данных"""
    print(f"Обрабатываю часть {index}")
    time.sleep(1)  # Имитация обработки
    result = sum(data_chunk)  # Простая обработка
    result_list[index] = result
    print(f"Часть {index} обработана, результат: {result}")

# Большой массив данных
data = list(range(100))

# Делим на 4 части
chunk_size = 25
chunks = [data[i:i+chunk_size] for i in range(0, len(data), chunk_size)]

# Обрабатываем каждую часть в отдельном потоке
results = [0] * 4
threads = []

start = time.time()

for i, chunk in enumerate(chunks):
    thread = threading.Thread(target=process_data, args=(chunk, results, i))
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()

total = sum(results)
print(f"Итоговый результат: {total}")
print(f"Время: {time.time() - start:.2f} сек")

# Вывод:
# Обрабатываю часть 0
# Обрабатываю часть 1
# Обрабатываю часть 2
# Обрабатываю часть 3
# Часть 0 обработана, результат: 300
# Часть 1 обработана, результат: 925
# Часть 2 обработана, результат: 1550
# Часть 3 обработана, результат: 2175
# Итоговый результат: 4950
# Время: ~1 секунда (вместо 4)
```

### **Когда многопоточность полезна:**

✅ **Подходит для:**
- Загрузка файлов из интернета
- Работа с несколькими API одновременно
- Чтение/запись множества файлов
- Работа с базами данных (много запросов)
- GUI приложения (фоновые задачи)
- Сетевые серверы (обработка клиентов)

❌ **НЕ подходит для:**
- Тяжёлые вычисления (математика, обработка изображений)
- CPU-интенсивные задачи (для них нужна многопроцессность)

### **Ключевые моменты:**

- **Поток** — независимая последовательность выполнения кода
- **Многопоточность** — несколько потоков работ

## `32.2` Потоки vs Процессы — основные различия
**Потоки (Threads)** и **процессы (Processes)** — два способа параллельного выполнения задач, но они работают по-разному.

### **Основные различия:**

| Характеристика | Потоки (Threads) | Процессы (Processes) |
|----------------|------------------|---------------------|
| **Память** | Общая (делят память программы) | Изолированная (своя копия памяти) |
| **Создание** | Быстрое и лёгкое | Медленное, требует больше ресурсов |
| **Коммуникация** | Простая (общие переменные) | Сложная (нужны специальные механизмы) |
| **Изоляция** | Низкая (ошибка в одном влияет на все) | Высокая (независимы друг от друга) |
| **Использование** | I/O операции (файлы, сеть, БД) | CPU-интенсивные вычисления |

### **Визуальная аналогия:**

**Потоки** — это как несколько поваров на одной кухне:
- Делят одно пространство (общая память)
- Быстро передают друг другу продукты
- Могут мешать друг другу
- Если один сломает плиту, пострадают все

**Процессы** — это как несколько отдельных кухонь:
- У каждого своя кухня (своя память)
- Медленнее передавать продукты между кухнями
- Не мешают друг другу
- Если сломается одна кухня, другие работают

### **Пример с потоками:**

```python
import threading

# Общая переменная (все потоки видят её)
counter = 0

def increment():
    global counter
    for _ in range(100000):
        counter += 1

# Два потока работают с общей переменной
thread1 = threading.Thread(target=increment)
thread2 = threading.Thread(target=increment)

thread1.start()
thread2.start()

thread1.join()
thread2.join()

print(f"Counter: {counter}")  # Может быть не 200000! (race condition)
```

### **Когда использовать что:**

**Используйте потоки для:**
- Загрузка файлов из интернета
- Множественные запросы к API
- Работа с базой данных
- Чтение/запись файлов
- Сетевые операции

**Используйте процессы для:**
- Тяжёлые математические вычисления
- Обработка изображений/видео
- Машинное обучение
- Любые CPU-интенсивные задачи

## `32.3` GIL (Global Interpreter Lock) — что это и как влияет на многопоточность в Python
**GIL (Global Interpreter Lock)** — это механизм в CPython (стандартная реализация Python), который позволяет выполняться только одному потоку Python-кода одновременно, даже на многоядерном процессоре.

### **Простыми словами:**

Представьте, что у вас 4 повара (потока) и 4 плиты (ядра процессора), но есть только один ключ от кухни (GIL). Только один повар может готовить в данный момент, остальные ждут своей очереди с ключом.

### **Как это влияет:**

**Для I/O операций (файлы, сеть, БД):**
- ✅ GIL **не мешает** — потоки эффективны
- Во время ожидания (чтение файла, HTTP-запрос) GIL отпускается
- Другие потоки могут работать

**Для CPU-интенсивных вычислений:**
- ❌ GIL **блокирует** — потоки неэффективны
- Только один поток вычисляет в момент времени
- Многопоточность может быть даже медленнее

### **Пример влияния GIL:**

```python
import threading
import time

# CPU-интенсивная задача (вычисления)
def calculate():
    result = 0
    for i in range(10_000_000):
        result += i
    return result

# I/O задача (ожидание)
def wait():
    time.sleep(2)
    return "done"

# CPU задача — GIL мешает
start = time.time()
thread1 = threading.Thread(target=calculate)
thread2 = threading.Thread(target=calculate)
thread1.start()
thread2.start()
thread1.join()
thread2.join()
print(f"CPU с потоками: {time.time() - start:.2f} сек")  # ~1.5 сек

# Без потоков
start = time.time()
calculate()
calculate()
print(f"CPU без потоков: {time.time() - start:.2f} сек")  # ~1.5 сек
# Почти одинаково! GIL не даёт ускорения

# I/O задача — GIL не мешает
start = time.time()
thread1 = threading.Thread(target=wait)
thread2 = threading.Thread(target=wait)
thread1.start()
thread2.start()
thread1.join()
thread2.join()
print(f"I/O с потоками: {time.time() - start:.2f} сек")  # ~2 сек

# Без потоков
start = time.time()
wait()
wait()
print(f"I/O без потоков: {time.time() - start:.2f} сек")  # ~4 сек
# В 2 раза быстрее с потоками!
```

### **Решения проблемы GIL:**

1. **Для CPU задач:** используйте `multiprocessing` (процессы вместо потоков)
2. **Для I/O задач:** используйте `threading` или `asyncio`
3. **Альтернативные реализации Python:** Jython, IronPython (без GIL)

### **Ключевые моменты:**

- **GIL** — ограничение CPython, не самого языка Python
- **Не влияет на I/O операции** — потоки эффективны для файлов, сети, БД
- **Блокирует CPU вычисления** — для них используйте процессы
- **Упрощает разработку** — защищает от некоторых проблем многопоточности
- **Не проблема в большинстве случаев** — Python часто используется для I/O задач

## `32.4` Модуль threading — основной инструмент для работы с потоками
`threading` — это встроенный модуль Python для создания и управления потоками. Он предоставляет высокоуровневый интерфейс для многопоточного программирования.

### **Базовый импорт и проверка:**

```python
import threading

# Узнать количество активных потоков
print(f"Активных потоков: {threading.active_count()}")  # 1 (главный поток)

# Получить текущий поток
current = threading.current_thread()
print(f"Текущий поток: {current.name}")  # MainThread

# Список всех активных потоков
print(f"Все потоки: {threading.enumerate()}")  # [<_MainThread(MainThread, started ...)>]
```

### **Основные компоненты модуля:**

```python
import threading

# Thread — класс для создания потоков
# Lock — блокировка для синхронизации
# Event — событие для сигнализации между потоками
# Semaphore — семафор для ограничения доступа
# Queue — очередь для безопасного обмена данными

# Пример простого потока
def worker():
    print(f"Поток {threading.current_thread().name} работает")

thread = threading.Thread(target=worker, name="Worker-1")
thread.start()
thread.join()

# Вывод:
# Поток Worker-1 работает
```

### **Информация о потоке:**

```python
import threading
import time

def task():
    print(f"Имя потока: {threading.current_thread().name}")
    print(f"ID потока: {threading.get_ident()}")
    time.sleep(1)

# Создание именованного потока
thread = threading.Thread(target=task, name="MyWorker")
print(f"Поток создан: {thread.name}")
print(f"Поток живой: {thread.is_alive()}")  # False (ещё не запущен)

thread.start()
print(f"Поток живой: {thread.is_alive()}")  # True (запущен)

thread.join()
print(f"Поток живой: {thread.is_alive()}")  # False (завершён)

# Вывод:
# Поток создан: MyWorker
# Поток живой: False
# Поток живой: True
# Имя потока: MyWorker
# ID потока: 123145472000000 (пример)
# Поток живой: False
```

## `32.5` Создание и запуск потоков:
### **Класс `Thread` — создание потока**

`Thread` — основной класс для создания потоков. Ему передаётся функция, которую нужно выполнить в отдельном потоке.

```python
import threading
import time

def print_numbers():
    for i in range(5):
        print(f"Число: {i}")
        time.sleep(0.5)

# Создаём поток
thread = threading.Thread(target=print_numbers)

# target — функция, которая будет выполнена в потоке
# Поток создан, но ещё не запущен!
```

### **Параметр `target` — функция для выполнения**

`target` — это функция, которую поток будет выполнять.

```python
import threading

def greet():
    print("Привет из потока!")

def calculate():
    result = sum(range(1000000))
    print(f"Результат: {result}")

# Разные функции — разные потоки
thread1 = threading.Thread(target=greet)
thread2 = threading.Thread(target=calculate)

thread1.start()
thread2.start()

thread1.join()
thread2.join()

# Вывод:
# Привет из потока!
# Результат: 499999500000
```

### **Параметры `args` и `kwargs` — передача аргументов**

`args` — позиционные аргументы (кортеж)  
`kwargs` — именованные аргументы (словарь)

```python
import threading
import time

# Функция с параметрами
def download_file(filename, size, delay=1):
    print(f"Загружаю {filename} ({size} MB)")
    time.sleep(delay)
    print(f"{filename} загружен")

# Передача аргументов через args (кортеж)
thread1 = threading.Thread(
    target=download_file,
    args=("file1.txt", 100)  # позиционные аргументы
)

# Передача через args и kwargs
thread2 = threading.Thread(
    target=download_file,
    args=("file2.txt", 50),
    kwargs={"delay": 2}  # именованные аргументы
)

thread1.start()
thread2.start()

thread1.join()
thread2.join()

# Вывод:
# Загружаю file1.txt (100 MB)
# Загружаю file2.txt (50 MB)
# file1.txt загружен
# file2.txt загружен
```

**Ещё примеры с аргументами:**

```python
import threading

# Пример 1: только args
def add(a, b):
    print(f"{a} + {b} = {a + b}")

thread = threading.Thread(target=add, args=(5, 3))
thread.start()
thread.join()
# Вывод: 5 + 3 = 8

# Пример 2: только kwargs
def greet(name, greeting="Привет"):
    print(f"{greeting}, {name}!")

thread = threading.Thread(target=greet, kwargs={"name": "Alice", "greeting": "Здравствуй"})
thread.start()
thread.join()
# Вывод: Здравствуй, Alice!

# Пример 3: args + kwargs
def process(data, mode, verbose=False):
    if verbose:
        print(f"Обрабатываю {data} в режиме {mode}")
    else:
        print(f"Обработка {data}")

thread = threading.Thread(
    target=process,
    args=("данные", "fast"),
    kwargs={"verbose": True}
)
thread.start()
thread.join()
# Вывод: Обрабатываю данные в режиме fast
```

### **Метод `start()` — запуск потока**

`start()` запускает выполнение потока. После вызова `start()` поток начинает работать параллельно с основной программой.

```python
import threading
import time

def worker(name):
    print(f"{name}: начал работу")
    time.sleep(2)
    print(f"{name}: закончил работу")

# Создаём потоки
thread1 = threading.Thread(target=worker, args=("Поток-1",))
thread2 = threading.Thread(target=worker, args=("Поток-2",))

print("Запускаю потоки...")

# Запускаем потоки
thread1.start()  # Поток-1 начинает работать
thread2.start()  # Поток-2 начинает работать

print("Потоки запущены, основная программа продолжает работу")

# ВАЖНО: start() вызывается только один раз!
# thread1.start()  # RuntimeError: threads can only be started once

# Основная программа продолжает работать параллельно
for i in range(3):
    print(f"Основной поток: {i}")
    time.sleep(0.5)

# Вывод:
# Запускаю потоки...
# Поток-1: начал работу
# Поток-2: начал работу
# Потоки запущены, основная программа продолжает работу
# Основной поток: 0
# Основной поток: 1
# Основной поток: 2
# Поток-1: закончил работу
# Поток-2: закончил работу
```

### **Метод `join()` — ожидание завершения потока**

`join()` блокирует выполнение основной программы до тех пор, пока поток не завершится. Это нужно, чтобы дождаться результата работы потока.

```python
import threading
import time

def long_task(name, duration):
    print(f"{name}: начинаю задачу на {duration} сек")
    time.sleep(duration)
    print(f"{name}: задача завершена")

# Создаём и запускаем потоки
thread1 = threading.Thread(target=long_task, args=("Поток-1", 2))
thread2 = threading.Thread(target=long_task, args=("Поток-2", 3))

thread1.start()
thread2.start()

print("Потоки запущены")

# БЕЗ join() — основная программа не ждёт
# print("Программа завершена")
# Программа может завершиться до окончания потоков!

# С join() — ждём завершения
thread1.join()  # Ждём, пока Поток-1 закончит
print("Поток-1 завершён")

thread2.join()  # Ждём, пока Поток-2 закончит
print("Поток-2 завершён")

print("Все потоки завершены, программа завершается")

# Вывод:
# Поток-1: начинаю задачу на 2 сек
# Поток-2: начинаю задачу на 3 сек
# Потоки запущены
# Поток-1: задача завершена
# Поток-1 завершён
# Поток-2: задача завершена
# Поток-2 завершён
# Все потоки завершены, программа завершается
```

**`join()` с таймаутом:**

```python
import threading
import time

def slow_task():
    print("Начинаю долгую задачу...")
    time.sleep(5)
    print("Задача завершена")

thread = threading.Thread(target=slow_task)
thread.start()

# Ждём максимум 2 секунды
thread.join(timeout=2)

# Проверяем, завершился ли поток
if thread.is_alive():
    print("Поток всё ещё работает (превышен таймаут)")
else:
    print("Поток завершён")

# Вывод:
# Начинаю долгую задачу...
# Поток всё ещё работает (превышен таймаут)
# (через 3 секунды)
# Задача завершена
```

### **Практический пример — загрузка файлов:**

```python
import threading
import time

def download_file(url, filename):
    print(f"Начинаю загрузку {filename} с {url}")
    time.sleep(2)  # Имитация загрузки
    print(f"✓ {filename} загружен")

# Список файлов для загрузки
files = [
    ("http://site.com/file1.pdf", "документ1.pdf"),
    ("http://site.com/file2.jpg", "фото1.jpg"),
    ("http://site.com/file3.zip", "архив1.zip"),
]

# Создаём потоки для каждого файла
threads = []

start_time = time.time()

for url, filename in files:
    thread = threading.Thread(
        target=download_file,
        args=(url, filename)
    )
    threads.append(thread)
    thread.start()

# Ждём завершения всех потоков
for thread in threads:
    thread.join()

elapsed = time.time() - start_time
print(f"\nВсе файлы загружены за {elapsed:.2f} секунд")

# Вывод:
# Начинаю загрузку документ1.pdf с http://site.com/file1.pdf
# Начинаю загрузку фото1.jpg с http://site.com/file2.jpg
# Начинаю загрузку архив1.zip с http://site.com/file3.zip
# ✓ документ1.pdf загружен
# ✓ фото1.jpg загружен
# ✓ архив1.zip загружен
#
# Все файлы загружены за 2.00 секунд
```

**Ключевые моменты:**

- `Thread(target=func)` — создаёт поток для выполнения функции
- `args=(...)` — передаёт позиционные аргументы (кортеж)
- `kwargs={...}` — передаёт именованные аргументы (словарь)
- `start()` — запускает поток (вызывается один раз!)
- `join()` — ждёт завершения потока
- `join(timeout=N)` — ждёт максимум N секунд
- `is_alive()` — проверяет, работает ли поток

## `32.6` Наследование от класса Thread — создание собственных потоков
Вместо передачи функции в `target`, можно создать собственный класс, унаследованный от `Thread`, и переопределить метод `run()`. Это удобно для сложных потоков с собственным состоянием и логикой.

### **Базовый синтаксис:**

```python
import threading
import time

class MyThread(threading.Thread):
    def run(self):
        """Этот метод выполняется при вызове start()"""
        print(f"Поток {self.name} запущен")
        time.sleep(2)
        print(f"Поток {self.name} завершён")

# Создание и запуск
thread = MyThread()
thread.start()
thread.join()

# Вывод:
# Поток Thread-1 запущен
# Поток Thread-1 завершён
```

### **Пример с параметрами в конструкторе:**

```python
import threading
import time

class DownloadThread(threading.Thread):
    def __init__(self, url, filename):
        super().__init__()  # ВАЖНО: вызвать конструктор родителя!
        self.url = url
        self.filename = filename
        self.result = None
    
    def run(self):
        """Логика загрузки файла"""
        print(f"Загружаю {self.filename} с {self.url}")
        time.sleep(2)  # Имитация загрузки
        self.result = f"{self.filename} загружен"
        print(f"✓ {self.result}")

# Создание и запуск потоков
thread1 = DownloadThread("http://site.com/file1.pdf", "документ.pdf")
thread2 = DownloadThread("http://site.com/file2.jpg", "фото.jpg")

thread1.start()
thread2.start()

thread1.join()
thread2.join()

# Получение результатов
print(f"Результат 1: {thread1.result}")
print(f"Результат 2: {thread2.result}")

# Вывод:
# Загружаю документ.pdf с http://site.com/file1.pdf
# Загружаю фото.jpg с http://site.com/file2.jpg
# ✓ документ.pdf загружен
# ✓ фото.jpg загружен
# Результат 1: документ.pdf загружен
# Результат 2: фото.jpg загружен
```

### **Пример с обработкой данных:**

```python
import threading
import time

class DataProcessor(threading.Thread):
    def __init__(self, data, processor_id):
        super().__init__()
        self.data = data
        self.processor_id = processor_id
        self.result = 0
    
    def run(self):
        print(f"Процессор {self.processor_id}: начинаю обработку {len(self.data)} элементов")
        time.sleep(1)  # Имитация обработки
        self.result = sum(self.data)
        print(f"Процессор {self.processor_id}: результат = {self.result}")

# Данные для обработки
data = list(range(100))
chunk_size = 25

# Создаём несколько процессоров
processors = []
for i in range(4):
    chunk = data[i*chunk_size:(i+1)*chunk_size]
    processor = DataProcessor(chunk, i+1)
    processors.append(processor)
    processor.start()

# Ждём завершения
for processor in processors:
    processor.join()

# Собираем результаты
total = sum(p.result for p in processors)
print(f"\nИтоговый результат: {total}")

# Вывод:
# Процессор 1: начинаю обработку 25 элементов
# Процессор 2: начинаю обработку 25 элементов
# Процессор 3: начинаю обработку 25 элементов
# Процессор 4: начинаю обработку 25 элементов
# Процессор 1: результат = 300
# Процессор 2: результат = 925
# Процессор 3: результат = 1550
# Процессор 4: результат = 2175
#
# Итоговый результат: 4950
```

### **Когда использовать наследование:**

✅ **Используйте класс, если:**
- Поток имеет сложную логику
- Нужно хранить состояние (результаты, промежуточные данные)
- Требуется переиспользование логики потока
- Нужны дополнительные методы

❌ **Используйте `target`, если:**
- Простая функция без состояния
- Одноразовая задача
- Не нужны дополнительные методы

**Ключевые моменты:**
- Наследуйтесь от `threading.Thread`
- Вызовите `super().__init__()` в конструкторе
- Переопределите метод `run()` с логикой потока
- Результаты храните в атрибутах экземпляра
- Запускайте через `start()`, а не `run()`!


## `32.7` Daemon потоки — что это и когда использовать
**Daemon поток (фоновый поток)** — это поток, который автоматически завершается при завершении главной программы. В отличие от обычных потоков, программа не ждёт завершения daemon-потоков.

### **Обычные vs Daemon потоки:**

```python
import threading
import time

def worker(name, is_daemon):
    print(f"{name}: начал работу")
    time.sleep(3)
    print(f"{name}: закончил работу")

# Обычный поток
normal_thread = threading.Thread(target=worker, args=("Обычный", False))

# Daemon поток (устанавливается ПЕРЕД start!)
daemon_thread = threading.Thread(target=worker, args=("Daemon", True))
daemon_thread.daemon = True  # Помечаем как daemon

print("Запускаю потоки...")
normal_thread.start()
daemon_thread.start()

print("Главная программа ждёт 1 секунду и завершается")
time.sleep(1)
print("Главная программа завершена")

# Вывод:
# Запускаю потоки...
# Обычный: начал работу
# Daemon: начал работу
# Главная программа ждёт 1 секунду и завершается
# Главная программа завершена
# Обычный: закончил работу
# (Daemon поток принудительно завершён, не выведет "закончил работу")
```

### **Как создать daemon поток:**

```python
import threading

def task():
    print("Работаю...")

# Способ 1: через атрибут daemon (ПЕРЕД start!)
thread1 = threading.Thread(target=task)
thread1.daemon = True
thread1.start()

# Способ 2: через параметр конструктора
thread2 = threading.Thread(target=task, daemon=True)
thread2.
```

### **Примеры из реальной жизни**
1) `Автоматическая очистка мусора`
Например, служба, удаляющая временные файлы на сервере — она просто работает в фоне и всё завершает, когда сервер отключается.

2) `Мониторинг состояния системы`
Системные утилиты, отслеживающие температуру CPU, загрузку диска, состояние сетевого подключения — работают в фоне и не требуют ручного контроля.

3) `Логгирование событий`
Приложения, которые пишут логи в отдельном потоке: поток логгирования работает в фоне, не блокируя основную работу.

4) `Фоновые проверки почты или обновлений`
Почтовые клиенты периодически проверяют новые письма в фоне; обновлялка приложений раз в час ищет апдейты и завершает работу с выходом из программы.

5) `Слежение за действиями пользователя`
В IDE или браузере отдельный поток может следить за действиями пользователя (например, автосохранение или запись макросов), завершаясь, если пользователь закроет приложение.

6) `Сетевые "сердцебиения" (heartbeat)`
Сервис отправляет регулярные сообщения, чтобы показать, что всё работает — такой поток завершится, если программа выключится.


## `32.8` Проблема гонки данных (race condition)
### Что такое race condition?
**Race condition (гонка данных)** — это ситуация, когда результат работы программы зависит от порядка выполнения потоков, который невозможно предсказать. Возникает, когда несколько потоков одновременно пытаются читать и изменять общие данные.

#### Почему это происходит?

Даже простая операция `counter += 1` на самом деле состоит из нескольких шагов:
1. Прочитать текущее значение `counter`
2. Увеличить его на 1
3. Записать новое значение обратно

Если два потока выполняют эти шаги одновременно, они могут "наступить друг другу на пятки".

### Пример проблемы

```python
import threading
import time

counter = 0

def increment():
    global counter
    for _ in range(100000):
        counter += 1

# Создаём 5 потоков
threads = []
for _ in range(5):
    t = threading.Thread(target=increment)
    threads.append(t)
    t.start()

# Ждём завершения всех потоков
for t in threads:
    t.join()

print(f"Ожидаемое значение: {5 * 100000}")
print(f"Реальное значение: {counter}")
```

**Вывод (может варьироваться):**
```
Ожидаемое значение: 500000
Реальное значение: 287463
```

Значение меньше ожидаемого! Это классический пример race condition — потоки "затёрли" изменения друг друга.

### Как избежать race condition?

#### 1. Использование блокировок (Lock)

Самый простой способ — использовать `threading.Lock()`, чтобы только один поток мог изменять данные в определённый момент времени.

```python
import threading

counter = 0
lock = threading.Lock()

def increment_safe():
    global counter
    for _ in range(100000):
        with lock:  # Блокируем доступ для других потоков
            counter += 1

threads = []
for _ in range(5):
    t = threading.Thread(target=increment_safe)
    threads.append(t)
    t.start()

for t in threads:
    t.join()

print(f"Ожидаемое значение: {5 * 100000}")
print(f"Реальное значение: {counter}")
```

**Вывод:**
```
Ожидаемое значение: 500000
Реальное значение: 500000
```

Теперь результат правильный! Блокировка гарантирует, что только один поток за раз может выполнять код внутри `with lock:`.

#### 2. Работа со списками

```python
import threading

results = []
lock = threading.Lock()

def add_items(start, end):
    for i in range(start, end):
        with lock:
            results.append(i)

threads = []
for i in range(5):
    t = threading.Thread(target=add_items, args=(i*1000, (i+1)*1000))
    threads.append(t)
    t.start()

for t in threads:
    t.join()

print(f"Добавлено элементов: {len(results)}")
print(f"Первые 10: {sorted(results)[:10]}")
```

#### 3. Банковский счёт — классический пример

```python
import threading
import time
import random

class BankAccount:
    def __init__(self, balance):
        self.balance = balance
        self.lock = threading.Lock()
    
    def withdraw(self, amount):
        with self.lock:
            if self.balance >= amount:
                # Имитируем задержку (проверка, обработка и т.д.)
                time.sleep(0.001)
                self.balance -= amount
                return True
            return False
    
    def deposit(self, amount):
        with self.lock:
            self.balance += amount

account = BankAccount(1000)

def make_transactions(account_obj):
    for _ in range(10):
        # Случайная операция: снятие или пополнение
        if random.choice([True, False]):
            amount = random.randint(10, 100)
            if account_obj.withdraw(amount):
                print(f"Снято {amount}, баланс: {account_obj.balance}")
        else:
            amount = random.randint(10, 100)
            account_obj.deposit(amount)
            print(f"Пополнено {amount}, баланс: {account_obj.balance}")

threads = []
for _ in range(3):
    t = threading.Thread(target=make_transactions, args=(account,))
    threads.append(t)
    t.start()

for t in threads:
    t.join()

print(f"\nИтоговый баланс: {account.balance}")
```

Без блокировки баланс мог бы стать отрицательным или операции могли бы "потеряться".

### Когда блокировки не нужны?

Есть случаи, когда race condition не возникает:

#### 1. Потоки работают с разными данными

```python
import threading

def process_range(start, end, results, index):
    # Каждый поток записывает в свою ячейку списка
    results[index] = sum(range(start, end))

results = [0, 0, 0, 0]
threads = []

for i in range(4):
    t = threading.Thread(
        target=process_range,
        args=(i*250, (i+1)*250, results, i)
    )
    threads.append(t)
    t.start()

for t in threads:
    t.join()

print(f"Результаты: {results}")
print(f"Сумма: {sum(results)}")
```

Здесь блокировка не нужна, потому что каждый поток работает со своим индексом.

#### 2. Только чтение данных

```python
import threading

# Общие данные, которые только читаются
config = {
    'timeout': 30,
    'max_retries': 3,
    'server': 'example.com'
}

def worker(worker_id):
    # Только читаем данные — безопасно без блокировок
    timeout = config['timeout']
    print(f"Воркер {worker_id} использует timeout={timeout}")

threads = []
for i in range(5):
    t = threading.Thread(target=worker, args=(i,))
    threads.append(t)
    t.start()

for t in threads:
    t.join()
```

### Резюме

**Race condition возникает когда:**
- Несколько потоков обращаются к общим данным
- Хотя бы один поток изменяет эти данные
- Операции не синхронизированы

**Как избежать:**
- Используйте `threading.Lock()` для критических секций
- Применяйте контекстный менеджер `with lock:` для автоматического освобождения блокировки
- Проектируйте код так, чтобы потоки работали с разными данными
- Используйте потокобезопасные структуры данных (о них в следующих топиках)


## `32.9` Синхронизация потоков: `Lock`, `RLock`, `Semaphore`, `Event`, `Condition`
Модуль `threading` предоставляет несколько примитивов синхронизации для координации работы потоков. Каждый из них решает свои задачи.

### 1. Lock — базовая блокировка

`Lock` — самый простой примитив синхронизации. Работает как замок: один поток "запирает" его, другие ждут, пока он не "откроется".

#### Основные методы:
- `acquire()` — захватить блокировку (заблокировать, если уже занята)
- `release()` — освободить блокировку
- `locked()` — проверить, занята ли блокировка

```python
import threading
import time

lock = threading.Lock()
counter = 0

def increment_with_lock():
    global counter
    for _ in range(100000):
        lock.acquire()
        try:
            counter += 1
        finally:
            lock.release()  # Обязательно освобождаем в finally

# Или используем контекстный менеджер (рекомендуется)
def increment_safe():
    global counter
    for _ in range(100000):
        with lock:  # Автоматически вызывает acquire и release
            counter += 1

threads = [threading.Thread(target=increment_safe) for _ in range(5)]

for t in threads:
    t.start()
for t in threads:
    t.join()

print(f"Counter: {counter}")
```

#### Важно!
Lock нельзя захватить дважды в одном потоке:

```python
lock = threading.Lock()

lock.acquire()
lock.acquire()  # Зависнет навсегда! Deadlock
lock.release()
```

### 2. RLock — рекурсивная блокировка

`RLock` (Reentrant Lock) позволяет одному и тому же потоку захватывать блокировку несколько раз. Полезно для рекурсивных функций.

```python
import threading

rlock = threading.RLock()

def recursive_function(n):
    with rlock:
        print(f"Уровень {n}")
        if n > 0:
            recursive_function(n - 1)  # Повторный захват той же блокировки

thread = threading.Thread(target=recursive_function, args=(5,))
thread.start()
thread.join()
```

**Вывод:**
```
Уровень 5
Уровень 4
Уровень 3
Уровень 2
Уровень 1
Уровень 0
```

#### Пример с классом

```python
import threading

class Counter:
    def __init__(self):
        self.value = 0
        self.lock = threading.RLock()
    
    def increment(self):
        with self.lock:
            self.value += 1
    
    def increment_by(self, amount):
        with self.lock:  # Первый захват блокировки
            for _ in range(amount):
                self.increment()  # Повторный захват — работает благодаря RLock!

counter = Counter()
threads = [threading.Thread(target=counter.increment_by, args=(1000,)) for _ in range(5)]

for t in threads:
    t.start()
for t in threads:
    t.join()

print(f"Counter: {counter.value}")
```

### 3. Semaphore — ограничение количества доступов

`Semaphore` позволяет ограничить количество потоков, которые могут одновременно выполнять определённый код. Это как турникет с несколькими проходами.

```python
import threading
import time

# Разрешаем только 3 одновременных подключения
semaphore = threading.Semaphore(3)

def access_resource(worker_id):
    print(f"Воркер {worker_id} ждёт доступа...")
    with semaphore:
        print(f"Воркер {worker_id} получил доступ к ресурсу")
        time.sleep(2)  # Имитация работы с ресурсом
        print(f"Воркер {worker_id} освободил ресурс")

threads = [threading.Thread(target=access_resource, args=(i,)) for i in range(10)]

for t in threads:
    t.start()
for t in threads:
    t.join()
```

**Вывод (с задержками):**
```
Воркер 0 ждёт доступа...
Воркер 1 ждёт доступа...
Воркер 2 ждёт доступа...
Воркер 0 получил доступ к ресурсу
Воркер 1 получил доступ к ресурсу
Воркер 2 получил доступ к ресурсу
Воркер 3 ждёт доступа...
Воркер 4 ждёт доступа...
...
```

#### Практический пример: ограничение запросов к API

```python
import threading
import time
import random

# Ограничиваем до 5 одновременных запросов
api_semaphore = threading.Semaphore(5)

def make_api_request(request_id):
    with api_semaphore:
        print(f"Запрос {request_id} отправлен")
        time.sleep(random.uniform(0.5, 2))  # Имитация запроса
        print(f"Запрос {request_id} завершён")

threads = [threading.Thread(target=make_api_request, args=(i,)) for i in range(20)]

for t in threads:
    t.start()
for t in threads:
    t.join()

print("Все запросы выполнены")
```

### 4. Event — сигнализация между потоками

`Event` используется для оповещения потоков о каких-то событиях. Работает как флаг: установлен или не установлен.

#### Основные методы:
- `set()` — установить флаг (событие произошло)
- `clear()` — сбросить флаг
- `wait(timeout=None)` — ждать, пока флаг не будет установлен
- `is_set()` — проверить состояние флага

```python
import threading
import time

event = threading.Event()

def waiter(name):
    print(f"{name}: Жду сигнала...")
    event.wait()  # Блокируется до вызова event.set()
    print(f"{name}: Получил сигнал! Начинаю работу")

def sender():
    print("Sender: Готовлю данные...")
    time.sleep(3)
    print("Sender: Данные готовы, отправляю сигнал")
    event.set()  # Разблокирует все ожидающие потоки

# Создаём несколько ожидающих потоков
waiters = [threading.Thread(target=waiter, args=(f"Воркер-{i}",)) for i in range(3)]
sender_thread = threading.Thread(target=sender)

for t in waiters:
    t.start()

sender_thread.start()

for t in waiters:
    t.join()
sender_thread.join()
```

**Вывод:**
```
Воркер-0: Жду сигнала...
Воркер-1: Жду сигнала...
Воркер-2: Жду сигнала...
Sender: Готовлю данные...
Sender: Данные готовы, отправляю сигнал
Воркер-0: Получил сигнал! Начинаю работу
Воркер-1: Получил сигнал! Начинаю работу
Воркер-2: Получил сигнал! Начинаю работу
```

#### Пример: запуск задач по сигналу

```python
import threading
import time

start_event = threading.Event()
stop_event = threading.Event()

def worker(worker_id):
    print(f"Воркер {worker_id} готов")
    start_event.wait()  # Ждём команды на старт
    
    print(f"Воркер {worker_id} начал работу")
    while not stop_event.is_set():
        print(f"Воркер {worker_id} работает...")
        time.sleep(1)
    
    print(f"Воркер {worker_id} остановлен")

threads = [threading.Thread(target=worker, args=(i,)) for i in range(3)]

for t in threads:
    t.start()

time.sleep(2)
print("Даём команду на старт!")
start_event.set()

time.sleep(5)
print("Даём команду на остановку!")
stop_event.set()

for t in threads:
    t.join()
```

### 5. Condition — условная синхронизация

`Condition` — это комбинация блокировки и события. Позволяет потокам ждать определённого условия и уведомлять друг друга.

#### Основные методы:
- `wait()` — ждать уведомления
- `notify(n=1)` — уведомить n ожидающих потоков
- `notify_all()` — уведомить все ожидающие потоки

```python
import threading
import time
import random

condition = threading.Condition()
items = []

def producer():
    for i in range(5):
        time.sleep(random.uniform(0.5, 1.5))
        with condition:
            item = f"Товар-{i}"
            items.append(item)
            print(f"Производитель создал: {item}")
            condition.notify()  # Уведомляем одного потребителя

def consumer(consumer_id):
    while True:
        with condition:
            while not items:  # Пока список пуст
                print(f"Потребитель {consumer_id} ждёт товара...")
                condition.wait()  # Ждём уведомления
            
            item = items.pop(0)
            print(f"Потребитель {consumer_id} получил: {item}")
            
            if "Товар-4" in item:  # Последний товар
                break

producer_thread = threading.Thread(target=producer)
consumer_threads = [threading.Thread(target=consumer, args=(i,)) for i in range(2)]

producer_thread.start()
for t in consumer_threads:
    t.start()

producer_thread.join()
for t in consumer_threads:
    t.join()
```

#### Пример: очередь задач с ограничением

```python
import threading
import time

class TaskQueue:
    def __init__(self, max_size):
        self.queue = []
        self.max_size = max_size
        self.condition = threading.Condition()
    
    def put(self, task):
        with self.condition:
            while len(self.queue) >= self.max_size:
                print(f"Очередь полна, ждём...")
                self.condition.wait()
            
            self.queue.append(task)
            print(f"Добавлена задача: {task}")
            self.condition.notify()  # Уведомляем потребителя
    
    def get(self):
        with self.condition:
            while not self.queue:
                print("Очередь пуста, ждём задачи...")
                self.condition.wait()
            
            task = self.queue.pop(0)
            print(f"Получена задача: {task}")
            self.condition.notify()  # Уведомляем производителя
            return task

task_queue = TaskQueue(max_size=3)

def producer():
    for i in range(10):
        time.sleep(0.5)
        task_queue.put(f"Задача-{i}")

def consumer():
    for _ in range(10):
        task = task_queue.get()
        time.sleep(1)  # Обработка задачи

producer_thread = threading.Thread(target=producer)
consumer_thread = threading.Thread(target=consumer)

producer_thread.start()
consumer_thread.start()

producer_thread.join()
consumer_thread.join()
```

### Сравнительная таблица

| Примитив | Когда использовать |
|----------|-------------------|
| **Lock** | Защита общих данных от одновременного изменения |
| **RLock** | Когда один поток может захватывать блокировку несколько раз (рекурсия) |
| **Semaphore** | Ограничение количества одновременных доступов к ресурсу |
| **Event** | Простая сигнализация между потоками (старт/стоп) |
| **Condition** | Сложная координация: ожидание определённых условий и уведомления |

### Резюме

- **Lock** — базовая защита от race condition
- **RLock** — для случаев с повторным захватом блокировки в одном потоке
- **Semaphore** — ограничение числа одновременных доступов (например, к API или БД)
- **Event** — простая сигнализация (флаг "да/нет")
- **Condition** — продвинутая координация с ожиданием условий

Выбирайте примитив в зависимости от задачи. В большинстве случаев достаточно `Lock` или `RLock`. Для более сложных сценариев используйте `Semaphore`, `Event` или `Condition`.


## `32.10` Deadlock (взаимная блокировка) — что это и как предотвратить
## `32.11` Модуль queue для безопасного обмена данными между потоками:
`Queue` — FIFO очередь
`LifoQueue` — LIFO очередь (стек)
`PriorityQueue` — очередь с приоритетами
## `32.12` threading.local() — thread-local данные
## `32.13` concurrent.futures.ThreadPoolExecutor — пул потоков для упрощённой работы
## `32.14` Контекстный менеджер для работы с блокировками
## `32.15` Когда использовать многопоточность: I/O-bound задачи

----

# `33` (`*`) Асинхронность
## `33.1` Что такое асинхронность и чем отличается от многопоточности
## `33.2` Синхронный vs асинхронный код — основные различия
## `33.3` Event Loop (цикл событий) — что это и как работает
## `33.4` Ключевые слова `async` и `await` — основы async/await синтаксиса
## `33.5` Корутины (coroutines) — что это и как их создавать
## `33.6` Модуль `asyncio` — основной инструмент для асинхронного программирования
## `33.7` Запуск асинхронного кода:
- `asyncio.run()` — запуск корутины
- `asyncio.create_task()` — создание задачи
- `asyncio.gather()` — параллельное выполнение корутин
## `33.8` Awaitable объекты — что можно await'ить
## `33.9` Task (задачи) — управление асинхронными операциями
## `33.10` `asyncio.sleep()` — асинхронная пауза
## `33.11` Async context managers — `async with`
## `33.12` Async iterators и async generators — `async for`
## `33.13` Работа с асинхронными очередями — `asyncio.Queue`
## `33.14` Синхронизация в asyncio:
- `asyncio.Lock`
- `asyncio.Semaphore`
- `asyncio.Event`
- `asyncio.Condition`
## `33.15` `asyncio.wait()` и `asyncio.wait_for()` — управление временем выполнения
## `33.16` Обработка исключений в асинхронном коде
## `33.17` `asyncio.shield()` — защита задач от отмены
## `33.18` Отмена задач — `task.cancel()` и обработка `CancelledError`
## `33.19` Работа с subprocess асинхронно — `asyncio.create_subprocess_exec()`
## `33.20` Интеграция синхронного кода в асинхронный:
- `asyncio.to_thread()` — выполнение блокирующего кода
- `loop.run_in_executor()` — использование executor'ов
## `33.21` `concurrent.futures` и asyncio — совместное использование
## `33.22` Async библиотеки для HTTP-запросов:
- `aiohttp` — основы (упоминание без деталей)
- `httpx` — основы (упоминание без деталей)
## `33.23` Когда использовать асинхронность: I/O-bound задачи с высоким concurrency
## `33.24` Продвинутое: создание собственного event loop
## `33.25` Продвинутое: `asyncio.Future` — низкоуровневая работа с результатами

----

# `34` (`*`) Логирование
## `34.1` Что такое логирование и зачем оно нужно
## `34.2` Логирование vs `print()` — основные различия
## `34.3` Модуль `logging` — стандартный инструмент
## `34.4` Уровни логирования — `DEBUG`, `INFO`, `WARNING`, `ERROR`, `CRITICAL`
## `34.5` Базовое логирование — `logging.basicConfig()` и простые функции
## `34.6` Logger — создание именованных логгеров через `logging.getLogger()`
## `34.7` Handler — куда отправляются логи:
- `StreamHandler` — консоль
- `FileHandler` — файл
- `RotatingFileHandler` — ротация файлов
## `34.8` Formatter — форматирование сообщений и основные переменные
## `34.9` Настройка уровней логирования для logger и handler
## `34.10` Логирование исключений — `logger.exception()` и `exc_info=True`
## `34.11` Конфигурация через словарь — `logging.config.dictConfig()`

----

# `35` (`*`) Паттерны проектирования
## `35.1` Что такое паттерны проектирования и зачем они нужны
`Паттерны проектирования` — это проверенные временем решения типовых проблем, которые возникают при разработке программного обеспечения. Это не готовый код, который можно скопировать, а концептуальные шаблоны для решения конкретных задач.

**Зачем нужны паттерны**:
- **Переиспользование решений** — не нужно изобретать велосипед для типовых задач
- **Общий язык** — разработчики понимают друг друга, когда говорят "здесь нужен Singleton" или "давай используем Factory"
- **Улучшение архитектуры** — код становится более гибким, расширяемым и поддерживаемым
- **Избежание ошибок** — паттерны учитывают подводные камни, с которыми уже столкнулись другие разработчики

## `35.2` Категории паттернов — порождающие, структурные, поведенческие
`Паттерны проектирования` делятся на три основные категории по типу решаемых задач:

### **Порождающие паттерны (Creational Patterns)**
Отвечают за создание объектов. Помогают сделать систему независимой от способа создания, композиции и представления объектов.

**Основные паттерны:**
- **Singleton** — гарантирует единственный экземпляр класса
- **Factory Method** — делегирует создание объектов подклассам
- **Builder** — пошаговое создание сложных объектов
- **Prototype** — создание объектов через клонирование

**Когда использовать:** когда нужно контролировать процесс создания объектов, скрыть сложную логику инициализации или обеспечить гибкость при создании.

### **Структурные паттерны (Structural Patterns)**
Описывают способы композиции классов и объектов. Помогают организовать связи между объектами так, чтобы система оставалась гибкой и эффективной.

**Основные паттерны:**
- **Decorator** — позволяет динамически добавлять объектам новую функциональность, оборачивая их в специальные объекты-обёртки
- **Adapter** — приводит интерфейс класса к ожидаемому виду
- **Facade** — предоставляет простой интерфейс к сложной системе
- **Proxy** — контролирует доступ к объекту
- **Composite** — организует объекты в древовидную структуру

**Когда использовать:** когда нужно упростить сложные связи между объектами, сделать систему модульной или обеспечить совместимость несовместимых интерфейсов.

### **Поведенческие паттерны (Behavioral Patterns)**
Определяют взаимодействие между объектами и распределение обязанностей. Помогают организовать эффективную коммуникацию и управление алгоритмами.

**Основные паттерны:**
- **Strategy** — позволяет менять алгоритмы независимо от клиента
- **Observer** — механизм подписки на события
- **Iterator** — последовательный доступ к элементам коллекции
- **Command** — инкапсулирует запрос как объект
- **State** — изменяет поведение объекта при изменении состояния

**Когда использовать:** когда нужно гибко управлять поведением объектов, организовать взаимодействие между компонентами или инкапсулировать изменяющееся поведение.

## `35.3` Singleton — единственный экземпляр класса
`Singleton` гарантирует, что у класса существует только один экземпляр, и предоставляет глобальную точку доступа к нему.

**Зачем нужен:**
- Управление общими ресурсами — подключение к БД, логгер, конфигурация приложения
- Координация действий в системе через единую точку доступа
- Экономия ресурсов — создаём объект только один раз

**Реализация через `__new__`:**
```python
class Database:
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self, host='localhost'):
        self.host = host

# Использование
db1 = Database('localhost')
db2 = Database('remote')
print(db1 is db2)  # True — один и тот же объект
```

Еще можно реализовать через: `декоратор` и `создания единственный экземпляр в коде, а затем его переиспользование (более Питонячий подход)`

**Когда использовать:**
- Конфигурация приложения
- Пул соединений к БД
- Система логирования
- Кеш или реестр объектов

**Осторожно:**
- Усложняет тестирование (глобальное состояние)
- Может нарушать принцип единственной ответственности
- В многопоточности требует синхронизации

[Больше про Singleton](https://habr.com/ru/companies/otus/articles/779914/)


## `35.4` Factory Method — фабричный метод для создания объектов
`Factory Method` делегирует создание объектов подклассам или отдельным методам, позволяя выбирать тип создаваемого объекта во время выполнения программы.

**Зачем нужен:**
- Скрывает сложную логику создания объектов
- Позволяет создавать разные типы объектов через единый интерфейс
- Упрощает добавление новых типов объектов без изменения существующего кода

**Простой пример — создание транспорта:**
```python
from abc import ABC, abstractmethod

class Transport(ABC):
    @abstractmethod
    def deliver(self):
        pass

class Truck(Transport):
    def deliver(self):
        return "Доставка по земле на грузовике"

class Ship(Transport):
    def deliver(self):
        return "Доставка по морю на корабле"

# Простой фабричный метод
class Logistics:
    @staticmethod
    def create_transport(transport_type: str) -> Transport:
        if transport_type == "ground":
            return Truck()
        elif transport_type == "sea":
            return Ship()
        else:
            raise ValueError(f"Неизвестный тип транспорта: {transport_type}")

# Использование
transport = Logistics.create_transport("ground")
print(transport.deliver())  # Доставка по земле на грузовике

transport = Logistics.create_transport("sea")
print(transport.deliver())  # Доставка по морю на корабле
```

**Pythonic подход — функция-фабрика:**
```python
def create_payment_processor(payment_type: str):
    processors = {
        'credit_card': CreditCardProcessor,
        'paypal': PayPalProcessor,
        'crypto': CryptoProcessor
    }
    
    processor_class = processors.get(payment_type)
    if processor_class is None:
        raise ValueError(f"Неизвестный тип платежа: {payment_type}")
    
    return processor_class()

# Использование
processor = create_payment_processor('paypal')
processor.process_payment(100)
```

**Когда использовать:**
- Когда заранее неизвестно, объекты каких типов нужно создавать
- Когда логика создания объектов сложная и её нужно инкапсулировать
- Когда нужно легко добавлять новые типы объектов
- Для парсеров, обработчиков файлов разных форматов, драйверов БД

**Преимущества:**
- Слабая связанность — клиент не зависит от конкретных классов
- Легко расширяется новыми типами
- Централизованная логика создания

[Больше про Factory Method](https://habr.com/ru/articles/725340/)

## `35.5` Builder — пошаговое создание сложных объектов
`Builder` позволяет создавать сложные объекты пошагово, разделяя процесс конструирования и представления. Особенно полезен, когда объект имеет много параметров или сложную структуру.

**Зачем нужен:**
- Упрощает создание объектов с множеством параметров
- Делает код читаемым и понятным
- Позволяет создавать разные представления объекта через один интерфейс
- Избегает "телескопических конструкторов" с десятками параметров

**Классический пример — построение дома:**
```python
class House:
    def __init__(self):
        self.walls = None
        self.roof = None
        self.windows = None
        self.doors = None
        self.garage = None
    
    def __str__(self):
        parts = []
        if self.walls:
            parts.append(f"Стены: {self.walls}")
        if self.roof:
            parts.append(f"Крыша: {self.roof}")
        if self.windows:
            parts.append(f"Окна: {self.windows}")
        if self.doors:
            parts.append(f"Двери: {self.doors}")
        if self.garage:
            parts.append(f"Гараж: {self.garage}")
        return "Дом с:\n" + "\n".join(parts)

class HouseBuilder:
    def __init__(self):
        self.house = House()
    
    def build_walls(self, material):
        self.house.walls = material
        return self  # Возвращаем self для цепочки вызовов
    
    def build_roof(self, roof_type):
        self.house.roof = roof_type
        return self
    
    def build_windows(self, count):
        self.house.windows = count
        return self
    
    def build_doors(self, count):
        self.house.doors = count
        return self
    
    def build_garage(self, has_garage):
        self.house.garage = has_garage
        return self
    
    def get_house(self):
        return self.house

# Использование — метод цепочки (fluent interface)
builder = HouseBuilder()
house = (builder
         .build_walls("кирпич")
         .build_roof("черепица")
         .build_windows(4)
         .build_doors(2)
         .build_garage(True)
         .get_house())

print(house)
# Дом с:
# Стены: кирпич
# Крыша: черепица
# Окна: 4
# Двери: 2
# Гараж: True
```

**Пример с HTTP-запросом:**
```python
class HttpRequest:
    def __init__(self):
        self.method = "GET"
        self.url = None
        self.headers = {}
        self.body = None
        self.timeout = 30
    
    def __str__(self):
        return f"{self.method} {self.url}\nHeaders: {self.headers}\nBody: {self.body}"

class RequestBuilder:
    def __init__(self, url):
        self.request = HttpRequest()
        self.request.url = url
    
    def method(self, method):
        self.request.method = method
        return self
    
    def header(self, key, value):
        self.request.headers[key] = value
        return self
    
    def body(self, data):
        self.request.body = data
        return self
    
    def timeout(self, seconds):
        self.request.timeout = seconds
        return self
    
    def build(self):
        return self.request

# Использование
request = (RequestBuilder("https://api.example.com/users")
           .method("POST")
           .header("Content-Type", "application/json")
           .header("Authorization", "Bearer token123")
           .body({"name": "John", "age": 30})
           .timeout(60)
           .build())

print(request)
# POST https://api.example.com/users
# Headers: {'Content-Type': 'application/json', 'Authorization': 'Bearer token123'}
# Body: {'name': 'John', 'age': 30}
```

**Pythonic подход — dataclass с Builder:**
```python
from dataclasses import dataclass, field
from typing import Optional, List

@dataclass
class Pizza:
    size: str
    cheese: bool = False
    pepperoni: bool = False
    mushrooms: bool = False
    olives: bool = False
    toppings: List[str] = field(default_factory=list)
    
    def __str__(self):
        base = f"Пицца {self.size}"
        ingredients = []
        if self.cheese:
            ingredients.append("сыр")
        if self.pepperoni:
            ingredients.append("пепперони")
        if self.mushrooms:
            ingredients.append("грибы")
        if self.olives:
            ingredients.append("оливки")
        ingredients.extend(self.toppings)
        
        if ingredients:
            return f"{base} с: {', '.join(ingredients)}"
        return base

class PizzaBuilder:
    def __init__(self, size: str):
        self.size = size
        self._cheese = False
        self._pepperoni = False
        self._mushrooms = False
        self._olives = False
        self._toppings = []
    
    def add_cheese(self):
        self._cheese = True
        return self
    
    def add_pepperoni(self):
        self._pepperoni = True
        return self
    
    def add_mushrooms(self):
        self._mushrooms = True
        return self
    
    def add_olives(self):
        self._olives = True
        return self
    
    def add_topping(self, topping: str):
        self._toppings.append(topping)
        return self
    
    def build(self) -> Pizza:
        return Pizza(
            size=self.size,
            cheese=self._cheese,
            pepperoni=self._pepperoni,
            mushrooms=self._mushrooms,
            olives=self._olives,
            toppings=self._toppings
        )

# Использование
pizza = (PizzaBuilder("большая")
         .add_cheese()
         .add_pepperoni()
         .add_mushrooms()
         .add_topping("бекон")
         .build())

print(pizza)  # Пицца большая с: сыр, пепперони, грибы, бекон
```

**Когда использовать:**
- Объект имеет много необязательных параметров
- Создание объекта требует множества шагов
- Нужно создавать разные представления одного объекта
- Хочется избежать конструктора с десятками параметров

**Преимущества:**
- Читаемый и понятный код
- Пошаговое конструирование
- Возможность повторного использования builder'а
- Изоляция сложной логики создания

[Еще реализация Builder](https://ru.hexlet.io/courses/python-object-oriented-design/lessons/builder/theory_unit)

## `35.6` Strategy — инкапсуляция алгоритмов
`Strategy (Стратегия)` — паттерн проектирования, который выносит набор алгоритмов в отдельные классы с общим интерфейсом и делает их взаимозаменяемыми. Позволяет выбирать алгоритм динамически во время выполнения.

**Проблема:** код с множественными условными операторами для выбора алгоритма становится сложным и негибким.

**Решение:** инкапсулировать каждый алгоритм в отдельный класс, определить общий интерфейс.

### **Классический подход с классами:**

```python
from abc import ABC, abstractmethod

# Интерфейс стратегии
class DiscountStrategy(ABC):
    @abstractmethod
    def calculate(self, price):
        pass

# Конкретные стратегии
class NoDiscount(DiscountStrategy):
    def calculate(self, price):
        return price

class PercentageDiscount(DiscountStrategy):
    def __init__(self, percent):
        self.percent = percent
    
    def calculate(self, price):
        return price * (1 - self.percent / 100)

class FixedDiscount(DiscountStrategy):
    def __init__(self, amount):
        self.amount = amount
    
    def calculate(self, price):
        return max(0, price - self.amount)

# Контекст использует стратегию
class Order:
    def __init__(self, price, discount_strategy):
        self.price = price
        self.discount_strategy = discount_strategy
    
    def final_price(self):
        return self.discount_strategy.calculate(self.price)
    
    def set_discount_strategy(self, strategy):
        self.discount_strategy = strategy

# Использование
order = Order(100, NoDiscount())
print(order.final_price())  # 100

order.set_discount_strategy(PercentageDiscount(20))
print(order.final_price())  # 80.0

order.set_discount_strategy(FixedDiscount(15))
print(order.final_price())  # 85
```

### **Pythonic подход — функции как стратегии:**

В Python функции — это объекты первого класса, поэтому можно использовать их напрямую вместо классов.

```python
# Стратегии как функции
def no_discount(price):
    return price

def percentage_discount(percent):
    return lambda price: price * (1 - percent / 100)

def fixed_discount(amount):
    return lambda price: max(0, price - amount)

# Контекст
class Order:
    def __init__(self, price, discount_strategy=no_discount):
        self.price = price
        self.discount_strategy = discount_strategy
    
    def final_price(self):
        return self.discount_strategy(self.price)

# Использование
order = Order(100)
print(order.final_price())  # 100

order.discount_strategy = percentage_discount(20)
print(order.final_price())  # 80.0

order.discount_strategy = fixed_discount(15)
print(order.final_price())  # 85
```

### **Практический пример — система оплаты:**

```python
from abc import ABC, abstractmethod

class PaymentStrategy(ABC):
    @abstractmethod
    def pay(self, amount):
        pass

class CreditCardPayment(PaymentStrategy):
    def __init__(self, card_number):
        self.card_number = card_number
    
    def pay(self, amount):
        return f"Оплачено {amount}₽ картой {self.card_number[-4:]}"

class PayPalPayment(PaymentStrategy):
    def __init__(self, email):
        self.email = email
    
    def pay(self, amount):
        return f"Оплачено {amount}₽ через PayPal ({self.email})"

class CryptoPayment(PaymentStrategy):
    def __init__(self, wallet):
        self.wallet = wallet
    
    def pay(self, amount):
        return f"Оплачено {amount}₽ криптовалютой на {self.wallet}"

class ShoppingCart:
    def __init__(self):
        self.items = []
        self.payment_strategy = None
    
    def add_item(self, item, price):
        self.items.append((item, price))
    
    def total(self):
        return sum(price for _, price in self.items)
    
    def set_payment_method(self, strategy):
        self.payment_strategy = strategy
    
    def checkout(self):
        if not self.payment_strategy:
            return "Выберите способ оплаты"
        total = self.total()
        return self.payment_strategy.pay(total)

# Использование
cart = ShoppingCart()
cart.add_item("Ноутбук", 50000)
cart.add_item("Мышь", 1500)

cart.set_payment_method(CreditCardPayment("1234-5678-9012-3456"))
print(cart.checkout())  # Оплачено 51500₽ картой 3456

cart.set_payment_method(PayPalPayment("user@example.com"))
print(cart.checkout())  # Оплачено 51500₽ через PayPal (user@example.com)
```

### **Словарь стратегий для динамического выбора:**

```python
# Стратегии сжатия данных
class CompressionStrategy(ABC):
    @abstractmethod
    def compress(self, data):
        pass

class ZipCompression(CompressionStrategy):
    def compress(self, data):
        return f"ZIP: сжато '{data}'"

class RarCompression(CompressionStrategy):
    def compress(self, data):
        return f"RAR: сжато '{data}'"

class GzipCompression(CompressionStrategy):
    def compress(self, data):
        return f"GZIP: сжато '{data}'"

# Регистр стратегий
COMPRESSION_STRATEGIES = {
    'zip': ZipCompression(),
    'rar': RarCompression(),
    'gzip': GzipCompression()
}

class FileCompressor:
    def __init__(self, strategy_name):
        self.strategy = COMPRESSION_STRATEGIES.get(strategy_name)
        if not self.strategy:
            raise ValueError(f"Неизвестная стратегия: {strategy_name}")
    
    def compress_file(self, filename):
        return self.strategy.compress(filename)

# Использование
compressor = FileCompressor('zip')
print(compressor.compress_file('document.txt'))  # ZIP: сжато 'document.txt'

compressor = FileCompressor('gzip')
print(compressor.compress_file('archive.tar'))  # GZIP: сжато 'archive.tar'
```

### **Strategy + Композиция стратегий:**

```python
# Валидация с несколькими стратегиями
class ValidationStrategy(ABC):
    @abstractmethod
    def validate(self, value):
        pass

class LengthValidator(ValidationStrategy):
    def __init__(self, min_length, max_length):
        self.min_length = min_length
        self.max_length = max_length
    
    def validate(self, value):
        return self.min_length <= len(value) <= self.max_length

class RegexValidator(ValidationStrategy):
    def __init__(self, pattern):
        import re
        self.pattern = re.compile(pattern)
    
    def validate(self, value):
        return bool(self.pattern.match(value))

class Validator:
    def __init__(self):
        self.strategies = []
    
    def add_strategy(self, strategy):
        self.strategies.append(strategy)
        return self
    
    def validate(self, value):
        return all(strategy.validate(value) for strategy in self.strategies)

# Использование — композиция валидаторов
password_validator = Validator()
password_validator.add_strategy(LengthValidator(8, 20))
password_validator.add_strategy(RegexValidator(r'^(?=.*[A-Z])(?=.*\d).+$'))

print(password_validator.validate("Pass123"))    # True
print(password_validator.validate("pass"))       # False (нет заглавных и цифр)
print(password_validator.validate("PASSWORD"))   # False (нет цифр)
```

**Когда использовать:**
- Несколько вариантов выполнения одной операции
- Необходимость динамического выбора алгоритма
- Избежание условной логики (`if`/`elif` для выбора алгоритма)
- Алгоритмы должны быть взаимозаменяемыми

**Преимущества:**
- Open/Closed Principle — легко добавлять новые стратегии
- Single Responsibility Principle — каждая стратегия в отдельном классе
- Избавляет от сложных условных конструкций
- Стратегии легко тестировать независимо

**В стандартной библиотеке Python:**
- `sorted(data, key=function)` — функция `key` это стратегия
- `max(data, key=function)` — стратегия выбора максимума
- `json.dumps(obj, cls=CustomEncoder)` — стратегия сериализации

[Еще реализация Strategy](https://docs-python.ru/tutorial/oop-python-primerakh/shablon-strategy/)


## `35.7` Observer — подписка на события и уведомления
`Observer (Наблюдатель)` — паттерн, который создаёт механизм подписки, позволяющий объектам отслеживать и реагировать на события, происходящие в других объектах.

**Проблема:** нужно уведомлять множество объектов об изменениях в другом объекте без создания жёсткой связи между ними.

**Решение:** объект-издатель (Subject) хранит список подписчиков (Observers) и уведомляет их при изменениях.

### **Классический подход:**

```python
from abc import ABC, abstractmethod

# Интерфейс наблюдателя
class Observer(ABC):
    @abstractmethod
    def update(self, message):
        pass

# Издатель (Subject)
class NewsPublisher:
    def __init__(self):
        self._observers = []
        self._latest_news = None
    
    def subscribe(self, observer):
        self._observers.append(observer)
    
    def unsubscribe(self, observer):
        self._observers.remove(observer)
    
    def notify(self):
        for observer in self._observers:
            observer.update(self._latest_news)
    
    def add_news(self, news):
        self._latest_news = news
        self.notify()

# Конкретные наблюдатели
class EmailSubscriber(Observer):
    def __init__(self, email):
        self.email = email
    
    def update(self, message):
        print(f"Email на {self.email}: {message}")

class SMSSubscriber(Observer):
    def __init__(self, phone):
        self.phone = phone
    
    def update(self, message):
        print(f"SMS на {self.phone}: {message}")

# Использование
publisher = NewsPublisher()

subscriber1 = EmailSubscriber("user1@mail.com")
subscriber2 = SMSSubscriber("+7-900-123-45-67")

publisher.subscribe(subscriber1)
publisher.subscribe(subscriber2)

publisher.add_news("Новая статья опубликована!")
# Email на user1@mail.com: Новая статья опубликована!
# SMS на +7-900-123-45-67: Новая статья опубликована!

publisher.unsubscribe(subscriber1)
publisher.add_news("Обновление системы")
# SMS на +7-900-123-45-67: Обновление системы
```

### **Pythonic подход — функции как наблюдатели:**

```python
class EventManager:
    def __init__(self):
        self._subscribers = []
    
    def subscribe(self, callback):
        self._subscribers.append(callback)
    
    def unsubscribe(self, callback):
        self._subscribers.remove(callback)
    
    def notify(self, data):
        for callback in self._subscribers:
            callback(data)

class StockMarket:
    def __init__(self):
        self.price_changed = EventManager()
        self._price = 0
    
    @property
    def price(self):
        return self._price
    
    @price.setter
    def price(self, value):
        self._price = value
        self.price_changed.notify(value)

# Наблюдатели как функции
def trader_alert(price):
    print(f"Трейдер: Цена изменилась на {price}₽")

def analytics(price):
    print(f"Аналитика: Записываю цену {price}₽ в базу")

# Использование
stock = StockMarket()
stock.price_changed.subscribe(trader_alert)
stock.price_changed.subscribe(analytics)

stock.price = 100
# Трейдер: Цена изменилась на 100₽
# Аналитика: Записываю цену 100₽ в базу

stock.price = 150
# Трейдер: Цена изменилась на 150₽
# Аналитика: Записываю цену 150₽ в базу
```

### **Практический пример — система уведомлений:**

```python
class User:
    def __init__(self, name):
        self.name = name
        self.followers = []
    
    def follow(self, user):
        user.followers.append(self)
    
    def unfollow(self, user):
        user.followers.remove(self)
    
    def post_message(self, message):
        print(f"{self.name} опубликовал: {message}")
        self._notify_followers(message)
    
    def _notify_followers(self, message):
        for follower in self.followers:
            follower.receive_notification(self.name, message)
    
    def receive_notification(self, author, message):
        print(f"  → {self.name} получил уведомление от {author}: {message}")

# Использование
alice = User("Alice")
bob = User("Bob")
charlie = User("Charlie")

bob.follow(alice)
charlie.follow(alice)

alice.post_message("Привет всем!")
# Alice опубликовал: Привет всем!
#   → Bob получил уведомление от Alice: Привет всем!
#   → Charlie получил уведомление от Alice: Привет всем!

bob.unfollow(alice)
alice.post_message("Новый пост")
# Alice опубликовал: Новый пост
#   → Charlie получил уведомление от Alice: Новый пост
```

### **С типизированными событиями:**

```python
class Event:
    def __init__(self):
        self._handlers = []
    
    def subscribe(self, handler):
        self._handlers.append(handler)
        return self  # Для chain-вызовов
    
    def unsubscribe(self, handler):
        self._handlers.remove(handler)
    
    def emit(self, *args, **kwargs):
        for handler in self._handlers:
            handler(*args, **kwargs)

class TemperatureSensor:
    def __init__(self):
        self.on_temperature_changed = Event()
        self.on_critical_temperature = Event()
        self._temperature = 0
    
    def set_temperature(self, temp):
        self._temperature = temp
        self.on_temperature_changed.emit(temp)
        
        if temp > 80:
            self.on_critical_temperature.emit(temp)

# Подписчики
def log_temperature(temp):
    print(f"Лог: Температура {temp}°C")

def alert_critical(temp):
    print(f"⚠️ ВНИМАНИЕ! Критическая температура: {temp}°C")

def send_notification(temp):
    print(f"📧 Уведомление: температура достигла {temp}°C")

# Использование
sensor = TemperatureSensor()
sensor.on_temperature_changed.subscribe(log_temperature)
sensor.on_critical_temperature.subscribe(alert_critical)
sensor.on_critical_temperature.subscribe(send_notification)

sensor.set_temperature(50)
# Лог: Температура 50°C

sensor.set_temperature(85)
# Лог: Температура 85°C
# ⚠️ ВНИМАНИЕ! Критическая температура: 85°C
# 📧 Уведомление: температура достигла 85°C
```

**Когда использовать:**
- Изменение одного объекта требует изменения других, но заранее неизвестно каких и сколько
- GUI приложения (кнопки, события)
- Системы уведомлений и логирования
- Реактивное программирование

**Преимущества:**
- Слабая связанность между издателем и подписчиками
- Динамическое добавление/удаление подписчиков
- Один издатель может уведомлять множество подписчиков

**Недостатки:**
- Подписчики уведомляются в произвольном порядке
- Возможны утечки памяти, если забыть отписаться

**В реальных библиотеках:**
- Django signals
- PyQt/PySide signals and slots
- RxPY (Reactive Extensions)

[Еще реализация Observer](https://www.youtube.com/watch?v=MgsQAoHgzlc)

## `35.8` Context Manager — паттерн `with` и протокол `__enter__`/`__exit__`
`Context Manager` — паттерн для управления ресурсами (файлы, соединения, блокировки), который гарантирует их корректное освобождение даже при возникновении ошибок. Реализуется через протокол `__enter__`/`__exit__` и используется с оператором `with`.

**Зачем нужен:** автоматически выполняет действия до и после блока кода (открытие/закрытие ресурса, установка/снятие блокировки).

### **Базовое использование:**

```python
# Без context manager — нужно помнить закрыть файл
file = open('data.txt', 'r')
try:
    content = file.read()
finally:
    file.close()  # Обязательно закрыть даже при ошибке

# С context manager — закрытие автоматическое
with open('data.txt', 'r') as file:
    content = file.read()
# Файл автоматически закрыт после блока with
```

### **Создание своего context manager:**

```python
class DatabaseConnection:
    def __init__(self, host):
        self.host = host
        self.connection = None
    
    def __enter__(self):
        """Вызывается при входе в блок with"""
        print(f"Подключение к {self.host}")
        self.connection = f"Connection to {self.host}"
        return self.connection  # Возвращаемое значение попадает в 'as'
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Вызывается при выходе из блока with"""
        print(f"Отключение от {self.host}")
        self.connection = None
        # exc_type, exc_val, exc_tb — информация об исключении (если было)
        return False  # False = пробросить исключение дальше

# Использование
with DatabaseConnection('localhost') as conn:
    print(f"Работаю с {conn}")
    # Можно использовать соединение
# Автоматически вызовется __exit__

# Вывод:
# Подключение к localhost
# Работаю с Connection to localhost
# Отключение от localhost
```

### **Параметры `__exit__(exc_type, exc_val, exc_tb)`:**

Эти параметры передают информацию об исключении, которое произошло внутри блока `with`. Они позволяют context manager-у реагировать на ошибки и решать, подавить их или пробросить дальше.

**Параметры:**
- `exc_type` — тип исключения (класс, например `ValueError`)
- `exc_val` — значение исключения (само исключение)
- `exc_tb` — traceback (стек вызовов)

**Если ошибки не было:** все три параметра равны `None`

**Возвращаемое значение `__exit__`:**
- `True` или truthy — подавить исключение (не пробрасывать дальше)
- `False` или falsy — пробросить исключение дальше

```python
class ErrorHandler:
    def __enter__(self):
        print("Начало работы")
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type is None:
            print("Завершено успешно, ошибок не было")
            return False
        
        # Если было исключение
        print(f"Тип ошибки: {exc_type.__name__}")
        print(f"Сообщение: {exc_val}")
        print(f"Traceback: {exc_tb}")
        
        # Решаем, что делать с ошибкой
        if exc_type == ValueError:
            print("ValueError подавлен")
            return True  # Подавить ValueError
        
        # Для других ошибок — пробросить дальше
        print("Ошибка будет проброшена")
        return False

# Без ошибки
with ErrorHandler():
    print("Выполняю код...")
# Вывод:
# Начало работы
# Выполняю код...
# Завершено успешно, ошибок не было

# С ValueError (подавляется)
try:
    with ErrorHandler():
        print("Вызываю ошибку...")
        raise ValueError("Это ValueError")
        print("Эта строка не выполнится")
except ValueError:
    print("ValueError не был подавлен")
# Вывод:
# Начало работы
# Вызываю ошибку...
# Тип ошибки: ValueError
# Сообщение: Это ValueError
# Traceback: <traceback object at 0x...>
# ValueError подавлен
# (Исключение НЕ доходит до except)

# С TypeError (пробрасывается)
try:
    with ErrorHandler():
        raise TypeError("Это TypeError")
except TypeError as e:
    print(f"Поймали: {e}")
# Вывод:
# Начало работы
# Тип ошибки: TypeError
# Сообщение: Это TypeError
# Traceback: <traceback object at 0x...>
# Ошибка будет проброшена
# Поймали: Это TypeError
```

### **Практический пример — логирование ошибок:**

```python
import traceback

class ErrorLogger:
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type is not None:
            # Логируем полную информацию об ошибке
            print("=" * 50)
            print("ОШИБКА В БЛОКЕ WITH:")
            print(f"Тип: {exc_type.__name__}")
            print(f"Сообщение: {exc_val}")
            print("Полный traceback:")
            traceback.print_tb(exc_tb)
            print("=" * 50)
            
            # Подавляем ошибку, чтобы программа продолжила работу
            return True
        return False

# Использование
with ErrorLogger():
    x = 10
    y = 0
    result = x / y  # ZeroDivisionError

print("Программа продолжает работу после ошибки")
# Вывод:
# ==================================================
# ОШИБКА В БЛОКЕ WITH:
# Тип: ZeroDivisionError
# Сообщение: division by zero
# Полный traceback:
#   File "...", line ..., in <module>
#     result = x / y
# ==================================================
# Программа продолжает работу после ошибки
```

### **Обработка исключений:**

```python
class Timer:
    def __enter__(self):
        import time
        self.start = time.time()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        import time
        self.elapsed = time.time() - self.start
        print(f"Время выполнения: {self.elapsed:.3f} сек")
        
        if exc_type:
            print(f"Произошла ошибка: {exc_val}")
            return True  # True = подавить исключение
        return False

# Использование
with Timer():
    print("Выполняю задачу...")
    # time.sleep(1)
# Время выполнения: 0.000 сек

with Timer():
    print("Начинаю...")
    raise ValueError("Ошибка!")
# Вывод:
# Начинаю...
# Время выполнения: 0.000 сек
# Произошла ошибка: Ошибка!
# (Исключение подавлено)
```

### **Context manager через `contextlib`:**

```python
from contextlib import contextmanager

@contextmanager
def file_manager(filename, mode):
    print(f"Открываю файл {filename}")
    file = open(filename, mode)
    try:
        yield file  # Все до yield — это __enter__, после — __exit__
    finally:
        print(f"Закрываю файл {filename}")
        file.close()

# Использование
with file_manager('test.txt', 'w') as f:
    f.write("Hello, World!")
# Открываю файл test.txt
# Закрываю файл test.txt
```

### **Практический пример — изменение директории:**

```python
import os
from contextlib import contextmanager

@contextmanager
def change_directory(path):
    original_dir = os.getcwd()
    print(f"Переход в {path}")
    os.chdir(path)
    try:
        yield
    finally:
        print(f"Возврат в {original_dir}")
        os.chdir(original_dir)

# Использование
print(f"Текущая: {os.getcwd()}")
with change_directory('/tmp'):
    print(f"Внутри with: {os.getcwd()}")
print(f"После with: {os.getcwd()}")
```


## `35.9` Async Context Manager — `async with` и `__aenter__`/`__aexit__`
`Async Context Manager` — асинхронная версия context manager для работы с асинхронными ресурсами (async HTTP-соединения, async файлы, async блокировки). Использует `__aenter__`/`__aexit__` и оператор `async with`.

### **Создание async context manager:**

```python
import asyncio

class AsyncDatabaseConnection:
    def __init__(self, host):
        self.host = host
    
    async def __aenter__(self):
        """Асинхронное подключение"""
        print(f"Подключаюсь к {self.host}...")
        await asyncio.sleep(1)  # Имитация подключения
        print(f"Подключено к {self.host}")
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Асинхронное отключение"""
        print(f"Отключаюсь от {self.host}...")
        await asyncio.sleep(0.5)  # Имитация отключения
        print(f"Отключено от {self.host}")
        
        # exc_type, exc_val, exc_tb работают так же, как в обычном context manager
        if exc_type:
            print(f"Async: произошла ошибка {exc_type.__name__}: {exc_val}")
        
        return False
    
    async def query(self, sql):
        print(f"Выполняю запрос: {sql}")
        await asyncio.sleep(0.3)
        return "Result"

# Использование
async def main():
    async with AsyncDatabaseConnection('localhost') as db:
        result = await db.query("SELECT * FROM users")
        print(f"Результат: {result}")

asyncio.run(main())
# Вывод:
# Подключаюсь к localhost...
# Подключено к localhost
# Выполняю запрос: SELECT * FROM users
# Результат: Result
# Отключаюсь от localhost...
# Отключено от localhost
```

### **Async context manager через `@asynccontextmanager`:**

```python
from contextlib import asynccontextmanager
import asyncio

@asynccontextmanager
async def async_timer():
    start = asyncio.get_event_loop().time()
    print("Таймер запущен")
    try:
        yield
    finally:
        elapsed = asyncio.get_event_loop().time() - start
        print(f"Прошло {elapsed:.2f} сек")

# Использование
async def main():
    async with async_timer():
        print("Выполняю асинхронную операцию...")
        await asyncio.sleep(2)

asyncio.run(main())
# Вывод:
# Таймер запущен
# Выполняю асинхронную операцию...
# Прошло 2.00 сек
```

### **Практический пример — HTTP-клиент:**

```python
import asyncio
from contextlib import asynccontextmanager

@asynccontextmanager
async def http_session(url):
    print(f"Открываю HTTP-сессию для {url}")
    session = {"url": url, "connected": True}
    await asyncio.sleep(0.5)  # Имитация установки соединения
    
    try:
        yield session
    finally:
        print(f"Закрываю HTTP-сессию для {url}")
        session["connected"] = False
        await asyncio.sleep(0.2)  # Имитация закрытия

async def fetch_data():
    async with http_session("https://api.example.com") as session:
        print(f"Отправляю запрос к {session['url']}")
        await asyncio.sleep(1)
        print("Получен ответ")

asyncio.run(fetch_data())
# Вывод:
# Открываю HTTP-сессию для https://api.example.com
# Отправляю запрос к https://api.example.com
# Получен ответ
# Закрываю HTTP-сессию для https://api.example.com
```

### **Async блокировки:**

```python
import asyncio

async def worker(lock, worker_id):
    async with lock:  # asyncio.Lock — это async context manager
        print(f"Работник {worker_id} получил доступ")
        await asyncio.sleep(1)
        print(f"Работник {worker_id} завершил работу")

async def main():
    lock = asyncio.Lock()
    await asyncio.gather(
        worker(lock, 1),
        worker(lock, 2),
        worker(lock, 3)
    )

asyncio.run(main())
# Работники выполняются последовательно (по одному)
```

**Ключевые отличия:**

| Context Manager | Async Context Manager |
|----------------|----------------------|
| `__enter__` / `__exit__` | `__aenter__` / `__aexit__` |
| `with` | `async with` |
| Синхронные операции | Асинхронные операции (`await`) |
| Блокирующие вызовы | Неблокирующие вызовы |
| `exc_type, exc_val, exc_tb` в `__exit__` | `exc_type, exc_val, exc_tb` в `__aexit__` |

**Когда использовать:**
- **Context Manager**: файлы, блокировки потоков, транзакции БД
- **Async Context Manager**: async HTTP-клиенты, async БД, async файлы, async блокировки

[Еще реализация Context Manager](https://habr.com/ru/articles/739326/)

## `35.10` Async Decorator — декораторы для асинхронных функций
`Async Decorator` — это декоратор для асинхронных функций (`async def`), который сам должен быть асинхронным или корректно обрабатывать `await`. Позволяет добавлять дополнительную логику (логирование, таймеры, кеширование) к async функциям.

**Проблема:** обычный декоратор не работает с `async` функциями, так как они возвращают корутину, а не результат.

### **Простой async декоратор:**

```python
import asyncio
import functools

def async_timer(func):
    @functools.wraps(func)
    async def wrapper(*args, **kwargs):
        start = asyncio.get_event_loop().time()
        result = await func(*args, **kwargs)  # Важно: await!
        elapsed = asyncio.get_event_loop().time() - start
        print(f"{func.__name__} выполнилась за {elapsed:.2f} сек")
        return result
    return wrapper

@async_timer
async def fetch_data():
    print("Загружаю данные...")
    await asyncio.sleep(2)
    return "Данные получены"

# Использование
async def main():
    result = await fetch_data()
    print(result)

asyncio.run(main())
# Вывод:
# Загружаю данные...
# fetch_data выполнилась за 2.00 сек
# Данные получены
```

### **Декоратор с параметрами:**

```python
import asyncio
import functools

def async_retry(max_attempts=3, delay=1):
    """Повторяет async функцию при ошибке"""
    def decorator(func):
        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            for attempt in range(1, max_attempts + 1):
                try:
                    return await func(*args, **kwargs)
                except Exception as e:
                    print(f"Попытка {attempt}/{max_attempts} не удалась: {e}")
                    if attempt == max_attempts:
                        raise
                    await asyncio.sleep(delay)
        return wrapper
    return decorator

@async_retry(max_attempts=3, delay=0.5)
async def unstable_operation():
    import random
    if random.random() < 0.7:
        raise ValueError("Случайная ошибка")
    return "Успех!"

# Использование
async def main():
    result = await unstable_operation()
    print(result)

asyncio.run(main())
# Попытка 1/3 не удалась: Случайная ошибка
# Попытка 2/3 не удалась: Случайная ошибка
# Успех!
```

### **Кеширование async функций:**

```python
import asyncio
import functools

def async_cache(func):
    cache = {}
    
    @functools.wraps(func)
    async def wrapper(*args):
        if args in cache:
            print(f"Возвращаю из кеша: {args}")
            return cache[args]
        
        result = await func(*args)
        cache[args] = result
        return result
    
    return wrapper

@async_cache
async def expensive_calculation(n):
    print(f"Вычисляю для {n}...")
    await asyncio.sleep(2)
    return n * n

# Использование
async def main():
    print(await expensive_calculation(5))  # Вычисляет
    print(await expensive_calculation(5))  # Из кеша
    print(await expensive_calculation(10)) # Вычисляет

asyncio.run(main())
# Вывод:
# Вычисляю для 5...
# 25
# Возвращаю из кеша: (5,)
# 25
# Вычисляю для 10...
# 100
```

### **Логирование async функций:**

```python
import asyncio
import functools
from datetime import datetime

def async_logger(func):
    @functools.wraps(func)
    async def wrapper(*args, **kwargs):
        timestamp = datetime.now().strftime("%H:%M:%S")
        print(f"[{timestamp}] Вызов {func.__name__} с args={args}, kwargs={kwargs}")
        
        try:
            result = await func(*args, **kwargs)
            print(f"[{timestamp}] {func.__name__} вернула: {result}")
            return result
        except Exception as e:
            print(f"[{timestamp}] {func.__name__} вызвала ошибку: {e}")
            raise
    
    return wrapper

@async_logger
async def process_user(user_id, action="view"):
    await asyncio.sleep(1)
    return f"User {user_id}: {action}"

# Использование
async def main():
    await process_user(123, action="update")

asyncio.run(main())
# [14:30:45] Вызов process_user с args=(123,), kwargs={'action': 'update'}
# [14:30:45] process_user вернула: User 123: update
```

**Ключевые моменты:**
- Async декоратор должен быть `async def` и использовать `await func()`
- Обязательно используйте `@functools.wraps(func)` для сохранения метаданных
- Работает только с `async def` функциями
- Можно комбинировать несколько async декораторов

**Когда использовать:**
- Таймеры для async операций
- Retry логика для нестабильных async запросов
- Кеширование результатов async функций
- Логирование async вызовов


## `35.11` Dependency Injection — внедрение зависимостей
`Dependency Injection (DI)` — паттерн, при котором объект получает свои зависимости извне, а не создаёт их самостоятельно. Это делает код более гибким, тестируемым и слабо связанным.

**Проблема:** жёсткая связь между компонентами — объект сам создаёт свои зависимости, что усложняет тестирование и замену реализации.

**Решение:** передавать зависимости в объект снаружи (через конструктор, параметры функции или setter).

### **Пример 1: Без DI vs с DI**

```python
# Без Dependency Injection (плохо)
class EmailSender:
    def send(self, message):
        print(f"Email: {message}")

class UserService:
    def __init__(self):
        # Жёсткая зависимость — создаём внутри
        self.email_sender = EmailSender()
    
    def register_user(self, username):
        print(f"Регистрирую {username}")
        self.email_sender.send(f"Добро пожаловать, {username}!")

# Проблемы:
# 1. Нельзя заменить EmailSender на другую реализацию
# 2. Сложно тестировать (нельзя подставить mock)
service = UserService()
service.register_user("Alice")


# С Dependency Injection (хорошо)
class EmailSender:
    def send(self, message):
        print(f"Email: {message}")

class SMSSender:
    def send(self, message):
        print(f"SMS: {message}")

class UserService:
    def __init__(self, notifier):
        # Зависимость передаётся извне
        self.notifier = notifier
    
    def register_user(self, username):
        print(f"Регистрирую {username}")
        self.notifier.send(f"Добро пожаловать, {username}!")

# Теперь можно легко менять реализацию
email_service = UserService(EmailSender())
email_service.register_user("Alice")
# Регистрирую Alice
# Email: Добро пожаловать, Alice!

sms_service = UserService(SMSSender())
sms_service.register_user("Bob")
# Регистрирую Bob
# SMS: Добро пожаловать, Bob!
```

### **Пример 2: База данных с разными реализациями**

```python
# Разные реализации БД
class PostgresDB:
    def save(self, data):
        print(f"PostgreSQL: сохраняю {data}")

class InMemoryDB:
    def __init__(self):
        self.storage = []
    
    def save(self, data):
        self.storage.append(data)
        print(f"InMemory: сохранено {data}, всего: {len(self.storage)}")

# Сервис, который не зависит от конкретной БД
class ProductService:
    def __init__(self, database):
        self.db = database
    
    def add_product(self, product):
        print(f"Добавляю продукт: {product}")
        self.db.save(product)

# Production: используем PostgreSQL
prod_service = ProductService(PostgresDB())
prod_service.add_product("Ноутбук")
# Добавляю продукт: Ноутбук
# PostgreSQL: сохраняю Ноутбук

# Testing: используем InMemory
test_service = ProductService(InMemoryDB())
test_service.add_product("Мышь")
test_service.add_product("Клавиатура")
# Добавляю продукт: Мышь
# InMemory: сохранено Мышь, всего: 1
# Добавляю продукт: Клавиатура
# InMemory: сохранено Клавиатура, всего: 2
```

### **Пример 3: Тестирование с mock-объектом**

```python
class MockDatabase:
    """Заглушка для тестирования"""
    def __init__(self):
        self.saved_data = []
    
    def save(self, data):
        self.saved_data.append(data)

# Тестируемый сервис
class UserRepository:
    def __init__(self, db):
        self.db = db
    
    def create_user(self, username):
        user_data = {'username': username}
        self.db.save(user_data)
        return user_data

# Тест с mock-объектом
mock_db = MockDatabase()
repo = UserRepository(mock_db)
repo.create_user("TestUser")

# Проверяем, что данные сохранены
assert len(mock_db.saved_data) == 1
assert mock_db.saved_data[0]['username'] == "TestUser"
print("✓ Тест пройден")
```

**Преимущества:**
- **Гибкость** — легко менять реализацию зависимостей
- **Тестируемость** — можно подставлять mock-объекты
- **Слабая связанность** — компоненты не зависят от конкретных реализаций
- **Переиспользование** — одну зависимость можно использовать в разных местах

**Способы внедрения:**
1. **Constructor Injection** — через `__init__` (самый распространённый)
2. **Setter Injection** — через метод setter
3. **Parameter Injection** — через параметры функции

**Когда использовать:**
- Компонент зависит от внешних сервисов (БД, API, файлы)
- Нужна гибкая замена реализации
- Требуется тестируемость кода

[DI в Python & Популярных фреймворках](https://snyk.io/blog/dependency-injection-python/)

----

