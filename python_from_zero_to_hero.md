# Правила
- Все что не отмечено звездочкой надо точно и уверено знать  
- `*` - must have for interview  
- `**` - for flex in the interview

----

# Python
## `1.1` Что такое компилируемых и интерпретируемых языки? В чем их отличие?  
## `1.2` Плюсы и минусы `Python`  
## `1.3` Какие задачи решает `Python`?

----

# Ввод - вывод
## print()
### `2.1` Как работает `print()`?  
### `2.2` Что такон аргумент?

## input()
### `2.3` Как работает `input()`? Что принимает `input()`?  
### `2.4` Что такое переменная? Как можно и принято называть переменную?  
### `2.5` Что такое комментарий и как его делать?  
### `2.6` Несколько переменных в `print()`  
### `2.7` Переменные в `input()`  
### `2.8` Параметры `sep` & `end` в `print()`  

## PEP8
### `2.9` Что такое `PEP8`?  
### `2.10` Обшие рекомендации  

## Целочисленные операции
### `2.11` `int()`, `int(input())`  
### `2.12` Математические операции  
### `2.13` Операторы: (), **, //, %  

----

# Условный оператор
## `3.1` `if-else`  
## `3.2` Что такое табуляция?  
## `3.3` Какие есть операторы сравнения? Можно еще посмотреть цепочки сравнения и транзитивность  
## `3.4` Логические операции: `and`, `or`, `not`

## `3.5` (`*`) Комбинирование и приоритизация логических операций  
Приоритет выполнения логических операторов:
- в первую очередь выполняется логическое отрицание `not`
- далее выполняется логическое умножение `and`
- далее выполняется логическое сложение `or`

## `3.6` Вложенные условия  
## `3.7` Каскадные условия. Что такое `elif`

----

# Типы данных 1
## `4.1` Что такое тип данных и зачем он нужен?  
## `4.2` Числовые типы данных. Целые числа и числа с плавающей точкой  
## `4.3` Функции `min()`, `max()`, `abs()`  
## `4.4` Функция `round`  
## `4.5` Строковый тип данных  
## `4.6` Функции `len()`, `in` для строк!  
## `4.7` `bool` & `None`

----

# Строки
## `5.1` (`*`) Индексы  
`Индекс` — это числовое значение, обозначающее позицию символа в строке. В Python индексы начинаются с `0` для первого символа. Отрицательные индексы позволяют считать символы с конца строки:  
`-1` — последний символ,  
`-2` — предпоследний и так далее.  

```python
s = "Python"
print(s[0])  # Выведет 'P'
print(s[-1]) # Выведет 'n'
```

## `5.2` (`*`) Срезы. Срезы с одним/двумя/тремя параметрами `[x:y:z]` 
`Срез` позволяет получить подстроку, указав стартовый индекс (`start`), конечный индекс (`stop`), не включая его, и шаг (`step`), с которым выбираются символы. Все параметры опциональны:  

`start` по умолчанию — начало строки;  
`stop` по умолчанию — конец строки;  
`step` по умолчанию — `1`.  

```python
s = "Python"
print(s[1:4])   # 'yth'
print(s[:3])    # 'Pyt'
print(s[::2])   # 'Pto'
print(s[::-1])  # 'nohtyP'
```

## `5.3` (`*`) Отрицательные срезы  
`Отрицательные индексы` позволяют работать с концом строки, не зная её длины. Например, `s[-4:-1]` — подстрока с четвертого символа с конца по предпоследний (последний не включается). `s[-4:]` — последние четыре символа строки.  
Также можно использовать отрицательный шаг, например, `s[::-1]` — строка в обратном порядке. При отрицательном шаге границы среза указываются в обратном порядке, чтобы получить правильный результат.  
Таким образом, отрицательные срезы — удобный и мощный инструмент для работы с концом строки или её реверсом.

```python
s = "Hello, Python!"
print(s[-6:])   # 'Python!'
print(s[-4:-1]) # 'tho'
print(s[::-1])  # '!nohtyP ,olleH'
```

## `5.4` Методы строк (можно посмотреть все, но укажу, которые точно надо знать):  
- `capitalize()`  
- `title()`  
- `lower()`  
- `upper()`  
- `startswith()`  
- `strip()`  
- `isalpha()`  
- `isdigit()`  
- `islower()`  
- `isupper()`

## `5.5` Конкатенация и другие математические операции  
## `5.6` (`*`) Форматирование:  
### `format()`  
Метод `format()` вставляет значения в строку по местам-заполнителям, указанным в фигурных скобках `{}`. Можно использовать позиционные или именованные аргументы, указывая внутри скобок номера или имена: 
```python
"Hello, {}!".format("Alice")  # Hello, Alice!
"{1}, {0}".format('first', 'second')  # second, first
"{name} is {age}".format(name="Bob", age=25)  # Bob is 25
```
Форматирование внутри фигурных скобок позволяет задавать выравнивание, ширину, точность и другие параметры:
```python
"{:>10}".format("cat")    # "       cat" (выравнивание по правому краю, ширина 10)
"{:.3}".format("caterpillar")  # "cat" (обрезка до 3 символов)
"{:0^9}".format(123)      # "000123000" (выравнивание с заполнением нулями)
```

### `f-строки` 
`F-строки` появились в Python 3.6 и позволяют вставлять выражения прямо в строку с префиксом f:
```python
name = "Alice"
age = 30
print(f"Hello, {name}! You are {age} years old.")  # Hello, Alice! You are 30 years old.
```
Также внутри фигурных скобок можно использовать форматирование:
```python
print(f"{123:0>9}")  # '000000123' (выравнивание по правому краю с заполнением нулями)
print(f"{123:.2f}")   # '123.00' (формат с двумя десятичными знаками)
```

## `5.7` (`**`) Если интересно, можно посмотреть, как строки хранятся в памяти компьютера. Команды `ord()`, `chr()`  
## `5.8` (`**`) Если интересно, можно посмотреть про кодировки

----

# Циклы
## For loop
### `6.1` Как написать for loop в `Python`?  
### `6.2` Функция `range`. `Range` с несколькими параметрами и отрицательным шагом генерации  
### `6.3` `_` в цикле for  
### `6.4` Концепция `флага` (сигнала)  

## While loop
### `6.5` Как написать while loop в `Python`?  
### `6.6` Бесконечные циклы
### `6.7` (`*`) Операторы: `break`, `continue`, `else`. Кейсы применения
Оператор `break` досрочно прерывает цикл — выполнение переходит к коду после цикла. Он полезен, когда нужно остановить цикл при выполнении условия. 

```python
for i in range(10):
    if i == 5:
        break
    print(i)
# Выведет числа от 0 до 4
```

Оператор `continue` пропускает текущую итерацию и переходит к следующей. Это удобно, чтобы игнорировать определённые условия, не выходя из цикла.

```python
for i in range(5):
    if i == 3:
        continue
    print(i)
# Выведет 0, 1, 2, 4
```

Циклы в Python могут иметь блок `else`, который выполняется, если цикл завершился "естественно" — без срабатывания `break`.

```python
for i in range(3):
    if i == 5:
        break
else:
    print("Цикл выполнен до конца")
# Выведет сообщение, потому что break не сработал
```

**Кейсы применения:**
- `break` — выход из цикла при достижении условия (например, поиск элемента в списке);
- `continue` — пропуск итераций с ненужными значениями для упрощения кода и уменьшения вложенности;
- `else` с циклом — выполнение постдействий, если цикл прошёл без преждевременного выхода.

## Вложенные циклы
### `6.8` Что такое вложенные циклы?
### `6.9` (`*`) Как работают операторы `break`, `continue`, `else` во вложенных циклах
Оператор `break` прерывает только тот цикл, в котором он вызван. При вложенных циклах это значит, что `break` завершит внутренний цикл, а внешний продолжит работать. Чтобы выйти из всех циклов сразу, часто используют дополнительную переменную-флаг или исключения.

Оператор `continue` действует только на текущий (вложенный) цикл — он пропускает оставшуюся часть цикла и переходит к следующей итерации внутреннего цикла.

Блок `else` в циклах выполняется только если цикл завершился без прерывания `break`. Если во внутреннем цикле сработал `break`, то внешнему циклу не будет выполнен его `else`.

**Пример с флагом для выхода из вложенных циклов:**
```python
flag = False
for i in range(3):
    for j in range(3):
        if i == 1 and j == 1:
            flag = True
            break
    if flag:
        break
```
Здесь `flag` сообщает внешнему циклу, что нужно тоже прервать выполнение.
Такое поведение помогает точно контролировать выполнение вложенных циклов и управлять логикой выхода.

----

# Типы данных 2
## Списки
### `7.1` Что такое список? На что он похож в других языках (доп знание). Функция `list()`. Изменяемость списков.  
### `7.2` Функции `len()`, `in` для списков  
### `7.3` Индексы  
### `7.4` Slices. Посмотреть различные вариации  
### `7.5` Функции `sum()`, `min()`, `max()`  
### `7.6` Конкатенация и другие математические операции  
### `7.7` Методы списков (можно посмотреть все, но укажу, которые точно надо знать):  
- `append()`  
- `extend()`  
- оператор `del`  
- `remove()`  
- `pop()`  
- `reverse()`  
- `copy()`  
- `clear()`  
- `sort()`

### `7.8` Уметь перебирать списки через for  
### `7.9` (`*`) Распаковка списков
Распаковка списков в Python позволяет одновременно присвоить элементы списка нескольким переменным. Важно, чтобы количество переменных совпадало с количеством элементов.

```python
colors = ["red", "green", "blue"]
first, second, third = colors
print(first, second, third)  # red green blue
```

Для неопределённого количества элементов используют оператор `*`, чтобы собрать остаток элементов в отдельный список:
```python
numbers = [1, 2, 3, 4, 5]
first, *middle, last = numbers
print(first)   # 1
print(middle)  # [2, 3, 4]
print(last)    # 5
```

Распаковку легко использовать при объединении списков:
```python
list1 = [1, 2]
list2 = [3, 4]
merged = [*list1, *list2]
print(merged)  # [1, 2, 3, 4]
```

### `7.10` (`*`) Методы `split()`, `join()`
Метод `split()` разбивает строку на список подстрок по заданному разделителю. Если разделитель не указан, разбиение идёт по пробелам.

```python
text = "яблоко,банан,апельсин"
print(text.split(','))  # ['яблоко', 'банан', 'апельсин']

text = "раз,два;три.четыре"
print(text.split(';'))  # ['раз,два', 'три.четыре']

text = "один два три"
print(text.split())  # ['один', 'два', 'три']
```

Метод `join()` объединяет список строк в одну строку, вставляя между ними указанный разделитель.

```python
words = ['яблоко', 'банан', 'апельсин']
print(", ".join(words))  # "яблоко, банан, апельсин"

chars = list("Python")
print("-".join(chars))  # "P-y-t-h-o-n"

lines = ['строка 1', 'строка 2', 'строка 3']
print("\n".join(lines))
# Выведет строки построчно
```
  
### `7.11` (`*`) Списочные выражения (list comprehensions)
`List comprehension` — это компактный способ создать новый список, перебирая элементы из итерируемого объекта и применяя к ним выражение. Можно добавить условие, чтобы отфильтровать элементы.

Пример простого list comprehension:
```python
nums = [n for n in range(1, 6)]  # [1, 2, 3, 4, 5]
```

С преобразованием элементов:
```python
squares = [n * n for n in nums]  # [1, 4, 9, 16, 25]
```

С фильтрацией по условию:
```python
odd_squares = [n * n for n in nums if n % 2 == 1]  # [1, 9, 25]
```

С фильтрацией по условию с else:
```python
result = ["even" if x % 2 == 0 else "odd" for x in range(10)]
# ['even', 'odd', 'even', 'odd', 'even', 'odd', 'even', 'odd', 'even', 'odd']
```

Вложенный цикл:
```python
matrix = [[x for x in range(1, 4)] for y in range(1, 4)]
# [[1, 2, 3], [1, 2, 3], [1, 2, 3]]
```

### `7.12` Вложенные списки. Матрицы  
### `7.13` (`*`) Сортировка: `sorted()`



# Функции 1
## `8.1` Что такое функциональное программирование?  
## `8.2` Что такое функция? Как объявить функцию в Python?  
## `8.3` Функции с и без параметров  
## `8.4` Разница аргумента и параметра  
## `8.5` Локальные и глобальные переменные. Область видимости. Правило `LEGB`  
## `8.6` Разные виды `return`  


# Типы данных 3
## Кортежи
`9.1` Что такое кортежи?  
`9.2` В чем их плюсы и минусы? Их свойства. Отличие от списков  
`9.3` Функции `len()`, `in` для кортежей и другие по типу `sum()`  
`9.4` Методы кортежей:  
- `index()`  
- `count()`  
- `join()`

`9.5` Распаковка кортежей  

## Множества
`9.6` Что такое множества? Свойства множеств  
`9.7` Функции `len()`, `in` для множеств и другие по типу `sum()`  
`9.8` Методы множеств (можно посмотреть все, но укажу, который точно надо знать):  
- `add()`  
- `remove()`  
- `discard()`  
- `pop()`  
- `clear()`  
- методы и операторы для операций между множествами  
- `issubset()`  
- `issuperset()`

`9.9` Генераторы множеств или `set comprehensions`  
`9.10` Можно посмотреть, что такое `frozenset`  

## Словари
`9.11` Что такое словари? Свойства словарей  
`9.12` Что может быть ключом словаря, а что нет?  
`9.13` Функции `len()`, `in` для словарей и другие по типу `sum()`  
`9.14` Методы словарей (можно посмотреть все, но укажу, который точно надо знать):  
- получение элемента из словаря  
- удаление элемента из словаря  
- `keys()`  
- `values()`  
- `items()`  
- `get()`  
- `update()`  
- `setdefault()`  
- `pop()`  
- `clear()`  
- `copy()`

`9.15` Уметь перебирать словари через for  
`9.16` Вложенные словари  
`9.17` Генераторы словарей или `dict comprehensions`
### `9.18` (`*`) Что такое коллекции и последовательности?
Коллекции в Python — это структуры данных, хранящие группы объектов. Основные типы коллекций: списки (`list`), кортежи (`tuple`), множества (`set`), словари (`dict`).  

Последовательности — подмножество коллекций, в которых элементы имеют упорядоченный индекс и доступны по позициям. К ним относятся списки, строки, кортежи и диапазоны (`range`). Последовательности поддерживают операции индексации, срезы и итерацию.

В Python все эти типы реализуют интерфейс `Iterable` (итерируемые), а последовательности дополнительно — интерфейс `Sequence`. Это позволяет последовательно перебирать элементы и использовать стандартные операции.


# Управление памятью
`10.1` Устройство памяти в общем  
`10.2` Устройства памяти в Python  
`10.3` Переменные в Python. Как работают ссылки в Python  
`10.4` Изменяемые и неизменяемые типы данных  
`10.5` `copy()` & `deepcopy()`  
`10.6` Garbage collector. Слабые и сильные ссылки  

# Функции 2
`11.1` Встроенные функции `type()`, `sorted()`, `reversed()`, `isinstance()`, `callable()`, `hasattr()`, `hash()` и другие  
`11.2` Позиционные и именованные аргументы  
`11.3` Аргументы по умолчанию  
`11.4` Функции высшего порядка  
`11.5` `lambda` функции  
`11.6` `map()`, `filter()`, `reduce()`. Кейсы их применения  
`11.7` `any()`, `all()`, `zip()`, `enumerate()`  


# Работа с файлами
`12.1` Потоковый ввод и вывод данных  

## TXT
`12.2` Что такое контекстный менеджер?  
`12.3` Как читать и записывать в файл?  
`12.4` Какие есть функции и методы для работы с TXT в Python?  

## JSON
`12.5` Что такое JSON? Для чего он нужен?  
`12.6` Какие есть функции и методы для работы с JSON в Python?  
`12.7` Как происходит конвертация типов данных при сериализации?  

## CSV
`12.8` Что такое CSV? Для чего он нужен?  
`12.9` Какие есть функции и методы для работы с CSV в Python?  


# Работа с датой и временем
`13.1` Посмотреть модуль `datetime` и различные типы данных в нем: `date`, `time`, etc.  
`13.2` На дате можно изучить `repr()` и посмотреть разницу с `str()`  
`13.3` `strftime()`, `strptime()`, `isoformat()`, `fromisoformat()`, `combine()`, `now()`  
`13.4` Что такое начало эпохи?  
`13.5` Что такое `timedelta` и зачем оно нужно?  
`13.6` Посмотреть, что такое временные зоны и как с ними работать  


# Обработка исключений
`14.1` Типы ошибок. Основные исключения в Python и их иерархия  
`14.2` `try-except`  
`14.3` `else` & `finally` в `try-except`  
`14.4` Оператор `raise`  
`14.5` Кастомные ошибки  


# Рекурсия
`15.1` Что такое рекурсия?  
`15.2` Какие задачи решает рекурсия?  


# Функции 3
`16.1` Вложенные функции  
`16.2` Замыкание. Зачем оно нужно?  


# Декораторы
`17.1` Что такое декоратор? Как написать свой декоратор?  
`17.2` Есть ли что-то похожее в других языках?  
`17.3` Атрибуты `__name__` & `__doc__`  
`17.4` `@functools.wraps` - что такое и зачем?  
`17.5` Параметризованный декоратор  


# Итераторы
`18.1` Что такое итераторы? Зачем они нужны? В чем их профит?  
`18.2` Генераторы  
`18.3` В чем разница генераторов от итераторов?  
`18.4` Когда использовать и кейсы  
`18.5` Повторить, что такое `range`  


# Type hints
`19.1` Что такое и зачем нужны?  
`19.2` Что такое динамическая типизация?  
`19.3` Модуль `typing`  
`19.4` Если есть желание, посмотреть, как было на более старых версиях  


# Extra Python  
_P.S: only for flexing on the job interview_  

`20.1` Модуль `itertools`  
`20.2` Модуль `functools`  
`20.3` Регулярные выражения. Модуль `re`  


# Cache
`21.1` Что такое кэш?  
`21.2` `lru_cache` и мемоизация  
`21.3` Методы кэширования  
`21.4` Что такое хэш?  
`21.5` Разница кэша и хэша  


# Типы данных 4  
_P.S: only for flexing on the job interview_  

`22.1` `Decimal` что такое и для чего нужен?  
`22.2` `namedtuple` что такое и для чего нужен?  
`22.3` `defaultdict` что такое и для чего нужен?  
`22.4` `OrderedDict` что такое и для чего нужен?  
`22.5` `ChainMap` что такое и для чего нужен?  
`22.6` `deque` что такое и для чего нужен?  
`22.7` Можно ещё поизучать модуль `collections`  


# Принципы ООП
`23.1` Парадигмы программирования. Что такое объект в Python?  
`23.2` Преимущества ООП и недостатки  
`23.3` Что такое класс и объект?  
`23.4` 4 принципа ООП  
- абстракция  
- инкапсуляция  
- наследование  
- полиморфизм  


# Атрибуты и методы
`24.1` Какие кейсы есть вообще, и какие соглашения на использовании в Python (camelCase, snake_case, etc)  
`24.2` Функция `dir()` — для получения списка атрибутов и методов объекта  
`24.3` Создание классов и объектов в Python  
`24.4` Атрибуты класса и объекта (без `__init__`)  
`24.5` Атрибут `__dict__` — словарь атрибутов объекта  
`24.6` Встроенные функции для работы с атрибутами:  
- `getattr()` — получить атрибут  
- `setattr()` — установить атрибут  
- `delattr()` — удалить атрибут  
- `hasattr()` — проверить наличие атрибута  

`24.7` Что такое метод и как его создавать?  

# Методы экземпляра класса
`25.1` Метод `__init__` — конструктор класса  
`25.2` Параметр `self` — что это и зачем нужен  


# Доступ к атрибутам
`26.1` Сокрытие данных (инкапсуляция) в Python  
`26.2` Соглашения между разработчиками по именованию и доступу  
`26.3` Геттеры, сеттеры, делитеры — что это и зачем нужны  
`26.4` Свойство (`property`) — атрибут с управляемым доступом  
`26.5` Декоратор `@property` — как работает и зачем  
`26.6` Декораторы `@classmethod` и `@staticmethod` — что такое `cls` и различия  
`26.7` Продвинутое: `@singledispatchmethod` — перегрузка методов по типу аргумента  


# Виртуальное окружение
## venv
## poetry
## 


# Логирование
