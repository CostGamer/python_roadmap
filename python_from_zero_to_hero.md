# Правила
- Все что не отмечено звездочкой надо точно и уверено знать  
- `*` - must have for interview  
- `**` - for flex in the interview

----

# `1` Python
## `1.1` Что такое компилируемых и интерпретируемых языки? В чем их отличие?  
## `1.2` Плюсы и минусы `Python`  
## `1.3` Какие задачи решает `Python`?

----

# `2` Ввод - вывод
## `2.1` print()
### `2.1.1` Как работает `print()`?  
### `2.1.2` Что такон аргумент?

## `2.2` input()
### `2.2.1` Как работает `input()`? Что принимает `input()`?  
### `2.2.2` Что такое переменная? Как можно и принято называть переменную?  
### `2.2.3` Что такое комментарий и как его делать?  
### `2.2.4` Несколько переменных в `print()`  
### `2.2.5` Переменные в `input()`  
### `2.2.6` Параметры `sep` & `end` в `print()`  

## `2.3` PEP8
### `2.3.1` Что такое `PEP8`?  
### `2.3.2` Обшие рекомендации  

## `2.4` Целочисленные операции
### `2.4.1` `int()`, `int(input())`  
### `2.4.2` Математические операции  
### `2.4.2` Операторы: (), **, //, %  

----

# `3` Условный оператор
## `3.1` `if-else`  
## `3.2` Что такое табуляция?  
## `3.3` Какие есть операторы сравнения? Цепочки сравнения и транзитивность  
## `3.4` Логические операции: `and`, `or`, `not`

## `3.5` (`*`) Комбинирование и приоритизация логических операций  
Приоритет выполнения логических операторов:
- в первую очередь выполняется логическое отрицание `not`
- далее выполняется логическое умножение `and`
- далее выполняется логическое сложение `or`

## `3.6` Вложенные условия  
## `3.7` Каскадные условия. Что такое `elif`

----

# `4` Типы данных 1
## `4.1` Что такое тип данных и зачем он нужен?  
## `4.2` Числовые типы данных. Целые числа и числа с плавающей точкой  
## `4.3` Функции `min()`, `max()`, `abs()`  
## `4.4` Функция `round`  
## `4.5` Строковый тип данных  
## `4.6` Функции `len()`, `in` для строк!  
## `4.7` `bool` & `None`

----

# `5` Строки
## `5.1` (`*`) Индексы  
`Индекс` — это числовое значение, обозначающее позицию символа в строке. В Python индексы начинаются с `0` для первого символа. Отрицательные индексы позволяют считать символы с конца строки:  
`-1` — последний символ,  
`-2` — предпоследний и так далее.  

```python
s = "Python"
print(s[0])  # Выведет 'P'
print(s[-1]) # Выведет 'n'
```

## `5.2` (`*`) Срезы. Срезы с одним/двумя/тремя параметрами `[x:y:z]` 
`Срез` позволяет получить подстроку, указав стартовый индекс (`start`), конечный индекс (`stop`), не включая его, и шаг (`step`), с которым выбираются символы. Все параметры опциональны:  

`start` по умолчанию — начало строки;  
`stop` по умолчанию — конец строки;  
`step` по умолчанию — `1`.  

```python
s = "Python"
print(s[1:4])   # 'yth'
print(s[:3])    # 'Pyt'
print(s[::2])   # 'Pto'
print(s[::-1])  # 'nohtyP'
```

## `5.3` (`*`) Отрицательные срезы  
`Отрицательные индексы` позволяют работать с концом строки, не зная её длины. Например, `s[-4:-1]` — подстрока с четвертого символа с конца по предпоследний (последний не включается). `s[-4:]` — последние четыре символа строки.  
Также можно использовать отрицательный шаг, например, `s[::-1]` — строка в обратном порядке. При отрицательном шаге границы среза указываются в обратном порядке, чтобы получить правильный результат.  
Таким образом, отрицательные срезы — удобный и мощный инструмент для работы с концом строки или её реверсом.

```python
s = "Hello, Python!"
print(s[-6:])   # 'Python!'
print(s[-4:-1]) # 'tho'
print(s[::-1])  # '!nohtyP ,olleH'
```

## `5.4` Методы строк (можно посмотреть все, но укажу, которые точно надо знать):  
- `capitalize()`  
- `title()`  
- `lower()`  
- `upper()`  
- `startswith()`  
- `strip()`  
- `isalpha()`  
- `isdigit()`  
- `islower()`  
- `isupper()`

## `5.5` Конкатенация и другие математические операции  
## `5.6` (`*`) Форматирование:  
### `format()`  
Метод `format()` вставляет значения в строку по местам-заполнителям, указанным в фигурных скобках `{}`. Можно использовать позиционные или именованные аргументы, указывая внутри скобок номера или имена: 
```python
"Hello, {}!".format("Alice")  # Hello, Alice!
"{1}, {0}".format('first', 'second')  # second, first
"{name} is {age}".format(name="Bob", age=25)  # Bob is 25
```
Форматирование внутри фигурных скобок позволяет задавать выравнивание, ширину, точность и другие параметры:
```python
"{:>10}".format("cat")    # "       cat" (выравнивание по правому краю, ширина 10)
"{:.3}".format("caterpillar")  # "cat" (обрезка до 3 символов)
"{:0^9}".format(123)      # "000123000" (выравнивание с заполнением нулями)
```

### `f-строки` 
`F-строки` появились в Python 3.6 и позволяют вставлять выражения прямо в строку с префиксом f:
```python
name = "Alice"
age = 30
print(f"Hello, {name}! You are {age} years old.")  # Hello, Alice! You are 30 years old.
```
Также внутри фигурных скобок можно использовать форматирование:
```python
print(f"{123:0>9}")  # '000000123' (выравнивание по правому краю с заполнением нулями)
print(f"{123:.2f}")   # '123.00' (формат с двумя десятичными знаками)
```

## `5.7` (`**`) Как строки хранятся в памяти компьютера. Команды `ord()`, `chr()`  
## `5.8` (`**`) Кодировки

----

# `6` Циклы
## `6.1` For loop
### `6.1.1` Как написать for loop в `Python`?  
### `6.1.2` Функция `range`. `Range` с несколькими параметрами и отрицательным шагом генерации  
### `6.1.3` `_` в цикле for  
### `6.1.4` Концепция `флага` (сигнала)  

## `6.2` While loop
### `6.2.1` Как написать while loop в `Python`?  
### `6.2.2` Бесконечные циклы
### `6.2.3` (`*`) Операторы: `break`, `continue`, `else`. Кейсы применения
Оператор `break` досрочно прерывает цикл — выполнение переходит к коду после цикла. Он полезен, когда нужно остановить цикл при выполнении условия. 

```python
for i in range(10):
    if i == 5:
        break
    print(i)
# Выведет числа от 0 до 4
```

Оператор `continue` пропускает текущую итерацию и переходит к следующей. Это удобно, чтобы игнорировать определённые условия, не выходя из цикла.

```python
for i in range(5):
    if i == 3:
        continue
    print(i)
# Выведет 0, 1, 2, 4
```

Циклы в Python могут иметь блок `else`, который выполняется, если цикл завершился "естественно" — без срабатывания `break`.

```python
for i in range(3):
    if i == 5:
        break
else:
    print("Цикл выполнен до конца")
# Выведет сообщение, потому что break не сработал
```

**Кейсы применения:**
- `break` — выход из цикла при достижении условия (например, поиск элемента в списке);
- `continue` — пропуск итераций с ненужными значениями для упрощения кода и уменьшения вложенности;
- `else` с циклом — выполнение постдействий, если цикл прошёл без преждевременного выхода.

## `6.3` Вложенные циклы
### `6.3.1` Что такое вложенные циклы?
### `6.3.2` (`*`) Как работают операторы `break`, `continue`, `else` во вложенных циклах
Оператор `break` прерывает только тот цикл, в котором он вызван. При вложенных циклах это значит, что `break` завершит внутренний цикл, а внешний продолжит работать. Чтобы выйти из всех циклов сразу, часто используют дополнительную переменную-флаг или исключения.

Оператор `continue` действует только на текущий (вложенный) цикл — он пропускает оставшуюся часть цикла и переходит к следующей итерации внутреннего цикла.

Блок `else` в циклах выполняется только если цикл завершился без прерывания `break`. Если во внутреннем цикле сработал `break`, то внешнему циклу не будет выполнен его `else`.

**Пример с флагом для выхода из вложенных циклов:**
```python
flag = False
for i in range(3):
    for j in range(3):
        if i == 1 and j == 1:
            flag = True
            break
    if flag:
        break
```
Здесь `flag` сообщает внешнему циклу, что нужно тоже прервать выполнение.
Такое поведение помогает точно контролировать выполнение вложенных циклов и управлять логикой выхода.

----

# `7` Типы данных 2 (Списки)
## `7.1` Что такое список? На что он похож в других языках (доп знание). Функция `list()`. Изменяемость списков.  
## `7.2` Функции `len()`, `in` для списков  
## `7.3` Индексы  
## `7.4` Slices. Посмотреть различные вариации  
## `7.5` Функции `sum()`, `min()`, `max()`  
## `7.6` Конкатенация и другие математические операции  
## `7.7` Методы списков (можно посмотреть все, но укажу, которые точно надо знать):  
- `append()`  
- `extend()`  
- оператор `del`  
- `remove()`  
- `pop()`  
- `reverse()`  
- `copy()`  
- `clear()`  
- `sort()`

## `7.8` Уметь перебирать списки через for  
## `7.9` (`*`) Распаковка списков
Распаковка списков в Python позволяет одновременно присвоить элементы списка нескольким переменным. Важно, чтобы количество переменных совпадало с количеством элементов.

```python
colors = ["red", "green", "blue"]
first, second, third = colors
print(first, second, third)  # red green blue
```

Для неопределённого количества элементов используют оператор `*`, чтобы собрать остаток элементов в отдельный список:
```python
numbers = [1, 2, 3, 4, 5]
first, *middle, last = numbers
print(first)   # 1
print(middle)  # [2, 3, 4]
print(last)    # 5
```

Распаковку легко использовать при объединении списков:
```python
list1 = [1, 2]
list2 = [3, 4]
merged = [*list1, *list2]
print(merged)  # [1, 2, 3, 4]
```

## `7.10` (`*`) Методы `split()`, `join()`
Метод `split()` разбивает строку на список подстрок по заданному разделителю. Если разделитель не указан, разбиение идёт по пробелам.

```python
text = "яблоко,банан,апельсин"
print(text.split(','))  # ['яблоко', 'банан', 'апельсин']

text = "раз,два;три.четыре"
print(text.split(';'))  # ['раз,два', 'три.четыре']

text = "один два три"
print(text.split())  # ['один', 'два', 'три']
```

Метод `join()` объединяет список строк в одну строку, вставляя между ними указанный разделитель.

```python
words = ['яблоко', 'банан', 'апельсин']
print(", ".join(words))  # "яблоко, банан, апельсин"

chars = list("Python")
print("-".join(chars))  # "P-y-t-h-o-n"

lines = ['строка 1', 'строка 2', 'строка 3']
print("\n".join(lines))
# Выведет строки построчно
```
  
## `7.11` (`*`) Списочные выражения (list comprehensions)
`List comprehension` — это компактный способ создать новый список, перебирая элементы из итерируемого объекта и применяя к ним выражение. Можно добавить условие, чтобы отфильтровать элементы.

Пример простого list comprehension:
```python
nums = [n for n in range(1, 6)]  # [1, 2, 3, 4, 5]
```

С преобразованием элементов:
```python
squares = [n * n for n in nums]  # [1, 4, 9, 16, 25]
```

С фильтрацией по условию:
```python
odd_squares = [n * n for n in nums if n % 2 == 1]  # [1, 9, 25]
```

С фильтрацией по условию с else:
```python
result = ["even" if x % 2 == 0 else "odd" for x in range(10)]
# ['even', 'odd', 'even', 'odd', 'even', 'odd', 'even', 'odd', 'even', 'odd']
```

Вложенный цикл:
```python
matrix = [[x for x in range(1, 4)] for y in range(1, 4)]
# [[1, 2, 3], [1, 2, 3], [1, 2, 3]]
```

## `7.12` Вложенные списки. Матрицы  
## `7.13` (`*`) Сортировка: `sorted()` и параметр `key`
Функция `sorted()` создаёт новый отсортированный список из любого итерируемого объекта без изменения исходного. По умолчанию сортировка идёт по самим элементам, но часто нужна более сложная сортировка — для этого есть параметр `key`.

Параметр `key` — это функция, которая для каждого элемента возвращает значение, по которому будет производиться сортировка. Это позволяет сортировать по внутренним атрибутам, ключам, длине или любым произвольным критериям.

*Сортировка списка чисел по возрастанию (по умолчанию):*
```python
numbers = [5, 8, 6, 9, 7, 10]
sorted_numbers = sorted(numbers)
print(sorted_numbers)  # [5, 6, 7, 8, 9, 10]
```

*Сортировка списка строк без учёта регистра по алфавиту с помощью `key=str.lower`:*
```python
words = ["Banana", "apple", "Cherry"]
sorted_words = sorted(words, key=str.lower)
print(sorted_words)  # ['apple', 'Banana', 'Cherry']
```

*Сортировка списка кортежей по второму элементу каждого кортежа:*
```python
pairs = [(1, 'one'), (3, 'three'), (2, 'two')]
sorted_pairs = sorted(pairs, key=lambda x: x[1])
print(sorted_pairs)  # [(1, 'one'), (3, 'three'), (2, 'two')]
```

*Сортировка списка объектов по атрибуту `grade`:*
```python
class Student:
    def __init__(self, name, grade):
        self.name = name
        self.grade = grade

students = [Student('Alice', 85), Student('Bob', 92), Student('Charlie', 78)]
sorted_students = sorted(students, key=lambda s: s.grade)
print([(s.name, s.grade) for s in sorted_students])  # [('Charlie', 78), ('Alice', 85), ('Bob', 92)]
```

Параметр `reverse=True` позволяет сортировать в обратном порядке.  
Функция `sorted()` очень гибкая и применяется для сортировки списков, кортежей, строк и даже пользовательских объектов по любому критерию.

----

# `8` Функции 1
## `8.1` Что такое функциональное программирование?  
## `8.2` Что такое функция? Как объявить функцию в Python?  
## `8.3` Функции с и без параметров  
## `8.4` Разница аргумента и параметра  
## `8.5` Разные виды `return`  

----

# `9` Типы данных 3
## `9.1` Кортежи
### `9.1.1` Что такое кортежи?  
### `9.1.2` В чем их плюсы и минусы? Их свойства. Отличие от списков  
### `9.1.3` Функции `len()`, `in` для кортежей и другие по типу `sum()`  
### `9.1.4` Методы кортежей:  
- `index()`  
- `count()`  
- `join()`
### `9.1.5` Распаковка кортежей  

## `9.2` Множества
### `9.2.1` Что такое множества? Свойства множеств  
### `9.2.2` Функции `len()`, `in` для множеств и другие по типу `sum()`  
### `9.2.3` Методы множеств (можно посмотреть все, но укажу, который точно надо знать):  
- `add()`  
- `remove()`  
- `discard()`  
- `pop()`  
- `clear()`  
- методы и операторы для операций между множествами  
- `issubset()`  
- `issuperset()`
### `9.2.3` (`*`) Генераторы множеств (`set comprehensions`)
`Set comprehension` — это компактный способ создать множество (set) на основе существующего итерируемого объекта с возможностью фильтрации и трансформации элементов.

Синтаксис похож на list comprehension, но используются фигурные скобки:
```python
{expression for item in iterable if condition}
```

Пример: создадим множество из чётных чисел списка:

```python
numbers = [13, 21, 14, 24, 53, 62]
even_numbers = {num for num in numbers if num % 2 == 0}
print(even_numbers)  # Например: {24, 62, 14}
```

Множества автоматически исключают дубликаты и неупорядочены.
Set comprehension эффективны для быстрого создания уникальных коллекций с фильтрацией или преобразованием элементов.


### `9.2.4` (`**`) `frozenset`
`frozenset` — это неизменяемый (immutable) аналог множества (`set`). Как и множество, он хранит уникальные элементы, но после создания его нельзя изменить (добавлять или удалять элементы).

Основные особенности:
- Можно использовать как ключи в словарях или элементы других множеств (т.к. хешируем).
- Создаётся из итерируемого объекта: `frozenset(iterable)`.

```python
s = frozenset([1, 2, 2, 3])
print(s)  # frozenset({1, 2, 3})

# Попытка изменить вызовет ошибку:
# s.add(4)  # AttributeError: 'frozenset' object has no attribute 'add'
```
`frozenset` полезен, когда нужно неизменяемое множество, например, для хранения множества в качестве ключа словаря или для передачи данных, которые нельзя случайно изменить.


## `9.3` Словари
### `9.3.1` Что такое словари? Свойства словарей  
### `9.3.2` Что может быть ключом словаря, а что нет?  
### `9.3.3` Функции `len()`, `in` для словарей и другие по типу `sum()`  
### `9.3.4` Методы словарей (можно посмотреть все, но укажу, который точно надо знать):  
- получение элемента из словаря  
- удаление элемента из словаря  
- `keys()`  
- `values()`  
- `items()`  
- `get()`  
- `update()`  
- `setdefault()`  
- `pop()`  
- `clear()`  
- `copy()`

### `9.3.5` Уметь перебирать словари через for  
### `9.3.6` Вложенные словари  
### `9.3.7` Генераторы словарей или `dict comprehensions`
### `9.3.8` (`*`) Что такое коллекции и последовательности?
Коллекции в Python — это структуры данных, хранящие группы объектов. Основные типы коллекций: списки (`list`), кортежи (`tuple`), множества (`set`), словари (`dict`).  

Последовательности — подмножество коллекций, в которых элементы имеют упорядоченный индекс и доступны по позициям. К ним относятся списки, строки, кортежи и диапазоны (`range`). Последовательности поддерживают операции индексации, срезы и итерацию.

В Python все эти типы реализуют интерфейс `Iterable` (итерируемые), а последовательности дополнительно — интерфейс `Sequence`. Это позволяет последовательно перебирать элементы и использовать стандартные операции.

----

# `10` Управление памятью
## `10.1` Устройство памяти в общем  
## `10.2` Устройства памяти в Python  
## `10.3` Переменные в Python. Как работают ссылки в Python  
## `10.4` Изменяемые и неизменяемые типы данных  
## `10.5` `copy()` & `deepcopy()`  
## `10.6` Garbage collector. Слабые и сильные ссылки  

----

# `11` Функции 2
## `11.1` Встроенные функции `type()`, `sorted()`, `reversed()`, `isinstance()`, `callable()`, `hasattr()`, `hash()` и другие  
## `11.2` Позиционные и именованные аргументы  
## `11.3` Аргументы по умолчанию  
## `11.4` Функции высшего порядка  
## `11.5` `lambda` функции  
## `11.6` `map()`, `filter()`, `reduce()`. Кейсы их применения  
## `11.7` `any()`, `all()`, `zip()`, `enumerate()`  

----

# `12` Работа с файлами
### `12.0.1` Потоковый ввод и вывод данных  

## `12.1` TXT
### `12.1.1` Что такое контекстный менеджер?  
### `12.1.2` Как читать и записывать в файл?  
### `12.1.3` Какие есть функции и методы для работы с TXT в Python?  

## `12.2` JSON
### `12.2.1` Что такое JSON? Для чего он нужен?  
### `12.2.2` Какие есть функции и методы для работы с JSON в Python?  
### `12.2.3` Как происходит конвертация типов данных при сериализации?  

## `12.3` CSV
### `12.3.1` Что такое CSV? Для чего он нужен?  
### `12.3.2` Какие есть функции и методы для работы с CSV в Python?  

----

# `13` Работа с датой и временем
## `13.1` Посмотреть модуль `datetime` и различные типы данных в нем: `date`, `time`, etc.  
## `13.2` На дате можно изучить `repr()` и посмотреть разницу с `str()`  
## `13.3` `strftime()`, `strptime()`, `isoformat()`, `fromisoformat()`, `combine()`, `now()`  
## `13.4` Что такое начало эпохи?  
## `13.5` Что такое `timedelta` и зачем оно нужно?  
## `13.6` Посмотреть, что такое временные зоны и как с ними работать  

----

# `14` Обработка исключений
## `14.1` Типы ошибок. Основные исключения в Python и их иерархия  
## `14.2` `try-except`  
## `14.3` `else` & `finally` в `try-except`  
## `14.4` Оператор `raise`  
## `14.5` Кастомные ошибки  

----

# `15` Рекурсия
## `15.1` Что такое рекурсия?  
## `15.2` Какие задачи решает рекурсия?  

----

# `16` Функции 3
## `16.1` Вложенные функции
## `16.2` (`*`) Замыкание. Зачем оно нужно?
**Замыкание** (closure) — это функция, которая определена внутри другой функции и хранит «замкнутые» значения переменных из внешней области видимости, даже после завершения работы внешней функции. То есть она "запоминает" своё окружение и может использовать переменные внешней функции, когда уже вне её контекста.

**Зачем нужны замыкания:**
- Для создания _фабричных функций_ с сохранением внутренних параметров (вместо глобальных переменных).
- Для инкапсуляции данных, когда не хочется использовать классы и нужно скрыть внутреннюю логику или состояние.
- Для генерации функций с "запомненным" состоянием или параметром.

```python
def make_multiplier(n):
    def multiplier(x):
        return x * n
    return multiplier

double = make_multiplier(2)
triple = make_multiplier(3)

print(double(4))  # 8
print(triple(4))  # 12
```
Здесь `multiplier` — замыкание: оно "помнит" значение `n` из внешней функции.

```python
def counter():
    count = 0
    def inc():
        nonlocal count
        count += 1
        return count
    return inc

count1 = counter()
print(count1())  # 1
print(count1())  # 2
```


## `16.3` (`*`) Паттерн Фабрика
`Паттерн Фабрика` — это способ централизованного создания объектов или значений, когда точный тип или параметры неизвестны заранее. В Python, без использования классов, он часто реализуется как функция, которая принимает параметры и возвращает нужное значение (например, другую функцию или структуру).

### Зачем нужен
- Чтобы упростить создание разных вариантов объектов или функций.
- Чтобы скрыть логику создания внутри одной функции.
- Чтобы избежать повторения кода.

### Пример простой фабрики без классов
```python
def animal_factory(animal_type):
    if animal_type == "dog":
        return "Гав-гав"
    elif animal_type == "cat":
        return "Мяу"
    else:
        return "Неизвестный звук"

print(animal_factory("dog"))  # Гав-гав
print(animal_factory("cat"))  # Мяу
```


## `16.4` (`*`) Локальные и глобальные переменные. Область видимости. Правило `LEGB`
В Python **локальные переменные** объявляются внутри функций и доступны только в этих функциях. **Глобальные переменные** находятся вне всех функций и доступны во всей программе. Если объявить переменную внутри функции с тем же именем, что и глобальная — внутри функции будет использоваться локальная версия, а глобальная вне функции.

**Область видимости** — определяет, где переменная "видна" и доступна для использования. Локальные переменные исчезают после завершения функции, глобальные — сохраняются на протяжении исполнения всей программы.

### LEGB правило поиска переменных
Python ищет переменные по цепочке областей видимости:
- **L**ocal (Локальная): внутри текущей функции или метода
- **E**nclosing (Вложенная): в родительских (внешних) функциях, если используется вложенность
- **G**lobal (Глобальная): на уровне всего модуля (файла)
- **B**uilt-in (Встроенная): специальные переменные и функции Python (например, `print`, `len`)

**Глобальная переменная:**
```python
x = "глобальная переменная"

def show():
    print(x)  # доступ к глобальной переменной
show()
print(x)      # доступ вне функции
```

**Локальная переменная:**
```python
def foo():
    y = "локальная переменная"
    print(y)
foo()
# print(y)  # Ошибка, вне функции переменная недоступна
```

**LEGB - вложенные функции:**
```python
def outer():
    a = "enclosing"
    def inner():
        print(a)  # ищет переменную во внешней функции (Enclosing)
    inner()
outer()
```

**Изменение глобальной переменной внутри функции:**
```python
global_var = 10

def update():
    global global_var
    global_var = 20  # изменится глобальная переменная
update()
print(global_var)    # 20
```

----

# `17` Декораторы
## `17.1` Что такое декоратор? Как написать свой декоратор?  
## `17.2` Есть ли что-то похожее в других языках?  
## `17.3` Атрибуты `__name__` & `__doc__`  
## `17.4` `@functools.wraps` - что такое и зачем?  
## `17.5` Параметризованный декоратор  

----

# `18` Итераторы
## `18.1` Что такое итераторы? Зачем они нужны? В чем их профит?  
## `18.2` Генераторы  
## `18.3` В чем разница генераторов от итераторов?  
## `18.4` Когда использовать и кейсы  
## `18.5` Повторить, что такое `range`  

----

# `19` Type hints
## `19.1` Что такое и зачем нужны?  
## `19.2` Что такое динамическая типизация?  
## `19.3` Модуль `typing`  
## `19.4` Если есть желание, посмотреть, как было на более старых версиях  

----

# `20` Extra Python  
_P.S: only for flexing on the job interview_  

## `20.1` Модуль `itertools`  
## `20.2` Модуль `functools`  
## `20.3` Регулярные выражения. Модуль `re`  

----

# `21` Cache
## `21.1` Что такое кэш?  
## `21.2` `lru_cache` и мемоизация  
## `21.3` Методы кэширования  
## `21.4` Что такое хэш?  
## `21.5` Разница кэша и хэша  

----

# `22` Типы данных 4  
_P.S: only for flexing on the job interview_  

## `22.1` `Decimal` что такое и для чего нужен?  
## `22.2` `namedtuple` что такое и для чего нужен?  
## `22.3` `defaultdict` что такое и для чего нужен?  
## `22.4` `OrderedDict` что такое и для чего нужен?  
## `22.5` `ChainMap` что такое и для чего нужен?  
## `22.6` `deque` что такое и для чего нужен?  
## `22.7` Можно ещё поизучать модуль `collections`  

----

# `23` Принципы ООП
## `23.1` Парадигмы программирования. Что такое объект в Python?  
## `23.2` Преимущества ООП и недостатки  
## `23.3` Что такое класс и объект?  
## `23.4` 4 принципа ООП  
- абстракция  
- инкапсуляция  
- наследование  
- полиморфизм  

----

# `24` Атрибуты и методы
## `24.1` Какие кейсы есть вообще, и какие соглашения на использовании в Python (camelCase, snake_case, etc)  
## `24.2` Функция `dir()` — для получения списка атрибутов и методов объекта  
## `24.3` Создание классов и объектов в Python  
## `24.4` Атрибуты класса и объекта (без `__init__`)  
## `24.5` Атрибут `__dict__` — словарь атрибутов объекта  
## `24.6` Встроенные функции для работы с атрибутами:  
- `getattr()` — получить атрибут  
- `setattr()` — установить атрибут  
- `delattr()` — удалить атрибут  
- `hasattr()` — проверить наличие атрибута  
## `24.7` Что такое метод и как его создавать?  

----

# `25` Методы экземпляра класса
## `25.1` Метод `__init__` — конструктор класса  
## `25.2` Параметр `self` — что это и зачем нужен  

----

# `26` Доступ к атрибутам
## `26.1` Сокрытие данных (инкапсуляция) в Python  
## `26.2` Соглашения между разработчиками по именованию и доступу  
## `26.3` Геттеры, сеттеры, делитеры — что это и зачем нужны  
## `26.4` Свойство (`property`) — атрибут с управляемым доступом  
## `26.5` Декоратор `@property` — как работает и зачем  
## `26.6` Декораторы `@classmethod` и `@staticmethod` — что такое `cls` и различия  
## `26.7` Продвинутое: `@singledispatchmethod` — перегрузка методов по типу аргумента  

----

# `27` (`*`) Магические методы
Что такое магические методы и зачем нужны?
## `27.1` `__init__`, `__new__`, `super()`, `__del__`
## `27.2` `__str__`, `__repr__`
## `27.3` Сравнение объектов
- `__eq__`
- `__ne__`
- `__lt__`
- `__gt__`
- `__le__`
- `__ge__`
## `27.4` Вызываемые объекты
- `__call__`
## `27.5` Работа с атрибутами
- `__getattribute__`
- `__getattr__`
- `__setattr__`
- `__delattr__`
## `27.6` Хэширование
## `27.7` (`**`) Ultra flex
1) Унарные операторы
2) Арифметические операции
3) Преобразование типов

----

# `28` (`*`) Протоколы
## `28.1` Итерируемые объекты и итераторы
## `28.2` Протокол контекстных менеджеров
## `28.3` Дескрипторы
## `28.4` (`**`) Ultra flex
1) Протокол последовательностей
2) Протокол дескрипторов

----

# `29` (`*`) Наследование и Полиморфизм
## `29.1` Наследование
## `29.2` Полиморфизм
## `29.3` Абстрактные классы и протоколы
## `29.4` Generics
## `29.5` Композиция

----

# `30` (`*`) Extra OOP
## `30.1` `__slots__`, `__dict__`
## `30.2` Enum
## `30.3` Миксины
## `30.4` dataclasses

----

# `31` (`*`) Виртуальное окружение
## `31.1` Что такое виртуальное окружение и зачем?
## `31.1` venv
## `31.1` poetry

----

# `32` (`*`) Многопоточность
## `32.1` Что такое многопоточность и зачем она нужна
## `32.2` Потоки vs Процессы — основные различия
## `32.3` GIL (Global Interpreter Lock) — что это и как влияет на многопоточность в Python
## `32.4` Модуль threading — основной инструмент для работы с потоками
## `32.5` Создание и запуск потоков:
- Класс `Thread`
- Параметры `target`, `args`, `kwargs`
- Метод `start()` — запуск потока
- Метод `join()` — ожидание завершения потока
## `32.6` Наследование от класса Thread — создание собственных потоков
## `32.7` Daemon потоки — что это и когда использовать
## `32.8` Синхронизация потоков:
`Lock` — блокировка для предотвращения гонки данных
`RLock` — рекурсивная блокировка
`Semaphore` — ограничение количества одновременных доступов
`Event` — сигнализация между потоками
`Condition` — условная синхронизация
## `32.9` Проблема гонки данных (race condition) и как её избежать
## `32.10` Deadlock (взаимная блокировка) — что это и как предотвратить
## `32.11` Модуль queue для безопасного обмена данными между потоками:
`Queue` — FIFO очередь
`LifoQueue` — LIFO очередь (стек)
`PriorityQueue` — очередь с приоритетами
## `32.12` threading.local() — thread-local данные
## `32.13` concurrent.futures.ThreadPoolExecutor — пул потоков для упрощённой работы
## `32.14` Контекстный менеджер для работы с блокировками
## `32.15` Когда использовать многопоточность: I/O-bound задачи

----

# `33` (`*`) Асинхронность
## `33.1` Что такое асинхронность и чем отличается от многопоточности
## `33.2` Синхронный vs асинхронный код — основные различия
## `33.3` Event Loop (цикл событий) — что это и как работает
## `33.4` Ключевые слова `async` и `await` — основы async/await синтаксиса
## `33.5` Корутины (coroutines) — что это и как их создавать
## `33.6` Модуль `asyncio` — основной инструмент для асинхронного программирования
## `33.7` Запуск асинхронного кода:
- `asyncio.run()` — запуск корутины
- `asyncio.create_task()` — создание задачи
- `asyncio.gather()` — параллельное выполнение корутин
## `33.8` Awaitable объекты — что можно await'ить
## `33.9` Task (задачи) — управление асинхронными операциями
## `33.10` `asyncio.sleep()` — асинхронная пауза
## `33.11` Async context managers — `async with`
## `33.12` Async iterators и async generators — `async for`
## `33.13` Работа с асинхронными очередями — `asyncio.Queue`
## `33.14` Синхронизация в asyncio:
- `asyncio.Lock`
- `asyncio.Semaphore`
- `asyncio.Event`
- `asyncio.Condition`
## `33.15` `asyncio.wait()` и `asyncio.wait_for()` — управление временем выполнения
## `33.16` Обработка исключений в асинхронном коде
## `33.17` `asyncio.shield()` — защита задач от отмены
## `33.18` Отмена задач — `task.cancel()` и обработка `CancelledError`
## `33.19` Работа с subprocess асинхронно — `asyncio.create_subprocess_exec()`
## `33.20` Интеграция синхронного кода в асинхронный:
- `asyncio.to_thread()` — выполнение блокирующего кода
- `loop.run_in_executor()` — использование executor'ов
## `33.21` `concurrent.futures` и asyncio — совместное использование
## `33.22` Async библиотеки для HTTP-запросов:
- `aiohttp` — основы (упоминание без деталей)
- `httpx` — основы (упоминание без деталей)
## `33.23` Когда использовать асинхронность: I/O-bound задачи с высоким concurrency
## `33.24` Продвинутое: создание собственного event loop
## `33.25` Продвинутое: `asyncio.Future` — низкоуровневая работа с результатами

----

# `33` (`*`) Логирование
## `33.1` Что такое логирование и зачем оно нужно
## `33.2` Логирование vs `print()` — основные различия
## `33.3` Модуль `logging` — стандартный инструмент
## `33.4` Уровни логирования — `DEBUG`, `INFO`, `WARNING`, `ERROR`, `CRITICAL`
## `33.5` Базовое логирование — `logging.basicConfig()` и простые функции
## `33.6` Logger — создание именованных логгеров через `logging.getLogger()`
## `33.7` Handler — куда отправляются логи:
- `StreamHandler` — консоль
- `FileHandler` — файл
- `RotatingFileHandler` — ротация файлов
## `33.8` Formatter — форматирование сообщений и основные переменные
## `33.9` Настройка уровней логирования для logger и handler
## `33.10` Логирование исключений — `logger.exception()` и `exc_info=True`
## `33.11` Конфигурация через словарь — `logging.config.dictConfig()`

----

# `34` (`*`) Паттерны проектирования*
## `34.1` Что такое паттерны проектирования и зачем они нужны
`Паттерны проектирования` — это проверенные временем решения типовых проблем, которые возникают при разработке программного обеспечения. Это не готовый код, который можно скопировать, а концептуальные шаблоны для решения конкретных задач.

**Зачем нужны паттерны**:
- **Переиспользование решений** — не нужно изобретать велосипед для типовых задач
- **Общий язык** — разработчики понимают друг друга, когда говорят "здесь нужен Singleton" или "давай используем Factory"
- **Улучшение архитектуры** — код становится более гибким, расширяемым и поддерживаемым
- **Избежание ошибок** — паттерны учитывают подводные камни, с которыми уже столкнулись другие разработчики

## `34.2` Категории паттернов — порождающие, структурные, поведенческие
`Паттерны проектирования` делятся на три основные категории по типу решаемых задач:

### **Порождающие паттерны (Creational Patterns)**
Отвечают за создание объектов. Помогают сделать систему независимой от способа создания, композиции и представления объектов.

**Основные паттерны:**
- **Singleton** — гарантирует единственный экземпляр класса
- **Factory Method** — делегирует создание объектов подклассам
- **Builder** — пошаговое создание сложных объектов
- **Prototype** — создание объектов через клонирование

**Когда использовать:** когда нужно контролировать процесс создания объектов, скрыть сложную логику инициализации или обеспечить гибкость при создании.

### **Структурные паттерны (Structural Patterns)**
Описывают способы композиции классов и объектов. Помогают организовать связи между объектами так, чтобы система оставалась гибкой и эффективной.

**Основные паттерны:**
- **Decorator** — позволяет динамически добавлять объектам новую функциональность, оборачивая их в специальные объекты-обёртки
- **Adapter** — приводит интерфейс класса к ожидаемому виду
- **Facade** — предоставляет простой интерфейс к сложной системе
- **Proxy** — контролирует доступ к объекту
- **Composite** — организует объекты в древовидную структуру

**Когда использовать:** когда нужно упростить сложные связи между объектами, сделать систему модульной или обеспечить совместимость несовместимых интерфейсов.

### **Поведенческие паттерны (Behavioral Patterns)**
Определяют взаимодействие между объектами и распределение обязанностей. Помогают организовать эффективную коммуникацию и управление алгоритмами.

**Основные паттерны:**
- **Strategy** — позволяет менять алгоритмы независимо от клиента
- **Observer** — механизм подписки на события
- **Iterator** — последовательный доступ к элементам коллекции
- **Command** — инкапсулирует запрос как объект
- **State** — изменяет поведение объекта при изменении состояния

**Когда использовать:** когда нужно гибко управлять поведением объектов, организовать взаимодействие между компонентами или инкапсулировать изменяющееся поведение.

## `34.3` Singleton — единственный экземпляр класса
`Singleton` гарантирует, что у класса существует только один экземпляр, и предоставляет глобальную точку доступа к нему.

**Зачем нужен:**
- Управление общими ресурсами — подключение к БД, логгер, конфигурация приложения
- Координация действий в системе через единую точку доступа
- Экономия ресурсов — создаём объект только один раз

**Реализация через `__new__`:**
```python
class Database:
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self, host='localhost'):
        self.host = host

# Использование
db1 = Database('localhost')
db2 = Database('remote')
print(db1 is db2)  # True — один и тот же объект
```

Еще можно реализовать через: `декоратор` и `создания единственный экземпляр в коде, а затем его переиспользование (более Питонячий подход)`

**Когда использовать:**
- Конфигурация приложения
- Пул соединений к БД
- Система логирования
- Кеш или реестр объектов

**Осторожно:**
- Усложняет тестирование (глобальное состояние)
- Может нарушать принцип единственной ответственности
- В многопоточности требует синхронизации

[Больше про Singleton](https://habr.com/ru/companies/otus/articles/779914/)


## `34.4` Factory Method — фабричный метод для создания объектов
`Factory Method` делегирует создание объектов подклассам или отдельным методам, позволяя выбирать тип создаваемого объекта во время выполнения программы.

**Зачем нужен:**
- Скрывает сложную логику создания объектов
- Позволяет создавать разные типы объектов через единый интерфейс
- Упрощает добавление новых типов объектов без изменения существующего кода

**Простой пример — создание транспорта:**
```python
from abc import ABC, abstractmethod

class Transport(ABC):
    @abstractmethod
    def deliver(self):
        pass

class Truck(Transport):
    def deliver(self):
        return "Доставка по земле на грузовике"

class Ship(Transport):
    def deliver(self):
        return "Доставка по морю на корабле"

# Простой фабричный метод
class Logistics:
    @staticmethod
    def create_transport(transport_type: str) -> Transport:
        if transport_type == "ground":
            return Truck()
        elif transport_type == "sea":
            return Ship()
        else:
            raise ValueError(f"Неизвестный тип транспорта: {transport_type}")

# Использование
transport = Logistics.create_transport("ground")
print(transport.deliver())  # Доставка по земле на грузовике

transport = Logistics.create_transport("sea")
print(transport.deliver())  # Доставка по морю на корабле
```

**Pythonic подход — функция-фабрика:**
```python
def create_payment_processor(payment_type: str):
    processors = {
        'credit_card': CreditCardProcessor,
        'paypal': PayPalProcessor,
        'crypto': CryptoProcessor
    }
    
    processor_class = processors.get(payment_type)
    if processor_class is None:
        raise ValueError(f"Неизвестный тип платежа: {payment_type}")
    
    return processor_class()

# Использование
processor = create_payment_processor('paypal')
processor.process_payment(100)
```

**Когда использовать:**
- Когда заранее неизвестно, объекты каких типов нужно создавать
- Когда логика создания объектов сложная и её нужно инкапсулировать
- Когда нужно легко добавлять новые типы объектов
- Для парсеров, обработчиков файлов разных форматов, драйверов БД

**Преимущества:**
- Слабая связанность — клиент не зависит от конкретных классов
- Легко расширяется новыми типами
- Централизованная логика создания

[Больше про Factory Method](https://habr.com/ru/articles/725340/)

## `34.5` Builder — пошаговое создание сложных объектов
`Builder` позволяет создавать сложные объекты пошагово, разделяя процесс конструирования и представления. Особенно полезен, когда объект имеет много параметров или сложную структуру.

**Зачем нужен:**
- Упрощает создание объектов с множеством параметров
- Делает код читаемым и понятным
- Позволяет создавать разные представления объекта через один интерфейс
- Избегает "телескопических конструкторов" с десятками параметров

**Классический пример — построение дома:**
```python
class House:
    def __init__(self):
        self.walls = None
        self.roof = None
        self.windows = None
        self.doors = None
        self.garage = None
    
    def __str__(self):
        parts = []
        if self.walls:
            parts.append(f"Стены: {self.walls}")
        if self.roof:
            parts.append(f"Крыша: {self.roof}")
        if self.windows:
            parts.append(f"Окна: {self.windows}")
        if self.doors:
            parts.append(f"Двери: {self.doors}")
        if self.garage:
            parts.append(f"Гараж: {self.garage}")
        return "Дом с:\n" + "\n".join(parts)

class HouseBuilder:
    def __init__(self):
        self.house = House()
    
    def build_walls(self, material):
        self.house.walls = material
        return self  # Возвращаем self для цепочки вызовов
    
    def build_roof(self, roof_type):
        self.house.roof = roof_type
        return self
    
    def build_windows(self, count):
        self.house.windows = count
        return self
    
    def build_doors(self, count):
        self.house.doors = count
        return self
    
    def build_garage(self, has_garage):
        self.house.garage = has_garage
        return self
    
    def get_house(self):
        return self.house

# Использование — метод цепочки (fluent interface)
builder = HouseBuilder()
house = (builder
         .build_walls("кирпич")
         .build_roof("черепица")
         .build_windows(4)
         .build_doors(2)
         .build_garage(True)
         .get_house())

print(house)
# Дом с:
# Стены: кирпич
# Крыша: черепица
# Окна: 4
# Двери: 2
# Гараж: True
```

**Пример с HTTP-запросом:**
```python
class HttpRequest:
    def __init__(self):
        self.method = "GET"
        self.url = None
        self.headers = {}
        self.body = None
        self.timeout = 30
    
    def __str__(self):
        return f"{self.method} {self.url}\nHeaders: {self.headers}\nBody: {self.body}"

class RequestBuilder:
    def __init__(self, url):
        self.request = HttpRequest()
        self.request.url = url
    
    def method(self, method):
        self.request.method = method
        return self
    
    def header(self, key, value):
        self.request.headers[key] = value
        return self
    
    def body(self, data):
        self.request.body = data
        return self
    
    def timeout(self, seconds):
        self.request.timeout = seconds
        return self
    
    def build(self):
        return self.request

# Использование
request = (RequestBuilder("https://api.example.com/users")
           .method("POST")
           .header("Content-Type", "application/json")
           .header("Authorization", "Bearer token123")
           .body({"name": "John", "age": 30})
           .timeout(60)
           .build())

print(request)
# POST https://api.example.com/users
# Headers: {'Content-Type': 'application/json', 'Authorization': 'Bearer token123'}
# Body: {'name': 'John', 'age': 30}
```

**Pythonic подход — dataclass с Builder:**
```python
from dataclasses import dataclass, field
from typing import Optional, List

@dataclass
class Pizza:
    size: str
    cheese: bool = False
    pepperoni: bool = False
    mushrooms: bool = False
    olives: bool = False
    toppings: List[str] = field(default_factory=list)
    
    def __str__(self):
        base = f"Пицца {self.size}"
        ingredients = []
        if self.cheese:
            ingredients.append("сыр")
        if self.pepperoni:
            ingredients.append("пепперони")
        if self.mushrooms:
            ingredients.append("грибы")
        if self.olives:
            ingredients.append("оливки")
        ingredients.extend(self.toppings)
        
        if ingredients:
            return f"{base} с: {', '.join(ingredients)}"
        return base

class PizzaBuilder:
    def __init__(self, size: str):
        self.size = size
        self._cheese = False
        self._pepperoni = False
        self._mushrooms = False
        self._olives = False
        self._toppings = []
    
    def add_cheese(self):
        self._cheese = True
        return self
    
    def add_pepperoni(self):
        self._pepperoni = True
        return self
    
    def add_mushrooms(self):
        self._mushrooms = True
        return self
    
    def add_olives(self):
        self._olives = True
        return self
    
    def add_topping(self, topping: str):
        self._toppings.append(topping)
        return self
    
    def build(self) -> Pizza:
        return Pizza(
            size=self.size,
            cheese=self._cheese,
            pepperoni=self._pepperoni,
            mushrooms=self._mushrooms,
            olives=self._olives,
            toppings=self._toppings
        )

# Использование
pizza = (PizzaBuilder("большая")
         .add_cheese()
         .add_pepperoni()
         .add_mushrooms()
         .add_topping("бекон")
         .build())

print(pizza)  # Пицца большая с: сыр, пепперони, грибы, бекон
```

**Когда использовать:**
- Объект имеет много необязательных параметров
- Создание объекта требует множества шагов
- Нужно создавать разные представления одного объекта
- Хочется избежать конструктора с десятками параметров

**Преимущества:**
- Читаемый и понятный код
- Пошаговое конструирование
- Возможность повторного использования builder'а
- Изоляция сложной логики создания

[Еще реализация Builder](https://ru.hexlet.io/courses/python-object-oriented-design/lessons/builder/theory_unit)

## `34.6` Strategy — инкапсуляция алгоритмов
## `34.7` Observer — подписка на события и уведомления
## `34.8` Iterator — последовательный доступ к элементам (протокол итератора)
## `34.9` Context Manager — паттерн `with` и протокол `__enter__`/`__exit__`
## `34.10` Async Context Manager — `async with` и `__aenter__`/`__aexit__`
## `34.11` Async Decorator — декораторы для асинхронных функций
## `34.12` Dependency Injection — внедрение зависимостей

----
