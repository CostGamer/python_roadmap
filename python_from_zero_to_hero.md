# Правила
- Все что не отмечено звездочкой надо точно и уверено знать  
- `*` - must have for interview  
- `**` - for flex in the interview

----

# `1` Python
## `1.1` Что такое компилируемых и интерпретируемых языки? В чем их отличие?  
## `1.2` Плюсы и минусы `Python`  
## `1.3` Какие задачи решает `Python`?

----

# `2` Ввод - вывод
## `2.1` print()
### `2.1.1` Как работает `print()`?  
### `2.1.2` Что такон аргумент?

## `2.2` input()
### `2.2.1` Как работает `input()`? Что принимает `input()`?  
### `2.2.2` Что такое переменная? Как можно и принято называть переменную?  
### `2.2.3` Что такое комментарий и как его делать?  
### `2.2.4` Несколько переменных в `print()`  
### `2.2.5` Переменные в `input()`  
### `2.2.6` Параметры `sep` & `end` в `print()`  

## `2.3` PEP8
### `2.3.1` Что такое `PEP8`?  
### `2.3.2` Обшие рекомендации  

## `2.4` Целочисленные операции
### `2.4.1` `int()`, `int(input())`  
### `2.4.2` Математические операции  
### `2.4.2` Операторы: (), **, //, %  

----

# `3` Условный оператор
## `3.1` `if-else`  
## `3.2` Что такое табуляция?  
## `3.3` Какие есть операторы сравнения? Цепочки сравнения и транзитивность  
## `3.4` Логические операции: `and`, `or`, `not`

## `3.5` (`*`) Комбинирование и приоритизация логических операций  
Приоритет выполнения логических операторов:
- в первую очередь выполняется логическое отрицание `not`
- далее выполняется логическое умножение `and`
- далее выполняется логическое сложение `or`

## `3.6` Вложенные условия  
## `3.7` Каскадные условия. Что такое `elif`

----

# `4` Типы данных 1
## `4.1` Что такое тип данных и зачем он нужен?  
## `4.2` Числовые типы данных. Целые числа и числа с плавающей точкой  
## `4.3` Функции `min()`, `max()`, `abs()`  
## `4.4` Функция `round`  
## `4.5` Строковый тип данных  
## `4.6` Функции `len()`, `in` для строк!  
## `4.7` `bool` & `None`

----

# `5` Строки
## `5.1` (`*`) Индексы  
`Индекс` — это числовое значение, обозначающее позицию символа в строке. В Python индексы начинаются с `0` для первого символа. Отрицательные индексы позволяют считать символы с конца строки:  
`-1` — последний символ,  
`-2` — предпоследний и так далее.  

```python
s = "Python"
print(s[0])  # Выведет 'P'
print(s[-1]) # Выведет 'n'
```

## `5.2` (`*`) Срезы. Срезы с одним/двумя/тремя параметрами `[x:y:z]` 
`Срез` позволяет получить подстроку, указав стартовый индекс (`start`), конечный индекс (`stop`), не включая его, и шаг (`step`), с которым выбираются символы. Все параметры опциональны:  

`start` по умолчанию — начало строки;  
`stop` по умолчанию — конец строки;  
`step` по умолчанию — `1`.  

```python
s = "Python"
print(s[1:4])   # 'yth'
print(s[:3])    # 'Pyt'
print(s[::2])   # 'Pto'
print(s[::-1])  # 'nohtyP'
```

## `5.3` (`*`) Отрицательные срезы  
`Отрицательные индексы` позволяют работать с концом строки, не зная её длины. Например, `s[-4:-1]` — подстрока с четвертого символа с конца по предпоследний (последний не включается). `s[-4:]` — последние четыре символа строки.  
Также можно использовать отрицательный шаг, например, `s[::-1]` — строка в обратном порядке. При отрицательном шаге границы среза указываются в обратном порядке, чтобы получить правильный результат.  
Таким образом, отрицательные срезы — удобный и мощный инструмент для работы с концом строки или её реверсом.

```python
s = "Hello, Python!"
print(s[-6:])   # 'Python!'
print(s[-4:-1]) # 'tho'
print(s[::-1])  # '!nohtyP ,olleH'
```

## `5.4` Методы строк (можно посмотреть все, но укажу, которые точно надо знать):  
- `capitalize()`  
- `title()`  
- `lower()`  
- `upper()`  
- `startswith()`  
- `strip()`  
- `isalpha()`  
- `isdigit()`  
- `islower()`  
- `isupper()`

## `5.5` Конкатенация и другие математические операции  
## `5.6` (`*`) Форматирование:  
### `format()`  
Метод `format()` вставляет значения в строку по местам-заполнителям, указанным в фигурных скобках `{}`. Можно использовать позиционные или именованные аргументы, указывая внутри скобок номера или имена: 
```python
"Hello, {}!".format("Alice")  # Hello, Alice!
"{1}, {0}".format('first', 'second')  # second, first
"{name} is {age}".format(name="Bob", age=25)  # Bob is 25
```
Форматирование внутри фигурных скобок позволяет задавать выравнивание, ширину, точность и другие параметры:
```python
"{:>10}".format("cat")    # "       cat" (выравнивание по правому краю, ширина 10)
"{:.3}".format("caterpillar")  # "cat" (обрезка до 3 символов)
"{:0^9}".format(123)      # "000123000" (выравнивание с заполнением нулями)
```

### `f-строки` 
`F-строки` появились в Python 3.6 и позволяют вставлять выражения прямо в строку с префиксом f:
```python
name = "Alice"
age = 30
print(f"Hello, {name}! You are {age} years old.")  # Hello, Alice! You are 30 years old.
```
Также внутри фигурных скобок можно использовать форматирование:
```python
print(f"{123:0>9}")  # '000000123' (выравнивание по правому краю с заполнением нулями)
print(f"{123:.2f}")   # '123.00' (формат с двумя десятичными знаками)
```

## `5.7` (`**`) Как строки хранятся в памяти компьютера. Команды `ord()`, `chr()`  
## `5.8` (`**`) Кодировки

----

# `6` Циклы
## `6.1` For loop
### `6.1.1` Как написать for loop в `Python`?  
### `6.1.2` Функция `range`. `Range` с несколькими параметрами и отрицательным шагом генерации  
### `6.1.3` `_` в цикле for  
### `6.1.4` Концепция `флага` (сигнала)  

## `6.2` While loop
### `6.2.1` Как написать while loop в `Python`?  
### `6.2.2` Бесконечные циклы
### `6.2.3` (`*`) Операторы: `break`, `continue`, `else`. Кейсы применения
Оператор `break` досрочно прерывает цикл — выполнение переходит к коду после цикла. Он полезен, когда нужно остановить цикл при выполнении условия. 

```python
for i in range(10):
    if i == 5:
        break
    print(i)
# Выведет числа от 0 до 4
```

Оператор `continue` пропускает текущую итерацию и переходит к следующей. Это удобно, чтобы игнорировать определённые условия, не выходя из цикла.

```python
for i in range(5):
    if i == 3:
        continue
    print(i)
# Выведет 0, 1, 2, 4
```

Циклы в Python могут иметь блок `else`, который выполняется, если цикл завершился "естественно" — без срабатывания `break`.

```python
for i in range(3):
    if i == 5:
        break
else:
    print("Цикл выполнен до конца")
# Выведет сообщение, потому что break не сработал
```

**Кейсы применения:**
- `break` — выход из цикла при достижении условия (например, поиск элемента в списке);
- `continue` — пропуск итераций с ненужными значениями для упрощения кода и уменьшения вложенности;
- `else` с циклом — выполнение постдействий, если цикл прошёл без преждевременного выхода.

## `6.3` Вложенные циклы
### `6.3.1` Что такое вложенные циклы?
### `6.3.2` (`*`) Как работают операторы `break`, `continue`, `else` во вложенных циклах
Оператор `break` прерывает только тот цикл, в котором он вызван. При вложенных циклах это значит, что `break` завершит внутренний цикл, а внешний продолжит работать. Чтобы выйти из всех циклов сразу, часто используют дополнительную переменную-флаг или исключения.

Оператор `continue` действует только на текущий (вложенный) цикл — он пропускает оставшуюся часть цикла и переходит к следующей итерации внутреннего цикла.

Блок `else` в циклах выполняется только если цикл завершился без прерывания `break`. Если во внутреннем цикле сработал `break`, то внешнему циклу не будет выполнен его `else`.

**Пример с флагом для выхода из вложенных циклов:**
```python
flag = False
for i in range(3):
    for j in range(3):
        if i == 1 and j == 1:
            flag = True
            break
    if flag:
        break
```
Здесь `flag` сообщает внешнему циклу, что нужно тоже прервать выполнение.
Такое поведение помогает точно контролировать выполнение вложенных циклов и управлять логикой выхода.

----

# `7` Типы данных 2 (Списки)
## `7.1` Что такое список? На что он похож в других языках (доп знание). Функция `list()`. Изменяемость списков.  
## `7.2` Функции `len()`, `in` для списков  
## `7.3` Индексы  
## `7.4` Slices. Посмотреть различные вариации  
## `7.5` Функции `sum()`, `min()`, `max()`  
## `7.6` Конкатенация и другие математические операции  
## `7.7` Методы списков (можно посмотреть все, но укажу, которые точно надо знать):  
- `append()`  
- `extend()`  
- оператор `del`  
- `remove()`  
- `pop()`  
- `reverse()`  
- `copy()`  
- `clear()`  
- `sort()`

## `7.8` Уметь перебирать списки через for  
## `7.9` (`*`) Распаковка списков
Распаковка списков в Python позволяет одновременно присвоить элементы списка нескольким переменным. Важно, чтобы количество переменных совпадало с количеством элементов.

```python
colors = ["red", "green", "blue"]
first, second, third = colors
print(first, second, third)  # red green blue
```

Для неопределённого количества элементов используют оператор `*`, чтобы собрать остаток элементов в отдельный список:
```python
numbers = [1, 2, 3, 4, 5]
first, *middle, last = numbers
print(first)   # 1
print(middle)  # [2, 3, 4]
print(last)    # 5
```

Распаковку легко использовать при объединении списков:
```python
list1 = [1, 2]
list2 = [3, 4]
merged = [*list1, *list2]
print(merged)  # [1, 2, 3, 4]
```

## `7.10` (`*`) Методы `split()`, `join()`
Метод `split()` разбивает строку на список подстрок по заданному разделителю. Если разделитель не указан, разбиение идёт по пробелам.

```python
text = "яблоко,банан,апельсин"
print(text.split(','))  # ['яблоко', 'банан', 'апельсин']

text = "раз,два;три.четыре"
print(text.split(';'))  # ['раз,два', 'три.четыре']

text = "один два три"
print(text.split())  # ['один', 'два', 'три']
```

Метод `join()` объединяет список строк в одну строку, вставляя между ними указанный разделитель.

```python
words = ['яблоко', 'банан', 'апельсин']
print(", ".join(words))  # "яблоко, банан, апельсин"

chars = list("Python")
print("-".join(chars))  # "P-y-t-h-o-n"

lines = ['строка 1', 'строка 2', 'строка 3']
print("\n".join(lines))
# Выведет строки построчно
```
  
## `7.11` (`*`) Списочные выражения (list comprehensions)
`List comprehension` — это компактный способ создать новый список, перебирая элементы из итерируемого объекта и применяя к ним выражение. Можно добавить условие, чтобы отфильтровать элементы.

Пример простого list comprehension:
```python
nums = [n for n in range(1, 6)]  # [1, 2, 3, 4, 5]
```

С преобразованием элементов:
```python
squares = [n * n for n in nums]  # [1, 4, 9, 16, 25]
```

С фильтрацией по условию:
```python
odd_squares = [n * n for n in nums if n % 2 == 1]  # [1, 9, 25]
```

С фильтрацией по условию с else:
```python
result = ["even" if x % 2 == 0 else "odd" for x in range(10)]
# ['even', 'odd', 'even', 'odd', 'even', 'odd', 'even', 'odd', 'even', 'odd']
```

Вложенный цикл:
```python
matrix = [[x for x in range(1, 4)] for y in range(1, 4)]
# [[1, 2, 3], [1, 2, 3], [1, 2, 3]]
```

## `7.12` Вложенные списки. Матрицы  
## `7.13` (`*`) Сортировка: `sorted()` и параметр `key`
Функция `sorted()` создаёт новый отсортированный список из любого итерируемого объекта без изменения исходного. По умолчанию сортировка идёт по самим элементам, но часто нужна более сложная сортировка — для этого есть параметр `key`.

Параметр `key` — это функция, которая для каждого элемента возвращает значение, по которому будет производиться сортировка. Это позволяет сортировать по внутренним атрибутам, ключам, длине или любым произвольным критериям.

*Сортировка списка чисел по возрастанию (по умолчанию):*
```python
numbers = [5, 8, 6, 9, 7, 10]
sorted_numbers = sorted(numbers)
print(sorted_numbers)  # [5, 6, 7, 8, 9, 10]
```

*Сортировка списка строк без учёта регистра по алфавиту с помощью `key=str.lower`:*
```python
words = ["Banana", "apple", "Cherry"]
sorted_words = sorted(words, key=str.lower)
print(sorted_words)  # ['apple', 'Banana', 'Cherry']
```

*Сортировка списка кортежей по второму элементу каждого кортежа:*
```python
pairs = [(1, 'one'), (3, 'three'), (2, 'two')]
sorted_pairs = sorted(pairs, key=lambda x: x[1])
print(sorted_pairs)  # [(1, 'one'), (3, 'three'), (2, 'two')]
```

*Сортировка списка объектов по атрибуту `grade`:*
```python
class Student:
    def __init__(self, name, grade):
        self.name = name
        self.grade = grade

students = [Student('Alice', 85), Student('Bob', 92), Student('Charlie', 78)]
sorted_students = sorted(students, key=lambda s: s.grade)
print([(s.name, s.grade) for s in sorted_students])  # [('Charlie', 78), ('Alice', 85), ('Bob', 92)]
```

Параметр `reverse=True` позволяет сортировать в обратном порядке.  
Функция `sorted()` очень гибкая и применяется для сортировки списков, кортежей, строк и даже пользовательских объектов по любому критерию.

----

# `8` Функции 1
## `8.1` Что такое функциональное программирование?  
## `8.2` Что такое функция? Как объявить функцию в Python?  
## `8.3` Функции с и без параметров  
## `8.4` Разница аргумента и параметра  
## `8.5` Разные виды `return`  

----

# `9` Типы данных 3
## `9.1` Кортежи
### `9.1.1` Что такое кортежи?  
### `9.1.2` В чем их плюсы и минусы? Их свойства. Отличие от списков  
### `9.1.3` Функции `len()`, `in` для кортежей и другие по типу `sum()`  
### `9.1.4` Методы кортежей:  
- `index()`  
- `count()`  
- `join()`
### `9.1.5` Распаковка кортежей  

## `9.2` Множества
### `9.2.1` Что такое множества? Свойства множеств  
### `9.2.2` Функции `len()`, `in` для множеств и другие по типу `sum()`  
### `9.2.3` Методы множеств (можно посмотреть все, но укажу, который точно надо знать):  
- `add()`  
- `remove()`  
- `discard()`  
- `pop()`  
- `clear()`  
- методы и операторы для операций между множествами  
- `issubset()`  
- `issuperset()`
### `9.2.3` (`*`) Генераторы множеств (`set comprehensions`)
`Set comprehension` — это компактный способ создать множество (set) на основе существующего итерируемого объекта с возможностью фильтрации и трансформации элементов.

Синтаксис похож на list comprehension, но используются фигурные скобки:
```python
{expression for item in iterable if condition}
```

Пример: создадим множество из чётных чисел списка:

```python
numbers = [13, 21, 14, 24, 53, 62]
even_numbers = {num for num in numbers if num % 2 == 0}
print(even_numbers)  # Например: {24, 62, 14}
```

Множества автоматически исключают дубликаты и неупорядочены.
Set comprehension эффективны для быстрого создания уникальных коллекций с фильтрацией или преобразованием элементов.


### `9.2.4` (`**`) `frozenset`
`frozenset` — это неизменяемый (immutable) аналог множества (`set`). Как и множество, он хранит уникальные элементы, но после создания его нельзя изменить (добавлять или удалять элементы).

Основные особенности:
- Можно использовать как ключи в словарях или элементы других множеств (т.к. хешируем).
- Создаётся из итерируемого объекта: `frozenset(iterable)`.

```python
s = frozenset([1, 2, 2, 3])
print(s)  # frozenset({1, 2, 3})

# Попытка изменить вызовет ошибку:
# s.add(4)  # AttributeError: 'frozenset' object has no attribute 'add'
```
`frozenset` полезен, когда нужно неизменяемое множество, например, для хранения множества в качестве ключа словаря или для передачи данных, которые нельзя случайно изменить.


## `9.3` Словари
### `9.3.1` Что такое словари? Свойства словарей  
### `9.3.2` Что может быть ключом словаря, а что нет?  
### `9.3.3` Функции `len()`, `in` для словарей и другие по типу `sum()`  
### `9.3.4` Методы словарей (можно посмотреть все, но укажу, который точно надо знать):  
- получение элемента из словаря  
- удаление элемента из словаря  
- `keys()`  
- `values()`  
- `items()`  
- `get()`  
- `update()`  
- `setdefault()`  
- `pop()`  
- `clear()`  
- `copy()`

### `9.3.5` Уметь перебирать словари через for  
### `9.3.6` Вложенные словари  
### `9.3.7` Генераторы словарей или `dict comprehensions`
### `9.3.8` (`*`) Что такое коллекции и последовательности?
Коллекции в Python — это структуры данных, хранящие группы объектов. Основные типы коллекций: списки (`list`), кортежи (`tuple`), множества (`set`), словари (`dict`).  

Последовательности — подмножество коллекций, в которых элементы имеют упорядоченный индекс и доступны по позициям. К ним относятся списки, строки, кортежи и диапазоны (`range`). Последовательности поддерживают операции индексации, срезы и итерацию.

В Python все эти типы реализуют интерфейс `Iterable` (итерируемые), а последовательности дополнительно — интерфейс `Sequence`. Это позволяет последовательно перебирать элементы и использовать стандартные операции.

----

# `10` Управление памятью
## `10.1` Устройство памяти в общем  
## `10.2` Устройства памяти в Python  
## `10.3` Переменные в Python. Как работают ссылки в Python  
## `10.4` Изменяемые и неизменяемые типы данных  
## `10.5` `copy()` & `deepcopy()`  
## `10.6` Garbage collector. Слабые и сильные ссылки  

----

# `11` Функции 2
## `11.1` Встроенные функции `type()`, `sorted()`, `reversed()`, `isinstance()`, `callable()`, `hasattr()`, `hash()` и другие  
## `11.2` Позиционные и именованные аргументы  
## `11.3` Аргументы по умолчанию  
## `11.4` Функции высшего порядка  
## `11.5` `lambda` функции  
## `11.6` `map()`, `filter()`, `reduce()`. Кейсы их применения  
## `11.7` `any()`, `all()`, `zip()`, `enumerate()`  

----

# `12` Работа с файлами
### `12.0.1` Потоковый ввод и вывод данных  

## `12.1` TXT
### `12.1.1` Что такое контекстный менеджер?  
### `12.1.2` Как читать и записывать в файл?  
### `12.1.3` Какие есть функции и методы для работы с TXT в Python?  

## `12.2` JSON
### `12.2.1` Что такое JSON? Для чего он нужен?  
### `12.2.2` Какие есть функции и методы для работы с JSON в Python?  
### `12.2.3` Как происходит конвертация типов данных при сериализации?  

## `12.3` CSV
### `12.3.1` Что такое CSV? Для чего он нужен?  
### `12.3.2` Какие есть функции и методы для работы с CSV в Python?  

----

# `13` Работа с датой и временем
## `13.1` Посмотреть модуль `datetime` и различные типы данных в нем: `date`, `time`, etc.  
## `13.2` На дате можно изучить `repr()` и посмотреть разницу с `str()`  
## `13.3` `strftime()`, `strptime()`, `isoformat()`, `fromisoformat()`, `combine()`, `now()`  
## `13.4` Что такое начало эпохи?  
## `13.5` Что такое `timedelta` и зачем оно нужно?  
## `13.6` Посмотреть, что такое временные зоны и как с ними работать  

----

# `14` Обработка исключений
## `14.1` Типы ошибок. Основные исключения в Python и их иерархия  
## `14.2` `try-except`  
## `14.3` `else` & `finally` в `try-except`  
## `14.4` Оператор `raise`  
## `14.5` Кастомные ошибки  

----

# `15` Рекурсия
## `15.1` Что такое рекурсия?  
## `15.2` Какие задачи решает рекурсия?  

----

# `16` Функции 3
## `16.1` Вложенные функции
## `16.2` (`*`) Замыкание. Зачем оно нужно?
**Замыкание** (closure) — это функция, которая определена внутри другой функции и хранит «замкнутые» значения переменных из внешней области видимости, даже после завершения работы внешней функции. То есть она "запоминает" своё окружение и может использовать переменные внешней функции, когда уже вне её контекста.

**Зачем нужны замыкания:**
- Для создания _фабричных функций_ с сохранением внутренних параметров (вместо глобальных переменных).
- Для инкапсуляции данных, когда не хочется использовать классы и нужно скрыть внутреннюю логику или состояние.
- Для генерации функций с "запомненным" состоянием или параметром.

```python
def make_multiplier(n):
    def multiplier(x):
        return x * n
    return multiplier

double = make_multiplier(2)
triple = make_multiplier(3)

print(double(4))  # 8
print(triple(4))  # 12
```
Здесь `multiplier` — замыкание: оно "помнит" значение `n` из внешней функции.

```python
def counter():
    count = 0
    def inc():
        nonlocal count
        count += 1
        return count
    return inc

count1 = counter()
print(count1())  # 1
print(count1())  # 2
```


## `16.3` (`*`) Паттерн Фабрика
`Паттерн Фабрика` — это способ централизованного создания объектов или значений, когда точный тип или параметры неизвестны заранее. В Python, без использования классов, он часто реализуется как функция, которая принимает параметры и возвращает нужное значение (например, другую функцию или структуру).

### Зачем нужен
- Чтобы упростить создание разных вариантов объектов или функций.
- Чтобы скрыть логику создания внутри одной функции.
- Чтобы избежать повторения кода.

### Пример простой фабрики без классов
```python
def animal_factory(animal_type):
    if animal_type == "dog":
        return "Гав-гав"
    elif animal_type == "cat":
        return "Мяу"
    else:
        return "Неизвестный звук"

print(animal_factory("dog"))  # Гав-гав
print(animal_factory("cat"))  # Мяу
```


## `16.4` (`*`) Локальные и глобальные переменные. Область видимости. Правило `LEGB`
В Python **локальные переменные** объявляются внутри функций и доступны только в этих функциях. **Глобальные переменные** находятся вне всех функций и доступны во всей программе. Если объявить переменную внутри функции с тем же именем, что и глобальная — внутри функции будет использоваться локальная версия, а глобальная вне функции.

**Область видимости** — определяет, где переменная "видна" и доступна для использования. Локальные переменные исчезают после завершения функции, глобальные — сохраняются на протяжении исполнения всей программы.

### LEGB правило поиска переменных
Python ищет переменные по цепочке областей видимости:
- **L**ocal (Локальная): внутри текущей функции или метода
- **E**nclosing (Вложенная): в родительских (внешних) функциях, если используется вложенность
- **G**lobal (Глобальная): на уровне всего модуля (файла)
- **B**uilt-in (Встроенная): специальные переменные и функции Python (например, `print`, `len`)

**Глобальная переменная:**
```python
x = "глобальная переменная"

def show():
    print(x)  # доступ к глобальной переменной
show()
print(x)      # доступ вне функции
```

**Локальная переменная:**
```python
def foo():
    y = "локальная переменная"
    print(y)
foo()
# print(y)  # Ошибка, вне функции переменная недоступна
```

**LEGB - вложенные функции:**
```python
def outer():
    a = "enclosing"
    def inner():
        print(a)  # ищет переменную во внешней функции (Enclosing)
    inner()
outer()
```

**Изменение глобальной переменной внутри функции:**
```python
global_var = 10

def update():
    global global_var
    global_var = 20  # изменится глобальная переменная
update()
print(global_var)    # 20
```

----

# `17` Декораторы
## `17.1` Что такое декоратор? Как написать свой декоратор?  
## `17.2` Есть ли что-то похожее в других языках?  
## `17.3` Атрибуты `__name__` & `__doc__`  
## `17.4` `@functools.wraps` - что такое и зачем?  
## `17.5` Параметризованный декоратор  

----

# `18` Итераторы
## `18.1` Что такое итераторы? Зачем они нужны? В чем их профит?  
## `18.2` Генераторы  
## `18.3` В чем разница генераторов от итераторов?  
## `18.4` Когда использовать и кейсы  
## `18.5` Повторить, что такое `range`  

----

# `19` Type hints
## `19.1` Что такое и зачем нужны?  
## `19.2` Что такое динамическая типизация?  
## `19.3` Модуль `typing`  
## `19.4` Если есть желание, посмотреть, как было на более старых версиях  

----

# `20` Extra Python  
_P.S: only for flexing on the job interview_  

## `20.1` Модуль `itertools`  
## `20.2` Модуль `functools`  
## `20.3` Регулярные выражения. Модуль `re`  

----

# `21` Cache
## `21.1` Что такое кэш?  
## `21.2` `lru_cache` и мемоизация  
## `21.3` Методы кэширования  
## `21.4` Что такое хэш?  
## `21.5` Разница кэша и хэша  

----

# `22` Типы данных 4  
_P.S: only for flexing on the job interview_  

## `22.1` `Decimal` что такое и для чего нужен?  
## `22.2` `namedtuple` что такое и для чего нужен?  
## `22.3` `defaultdict` что такое и для чего нужен?  
## `22.4` `OrderedDict` что такое и для чего нужен?  
## `22.5` `ChainMap` что такое и для чего нужен?  
## `22.6` `deque` что такое и для чего нужен?  
## `22.7` Можно ещё поизучать модуль `collections`  

----

# `23` Принципы ООП
## `23.1` Парадигмы программирования. Что такое объект в Python?  
## `23.2` Преимущества ООП и недостатки  
## `23.3` Что такое класс и объект?  
## `23.4` 4 принципа ООП  
- абстракция  
- инкапсуляция  
- наследование  
- полиморфизм  

----

# `24` Атрибуты и методы
## `24.1` Какие кейсы есть вообще, и какие соглашения на использовании в Python (camelCase, snake_case, etc)  
## `24.2` Функция `dir()` — для получения списка атрибутов и методов объекта  
## `24.3` Создание классов и объектов в Python  
## `24.4` Атрибуты класса и объекта (без `__init__`)  
## `24.5` Атрибут `__dict__` — словарь атрибутов объекта  
## `24.6` Встроенные функции для работы с атрибутами:  
- `getattr()` — получить атрибут  
- `setattr()` — установить атрибут  
- `delattr()` — удалить атрибут  
- `hasattr()` — проверить наличие атрибута  
## `24.7` Что такое метод и как его создавать?  

----

# `25` Методы экземпляра класса
## `25.1` Метод `__init__` — конструктор класса  
## `25.2` Параметр `self` — что это и зачем нужен  

----

# `26` Доступ к атрибутам
## `26.1` Сокрытие данных (инкапсуляция) в Python  
## `26.2` Соглашения между разработчиками по именованию и доступу  
## `26.3` Геттеры, сеттеры, делитеры — что это и зачем нужны  
## `26.4` Свойство (`property`) — атрибут с управляемым доступом  
## `26.5` Декоратор `@property` — как работает и зачем  
## `26.6` Декораторы `@classmethod` и `@staticmethod` — что такое `cls` и различия  
## `26.7` Продвинутое: `@singledispatchmethod` — перегрузка методов по типу аргумента  







# Виртуальное окружение
## venv
## poetry
## 


# Логирование
